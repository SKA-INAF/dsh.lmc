/*----- PROTECTED REGION ID(FormulaConf.cpp) ENABLED START -----*/
static const char *RcsId = "$Id:  $";
//=============================================================================
//
// file :        FormulaConf.cpp
//
// description : C++ source for the FormulaConf class and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               FormulaConf are implemented in this file.
//
// project :     FormulaConf
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
// $Author:  $
//
// $Revision:  $
// $Date:  $
//
// $HeadURL:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <FormulaConf.h>
#include <FormulaConfClass.h>
#include <math.h>
#include <stdint.h>
#include <algorithm>

#include "formula_grammar.h"

const char srvver[] = RELEASE;

std::map<parser_id, std::string> rule_names;  //only for log messages

/*----- PROTECTED REGION END -----*/	//	FormulaConf.cpp

/**
 *  FormulaConf class description:
 *    Configurable formula
 */

//================================================================
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name  |  Method name
//================================================================
//  State         |  Inherited (no method)
//  Status        |  Inherited (no method)
//================================================================

//================================================================
//  Attributes managed are:
//================================================================
//  Version        |  Tango::DevString	Scalar
//  DevicesStatus  |  Tango::DevString	Spectrum  ( max = 5000)
//================================================================

namespace FormulaConf_ns
{
/*----- PROTECTED REGION ID(FormulaConf::namespace_starting) ENABLED START -----*/

//	static initializations
bool compare_attr_index (attr_desc_t i,attr_desc_t j) { return (i.attr_index < j.attr_index); }

/*----- PROTECTED REGION END -----*/	//	FormulaConf::namespace_starting

//--------------------------------------------------------
/**
 *	Method      : FormulaConf::FormulaConf()
 *	Description : Constructors for a Tango device
 *                implementing the classFormulaConf
 */
//--------------------------------------------------------
FormulaConf::FormulaConf(Tango::DeviceClass *cl, string &s)
 : TANGO_BASE_CLASS(cl, s.c_str())
{
	/*----- PROTECTED REGION ID(FormulaConf::constructor_1) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	FormulaConf::constructor_1
}
//--------------------------------------------------------
FormulaConf::FormulaConf(Tango::DeviceClass *cl, const char *s)
 : TANGO_BASE_CLASS(cl, s)
{
	/*----- PROTECTED REGION ID(FormulaConf::constructor_2) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	FormulaConf::constructor_2
}
//--------------------------------------------------------
FormulaConf::FormulaConf(Tango::DeviceClass *cl, const char *s, const char *d)
 : TANGO_BASE_CLASS(cl, s, d)
{
	/*----- PROTECTED REGION ID(FormulaConf::constructor_3) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	FormulaConf::constructor_3
}

//--------------------------------------------------------
/**
 *	Method      : FormulaConf::delete_device()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void FormulaConf::delete_device()
{
	DEBUG_STREAM << "FormulaConf::delete_device() " << device_name << endl;
	/*----- PROTECTED REGION ID(FormulaConf::delete_device) ENABLED START -----*/
	
	//	Delete device allocated objects
	/*read_loop->abortflag = true;
	usleep(500000);*/
	
	//delete proxies
/*	vector<remote_dev_t>::iterator it;
	for(it=remote_devices.begin(); it!=remote_devices.end(); it++)
	{
		try {
			it->remote_device->unsubscribe_event(it->eid);
			usleep(10000);
			delete it->remote_device;
		} catch(...)
		{}
	}

	//remote_devices and other maps/vectors
	remote_devices.clear();
	att_data.clear();
	m_att_value.clear();
	created_attr = false;*/

	bool starting = Tango::Util::instance()->is_svr_starting();

	bool shutting_down = Tango::Util::instance()->is_svr_shutting_down();

	bool restarting = Tango::Util::instance()->is_device_restarting(device_name);
	
	DEBUG_STREAM << __func__ << " starting="<<(int)starting << " shutting_down="<<(int)shutting_down<<" restarting="<<(int)restarting;
    
	if(restarting || shutting_down)
		remove_dynamic_attributes();
	DEBUG_STREAM << __func__ << " exiting...";
	
	/*----- PROTECTED REGION END -----*/	//	FormulaConf::delete_device
	delete[] attr_Version_read;
	delete[] attr_DevicesStatus_read;
}

//--------------------------------------------------------
/**
 *	Method      : FormulaConf::init_device()
 *	Description : will be called at device initialization.
 */
//--------------------------------------------------------
void FormulaConf::init_device()
{
	DEBUG_STREAM << "FormulaConf::init_device() create device " << device_name << endl;
	/*----- PROTECTED REGION ID(FormulaConf::init_device_before) ENABLED START -----*/
	
	//	Initialization before get_device_property() call
	created_attr = false;
	attr_index = 0;
	
	/*----- PROTECTED REGION END -----*/	//	FormulaConf::init_device_before
	

	//	Get the device properties from database
	get_device_property();
	
	attr_Version_read = new Tango::DevString[1];
	attr_DevicesStatus_read = new Tango::DevString[5000];
	/*----- PROTECTED REGION ID(FormulaConf::init_device) ENABLED START -----*/
	
	//	Initialize device
	clock_gettime(CLOCK_MONOTONIC,&last_read);
	ecb.init(this);

	for(int i=0; i<3*MAX_ATTR_SIZE; i++)
	{
		attr_DevicesStatus_read[i] = (char *)devices_status_str[i];
	}

	rule_names[formula_grammar::val_rID] = "ValReal";
	rule_names[formula_grammar::val_hID] = "ValHex";
	rule_names[formula_grammar::val_stID] = "ValStatus";
	rule_names[formula_grammar::event_ID] = "EventFather";
	rule_names[formula_grammar::nameID] = "EventName";
	rule_names[formula_grammar::indexID] = "EventIndex";
	rule_names[formula_grammar::funcID] = "Function";
	rule_names[formula_grammar::logical_exprID] = "LogicalE";
	rule_names[formula_grammar::bitwise_exprID] = "BitwiseE";
	rule_names[formula_grammar::equality_exprID] = "EqualityE";
	rule_names[formula_grammar::compare_exprID] = "CompareE";
	rule_names[formula_grammar::add_exprID] = "AddE";
	rule_names[formula_grammar::mult_exprID] = "MultE";
	rule_names[formula_grammar::expr_atomID] = "AtomicE";
	rule_names[formula_grammar::shift_exprID] = "ShiftE";
	rule_names[formula_grammar::unary_exprID] = "UnaryE";
	rule_names[formula_grammar::val_stringID] = "ValString";
	rule_names[formula_grammar::func_dualID] = "FuncDualE";
	rule_names[formula_grammar::logical_expr_parenID] = "LogicalEPAREN";
	rule_names[formula_grammar::cond_exprID] = "CondE";

	DEBUG_STREAM << "FormulaConf::init_device() exiting... " << device_name << endl;
	
	//dev_add_dynamic_attributes();
	
	/*----- PROTECTED REGION END -----*/	//	FormulaConf::init_device
}

//--------------------------------------------------------
/**
 *	Method      : FormulaConf::get_device_property()
 *	Description : Read database to initialize property data members.
 */
//--------------------------------------------------------
void FormulaConf::get_device_property()
{
	/*----- PROTECTED REGION ID(FormulaConf::get_device_property_before) ENABLED START -----*/
	
	//	Initialize property data members
	
	/*----- PROTECTED REGION END -----*/	//	FormulaConf::get_device_property_before


	//	Read device properties from database.
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("Attr_config_file"));
	dev_prop.push_back(Tango::DbDatum("Attr_config_prop"));
	dev_prop.push_back(Tango::DbDatum("Polling_period"));
	dev_prop.push_back(Tango::DbDatum("Read_timeout"));

	//	is there at least one property to be read ?
	if (dev_prop.size()>0)
	{
		//	Call database and extract values
		if (Tango::Util::instance()->_UseDb==true)
			get_db_device()->get_property(dev_prop);
	
		//	get instance on FormulaConfClass to get class property
		Tango::DbDatum	def_prop, cl_prop;
		FormulaConfClass	*ds_class =
			(static_cast<FormulaConfClass *>(get_device_class()));
		int	i = -1;

		//	Try to initialize Attr_config_file from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  attr_config_file;
		else {
			//	Try to initialize Attr_config_file from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  attr_config_file;
		}
		//	And try to extract Attr_config_file value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  attr_config_file;

		//	Try to initialize Attr_config_prop from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  attr_config_prop;
		else {
			//	Try to initialize Attr_config_prop from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  attr_config_prop;
		}
		//	And try to extract Attr_config_prop value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  attr_config_prop;

		//	Try to initialize Polling_period from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  polling_period;
		else {
			//	Try to initialize Polling_period from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  polling_period;
		}
		//	And try to extract Polling_period value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  polling_period;

		//	Try to initialize Read_timeout from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  read_timeout;
		else {
			//	Try to initialize Read_timeout from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  read_timeout;
		}
		//	And try to extract Read_timeout value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  read_timeout;

	}

	/*----- PROTECTED REGION ID(FormulaConf::get_device_property_after) ENABLED START -----*/
	
	//	Check device property data members init
	
	/*----- PROTECTED REGION END -----*/	//	FormulaConf::get_device_property_after
}

//--------------------------------------------------------
/**
 *	Method      : FormulaConf::always_executed_hook()
 *	Description : method always executed before any command is executed
 */
//--------------------------------------------------------
void FormulaConf::always_executed_hook()
{
	DEBUG_STREAM << "FormulaConf::always_executed_hook()  " << device_name << endl;
	/*----- PROTECTED REGION ID(FormulaConf::always_executed_hook) ENABLED START -----*/
	
	//	code always executed before all requests
	
	/*----- PROTECTED REGION END -----*/	//	FormulaConf::always_executed_hook
}

//--------------------------------------------------------
/**
 *	Method      : FormulaConf::read_attr_hardware()
 *	Description : Hardware acquisition for attributes
 */
//--------------------------------------------------------
void FormulaConf::read_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "FormulaConf::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(FormulaConf::read_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	FormulaConf::read_attr_hardware
}

//--------------------------------------------------------
/**
 *	Read attribute Version related method
 *	Description: 
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void FormulaConf::read_Version(Tango::Attribute &attr)
{
	DEBUG_STREAM << "FormulaConf::read_Version(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(FormulaConf::read_Version) ENABLED START -----*/

	string tmp(srvver);
	size_t pos = tmp.find("Name: ");
	tmp = tmp.substr(pos+strlen("Name: "));

	sprintf(version_str,"srv_ver:%s",tmp.c_str());

	attr_Version_read[0] = (char *)version_str;
	//	Set the attribute value
	attr.set_value(attr_Version_read);
	
	/*----- PROTECTED REGION END -----*/	//	FormulaConf::read_Version
}
//--------------------------------------------------------
/**
 *	Read attribute DevicesStatus related method
 *	Description: Status of attributes involved in formulas with timestamp of last valid value, event status, polling status.
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 5000
 */
//--------------------------------------------------------
void FormulaConf::read_DevicesStatus(Tango::Attribute &attr)
{
	DEBUG_STREAM << "FormulaConf::read_DevicesStatus(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(FormulaConf::read_DevicesStatus) ENABLED START -----*/
    
	//	Set the attribute value

	attr.set_value(attr_DevicesStatus_read, remote_devices.size());
	
	/*----- PROTECTED REGION END -----*/	//	FormulaConf::read_DevicesStatus
}

//--------------------------------------------------------
/**
 *	Read attribute BoolScalarDyn related method
 *	Description: 
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void FormulaConf::read_BoolScalarDyn(Tango::Attribute &attr)
{
	DEBUG_STREAM << "FormulaConf::read_BoolScalarDyn(Tango::Attribute &attr) entering... " << endl;
	Tango::DevBoolean	*att_value = get_BoolScalarDyn_data_ptr(attr.get_name());
	/*----- PROTECTED REGION ID(FormulaConf::read_BoolScalarDyn) ENABLED START -----*/

	map<string,attr_val_t >::iterator it_val = m_att_value.find(attr.get_name());

	if(it_val == m_att_value.end())
	{
		Tango::Except::throw_exception( \
							(const char*)"Attribute Not Found", \
							(const char*)"Attribute Not Found", \
							__FUNCTION__, Tango::ERR);
	}
#if 0
	map<string,vector<attr_desc_t> >::iterator it_attr = att_data.find(attr.get_name());

	if(it_attr == att_data.end())
	{
		Tango::Except::throw_exception( \
							(const char*)"Attribute Not Found", \
							(const char*)"Attribute Not Found", \
							__FUNCTION__, Tango::ERR);
	}

	string attr_values;

	double res = 0.0;	//initialize to false
	try
	{
		res = eval_formula(it_attr->second[0].formula_tree, attr.get_name(), attr_values);
	}
	catch(string &err)
	{
		DEBUG_STREAM << __func__<<": error evaluating formula="<<err;
		Tango::Except::throw_exception(
						(const char*)"Error evaluating formula",
						(const char*)err.c_str(),
						(const char*)__func__, Tango::ERR);
	}

	it_val->second.val[ it_attr->second[0].attr_index ] = (res != 0.0);
	it_val->second.old_val[ it_attr->second[0].attr_index ] = (res != 0.0);
#endif
    //	Set the attribute value
    attr.set_value(&(it_val->second.val[0]));
	
	/*----- PROTECTED REGION END -----*/	//	FormulaConf::read_BoolScalarDyn
}
//--------------------------------------------------------
/**
 *	Read attribute DoubleScalarDyn related method
 *	Description: 
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void FormulaConf::read_DoubleScalarDyn(Tango::Attribute &attr)
{
	DEBUG_STREAM << "FormulaConf::read_DoubleScalarDyn(Tango::Attribute &attr) entering... " << endl;
	Tango::DevDouble	*att_value = get_DoubleScalarDyn_data_ptr(attr.get_name());
	/*----- PROTECTED REGION ID(FormulaConf::read_DoubleScalarDyn) ENABLED START -----*/

	map<string,attr_val_t >::iterator it_val = m_att_value.find(attr.get_name());

	if(it_val == m_att_value.end())
	{
		Tango::Except::throw_exception( \
							(const char*)"Attribute Not Found", \
							(const char*)"Attribute Not Found", \
							__FUNCTION__, Tango::ERR);
	}
#if 0
	map<string,vector<attr_desc_t> >::iterator it_attr = att_data.find(attr.get_name());

	if(it_attr == att_data.end())
	{
		Tango::Except::throw_exception( \
							(const char*)"Attribute Not Found", \
							(const char*)"Attribute Not Found", \
							__FUNCTION__, Tango::ERR);
	}

	string attr_values;

	double res = 0.0;	//initialize to false
	try
	{
		res = eval_formula(it_attr->second[0].formula_tree, attr.get_name(), attr_values);
	}
	catch(string &err)
	{
		DEBUG_STREAM << __func__<<": error evaluating formula="<<err;
		Tango::Except::throw_exception(
						(const char*)"Error evaluating formula",
						(const char*)err.c_str(),
						(const char*)__func__, Tango::ERR);
	}

	it_val->second.val_d[ it_attr->second[0].attr_index ] = res;
	it_val->second.old_val_d[ it_attr->second[0].attr_index ] = res;
#endif

    //	Set the attribute value
    attr.set_value(&(it_val->second.val_d[0]));
	
	/*----- PROTECTED REGION END -----*/	//	FormulaConf::read_DoubleScalarDyn
}
//--------------------------------------------------------
/**
 *	Read attribute LongScalarDyn related method
 *	Description: 
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void FormulaConf::read_LongScalarDyn(Tango::Attribute &attr)
{
	DEBUG_STREAM << "FormulaConf::read_LongScalarDyn(Tango::Attribute &attr) entering... " << endl;
	Tango::DevLong	*att_value = get_LongScalarDyn_data_ptr(attr.get_name());
	/*----- PROTECTED REGION ID(FormulaConf::read_LongScalarDyn) ENABLED START -----*/

	map<string,attr_val_t >::iterator it_val = m_att_value.find(attr.get_name());

	if(it_val == m_att_value.end())
	{
		Tango::Except::throw_exception( \
							(const char*)"Attribute Not Found", \
							(const char*)"Attribute Not Found", \
							__FUNCTION__, Tango::ERR);
	}
#if 0
	map<string,vector<attr_desc_t> >::iterator it_attr = att_data.find(attr.get_name());

	if(it_attr == att_data.end())
	{
		Tango::Except::throw_exception( \
							(const char*)"Attribute Not Found", \
							(const char*)"Attribute Not Found", \
							__FUNCTION__, Tango::ERR);
	}

	string attr_values;

	double res = 0.0;	//initialize to false
	try
	{
		res = eval_formula(it_attr->second[0].formula_tree, attr.get_name(), attr_values);
	}
	catch(string &err)
	{
		DEBUG_STREAM << __func__<<": error evaluating formula="<<err;
		Tango::Except::throw_exception(
						(const char*)"Error evaluating formula",
						(const char*)err.c_str(),
						(const char*)__func__, Tango::ERR);
	}

	it_val->second.val_l[ it_attr->second[0].attr_index ] = (Tango::DevLong)res;
	it_val->second.old_val_l[ it_attr->second[0].attr_index ] = (Tango::DevLong)res;
#endif

    //	Set the attribute value
    attr.set_value(&(it_val->second.val_l[0]));
	
	/*----- PROTECTED REGION END -----*/	//	FormulaConf::read_LongScalarDyn
}
//--------------------------------------------------------
/**
 *	Read attribute StringSpectrumDyn related method
 *	Description: 
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 1000
 */
//--------------------------------------------------------
void FormulaConf::read_StringSpectrumDyn(Tango::Attribute &attr)
{
	DEBUG_STREAM << "FormulaConf::read_StringSpectrumDyn(Tango::Attribute &attr) entering... " << endl;
	Tango::DevString	*att_value = get_StringSpectrumDyn_data_ptr(attr.get_name());
	/*----- PROTECTED REGION ID(FormulaConf::read_StringSpectrumDyn) ENABLED START -----*/
	//	Set the attribute value
	
	/*----- PROTECTED REGION END -----*/	//	FormulaConf::read_StringSpectrumDyn
}
//--------------------------------------------------------
/**
 *	Read attribute BoolSpectrumDyn related method
 *	Description: 
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Spectrum max = 1000
 */
//--------------------------------------------------------
void FormulaConf::read_BoolSpectrumDyn(Tango::Attribute &attr)
{
	DEBUG_STREAM << "FormulaConf::read_BoolSpectrumDyn(Tango::Attribute &attr) entering... " << endl;
	Tango::DevBoolean	*att_value = get_BoolSpectrumDyn_data_ptr(attr.get_name());
	/*----- PROTECTED REGION ID(FormulaConf::read_BoolSpectrumDyn) ENABLED START -----*/

	//	Set the attribute value
	map<string,attr_val_t >::iterator it_val = m_att_value.find(attr.get_name());

	if(it_val == m_att_value.end())
	{
		Tango::Except::throw_exception( \
							(const char*)"Attribute Not Found", \
							(const char*)"Attribute Not Found", \
							__FUNCTION__, Tango::ERR);
	}

	map<string,vector<attr_desc_t> >::iterator it_attr = att_data.find(attr.get_name());

	if(it_attr == att_data.end())
	{
		Tango::Except::throw_exception( \
							(const char*)"Attribute Not Found", \
							(const char*)"Attribute Not Found", \
							__FUNCTION__, Tango::ERR);
	}
#if 0
	for(vector<attr_desc_t>::iterator it_rem_attr = it_attr->second.begin(); it_rem_attr != it_attr->second.end(); it_rem_attr++)
	{
		DEBUG_STREAM << __FUNCTION__ << " looping " << it_rem_attr->formula;

		string attr_values;
		double res = 0.0;	//initialize to false
		try
		{
			res = eval_formula(it_rem_attr->formula_tree, attr.get_name(), attr_values);
		}
		catch(string &err)
		{
			INFO_STREAM << __func__<<": error evaluating formula="<<err;
			Tango::Except::throw_exception(
							(const char*)"Error evaluating formula",
							(const char*)err.c_str(),
							(const char*)__func__, Tango::ERR);
		}

		it_val->second.val[ it_rem_attr->attr_index ] = (res != 0.0);
		it_val->second.old_val[ it_rem_attr->attr_index ] = (res != 0.0);
	}
#endif
    //	Set the attribute value
    attr.set_value(&(it_val->second.val[0]), it_attr->second.size());
	
	/*----- PROTECTED REGION END -----*/	//	FormulaConf::read_BoolSpectrumDyn
}
//--------------------------------------------------------
/**
 *	Read attribute DoubleSpectrumDyn related method
 *	Description: 
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Spectrum max = 1000
 */
//--------------------------------------------------------
void FormulaConf::read_DoubleSpectrumDyn(Tango::Attribute &attr)
{
	DEBUG_STREAM << "FormulaConf::read_DoubleSpectrumDyn(Tango::Attribute &attr) entering... " << endl;
	Tango::DevDouble	*att_value = get_DoubleSpectrumDyn_data_ptr(attr.get_name());
	/*----- PROTECTED REGION ID(FormulaConf::read_DoubleSpectrumDyn) ENABLED START -----*/

	//	Set the attribute value
	map<string,attr_val_t >::iterator it_val = m_att_value.find(attr.get_name());

	if(it_val == m_att_value.end())
	{
		Tango::Except::throw_exception( \
							(const char*)"Attribute Not Found", \
							(const char*)"Attribute Not Found", \
							__FUNCTION__, Tango::ERR);
	}

	map<string,vector<attr_desc_t> >::iterator it_attr = att_data.find(attr.get_name());

	if(it_attr == att_data.end())
	{
		Tango::Except::throw_exception( \
							(const char*)"Attribute Not Found", \
							(const char*)"Attribute Not Found", \
							__FUNCTION__, Tango::ERR);
	}
#if 0
	for(vector<attr_desc_t>::iterator it_rem_attr = it_attr->second.begin(); it_rem_attr != it_attr->second.end(); it_rem_attr++)
	{
		DEBUG_STREAM << __FUNCTION__ << " looping " << it_rem_attr->formula;

		string attr_values;
		double res = 0.0;	//initialize to false
		try
		{
			res = eval_formula(it_rem_attr->formula_tree, attr.get_name(), attr_values);
		}
		catch(string &err)
		{
			INFO_STREAM << __func__<<": error evaluating formula="<<err;
			Tango::Except::throw_exception(
							(const char*)"Error evaluating formula",
							(const char*)err.c_str(),
							(const char*)__func__, Tango::ERR);
		}

		it_val->second.val_d[ it_rem_attr->attr_index ] = res;
	}
#endif
    //	Set the attribute value
    attr.set_value(&(it_val->second.val_d[0]), it_attr->second.size());
	
	/*----- PROTECTED REGION END -----*/	//	FormulaConf::read_DoubleSpectrumDyn
}
//--------------------------------------------------------
/**
 *	Read attribute LongSpectrumDyn related method
 *	Description: 
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Spectrum max = 1000
 */
//--------------------------------------------------------
void FormulaConf::read_LongSpectrumDyn(Tango::Attribute &attr)
{
	DEBUG_STREAM << "FormulaConf::read_LongSpectrumDyn(Tango::Attribute &attr) entering... " << endl;
	Tango::DevLong	*att_value = get_LongSpectrumDyn_data_ptr(attr.get_name());
	/*----- PROTECTED REGION ID(FormulaConf::read_LongSpectrumDyn) ENABLED START -----*/

	//	Set the attribute value
	map<string,attr_val_t >::iterator it_val = m_att_value.find(attr.get_name());

	if(it_val == m_att_value.end())
	{
		Tango::Except::throw_exception( \
							(const char*)"Attribute Not Found", \
							(const char*)"Attribute Not Found", \
							__FUNCTION__, Tango::ERR);
	}

	map<string,vector<attr_desc_t> >::iterator it_attr = att_data.find(attr.get_name());

	if(it_attr == att_data.end())
	{
		Tango::Except::throw_exception( \
							(const char*)"Attribute Not Found", \
							(const char*)"Attribute Not Found", \
							__FUNCTION__, Tango::ERR);
	}
#if 0
	for(vector<attr_desc_t>::iterator it_rem_attr = it_attr->second.begin(); it_rem_attr != it_attr->second.end(); it_rem_attr++)
	{
		DEBUG_STREAM << __FUNCTION__ << " looping " << it_rem_attr->formula;

		string attr_values;
		double res = 0.0;	//initialize to false
		try
		{
			res = eval_formula(it_rem_attr->formula_tree, attr.get_name(), attr_values);
		}
		catch(string &err)
		{
			INFO_STREAM << __func__<<": error evaluating formula="<<err;
			Tango::Except::throw_exception(
							(const char*)"Error evaluating formula",
							(const char*)err.c_str(),
							(const char*)__func__, Tango::ERR);
		}

		it_val->second.val_l[ it_rem_attr->attr_index ] = (Tango::DevLong)res;
	}
#endif
    //	Set the attribute value
    attr.set_value(&(it_val->second.val_l[0]), it_attr->second.size());
	
	/*----- PROTECTED REGION END -----*/	//	FormulaConf::read_LongSpectrumDyn
}
//--------------------------------------------------------
/**
 *	Method      : FormulaConf::add_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *                for specified device.
 */
//--------------------------------------------------------
void FormulaConf::add_dynamic_attributes()
{
	//	Example to add dynamic attribute:
	//	Copy inside the following protected area to create instance(s) at startup.
	//	add_BoolScalarDyn_dynamic_attribute("MyBoolScalarDynAttribute");
	//	add_DoubleScalarDyn_dynamic_attribute("MyDoubleScalarDynAttribute");
	//	add_LongScalarDyn_dynamic_attribute("MyLongScalarDynAttribute");
	//	add_StringSpectrumDyn_dynamic_attribute("MyStringSpectrumDynAttribute");
	//	add_BoolSpectrumDyn_dynamic_attribute("MyBoolSpectrumDynAttribute");
	//	add_DoubleSpectrumDyn_dynamic_attribute("MyDoubleSpectrumDynAttribute");
	//	add_LongSpectrumDyn_dynamic_attribute("MyLongSpectrumDynAttribute");
	
	/*----- PROTECTED REGION ID(FormulaConf::add_dynamic_attributes) ENABLED START -----*/
	DEBUG_STREAM << __func__ << " entering...";

	if (attr_config_prop.empty() == false)
	{
		DEBUG_STREAM << __FUNCTION__ << " going to create from device property...";
		create_dynamic_attributes(attr_config_prop);
	}

	if (attr_config_file.empty() == false)
	{
		DEBUG_STREAM << __FUNCTION__ << " going to create from file...";
		vector<string> attr_config;
		string line;
		string line_buffer;
		line_buffer = "";
		attr_config.clear();
		ifstream infile (attr_config_file.c_str(), ios_base::in);
		while (getline(infile, line, '\n'))
		{
		  //attr_config.push_back (line);

			if (line[line.size()-1]=='\\')
			{
				line_buffer += line.substr(0, line.size()-1);
			}
			else
			{
				attr_config.push_back (line_buffer + line);
				line_buffer = "";
			}
		}
		if (line_buffer.size())
		{
			attr_config.push_back (line_buffer);
		}
		infile.close();
		DEBUG_STREAM <<__FUNCTION__ << "Read " << attr_config.size() << " lines.\n";
		create_dynamic_attributes(attr_config);
	}


	//if(done something)
	{
		map<string,vector<attr_desc_t> >::iterator attr_it;
		for(attr_it=att_data.begin(); attr_it != att_data.end(); attr_it++)
		{
			map<string,attr_val_t >::iterator it_val = m_att_value.find(attr_it->first);

			if (attr_it->second.size() == 1 && (attr_it->second.begin())->type == "bool")
			{
				add_BoolScalarDyn_dynamic_attribute(attr_it->first);
			}
			else if (attr_it->second.size() == 1 && (attr_it->second.begin())->type == "double")
			{
				add_DoubleScalarDyn_dynamic_attribute(attr_it->first);
			}
			else if (attr_it->second.size() == 1 && (attr_it->second.begin())->type == "long")
			{
				add_LongScalarDyn_dynamic_attribute(attr_it->first);
			}
			else if((attr_it->second.begin())->type == "bool")
			{
				if(it_val != m_att_value.end())
					add_BoolSpectrumDyn_dynamic_attribute(attr_it->first, &(it_val->second.val[0]));
			}
			else if((attr_it->second.begin())->type == "string")
			{
				add_StringSpectrumDyn_dynamic_attribute(attr_it->first, NULL);
			}
			else if((attr_it->second.begin())->type == "double")
			{
				if(it_val != m_att_value.end())
					add_DoubleSpectrumDyn_dynamic_attribute(attr_it->first, &(it_val->second.val_d[0]));
			}
			else if((attr_it->second.begin())->type == "long")
			{
				if(it_val != m_att_value.end())
					add_LongSpectrumDyn_dynamic_attribute(attr_it->first, &(it_val->second.val_l[0]));
			}
			else
			{
				continue;
			}
			stringstream descr_prop;
			size_t ind_descr=0;
			for(vector<attr_desc_t>::iterator it_descr = attr_it->second.begin(); it_descr != attr_it->second.end(); it_descr++)
			{
				descr_prop << "[" << ind_descr << "] " << it_descr->descr.c_str();
				if(ind_descr < attr_it->second.size()-1)
					descr_prop << endl;
				ind_descr++;
			}
			sort(attr_it->second.begin(), attr_it->second.end(),compare_attr_index);
		}
	}

	init_attributeprop();
	created_attr = true;
	read_loop = new readthread(this);
	read_loop->start();
	DEBUG_STREAM << __func__ << " exiting...";
	
	/*----- PROTECTED REGION END -----*/	//	FormulaConf::add_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Method      : FormulaConf::add_dynamic_commands()
 *	Description : Create the dynamic commands if any
 *                for specified device.
 */
//--------------------------------------------------------
void FormulaConf::add_dynamic_commands()
{
	/*----- PROTECTED REGION ID(FormulaConf::add_dynamic_commands) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic commands if any
	
	/*----- PROTECTED REGION END -----*/	//	FormulaConf::add_dynamic_commands
}

/*----- PROTECTED REGION ID(FormulaConf::namespace_ending) ENABLED START -----*/

//	Additional Methods
//--------------------------------------------------------
/**
 *	Method      : FormulaConf::ControlBoxClass::create_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *	              for specified device.
 */
//--------------------------------------------------------
void FormulaConf::create_dynamic_attributes(vector<string> attr_config)
{
	DEBUG_STREAM << __FUNCTION__ << " entering...";

	attr_val_t tmp_val;
	vector<string> filter;
	for(unsigned int i=0; i<MAX_ATTR_SIZE; i++)
	{
		tmp_val.val[i] = false;
		tmp_val.val_d[i] = NAN;
		tmp_val.old_val_d[i] = NAN;
	}
	/*attr_val_string_t tmp_val_string;
	for(unsigned int i=0; i<MAX_ATTR_SIZE; i++)
		tmp_val_string.val[i][0] = 0;*/

	int k=attr_index;
	for (unsigned int i = 0;i < attr_config.size();i++)
	{
		vector<string> results;
		string_explode(attr_config[i], ";", &results);
		bool proxy_err = false;
		if((results.size() == 5 || results.size() == 6) && results[0] == "attr" && (results[1] == "bool" || results[1] == "double" || results[1] == "long"))
		{
			attr_desc_t tmp;
			tmp.attr_index=atoi(results[3].c_str());
			//tmp.remote_device_name=results[3];
			//tmp.remote_device = new Tango::DeviceProxy(tmp.remote_device_name);
			//tmp.remote_attr_name=results[4];
			tmp.formula=results[4];
			//remove trailing whitespaces
			if (!tmp.formula.empty() )
			{
				string::size_type pos = tmp.formula.find_last_not_of(' ');
				if (pos != tmp.formula.length()-1)
				{
					if ( pos == string::npos )
						pos = -1;
					tmp.formula.erase(pos+1);
				}
			}
			tmp.type=results[1];
			tmp.first_push=true;	//force first push_change_event
			formula_grammar formula_gr;
			DEBUG_STREAM << __func__<<": going to ast_parse: "<<string(tmp.formula.begin(), tmp.formula.end());
			tmp.formula_tree =
			//boost::spirit::tree_parse_info< std::string::iterator, factory_t> tmp =
					ast_parse<factory_t>(tmp.formula.begin(), tmp.formula.end(), formula_gr, space_p);	//parse string s with grammar al_gr, skipping white spaces
			if (tmp.formula_tree.full)
			{
				find_device_formula(tmp.formula_tree,tmp.remote_name);				//pupulate event list found in this formula

				if (tmp.remote_name.empty() == false)
				{
					//remove duplicated
					sort(tmp.remote_name.begin(), tmp.remote_name.end());
					vector<string>::iterator new_end = \
							unique(tmp.remote_name.begin(), tmp.remote_name.end());
					while (tmp.remote_name.end() != new_end)
					{
						tmp.remote_name.pop_back();
					}

					vector<string>::iterator j = tmp.remote_name.begin();

					while (j != tmp.remote_name.end() && !proxy_err)
					{
						bool found_ev = false;
						vector<remote_dev_t>::iterator it_ev=remote_devices.end();
						try {
							it_ev=find_events(*j);
							if(it_ev != remote_devices.end())
							{
								found_ev = true;
							}
						}
						catch (string &err)
						{
							DEBUG_STREAM << __func__<<": exception for '"<<*j<<"' err="<<err;
							if(it_ev != remote_devices.end())
							{
								found_ev = true;
							}
							else
							{
								found_ev = false;
							}
						}
						catch (...)
						{
							if(it_ev != remote_devices.end())
							{
								found_ev = true;
							}
							else
							{
								found_ev = false;
							}
						}
						if(found_ev)
						{
							//update list of local attributes interested in this remote attribute
							if(find(it_ev->loc_attr_name.begin(),it_ev->loc_attr_name.end(),results[2]) == it_ev->loc_attr_name.end())
								it_ev->loc_attr_name.push_back(results[2]);
							j++;
							continue;
						}
						//string device, attribute;
						remote_dev_t tmp_dev;
						string remote_name = *j;
						std::transform(remote_name.begin(), remote_name.end(), remote_name.begin(), (int(*)(int))tolower);		//transform to lowercase
						tmp_dev.remote_name = remote_name;
						const char *c = remote_name.c_str();
						int ind = 0;
						int num_slashes=3;	//not FQDN
						if(remote_name.find("tango://") != string::npos)	//FQDN!!
							num_slashes = 6;
						while (*c)
						{
							if (*c == '/')
								ind++;
							if (ind < num_slashes)
								tmp_dev.remote_device_name.push_back(*c);
							else if (*c != '/')
								tmp_dev.remote_attr_name.push_back(*c);
							c++;
						}
						if(k<3*MAX_ATTR_SIZE)
							tmp_dev.stat_index = k;
						else
							tmp_dev.stat_index = -1;
						try
						{
							tmp_dev.remote_device = NULL;
							tmp_dev.last_read.tv_sec = 0;
							tmp_dev.remote_device = new Tango::DeviceProxy(tmp_dev.remote_device_name);
							if(k<3*MAX_ATTR_SIZE)
								sprintf(devices_status_str[k], "%s: connected", tmp_dev.remote_device_name.c_str());
						}catch (Tango::DevFailed &e)
						{
							string err(e.errors[0].desc);
							INFO_STREAM << __func__ << ": error creating device proxy for " << tmp_dev.remote_device_name << " err="<<err;
							if(k<3*MAX_ATTR_SIZE)
								sprintf(devices_status_str[k], "%s: connection error: '%s'", tmp_dev.remote_device_name.c_str(), err.c_str());
							j++;
							k++;
							proxy_err = true;
							continue;
						}
						tmp_dev.loc_attr_name.push_back(results[2]);
						remote_devices.push_back(tmp_dev);
						try
						{
							tmp_dev.last_event_rx.tv_sec = 0;
							tmp_dev.eid = tmp_dev.remote_device->subscribe_event(tmp_dev.remote_attr_name, Tango::CHANGE_EVENT, &ecb, filter,false);	//stateful subscription ( fails if server not running)
							//if(k<3*MAX_ATTR_SIZE)
							//	sprintf(devices_status_str[k], "%s: subscribed", tmp_dev.remote_device_name.c_str());
						}catch (Tango::DevFailed &e)
						{
							/*vector<remote_dev_t>::iterator it_tmp;
							for(it_tmp=remote_devices.begin(); it_tmp != remote_devices.end(); it_tmp++)
							{
								if(it_tmp->remote_name == tmp_dev.remote_name)
									break;
							}
							if(it_tmp != remote_devices.end())
								remote_devices.erase(it_tmp);*/

							string err(e.errors[0].desc);
							INFO_STREAM << __func__ << ": error subscribing event "<< tmp_dev.remote_attr_name << " on " << tmp_dev.remote_device_name << " err="<<err;
							if(k<3*MAX_ATTR_SIZE)
								sprintf(devices_status_str[k], "%s: subscription error: '%s'", tmp_dev.remote_device_name.c_str(), err.c_str());
							j++;
							k++;
							continue;
						}
						j++;
						k++;
					}
					if(proxy_err)
					{
						DEBUG_STREAM << __func__ << ": exited devices loop size="<<tmp.remote_name.size() << " with proxy error! not creating "<<results[2];
						continue;
					}
					DEBUG_STREAM << __func__ << ": exited devices loop size="<<tmp.remote_name.size() << " created="<<remote_devices.size();
				}
			}
			else
			{
		       	ostringstream o;
				o << __func__<<": Parsing Failed, syntax error stopped at " << string(tmp.formula_tree.stop, tmp.formula.end()) << ends; //TODO
		       	DEBUG_STREAM << o.str() << endl;
		       	continue;
			}
			tmp.descr=(results.size() == 6) ? results[5] : "";

			map<string,vector<attr_desc_t> >::iterator f = att_data.find(results[2]);
			if(f!=att_data.end())
			{
				//DEBUG_STREAM << __func__ << ": " << results[2] << " found, adding";
				f->second.push_back(tmp);
			}
			else
			{
				//DEBUG_STREAM << __func__ << ": " << results[2] << " not found, creating";
				vector<attr_desc_t> tmp_v;
				tmp_v.push_back(tmp);
				att_data.insert(make_pair(results[2],tmp_v));
				m_att_value.insert(make_pair(results[2],tmp_val));
			}
			//DEBUG_STREAM << __func__ << ": ended creating attribute="<<results[2];
		}
		else
		{
			DEBUG_STREAM << __FUNCTION__ << " wrong configuration string size="<<results.size();
		}
		attr_index = k;
	}
	DEBUG_STREAM << __FUNCTION__ << " exiting...";
}

//--------------------------------------------------------
/**
 *	Method      : FormulaConf::remove_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *                for specified device.
 */
//--------------------------------------------------------
void FormulaConf::remove_dynamic_attributes()
{
	DEBUG_STREAM << __FUNCTION__ << " entering...";
	read_loop->abortflag = true;
	usleep(500000);
	vector<remote_dev_t>::iterator it;
	for(it=remote_devices.begin(); it!=remote_devices.end(); it++)
	{
		if(it->remote_device)
		{
			DEBUG_STREAM << __FUNCTION__ << " unsubscribing "<< it->remote_name;
			try {
				it->remote_device->unsubscribe_event(it->eid);
			} catch(...)
			{}
				usleep(10000);
			try {
				delete it->remote_device;
			} catch(...)
			{}
		}
	}

	//remote_devices and other maps/vectors
	remote_devices.clear();
	att_data.clear();
	m_att_value.clear();
	
	
	map<string,vector<attr_desc_t> >::iterator attr_it;
	for(attr_it=att_data.begin(); attr_it != att_data.end(); attr_it++)
	{
		map<string,attr_val_t >::iterator it_val = m_att_value.find(attr_it->first);

		if (attr_it->second.size() == 1 && (attr_it->second.begin())->type == "bool")
		{
			remove_BoolScalarDyn_dynamic_attribute(attr_it->first);
		}
		else if (attr_it->second.size() == 1 && (attr_it->second.begin())->type == "double")
		{
			remove_DoubleScalarDyn_dynamic_attribute(attr_it->first);
		}
		else if (attr_it->second.size() == 1 && (attr_it->second.begin())->type == "long")
		{
			remove_LongScalarDyn_dynamic_attribute(attr_it->first);
		}
		else if((attr_it->second.begin())->type == "bool")
		{
			if(it_val != m_att_value.end())
				remove_BoolSpectrumDyn_dynamic_attribute(attr_it->first, false);
		}
		else if((attr_it->second.begin())->type == "string")
		{
			remove_StringSpectrumDyn_dynamic_attribute(attr_it->first, true);
		}
		else if((attr_it->second.begin())->type == "double")
		{
			if(it_val != m_att_value.end())
				remove_DoubleSpectrumDyn_dynamic_attribute(attr_it->first, false);
		}
		else if((attr_it->second.begin())->type == "long")
		{
			if(it_val != m_att_value.end())
				remove_LongSpectrumDyn_dynamic_attribute(attr_it->first, false);
		}
		else
		{
			continue;
		}
		stringstream descr_prop;
		size_t ind_descr=0;
		for(vector<attr_desc_t>::iterator it_descr = attr_it->second.begin(); it_descr != attr_it->second.end(); it_descr++)
		{
			descr_prop << "[" << ind_descr << "] " << it_descr->descr.c_str();
			if(ind_descr < attr_it->second.size()-1)
				descr_prop << endl;
			ind_descr++;
		}
		sort(attr_it->second.begin(), attr_it->second.end(),compare_attr_index);
	}
	DEBUG_STREAM << __FUNCTION__ << " exiting...";
}

//+------------------------------------------------------------------
/**
 *	method:	FormulaConf::string_explode
 * Explode a string
*/
//+------------------------------------------------------------------
void FormulaConf::string_explode(string str, string separator, vector<string>* results)
{
	size_t found;

	found = str.find_first_of(separator);
	while(found != string::npos) {
		if(found > 0) {
			results->push_back(str.substr(0,found));
		}
		str = str.substr(found+1);
		found = str.find_first_of(separator);
	}
	if(str.length() > 0) {
		results->push_back(str);
	}

}

//+------------------------------------------------------------------
/**
 *	method:	FormulaConf::init_attributeprop
 *
 *	description:
 *
 *
 */
//+------------------------------------------------------------------
void FormulaConf::init_attributeprop()
{

	//DEBUG_STREAM << __FUNCTION__ << " entering...";
	Tango::Database *db = new Tango::Database();
	vector <Tango::DbData> vdb_data_set;

	for(map<string,vector<attr_desc_t> >::iterator it_att = att_data.begin(); it_att != att_data.end(); it_att++)
	{

		Tango::DbDatum db_datum_attr(it_att->first);
		db_datum_attr << (short)1;	//1 attribute property in 'it_att->first'

		Tango::DbDatum db_datum_descr("Comment");
		Tango::DbData db_data_set;

		vector <string> v_desc;
		for(vector<attr_desc_t>::iterator it_v = it_att->second.begin(); it_v != it_att->second.end(); it_v++)
		{
			stringstream tmp;
			tmp << it_att->first << "[" << it_v->attr_index << "]='" << it_v->formula << "' ("<< it_v->descr <<")";
			v_desc.push_back(tmp.str());
			DEBUG_STREAM << __FUNCTION__ << ": "<< tmp.str();
		}

		db_datum_descr << v_desc;
		db_data_set.push_back(db_datum_attr);
		db_data_set.push_back(db_datum_descr);

		vdb_data_set.push_back(db_data_set);
	}
	vector<Tango::DbData>::iterator ite;

	try {
		db->set_timeout_millis(10000);
		for( ite=vdb_data_set.begin() ; ite < vdb_data_set.end(); ite++ )
		{
			db->put_device_attribute_property(get_name(), *ite);
		}
	} catch (Tango::DevFailed &e) {
		INFO_STREAM << "FormulaConf::init_attributeprop() init attributeprop failed"<<endl;
		Tango::Except::print_exception(e);
	}
	delete db;
}


//==============================================================
//------------------- AST evaluation methods -------------------
//==============================================================
double FormulaConf::eval_formula(tree_parse_info_t tree, string attr_name, string &attr_values)
{
	return eval_expression(tree.trees.begin(), attr_name, attr_values);
}

double FormulaConf::eval_expression(iter_t const& i, string attr_name, string &attr_values, uint32_t ev_ind) //throw (string &), std::out_of_range
{

	ostringstream err;
	err << "Evaluating formula: ";
	//iter_t it = i->children.begin();

	if (i->value.id() == formula_grammar::val_rID)
	{
		if(i->children.size() != 0)
		{
			err <<  "in node val_rID(" << string(i->value.begin(), i->value.end()) << ") children=" << i->children.size() << ends;
			throw err.str();
		}
		string val_d(i->value.begin(), i->value.end());
		INFO_STREAM << "		node value real = " << val_d << endl;
		return strtod(val_d.c_str(), 0);
	}
	else if (i->value.id() == formula_grammar::val_hID)
	{
		if(i->children.size() != 0)
		{
			err <<  "in node val_hID(" << string(i->value.begin(), i->value.end()) << ") children=" << i->children.size() << ends;
			throw err.str();
		}
		string val_d(i->value.begin(), i->value.end());
		INFO_STREAM << "		node value hex = " << val_d << endl;
		return strtod(val_d.c_str(), 0);
	}
	else if (i->value.id() == formula_grammar::val_stID)
	{
		if(i->children.size() != 0)
		{
			err <<  "in node val_stID(" << string(i->value.begin(), i->value.end()) << ") children=" << i->children.size() << ends;
			throw err.str();
		}
		string val_st(i->value.begin(), i->value.end());

		double st =  i->value.value();			//get value directly from node saved with access_node_d
		INFO_STREAM << "		node value state : " << val_st << "=" << st << endl;
		return st;
	}
	else if (i->value.id() == formula_grammar::val_qualityID)
	{
		if(i->children.size() != 0)
		{
			err <<  "in node val_qualityID(" << string(i->value.begin(), i->value.end()) << ") children=" << i->children.size() << ends;
			throw err.str();
		}
		string val_quality(i->value.begin(), i->value.end());

		double quality =  i->value.value();			//get value directly from node saved with access_node_d
		INFO_STREAM << "		node value quality : " << val_quality << "=" << quality << endl;
		return quality;
	}
	else if (i->value.id() == formula_grammar::unary_exprID)
	{
		DEBUG_STREAM << "		node unary expression: " << string(i->value.begin(), i->value.end()) << endl;
		if(i->children.size() != 1)
	{
		err <<  "in node unary_exprID(" << string(i->value.begin(), i->value.end()) << ") children=" << i->children.size() << ends;
		throw err.str();
	}
	if (*i->value.begin() == '+')
		return + eval_expression(i->children.begin(), attr_name, attr_values);
	if (*i->value.begin() == '-')
		return - eval_expression(i->children.begin(), attr_name, attr_values);
	if (*i->value.begin() == '!')
		return ! eval_expression(i->children.begin(), attr_name, attr_values);
	/*if (*i->value.begin() == '~')
		return ~ eval_expression(i->children.begin(), attr_name, attr_values);*/	//TODO
	}
	else if (i->value.id() == formula_grammar::mult_exprID)
	{
		DEBUG_STREAM << "		node mult expression: " << string(i->value.begin(), i->value.end()) << endl;
		if(i->children.size() != 2)
		{
			err <<  "in node mult_exprID(" << string(i->value.begin(), i->value.end()) << ") children=" << i->children.size() << ends;
			throw err.str();
		}
		if (*i->value.begin() == '*')
		{
			return eval_expression(i->children.begin(), attr_name, attr_values) *
				eval_expression(i->children.begin()+1, attr_name, attr_values);
		}
		else if (*i->value.begin() == '/')
		{
			return eval_expression(i->children.begin(), attr_name, attr_values) /
				eval_expression(i->children.begin()+1, attr_name, attr_values);
		}
		else
		{
			err <<  "in node mult_exprID(" << string(i->value.begin(), i->value.end()) << ") value not allowed" << ends;
			throw err.str();
		}
	}
	else if (i->value.id() == formula_grammar::add_exprID)
	{
		DEBUG_STREAM << "		node add expression: " << string(i->value.begin(), i->value.end()) << endl;
		if(i->children.size() != 2)
		{
			err <<  "in node add_exprID(" << string(i->value.begin(), i->value.end()) << ") children=" << i->children.size() << ends;
			throw err.str();
		}
		if (*i->value.begin() == '+')
		{
			return eval_expression(i->children.begin(), attr_name, attr_values) +
				eval_expression(i->children.begin()+1, attr_name, attr_values);
		}
		else if (*i->value.begin() == '-')
		{
			return eval_expression(i->children.begin(), attr_name, attr_values) -
				eval_expression(i->children.begin()+1, attr_name, attr_values);
		}
		else
		{
			err <<  "in node add_exprID(" << string(i->value.begin(), i->value.end()) << ") value not allowed" << ends;
			throw err.str();
		}
	}
	else if (i->value.id() == formula_grammar::event_ID)
	{
		DEBUG_STREAM << "		node event" << string(i->value.begin(), i->value.end()) << endl;
		int ind;
		if(i->children.size() != 2)
		{
			err <<  "in node event_ID(" << string(i->value.begin(), i->value.end()) << ") children=" << i->children.size() << ends;;
			throw err.str();
		}
		if((i->children.begin()+1)->value.id() == formula_grammar::indexID)
			ind = (int)eval_expression(i->children.begin()+1, attr_name, attr_values);		//array index
		else
		{
			err <<  "in node event_ID(" << string(i->value.begin(), i->value.end()) << ") children2 is not an index ->" << string((i->children.begin()+1)->value.begin(), (i->children.begin()+1)->value.end()) << ends;;
			throw err.str();
		}
		return eval_expression(i->children.begin(), attr_name, attr_values ,ind);
	}
	else if (i->value.id() == formula_grammar::nameID)
	{
		if(i->children.size() != 0)
		{
			err <<  "in node nameID(" << string(i->value.begin(), i->value.end()) << ") children=" << i->children.size() << ends;
			throw err.str();
		}

		string name_id(i->value.begin(), i->value.end());
		std::transform(name_id.begin(), name_id.end(), name_id.begin(), (int(*)(int))tolower);		//transform to lowercase
		vector<remote_dev_t>::iterator it;
		for(it=remote_devices.begin(); it!=remote_devices.end(); it++)
		{
			//DEBUG_STREAM << __func__<<": looking for " << name_id << " now is "<< it->remote_name;
			if(it->remote_name == name_id)
				break;
		}

		if(it != remote_devices.end())
		{
			struct timespec now;
			clock_gettime(CLOCK_MONOTONIC,&now);
			double diff_time_poll_s = fabs((now.tv_sec - it->last_read.tv_sec) + ((double)(now.tv_nsec - it->last_read.tv_nsec))/1e9);
			double diff_time_ev_s = fabs((now.tv_sec - it->last_event_rx.tv_sec) + ((double)(now.tv_nsec - it->last_event_rx.tv_nsec))/1e9);


			if((diff_time_poll_s > 2+polling_period+read_timeout) && (diff_time_ev_s > 2+polling_period+read_timeout) && polling_period > 0)
			{
				err <<  "in node nameID(" << name_id << ") value not valid! (TIMEOUT diff_time_poll_s="<<diff_time_poll_s<<" diff_time_ev_s="<<diff_time_ev_s<<") " << ends;
				throw err.str();
			}

			if(ev_ind >= it->value.size())
			{
				err <<  "in node nameID(" << name_id << ") index ("<<ev_ind<<") out of range (size="<<it->value.size()<<")" << ends;
				throw err.str();
			}

			ostringstream temp_attr_val;
			temp_attr_val << it->remote_name << "[" << ev_ind << "]=" <<it->value.at(ev_ind) << ";";
			attr_values += temp_attr_val.str();
			INFO_STREAM << "		node name -> " << temp_attr_val.str() << endl;
			return it->value.at(ev_ind);		//throw  std::out_of_range
		}
		else
		{
			err <<  "in event: (" << name_id << ") not found in event table" << ends;
			throw err.str();
		}
	}
	else if (i->value.id() == formula_grammar::indexID)
	{
		if(i->children.size() != 0)
		{
			err <<  "in node indexID(" << string(i->value.begin(), i->value.end()) << ") children=" << i->children.size() << ends;
			throw err.str();
		}
		string val_d(i->value.begin(), i->value.end());
		DEBUG_STREAM << "		node index = " << val_d << endl;
		return strtod(val_d.c_str(), 0);
	}
	else if (i->value.id() == formula_grammar::logical_exprID)
	{
		DEBUG_STREAM << "		node logical expression: " << string(i->value.begin(), i->value.end()) << endl;
		if(i->children.size() != 2)
		{
			err <<  "in node logical_exprID(" << string(i->value.begin(), i->value.end()) << ") children=" << i->children.size() << ends;
			throw err.str();
		}
		if (string(i->value.begin(), i->value.end()) == string("&&"))
		{
			return eval_expression(i->children.begin(), attr_name, attr_values) &&
				eval_expression(i->children.begin()+1, attr_name, attr_values);
		}
		else if (string(i->value.begin(), i->value.end()) == string("||"))
		{
			return eval_expression(i->children.begin(), attr_name, attr_values) ||
				eval_expression(i->children.begin()+1, attr_name, attr_values);
		}
		else
		{
			err <<  "in node logical_exprID(" << string(i->value.begin(), i->value.end()) << ") value not allowed" << ends;
			throw err.str();
		}
	}
	else if (i->value.id() == formula_grammar::bitwise_exprID)
	{
		DEBUG_STREAM << "		node bitwise expression: " << string(i->value.begin(), i->value.end()) << endl;
		if(i->children.size() != 2)
		{
			err <<  "in node bitwise_exprID(" << string(i->value.begin(), i->value.end()) << ") children=" << i->children.size() << ends;
			throw err.str();
		}
		double val_d1=eval_expression(i->children.begin(), attr_name, attr_values),
			val_d2=eval_expression(i->children.begin()+1, attr_name, attr_values);
		long val_l1,val_l2;

		string err2("ERROR: non-int value in bitwise operation!");
		val_l1 = (long)trunc(val_d1);		//transform to long
		val_l2 = (long)trunc(val_d2);		//transform to long

		if((val_l1 != val_d1) || (val_l2 != val_d2))	//if different, lost something with truncf
			throw err2;

		if (*i->value.begin() == '&')
		{
			return (double)(val_l1 & val_l2);
		}
		else if (*i->value.begin() == '|')
		{
			return (double)(val_l1 | val_l2);
		}
		else if (*i->value.begin() == '^')
		{
			return (double)(val_l1 ^ val_l2);
		}
		else
		{
			err << "in node bitwise_exprID(" << string(i->value.begin(), i->value.end()) << ") value not allowed" << ends;
			throw err.str();
		}
	}
	else if (i->value.id() == formula_grammar::shift_exprID)
	{
		DEBUG_STREAM << "		node shift expression: " << string(i->value.begin(), i->value.end()) << endl;
		//assert(i->children.size() == 2);
		if(i->children.size() != 2)
		{
			err <<  "in node shift_exprID(" << string(i->value.begin(), i->value.end()) << ") children=" << i->children.size() << ends;
			throw err.str();
		}
		double val_d1=eval_expression(i->children.begin(), attr_name, attr_values),
			val_d2=eval_expression(i->children.begin()+1, attr_name, attr_values);
		long val_l1,val_l2;

		string err2("ERROR: non-int value in bitwise operation!");
		val_l1 = (long)trunc(val_d1);		//transform to long
		val_l2 = (long)trunc(val_d2);		//transform to long

		if((val_l1 != val_d1) || (val_l2 != val_d2))	//if different, lost something with truncf
			throw err2;

		if (string(i->value.begin(), i->value.end()) == string("<<"))
		{
			return (double)(val_l1 << val_l2);
		}
		else if (string(i->value.begin(), i->value.end()) == string(">>"))
		{
			return (double)(val_l1 >> val_l2);
		}
		else
		{
			err <<  "in node shift_exprID(" << string(i->value.begin(), i->value.end()) << ") value not allowed" << ends;
			throw err.str();
		}
	}
	else if (i->value.id() == formula_grammar::equality_exprID)
	{
		DEBUG_STREAM << "		node equality expression: " << string(i->value.begin(), i->value.end()) << endl;
		if(i->children.size() != 2)
		{
			err <<  "in node equality_exprID(" << string(i->value.begin(), i->value.end()) << ") children=" << i->children.size() << ends;
			throw err.str();
		}

		//string comparison here
		iter_t const& i2_1 = i->children.begin();
		iter_t const& i2_2 = i->children.begin()+1;
		//OK only attr == 'string' or attr != 'string'
		if(i2_1->value.id() == formula_grammar::nameID && i2_2->value.id() == formula_grammar::val_stringID)
		{
			if(i2_1->children.size() == 0 && i2_2->children.size() == 0)
			{
				//retrieve string from attribute:
				string attr_val = "";
				string name_id(i2_1->value.begin(), i2_1->value.end());
				std::transform(name_id.begin(), name_id.end(), name_id.begin(), (int(*)(int))tolower);		//transform to lowercase
				vector<remote_dev_t>::iterator it;
				for(it=remote_devices.begin(); it!=remote_devices.end(); it++)
				{
					//DEBUG_STREAM << __func__<<": looking for " << name_id << " now is "<< it->remote_name;
					if(it->remote_name == name_id)
						break;
				}

				if(it != remote_devices.end())
				{
					struct timespec now;
					clock_gettime(CLOCK_MONOTONIC,&now);
					double diff_time_poll_s = fabs((now.tv_sec - it->last_read.tv_sec) + ((double)(now.tv_nsec - it->last_read.tv_nsec))/1e9);
					double diff_time_ev_s = fabs((now.tv_sec - it->last_event_rx.tv_sec) + ((double)(now.tv_nsec - it->last_event_rx.tv_nsec))/1e9);


					if((diff_time_poll_s > 2+polling_period+read_timeout) && (diff_time_ev_s > 2+polling_period+read_timeout) && polling_period > 0)
					{
						err <<  "in node nameID(" << string(i->value.begin(), i->value.end()) << ") value not valid! (TIMEOUT 2 diff_time_poll_s="<<diff_time_poll_s<<" diff_time_ev_s="<<diff_time_ev_s<<")" << ends;
						throw err.str();
					}

					ostringstream temp_attr_val;
					temp_attr_val << it->remote_name << "=" <<it->value_string << ";";
					attr_values += temp_attr_val.str();
					INFO_STREAM << "		node name string -> " << temp_attr_val.str() << endl;
					attr_val =  string("'") + it->value_string + string("'");
				}
				else
				{
					err <<  "in event: (" << string(i->value.begin(), i->value.end()) << ") not found in event table" << ends;
					throw err.str();
				}
				//retrieve string from formula
				string val_string(i2_2->value.begin(), i2_2->value.end());

				if (string(i->value.begin(), i->value.end()) == string("!="))
				{
					return attr_val != val_string;
				}
				else if (string(i->value.begin(), i->value.end()) == string("=="))
				{
					return attr_val == val_string;
				}
				else
				{
					err <<  "in node equality_exprID(" << string(i->value.begin(), i->value.end()) << ") value not allowed (val_stringID)" << ends;
					throw err.str();
				}
			}
		}
		else
		{
			if (string(i->value.begin(), i->value.end()) == string("!="))
			{
				return eval_expression(i->children.begin(), attr_name, attr_values) !=
					eval_expression(i->children.begin()+1, attr_name, attr_values);
			}
			else if (string(i->value.begin(), i->value.end()) == string("=="))
			{
				return eval_expression(i->children.begin(), attr_name, attr_values) ==
					eval_expression(i->children.begin()+1, attr_name, attr_values);
			}
			else
			{
				err <<  "in node equality_exprID(" << string(i->value.begin(), i->value.end()) << ") value not allowed" << ends;
				throw err.str();
			}
		}
	}
	else if (i->value.id() == formula_grammar::compare_exprID)
	{
		DEBUG_STREAM << "		node compare expression: " << string(i->value.begin(), i->value.end()) << endl;
		if(i->children.size() != 2)
		{
			err <<  "in node compare_exprID(" << string(i->value.begin(), i->value.end()) << ") children=" << i->children.size() << ends;
			throw err.str();
		}
		if (string(i->value.begin(), i->value.end()) == string("<="))
		{
			return eval_expression(i->children.begin(), attr_name, attr_values) <=
				eval_expression(i->children.begin()+1, attr_name, attr_values);
		}
			else if (string(i->value.begin(), i->value.end()) == string(">="))
		{
			return eval_expression(i->children.begin(), attr_name, attr_values) >=
				eval_expression(i->children.begin()+1, attr_name, attr_values);
		}
		else if (*i->value.begin() == '<')
		{
			return eval_expression(i->children.begin(), attr_name, attr_values) <
				eval_expression(i->children.begin()+1, attr_name, attr_values);
		}
		else if (*i->value.begin() == '>')
		{
			return eval_expression(i->children.begin(), attr_name, attr_values) >
				eval_expression(i->children.begin()+1, attr_name, attr_values);
		}
		else
		{
			err <<  "in node equality_exprID(" << string(i->value.begin(), i->value.end()) << ") value not allowed" << ends;
			throw err.str();
		}
	}
	else if (i->value.id() == formula_grammar::funcID)
	{
		DEBUG_STREAM << "		node function: " << string(i->value.begin(), i->value.end()) << endl;
		if(i->children.size() != 1)
		{
			err <<  "in node funcID(" << string(i->value.begin(), i->value.end()) << ") children=" << i->children.size() << ends;
			throw err.str();
		}
		if (string(i->value.begin(), i->value.end()) == string("abs"))
		{
			return fabs(eval_expression(i->children.begin(), attr_name, attr_values));
		}
		else if (string(i->value.begin(), i->value.end()) == string("cos"))
		{
			return cos(eval_expression(i->children.begin(), attr_name, attr_values));
		}
		else if (string(i->value.begin(), i->value.end()) == string("sin"))
		{
			return sin(eval_expression(i->children.begin(), attr_name, attr_values));
		}
		else if (string(i->value.begin(), i->value.end()) == string("quality"))
		{
			if(i->children.size() != 1)
			{
				err <<  "in node funcID(" << string(i->value.begin(), i->value.end()) << ") children=" << i->children.size() << ends;
				throw err.str();
			}
			if(i->children.begin()->value.id() != formula_grammar::nameID)
			{
				string name_id(i->children.begin()->value.begin(), i->children.begin()->value.end());
				err <<  "in node funcID(" << string(i->value.begin(), i->value.end()) << ") children is not an attribute name but " << name_id << ends;
				throw err.str();
			}


			string name_id(i->children.begin()->value.begin(), i->children.begin()->value.end());
			std::transform(name_id.begin(), name_id.end(), name_id.begin(), (int(*)(int))tolower);		//transform to lowercase
			vector<remote_dev_t>::iterator it;
			for(it=remote_devices.begin(); it!=remote_devices.end(); it++)
			{
				//DEBUG_STREAM << __func__<<": looking for " << name_id << " now is "<< it->remote_name;
				if(it->remote_name == name_id)
					break;
			}

			if(it != remote_devices.end())
			{
				struct timespec now;
				clock_gettime(CLOCK_MONOTONIC,&now);
				double diff_time_poll_s = fabs((now.tv_sec - it->last_read.tv_sec) + ((double)(now.tv_nsec - it->last_read.tv_nsec))/1e9);
				double diff_time_ev_s = fabs((now.tv_sec - it->last_event_rx.tv_sec) + ((double)(now.tv_nsec - it->last_event_rx.tv_nsec))/1e9);

				if((diff_time_poll_s > 2+polling_period+read_timeout) && (diff_time_ev_s > 2+polling_period+read_timeout) && polling_period > 0)
				{
					err <<  "in node nameID(" << name_id << ") value not valid! (TIMEOUT diff_time_poll_s="<<diff_time_poll_s<<" diff_time_ev_s="<<diff_time_ev_s<<") " << ends;
					throw err.str();
				}

				ostringstream temp_attr_val;
				temp_attr_val << "quality("<< it->remote_name << ")=" <<it->quality << ";";
				attr_values += temp_attr_val.str();
				INFO_STREAM << "		node name -> " << temp_attr_val.str() << endl;
				return it->quality;		//throw  std::out_of_range
			}
			else
			{
				err <<  "in event: (" << name_id << ") not found in event table" << ends;
				throw err.str();
			}
		}
		else
		{
			err <<  "in node funcID(" << string(i->value.begin(), i->value.end()) << ") value not allowed" << ends;
			throw err.str();
		}
	}
	else if (i->value.id() == formula_grammar::func_dualID)
	{
		DEBUG_STREAM << "		node function dual: " << string(i->value.begin(), i->value.end()) << endl;
		if(i->children.size() != 2)
		{
			err <<  "in node func_dualID(" << string(i->value.begin(), i->value.end()) << ") children=" << i->children.size() << ends;
			throw err.str();
		}
		if (string(i->value.begin(), i->value.end()) == string("min"))
		{
			return min(eval_expression(i->children.begin(), attr_name, attr_values),
				eval_expression(i->children.begin()+1, attr_name, attr_values));
		}
		else if (string(i->value.begin(), i->value.end()) == string("max"))
		{
			return max(eval_expression(i->children.begin(), attr_name, attr_values),
				eval_expression(i->children.begin()+1, attr_name, attr_values));
		}
		else if (string(i->value.begin(), i->value.end()) == string("pow"))
		{
			return pow(eval_expression(i->children.begin(), attr_name, attr_values),
				eval_expression(i->children.begin()+1, attr_name, attr_values));
		}
		else
		{
			err <<  "in node func_dualID(" << string(i->value.begin(), i->value.end()) << ") value not allowed" << ends;
			throw err.str();
		}
	}
	else if (i->value.id() == formula_grammar::cond_exprID)
	{
		DEBUG_STREAM << "		node ternary_if expression: " << string(i->value.begin(), i->value.end()) << endl;
		if(i->children.size() != 3)
		{
			err <<  "in node ternary_ifID(" << string(i->value.begin(), i->value.end()) << ") children=" << i->children.size() << ends;
			throw err.str();
		}
		if(eval_expression(i->children.begin(), attr_name, attr_values))
			return (eval_expression(i->children.begin()+1, attr_name, attr_values));
		else
			return (eval_expression(i->children.begin()+2, attr_name, attr_values));
	}
	else
	{
		DEBUG_STREAM << "		node unknown id: " << string(i->value.begin(), i->value.end()) << endl;
		{
			err <<  "node unknown!! value=" << string(i->value.begin(), i->value.end()) << ends;
			throw err.str();
		}
	}
	return 0;
}


void FormulaConf::find_device_formula(tree_parse_info_t tree, vector<string> & devs)
{
	eval_node_device(tree.trees.begin(), devs);
	return;
}

void FormulaConf::eval_node_device(iter_t const& i, vector<string> & devs)
{
	/*DEBUG_STREAM << "In eval_node_event. i->value = " <<
	string(i->value.begin(), i->value.end()) <<
	" i->children.size() = " << i->children.size() << " NODE=" <<
	rule_names[i->value.id()] <<  endl;*/

	ostringstream err;
	err << "Looking for event in formula tree: ";
	/*if (i->value.id() == formula_grammar::event_ID)
	{
		DEBUG_STREAM << "eval_node_event(): in eventID!!!=" << string(i->value.begin(), i->value.end()) << endl;
	}
	else*/ if (i->value.id() == formula_grammar::nameID)
	{
		INFO_STREAM << "eval_node_event(): find event name=" << string(i->value.begin(), i->value.end()) << endl;
		if(i->children.size() != 0)
		{
			err <<  "in node nameID(" << string(i->value.begin(), i->value.end()) << ") children=" << i->children.size() << ends;
			throw err.str();
		}
		string s(i->value.begin(), i->value.end());
		std::transform(s.begin(), s.end(), s.begin(), (int(*)(int))tolower);		//transform to lowercase
		devs.push_back(s);
	}
	//cout << endl;
	//iter_t it = i->children.begin();
	for(iter_t it = i->children.begin(); it != i->children.end(); it++)
		eval_node_device(it, devs);
	return;
}

void FormulaConf::extract_values(Tango::DeviceAttribute *attr_value, vector<double> &val, string &val_string)
{
	Tango::DevState stval;
	vector<Tango::DevState> v_st;
	vector<Tango::DevULong> v_ulo;
	vector<Tango::DevUChar> v_uch;
	vector<Tango::DevShort> v_sh;
	vector<Tango::DevUShort> v_ush;
	vector<Tango::DevLong> v_lo;
	vector<Tango::DevDouble> v_do;
	vector<Tango::DevFloat> v_fl;
	vector<Tango::DevBoolean> v_bo;
	vector<string> v_string;

	val.clear();

	if (attr_value->get_type() == Tango::DEV_UCHAR)
	{
		*(attr_value) >> v_uch;
		for(vector<Tango::DevUChar>::iterator it = v_uch.begin(); it != v_uch.end(); it++)
			val.push_back((double)(*it));		//convert all to double
	}
	else if (attr_value->get_type() == Tango::DEV_SHORT)
	{
		*(attr_value) >> v_sh;
		for(vector<Tango::DevShort>::iterator  it = v_sh.begin(); it != v_sh.end(); it++)
			val.push_back((double)(*it));		//convert all to double
	}
	else if (attr_value->get_type() == Tango::DEV_USHORT)
	{
		*(attr_value) >> v_ush;
		for(vector<Tango::DevUShort>::iterator  it = v_ush.begin(); it != v_ush.end(); it++)
			val.push_back((double)(*it));		//convert all to double
	}
	else if (attr_value->get_type() == Tango::DEV_LONG)
	{
		*(attr_value) >> v_lo;
		for(vector<Tango::DevLong>::iterator  it = v_lo.begin(); it != v_lo.end(); it++)
			val.push_back((double)(*it));		//convert all to double
	}
	else if (attr_value->get_type() == Tango::DEV_STATE)
	{
		//*(attr_value) >> v_st;		//doesn't work in tango 5
		*(attr_value) >> stval;
		v_st.push_back(stval);
		for(vector<Tango::DevState>::iterator it = v_st.begin(); it != v_st.end(); it++)
			val.push_back((double)(*it));		//convert all to double
	}
	else if (attr_value->get_type() == Tango::DEV_ULONG)
	{
		*(attr_value) >> v_ulo;
		for(vector<Tango::DevULong>::iterator  it = v_ulo.begin(); it != v_ulo.end(); it++)
			val.push_back((double)(*it));		//convert all to double
	}
	else if (attr_value->get_type() == Tango::DEV_DOUBLE)
	{
		*(attr_value) >> v_do;
		for(vector<Tango::DevDouble>::iterator  it = v_do.begin(); it != v_do.end(); it++)
			val.push_back((double)(*it));		//convert all to double
	}
	else if (attr_value->get_type() == Tango::DEV_FLOAT)
	{
		*(attr_value) >> v_fl;
		for(vector<Tango::DevFloat>::iterator  it = v_fl.begin(); it != v_fl.end(); it++)
			val.push_back((double)(*it));		//convert all to double
	}
	else if (attr_value->get_type() == Tango::DEV_BOOLEAN)
	{
		*(attr_value) >> v_bo;
		for(vector<Tango::DevBoolean>::iterator  it = v_bo.begin(); it != v_bo.end(); it++)
			val.push_back((double)(*it));		//convert all to double
	}
	else if (attr_value->get_type() == Tango::DEV_STRING)
	{
		*(attr_value) >> v_string;
		val_string = *(v_string.begin());
	}
	else
	{
		ostringstream o;
		o << "unknown type=" << (int)attr_value->get_type() << ends;
		throw o.str();
	}
}

vector<remote_dev_t>::iterator FormulaConf::find_events(string event_name) throw(string&)
{

	vector<remote_dev_t>::iterator it_ev;
	std::transform(event_name.begin(), event_name.end(), event_name.begin(), (int(*)(int))tolower);		//transform to lowercase
	for(it_ev = remote_devices.begin(); it_ev != remote_devices.end(); it_ev++)
	{
		//DEBUG_STREAM << __func__<<": 1 looking for: '"<<event_name<<"' now remote_name: '"<<it_ev->remote_name<<"'";
		if(it_ev->remote_name.find(event_name) != string::npos)	//TODO: or ==
			return it_ev;
	}

	if (it_ev == remote_devices.end())
	{
		//try to remove network domain and FQDN
		string ev_name_str(event_name);
		string::size_type pos_slash = ev_name_str.find("tango://");
		if (pos_slash != string::npos)	//FQDN!!
		{
			//first remove network domain if any
			string::size_type pos_dot = ev_name_str.find(".",8);	//look for first . after tango://
			string::size_type pos_colon = ev_name_str.find(":",8);	//look for first : after tango://
			pos_slash = ev_name_str.find('/',8);					//look for first / after tango://
			if(pos_dot < pos_slash && pos_dot != string::npos && pos_colon != string::npos && pos_slash != string::npos)	//dot is in the TANGO_HOST part
			{
				string ev_name_str_no_domain = ev_name_str.substr(0,pos_dot) + ev_name_str.substr(pos_colon);
				for(it_ev = remote_devices.begin(); it_ev != remote_devices.end(); it_ev++)
				{
					//DEBUG_STREAM << __func__<<": 2 looking for: '"<<event_name<<"' now remote_name: '"<<it_ev->remote_name<<"'";
					if(it_ev->remote_name.find(ev_name_str_no_domain) != string::npos)	//TODO: or ==
						return it_ev;
				}
			}
			if (it_ev == remote_devices.end() && pos_slash != string::npos)
			{
				ev_name_str = ev_name_str.substr(pos_slash + 1);//remove FQDN
				for(it_ev = remote_devices.begin(); it_ev != remote_devices.end(); it_ev++)
				{
					//DEBUG_STREAM << __func__<<": 3 looking for: '"<<event_name<<"' now remote_name: '"<<it_ev->remote_name<<"'";
					if(it_ev->remote_name.find(ev_name_str) != string::npos)	//TODO: or ==
						return it_ev;
				}
			}
		}
		if (it_ev == remote_devices.end())
		{
			/*
			 * shouldn't happen!!!
			 */
			ostringstream o;
			o << "find_events(): event '" \
				<< event_name << "' not found!" << ends;
				ERROR_STREAM << o.str() << endl;
			//cerr << o.str() << endl;
			throw o.str();
		}
	}

	//if (it_ev != remote_devices.end())
	{
		return it_ev;
	}
}


/*
 * EventCallBack class methods
 */
EventCallBack::EventCallBack(void)
{
	//cout<<"EventCallBack::EventCallBack entering..."<<endl;
	mydevice = NULL;
	//mydevices.clear();
}

EventCallBack::~EventCallBack(void)
{
	//cout<<"EventCallBack::~EventCallBack entering..."<<endl;
	mydevice = NULL;
	//mydevices.clear();
}

void EventCallBack::push_event(Tango::EventData* ev)
{
	//cout<<"EventCallBack::push_event entering... event_name="<<ev->attr_name<<endl;
	string temp_name;
	string ev_name;
	Tango::DeviceAttribute attr_value;
	//vector<Tango::DevBoolean> value_b;

	//vector<FormulaConf *>::iterator it;
	//for(it = mydevices.begin(); it != mydevices.end(); it++)
	//{
	//	FormulaConf *mydevice = *it;

	vector<remote_dev_t>::iterator it_ev=mydevice->remote_devices.end();
	struct timeval now_log;
	gettimeofday(&now_log, NULL);

	try {
			it_ev=mydevice->find_events(ev->attr_name);
			if (!ev->err)
			{
				//e.ev_name = ev->attr_name;
				//e.ts = ev->attr_value->time;
				//vector<remote_dev_t>::iterator it_ev=find_events(ev->attr_name);
				//extract_values(ev->attr_value, e.value, e.type);
				if(it_ev != mydevice->remote_devices.end())
				{
					it_ev->quality = ev->attr_value->quality;
					mydevice->extract_values(ev->attr_value, it_ev->value, it_ev->value_string);
					int k = it_ev->stat_index;
					clock_gettime(CLOCK_MONOTONIC,&it_ev->last_event_rx);
					double dnow = (double)(it_ev->last_event_rx.tv_sec) + ((double)it_ev->last_event_rx.tv_nsec)/1e9;
					if(k<3*MAX_ATTR_SIZE)
						sprintf(mydevice->devices_status_str[k], "%s: %13.3f - EVENT '%s' OK", it_ev->remote_device_name.c_str(), dnow, it_ev->remote_attr_name.c_str());
					it_ev->event_error = false;

					//iterate through local attributes, evaluates formulas involved and push events
					for(vector<string>::iterator it_loc_attr=it_ev->loc_attr_name.begin(); it_loc_attr!=it_ev->loc_attr_name.end(); it_loc_attr++)
					{
						//cout<<(int)now_log.tv_sec<<" "<<__func__<<": event_name="<<ev->attr_name<<" evaluating loc attr: "<<*it_loc_attr<<endl;
						map<string,vector<attr_desc_t> >::iterator it_attr = mydevice->att_data.find(*it_loc_attr);
						map<string,attr_val_t >::iterator it_val = mydevice->m_att_value.find(*it_loc_attr);
						if(it_attr == mydevice->att_data.end() || it_val == mydevice->m_att_value.end())
							continue;

						bool formula_err = false;
						for(vector<attr_desc_t>::iterator it_rem_attr = it_attr->second.begin(); it_rem_attr != it_attr->second.end(); it_rem_attr++)
						{
							//cout <<(int)now_log.tv_sec<<" "<< __FUNCTION__ << " looping " << it_ev->formula<<endl;
							//cout<<(int)now_log.tv_sec<<" "<<"EventCallBack::push_event event_name="<<ev->attr_name<<" evaluating loc attr: "<<*it_loc_attr<<" evaluating formula: "<<it_rem_attr->formula<<endl;
							string attr_values;
							double res = 0.0;	//initialize to false
							try
							{
								res = mydevice->eval_formula(it_rem_attr->formula_tree, *it_loc_attr, attr_values);
							}
							catch(string &err)
							{
								cout <<(int)now_log.tv_sec<<" "<< __func__<<": error evaluating formula="<<it_rem_attr->formula<<" err="<<err<<endl;
								formula_err = true;
								break;
							}
							catch(std::out_of_range &err)
							{
								cout <<(int)now_log.tv_sec<<" "<< __func__<<": out_of_range exception evaluating formula="<<it_rem_attr->formula<<" err="<<err.what()<<endl;
								formula_err = true;
								break;
							}
							catch(...)
							{
								cout <<(int)now_log.tv_sec<<" "<< __func__<<": generic exception evaluating formula="<<it_rem_attr->formula<<endl;
								formula_err = true;
								break;
							}
							if(it_rem_attr->type == "bool")
							{
								it_val->second.val[ it_rem_attr->attr_index ] = (res != 0.0);
							}
							else if(it_rem_attr->type == "double")
							{
								it_val->second.val_d[ it_rem_attr->attr_index ] = res;
							}
							else if(it_rem_attr->type == "long")
							{
								it_val->second.val_l[ it_rem_attr->attr_index ] = (Tango::DevLong)round(res);
							}
							else
							{
								formula_err = true;
								break;
							}
						}
						//something went wrong-> skip this local attribute
						if(formula_err)
							continue;

					    //	Set the attribute value
					    //attr.set_value(&(it_val->second.val[0]), it_attr->second.size());
						bool changed = false;
						for(uint32_t i=0; i<it_attr->second.size(); i++)
						{
							if(it_attr->second[0].type == "bool")
							{
								if(it_val->second.val[ i ] != it_val->second.old_val[ i ])
									changed = true;
							}
							else if(it_attr->second[0].type == "double")
							{
								if(it_val->second.val_d[ i ] != it_val->second.old_val_d[ i ])
									changed = true;
							}
							else if(it_attr->second[0].type == "long")
							{
								if(it_val->second.val_l[ i ] != it_val->second.old_val_l[ i ])
									changed = true;
							}
						}

						if(changed || it_attr->second[0].first_push)
						{
							//cout<<(int)now_log.tv_sec<<" "<<"EventCallBack::push_event event_name="<<ev->attr_name<<" evaluating loc attr: "<<*it_loc_attr<<" CHANGED-> pushing changed="<<(int)changed<<" first_push="<<(int)it_attr->second[0].first_push<<endl;
							it_attr->second[0].first_push = false;
							bool push_err=false;
							try{
								if(it_attr->second[0].type == "bool")
									mydevice->push_change_event(*it_loc_attr,&(it_val->second.val[0]),/*NULL,Tango::ATTR_VALID,*/ it_attr->second.size(), 0, false);
								else if(it_attr->second[0].type == "double")
									mydevice->push_change_event(*it_loc_attr,&(it_val->second.val_d[0]),/*NULL,Tango::ATTR_VALID,*/ it_attr->second.size(), 0, false);
								else if(it_attr->second[0].type == "long")
									mydevice->push_change_event(*it_loc_attr,&(it_val->second.val_l[0]),/*NULL,Tango::ATTR_VALID,*/ it_attr->second.size(), 0, false);
							} catch(Tango::DevFailed &e)
							{
								cout <<(int)now_log.tv_sec<<" "<< "EventCallBack::push_event() error pushing change event="<<e.errors[0].desc<<endl;
								push_err=true;
							}
							if(!push_err)
							{
								for(uint32_t i=0; i<it_attr->second.size() && i<MAX_ATTR_SIZE; i++)
								{
									if(it_attr->second[0].type == "bool")
										it_val->second.old_val[ i ] = it_val->second.val[ i ];
									else if(it_attr->second[0].type == "double")
										it_val->second.old_val_d[ i ] = it_val->second.val_d[ i ];
									else if(it_attr->second[0].type == "long")
										it_val->second.old_val_l[ i ] = it_val->second.val_l[ i ];
								}
							}
						}
						else
						{
							//cout<<(int)now_log.tv_sec<<" "<<"EventCallBack::push_event event_name="<<ev->attr_name<<" evaluating loc attr: "<<*it_loc_attr<<" NOT CHANGED"<<endl;
						}
					}

				}
				else
				{
					cout <<(int)now_log.tv_sec<<" "<< __func__<<": event ok but event '"<<ev->attr_name<<"' not found!"<<endl;;
				}
			}
			else
			{
				temp_name = ev->attr_name + string(".") + ev->event;		//TODO: BUG IN TANGO: part of attr_name after first dot continues in field event

				size_t pos_change = temp_name.find(".change");
				if(pos_change != string::npos)
				{
					temp_name = temp_name.substr(0,pos_change);
				}
				ostringstream o;
				o << "Tango error for '" << temp_name << "'=" << ev->errors[0].desc.in() << ends;

				if(it_ev != mydevice->remote_devices.end())
				{
					int k = it_ev->stat_index;
					struct timespec now;
					clock_gettime(CLOCK_MONOTONIC,&now);
					double dnow = (double)(now.tv_sec) + ((double)now.tv_nsec)/1e9;
					string err(ev->errors[0].desc.in());
					if(k<3*MAX_ATTR_SIZE)
						sprintf(mydevice->devices_status_str[k], "%s: %13.3f - EVENT '%s' ERROR: '%s'", it_ev->remote_device_name.c_str(), dnow, it_ev->remote_attr_name.c_str(), err.c_str());
					it_ev->event_error = true;
				}
				else
				{
					cout <<(int)now_log.tv_sec<<" "<< __func__<<": event error and event '"<<ev->attr_name<<"' not found!"<<endl;
				}
			}
		}
		catch (string &err) {
			//cout <<(int)now_log.tv_sec<<" "<< __func__<<": exception for '"<<ev->attr_name<<"' err="<<err<<endl;
			if(it_ev != mydevice->remote_devices.end())
			{
				int k = it_ev->stat_index;
				struct timespec now;
				clock_gettime(CLOCK_MONOTONIC,&now);
				double dnow = (double)(now.tv_sec) + ((double)now.tv_nsec)/1e9;
				if(k<3*MAX_ATTR_SIZE)
					sprintf(mydevice->devices_status_str[k], "%s: %13.3f - EVENT '%s' ERROR: '%s'", it_ev->remote_device_name.c_str(), dnow, it_ev->remote_attr_name.c_str(), err.c_str());
				it_ev->event_error = true;
			}
			else
			{
				cout <<(int)now_log.tv_sec<<" "<< __func__<<": exception and event '"<<ev->attr_name<<"' not found! err="<<err<<endl;
			}

		} catch(Tango::DevFailed Terr)
		{
			if(it_ev != mydevice->remote_devices.end())
			{
				int k = it_ev->stat_index;
				struct timespec now;
				clock_gettime(CLOCK_MONOTONIC,&now);
				double dnow = (double)(now.tv_sec) + ((double)now.tv_nsec)/1e9;
				string err(Terr.errors[0].desc);
				if(k<3*MAX_ATTR_SIZE)
					sprintf(mydevice->devices_status_str[k], "%s: %13.3f - EVENT '%s' ERROR: '%s'", it_ev->remote_device_name.c_str(), dnow, it_ev->remote_attr_name.c_str(), err.c_str());
				it_ev->event_error = true;
			}
			else
			{
				cout <<(int)now_log.tv_sec<<" "<< __func__<<": Tango exception and event '"<<ev->attr_name<<"' not found! err="<<Terr.errors[0].desc<<endl;
			}
		}
		catch (...) {
			if(it_ev != mydevice->remote_devices.end())
			{
				int k = it_ev->stat_index;
				struct timespec now;
				clock_gettime(CLOCK_MONOTONIC,&now);
				double dnow = (double)(now.tv_sec) + ((double)now.tv_nsec)/1e9;
				string err("Generic Event Exception");
				if(k<3*MAX_ATTR_SIZE)
					sprintf(mydevice->devices_status_str[k], "%s: %13.3f - EVENT '%s' ERROR: '%s'", it_ev->remote_device_name.c_str(), dnow, it_ev->remote_attr_name.c_str(), err.c_str());
				it_ev->event_error = true;
			}
			else
			{
				cout <<(int)now_log.tv_sec<<" "<< __func__<<": generic exception and event '"<<ev->attr_name<<"' not found!"<<endl;
			}
		}
	//}
}  /* push_event() */

void EventCallBack::init(FormulaConf *p)
{
	//cout<<(int)now_log.tv_sec<<" "<<"EventCallBack::init entering..."<<endl;
	mydevice = p;
	//mydevices.push_back(p);
}

/*----- PROTECTED REGION END -----*/	//	FormulaConf::namespace_ending
} //	namespace
