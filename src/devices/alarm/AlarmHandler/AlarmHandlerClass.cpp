/*----- PROTECTED REGION ID(AlarmHandlerClass.cpp) ENABLED START -----*/
//=============================================================================
//
// file :        AlarmHandlerClass.cpp
//
// description : C++ source for the AlarmHandlerClass.
//               A singleton class derived from DeviceClass.
//               It implements the command and attribute list
//               and all properties and methods required
//               by the AlarmHandler once per process.
//
// project :     AlarmHandler
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
//
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <AlarmHandlerClass.h>

/*----- PROTECTED REGION END -----*/	//	AlarmHandlerClass.cpp

//-------------------------------------------------------------------
/**
 *	Create AlarmHandlerClass singleton and
 *	return it in a C function for Python usage
 */
//-------------------------------------------------------------------
extern "C" {
#ifdef _TG_WINDOWS_

__declspec(dllexport)

#endif

	Tango::DeviceClass *_create_AlarmHandler_class(const char *name) {
		return AlarmHandler_ns::AlarmHandlerClass::init(name);
	}
}

namespace AlarmHandler_ns
{
//===================================================================
//	Initialize pointer for singleton pattern
//===================================================================
AlarmHandlerClass *AlarmHandlerClass::_instance = NULL;

//--------------------------------------------------------
/**
 * method : 		AlarmHandlerClass::AlarmHandlerClass(string &s)
 * description : 	constructor for the AlarmHandlerClass
 *
 * @param s	The class name
 */
//--------------------------------------------------------
AlarmHandlerClass::AlarmHandlerClass(string &s):LMCDevice_ns::LMCDeviceClass(s)
{
	cout2 << "Entering AlarmHandlerClass constructor" << endl;
	set_default_property();
	write_class_property();

	/*----- PROTECTED REGION ID(AlarmHandlerClass::constructor) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	AlarmHandlerClass::constructor

	cout2 << "Leaving AlarmHandlerClass constructor" << endl;
}

//--------------------------------------------------------
/**
 * method : 		AlarmHandlerClass::~AlarmHandlerClass()
 * description : 	destructor for the AlarmHandlerClass
 */
//--------------------------------------------------------
AlarmHandlerClass::~AlarmHandlerClass()
{
	/*----- PROTECTED REGION ID(AlarmHandlerClass::destructor) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	AlarmHandlerClass::destructor

	_instance = NULL;
}


//--------------------------------------------------------
/**
 * method : 		AlarmHandlerClass::init
 * description : 	Create the object if not already done.
 *                  Otherwise, just return a pointer to the object
 *
 * @param	name	The class name
 */
//--------------------------------------------------------
AlarmHandlerClass *AlarmHandlerClass::init(const char *name)
{
	if (_instance == NULL)
	{
		try
		{
			string s(name);
			_instance = new AlarmHandlerClass(s);
		}
		catch (bad_alloc &)
		{
			throw;
		}
	}
	return _instance;
}

//--------------------------------------------------------
/**
 * method : 		AlarmHandlerClass::instance
 * description : 	Check if object already created,
 *                  and return a pointer to the object
 */
//--------------------------------------------------------
AlarmHandlerClass *AlarmHandlerClass::instance()
{
	if (_instance == NULL)
	{
		cerr << "Class is not initialised !!" << endl;
		exit(-1);
	}
	return _instance;
}



//===================================================================
//	Command execution method calls
//===================================================================
//--------------------------------------------------------
/**
 * method : 		AckClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *AckClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "AckClass::execute(): arrived" << endl;
	const Tango::DevVarStringArray *argin;
	extract(in_any, argin);
	((static_cast<AlarmHandler *>(device))->ack(argin));
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		LoadClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *LoadClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "LoadClass::execute(): arrived" << endl;
	Tango::DevString argin;
	extract(in_any, argin);
	((static_cast<AlarmHandler *>(device))->load(argin));
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		RemoveClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *RemoveClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "RemoveClass::execute(): arrived" << endl;
	Tango::DevString argin;
	extract(in_any, argin);
	((static_cast<AlarmHandler *>(device))->remove(argin));
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		SearchAlarmClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *SearchAlarmClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "SearchAlarmClass::execute(): arrived" << endl;
	Tango::DevString argin;
	extract(in_any, argin);
	return insert((static_cast<AlarmHandler *>(device))->search_alarm(argin));
}

//--------------------------------------------------------
/**
 * method : 		StopAudibleClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *StopAudibleClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "StopAudibleClass::execute(): arrived" << endl;
	((static_cast<AlarmHandler *>(device))->stop_audible());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		SilenceClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *SilenceClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "SilenceClass::execute(): arrived" << endl;
	const Tango::DevVarStringArray *argin;
	extract(in_any, argin);
	((static_cast<AlarmHandler *>(device))->silence(argin));
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		ModifyClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *ModifyClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "ModifyClass::execute(): arrived" << endl;
	Tango::DevString argin;
	extract(in_any, argin);
	((static_cast<AlarmHandler *>(device))->modify(argin));
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		ShelveClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *ShelveClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "ShelveClass::execute(): arrived" << endl;
	const Tango::DevVarStringArray *argin;
	extract(in_any, argin);
	((static_cast<AlarmHandler *>(device))->shelve(argin));
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		EnableClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *EnableClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "EnableClass::execute(): arrived" << endl;
	Tango::DevString argin;
	extract(in_any, argin);
	((static_cast<AlarmHandler *>(device))->enable(argin));
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		DisableClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *DisableClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "DisableClass::execute(): arrived" << endl;
	Tango::DevString argin;
	extract(in_any, argin);
	((static_cast<AlarmHandler *>(device))->disable(argin));
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		ResetStatisticsClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *ResetStatisticsClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "ResetStatisticsClass::execute(): arrived" << endl;
	((static_cast<AlarmHandler *>(device))->reset_statistics());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		StopNewClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *StopNewClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "StopNewClass::execute(): arrived" << endl;
	((static_cast<AlarmHandler *>(device))->stop_new());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		GetAlarmInfoClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *GetAlarmInfoClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "GetAlarmInfoClass::execute(): arrived" << endl;
	Tango::DevString argin;
	extract(in_any, argin);
	return insert((static_cast<AlarmHandler *>(device))->get_alarm_info(argin));
}

//--------------------------------------------------------
/**
 * method : 		RemoveAlarmAttrsClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *RemoveAlarmAttrsClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "RemoveAlarmAttrsClass::execute(): arrived" << endl;
	((static_cast<AlarmHandler *>(device))->remove_alarm_attrs());
	return new CORBA::Any();
}


//===================================================================
//	Properties management
//===================================================================
//--------------------------------------------------------
/**
 *	Method      : AlarmHandlerClass::get_class_property()
 *	Description : Get the class property for specified name.
 */
//--------------------------------------------------------
Tango::DbDatum AlarmHandlerClass::get_class_property(string &prop_name)
{
	for (unsigned int i=0 ; i<cl_prop.size() ; i++)
		if (cl_prop[i].name == prop_name)
			return cl_prop[i];
	//	if not found, returns  an empty DbDatum
	return Tango::DbDatum(prop_name);
}

//--------------------------------------------------------
/**
 *	Method      : AlarmHandlerClass::get_default_device_property()
 *	Description : Return the default value for device property.
 */
//--------------------------------------------------------
Tango::DbDatum AlarmHandlerClass::get_default_device_property(string &prop_name)
{
	for (unsigned int i=0 ; i<dev_def_prop.size() ; i++)
		if (dev_def_prop[i].name == prop_name)
			return dev_def_prop[i];
	//	if not found, return  an empty DbDatum
	return Tango::DbDatum(prop_name);
}

//--------------------------------------------------------
/**
 *	Method      : AlarmHandlerClass::get_default_class_property()
 *	Description : Return the default value for class property.
 */
//--------------------------------------------------------
Tango::DbDatum AlarmHandlerClass::get_default_class_property(string &prop_name)
{
	for (unsigned int i=0 ; i<cl_def_prop.size() ; i++)
		if (cl_def_prop[i].name == prop_name)
			return cl_def_prop[i];
	//	if not found, return  an empty DbDatum
	return Tango::DbDatum(prop_name);
}


//--------------------------------------------------------
/**
 *	Method      : AlarmHandlerClass::set_default_property()
 *	Description : Set default property (class and device) for wizard.
 *                For each property, add to wizard property name and description.
 *                If default value has been set, add it to wizard property and
 *                store it in a DbDatum.
 */
//--------------------------------------------------------
void AlarmHandlerClass::set_default_property()
{
	string	prop_name;
	string	prop_desc;
	string	prop_def;
	vector<string>	vect_data;

	//	Set Default Class Properties

	//	Set Default device Properties
	prop_name = "GroupNames";
	prop_desc = "Labels for Group mask, first is for mask 0x00 so ?none? is the default label \nassociated to it. Second label is associated to the mask 0x1, \nthird to the mask 0x2, ...\nOnly labels defined here can be used as group names in the \nalarm configuration.";
	prop_def  = "none";
	vect_data.clear();
	vect_data.push_back("none");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "SubscribeRetryPeriod";
	prop_desc = "Change event retry subscription period in seconds. Every time this period expires AlarmHandler tries to re-subscript all \nfaulty attributes";
	prop_def  = "30";
	vect_data.clear();
	vect_data.push_back("30");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "StatisticsTimeWindow";
	prop_desc = "Time window to compute statistics in seconds. Frequency of \nevents is computed using this period. Statistics are reset \nwith the ResetStatistics command";
	prop_def  = "60";
	vect_data.clear();
	vect_data.push_back("60");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
}

//--------------------------------------------------------
/**
 *	Method      : AlarmHandlerClass::write_class_property()
 *	Description : Set class description fields as property in database
 */
//--------------------------------------------------------
void AlarmHandlerClass::write_class_property()
{
	//	First time, check if database used
	if (Tango::Util::_UseDb == false)
		return;

	Tango::DbData	data;
	string	classname = get_name();
	string	header;
	string::size_type	start, end;

	//	Put title
	Tango::DbDatum	title("ProjectTitle");
	string	str_title("AlarmHandler");
	title << str_title;
	data.push_back(title);

	//	Put Description
	Tango::DbDatum	description("Description");
	vector<string>	str_desc;
	str_desc.push_back("AlarmHandler device. Fork of Tango ELETTRA Alarm System.");
	description << str_desc;
	data.push_back(description);

	//  Put inheritance
	Tango::DbDatum	inher_datum("InheritedFrom");
	vector<string> inheritance;
	inheritance.push_back("TANGO_BASE_CLASS");
	inher_datum << inheritance;
	data.push_back(inher_datum);

	//	Call database and and values
	get_db_class()->put_property(data);
}

//===================================================================
//	Factory methods
//===================================================================

//--------------------------------------------------------
/**
 *	Method      : AlarmHandlerClass::device_factory()
 *	Description : Create the device object(s)
 *                and store them in the device list
 */
//--------------------------------------------------------
void AlarmHandlerClass::device_factory(const Tango::DevVarStringArray *devlist_ptr)
{
	/*----- PROTECTED REGION ID(AlarmHandlerClass::device_factory_before) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	AlarmHandlerClass::device_factory_before

	//	Create devices and add it into the device list
	for (unsigned long i=0 ; i<devlist_ptr->length() ; i++)
	{
		cout4 << "Device name : " << (*devlist_ptr)[i].in() << endl;
		device_list.push_back(new AlarmHandler(this, (*devlist_ptr)[i]));
	}

	//	Manage dynamic attributes if any
	erase_dynamic_attributes(devlist_ptr, get_class_attr()->get_attr_list());

	//	Export devices to the outside world
	for (unsigned long i=1 ; i<=devlist_ptr->length() ; i++)
	{
		//	Add dynamic attributes if any
		AlarmHandler *dev = static_cast<AlarmHandler *>(device_list[device_list.size()-i]);
		dev->add_dynamic_attributes();

		//	Check before if database used.
		if ((Tango::Util::_UseDb == true) && (Tango::Util::_FileDb == false))
			export_device(dev);
		else
			export_device(dev, dev->get_name().c_str());
	}

	/*----- PROTECTED REGION ID(AlarmHandlerClass::device_factory_after) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	AlarmHandlerClass::device_factory_after
}
//--------------------------------------------------------
/**
 *	Method      : AlarmHandlerClass::attribute_factory()
 *	Description : Create the attribute object(s)
 *                and store them in the attribute list
 */
//--------------------------------------------------------
void AlarmHandlerClass::attribute_factory(vector<Tango::Attr *> &att_list)
{
	/*----- PROTECTED REGION ID(AlarmHandlerClass::attribute_factory_before) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	AlarmHandlerClass::attribute_factory_before
	//	Call atribute_factory for inherited class
	LMCDevice_ns::LMCDeviceClass::attribute_factory(att_list);

	//	Attribute : loggingLevelCentral - Check if not concrete in inherited class
	Tango::Attr *loggingLevelCentralAttr = get_attr_object_by_name(att_list, "loggingLevelCentral");
	if (loggingLevelCentralAttr == NULL)
	{
	}

	//	Attribute : loggingLevelElement - Check if not concrete in inherited class
	Tango::Attr *loggingLevelElementAttr = get_attr_object_by_name(att_list, "loggingLevelElement");
	if (loggingLevelElementAttr == NULL)
	{
	}

	//	Attribute : loggingLevelStorage - Check if not concrete in inherited class
	Tango::Attr *loggingLevelStorageAttr = get_attr_object_by_name(att_list, "loggingLevelStorage");
	if (loggingLevelStorageAttr == NULL)
	{
	}

	//	Attribute : loggingLevelConsole - Check if not concrete in inherited class
	Tango::Attr *loggingLevelConsoleAttr = get_attr_object_by_name(att_list, "loggingLevelConsole");
	if (loggingLevelConsoleAttr == NULL)
	{
	}

	//	Attribute : buildState - Check if not concrete in inherited class
	Tango::Attr *buildStateAttr = get_attr_object_by_name(att_list, "buildState");
	if (buildStateAttr == NULL)
	{
	}

	//	Attribute : centralLoggerStatus - Check if not concrete in inherited class
	Tango::Attr *centralLoggerStatusAttr = get_attr_object_by_name(att_list, "centralLoggerStatus");
	if (centralLoggerStatusAttr == NULL)
	{
	}

	//	Attribute : elementLoggerStatus - Check if not concrete in inherited class
	Tango::Attr *elementLoggerStatusAttr = get_attr_object_by_name(att_list, "elementLoggerStatus");
	if (elementLoggerStatusAttr == NULL)
	{
	}

	//	Attribute : storageLoggerStatus - Check if not concrete in inherited class
	Tango::Attr *storageLoggerStatusAttr = get_attr_object_by_name(att_list, "storageLoggerStatus");
	if (storageLoggerStatusAttr == NULL)
	{
	}

	//	Attribute : eventRate - Check if not concrete in inherited class
	Tango::Attr *eventRateAttr = get_attr_object_by_name(att_list, "eventRate");
	if (eventRateAttr == NULL)
	{
	}

	//	Attribute : exceptionRate - Check if not concrete in inherited class
	Tango::Attr *exceptionRateAttr = get_attr_object_by_name(att_list, "exceptionRate");
	if (exceptionRateAttr == NULL)
	{
	}

	//	Attribute : fwdAttrInitStatus - Check if not concrete in inherited class
	Tango::Attr *fwdAttrInitStatusAttr = get_attr_object_by_name(att_list, "fwdAttrInitStatus");
	if (fwdAttrInitStatusAttr == NULL)
	{
	}

	//	Attribute : audibleAlarm
	audibleAlarmAttrib	*audiblealarm = new audibleAlarmAttrib();
	Tango::UserDefaultAttrProp	audiblealarm_prop;
	audiblealarm_prop.set_description("True if there is at least one alarm that needs audible indication on the GUI");
	//	label	not set for audibleAlarm
	//	unit	not set for audibleAlarm
	//	standard_unit	not set for audibleAlarm
	//	display_unit	not set for audibleAlarm
	//	format	not set for audibleAlarm
	//	max_value	not set for audibleAlarm
	//	min_value	not set for audibleAlarm
	//	max_alarm	not set for audibleAlarm
	//	min_alarm	not set for audibleAlarm
	//	max_warning	not set for audibleAlarm
	//	min_warning	not set for audibleAlarm
	//	delta_t	not set for audibleAlarm
	//	delta_val	not set for audibleAlarm
	
	audiblealarm->set_default_properties(audiblealarm_prop);
	//	Not Polled
	audiblealarm->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	audiblealarm->set_change_event(true, false);
	audiblealarm->set_archive_event(true, false);
	att_list.push_back(audiblealarm);

	//	Attribute : StatisticsResetTime
	StatisticsResetTimeAttrib	*statisticsresettime = new StatisticsResetTimeAttrib();
	Tango::UserDefaultAttrProp	statisticsresettime_prop;
	statisticsresettime_prop.set_description("Time elapsed in seconds since last Resetstatistics");
	//	label	not set for StatisticsResetTime
	statisticsresettime_prop.set_unit("s");
	statisticsresettime_prop.set_standard_unit("1");
	statisticsresettime_prop.set_display_unit("s");
	//	format	not set for StatisticsResetTime
	//	max_value	not set for StatisticsResetTime
	//	min_value	not set for StatisticsResetTime
	//	max_alarm	not set for StatisticsResetTime
	//	min_alarm	not set for StatisticsResetTime
	//	max_warning	not set for StatisticsResetTime
	//	min_warning	not set for StatisticsResetTime
	//	delta_t	not set for StatisticsResetTime
	//	delta_val	not set for StatisticsResetTime
	
	statisticsresettime->set_default_properties(statisticsresettime_prop);
	//	Not Polled
	statisticsresettime->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(statisticsresettime);

	//	Attribute : centralLoggerEnabled - Check if not concrete in inherited class
	Tango::Attr *centralLoggerEnabledAttr = get_attr_object_by_name(att_list, "centralLoggerEnabled");
	if (centralLoggerEnabledAttr == NULL)
	{
	}

	//	Attribute : elementLoggerEnabled - Check if not concrete in inherited class
	Tango::Attr *elementLoggerEnabledAttr = get_attr_object_by_name(att_list, "elementLoggerEnabled");
	if (elementLoggerEnabledAttr == NULL)
	{
	}

	//	Attribute : storageLoggerEnabled - Check if not concrete in inherited class
	Tango::Attr *storageLoggerEnabledAttr = get_attr_object_by_name(att_list, "storageLoggerEnabled");
	if (storageLoggerEnabledAttr == NULL)
	{
	}

	//	Attribute : loggingTargetCentral - Check if not concrete in inherited class
	Tango::Attr *loggingTargetCentralAttr = get_attr_object_by_name(att_list, "loggingTargetCentral");
	if (loggingTargetCentralAttr == NULL)
	{
	}

	//	Attribute : loggingTargetElement - Check if not concrete in inherited class
	Tango::Attr *loggingTargetElementAttr = get_attr_object_by_name(att_list, "loggingTargetElement");
	if (loggingTargetElementAttr == NULL)
	{
	}

	//	Attribute : loggingTargetStorage - Check if not concrete in inherited class
	Tango::Attr *loggingTargetStorageAttr = get_attr_object_by_name(att_list, "loggingTargetStorage");
	if (loggingTargetStorageAttr == NULL)
	{
	}

	//	Attribute : alarm
	alarmAttrib	*alarm = new alarmAttrib();
	Tango::UserDefaultAttrProp	alarm_prop;
	//	description	not set for alarm
	//	label	not set for alarm
	//	unit	not set for alarm
	//	standard_unit	not set for alarm
	//	display_unit	not set for alarm
	//	format	not set for alarm
	//	max_value	not set for alarm
	//	min_value	not set for alarm
	//	max_alarm	not set for alarm
	//	min_alarm	not set for alarm
	//	max_warning	not set for alarm
	//	min_warning	not set for alarm
	//	delta_t	not set for alarm
	//	delta_val	not set for alarm
	
	alarm->set_default_properties(alarm_prop);
	//	Not Polled
	alarm->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(alarm);

	//	Attribute : normalAlarms
	normalAlarmsAttrib	*normalalarms = new normalAlarmsAttrib();
	Tango::UserDefaultAttrProp	normalalarms_prop;
	normalalarms_prop.set_description("List of alarms in normal state");
	//	label	not set for normalAlarms
	//	unit	not set for normalAlarms
	//	standard_unit	not set for normalAlarms
	//	display_unit	not set for normalAlarms
	//	format	not set for normalAlarms
	//	max_value	not set for normalAlarms
	//	min_value	not set for normalAlarms
	//	max_alarm	not set for normalAlarms
	//	min_alarm	not set for normalAlarms
	//	max_warning	not set for normalAlarms
	//	min_warning	not set for normalAlarms
	//	delta_t	not set for normalAlarms
	//	delta_val	not set for normalAlarms
	
	normalalarms->set_default_properties(normalalarms_prop);
	//	Not Polled
	normalalarms->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	normalalarms->set_change_event(true, true);
	normalalarms->set_archive_event(true, true);
	att_list.push_back(normalalarms);

	//	Attribute : unacknowledgedAlarms
	unacknowledgedAlarmsAttrib	*unacknowledgedalarms = new unacknowledgedAlarmsAttrib();
	Tango::UserDefaultAttrProp	unacknowledgedalarms_prop;
	unacknowledgedalarms_prop.set_description("List of alarms in unacknowledged state");
	//	label	not set for unacknowledgedAlarms
	//	unit	not set for unacknowledgedAlarms
	//	standard_unit	not set for unacknowledgedAlarms
	//	display_unit	not set for unacknowledgedAlarms
	//	format	not set for unacknowledgedAlarms
	//	max_value	not set for unacknowledgedAlarms
	//	min_value	not set for unacknowledgedAlarms
	//	max_alarm	not set for unacknowledgedAlarms
	//	min_alarm	not set for unacknowledgedAlarms
	//	max_warning	not set for unacknowledgedAlarms
	//	min_warning	not set for unacknowledgedAlarms
	//	delta_t	not set for unacknowledgedAlarms
	//	delta_val	not set for unacknowledgedAlarms
	
	unacknowledgedalarms->set_default_properties(unacknowledgedalarms_prop);
	//	Not Polled
	unacknowledgedalarms->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	unacknowledgedalarms->set_change_event(true, true);
	unacknowledgedalarms->set_archive_event(true, true);
	att_list.push_back(unacknowledgedalarms);

	//	Attribute : acknowledgedAlarms
	acknowledgedAlarmsAttrib	*acknowledgedalarms = new acknowledgedAlarmsAttrib();
	Tango::UserDefaultAttrProp	acknowledgedalarms_prop;
	acknowledgedalarms_prop.set_description("List of alarms in acknowledged state");
	//	label	not set for acknowledgedAlarms
	//	unit	not set for acknowledgedAlarms
	//	standard_unit	not set for acknowledgedAlarms
	//	display_unit	not set for acknowledgedAlarms
	//	format	not set for acknowledgedAlarms
	//	max_value	not set for acknowledgedAlarms
	//	min_value	not set for acknowledgedAlarms
	//	max_alarm	not set for acknowledgedAlarms
	//	min_alarm	not set for acknowledgedAlarms
	//	max_warning	not set for acknowledgedAlarms
	//	min_warning	not set for acknowledgedAlarms
	//	delta_t	not set for acknowledgedAlarms
	//	delta_val	not set for acknowledgedAlarms
	
	acknowledgedalarms->set_default_properties(acknowledgedalarms_prop);
	//	Not Polled
	acknowledgedalarms->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	acknowledgedalarms->set_change_event(true, true);
	acknowledgedalarms->set_archive_event(true, true);
	att_list.push_back(acknowledgedalarms);

	//	Attribute : unacknowledgedNormalAlarms
	unacknowledgedNormalAlarmsAttrib	*unacknowledgednormalalarms = new unacknowledgedNormalAlarmsAttrib();
	Tango::UserDefaultAttrProp	unacknowledgednormalalarms_prop;
	unacknowledgednormalalarms_prop.set_description("List of alarms in unacknowledged normal state");
	//	label	not set for unacknowledgedNormalAlarms
	//	unit	not set for unacknowledgedNormalAlarms
	//	standard_unit	not set for unacknowledgedNormalAlarms
	//	display_unit	not set for unacknowledgedNormalAlarms
	//	format	not set for unacknowledgedNormalAlarms
	//	max_value	not set for unacknowledgedNormalAlarms
	//	min_value	not set for unacknowledgedNormalAlarms
	//	max_alarm	not set for unacknowledgedNormalAlarms
	//	min_alarm	not set for unacknowledgedNormalAlarms
	//	max_warning	not set for unacknowledgedNormalAlarms
	//	min_warning	not set for unacknowledgedNormalAlarms
	//	delta_t	not set for unacknowledgedNormalAlarms
	//	delta_val	not set for unacknowledgedNormalAlarms
	
	unacknowledgednormalalarms->set_default_properties(unacknowledgednormalalarms_prop);
	//	Not Polled
	unacknowledgednormalalarms->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	unacknowledgednormalalarms->set_change_event(true, true);
	unacknowledgednormalalarms->set_archive_event(true, true);
	att_list.push_back(unacknowledgednormalalarms);

	//	Attribute : shelvedAlarms
	shelvedAlarmsAttrib	*shelvedalarms = new shelvedAlarmsAttrib();
	Tango::UserDefaultAttrProp	shelvedalarms_prop;
	shelvedalarms_prop.set_description("List of alarms in shelved state");
	//	label	not set for shelvedAlarms
	//	unit	not set for shelvedAlarms
	//	standard_unit	not set for shelvedAlarms
	//	display_unit	not set for shelvedAlarms
	//	format	not set for shelvedAlarms
	//	max_value	not set for shelvedAlarms
	//	min_value	not set for shelvedAlarms
	//	max_alarm	not set for shelvedAlarms
	//	min_alarm	not set for shelvedAlarms
	//	max_warning	not set for shelvedAlarms
	//	min_warning	not set for shelvedAlarms
	//	delta_t	not set for shelvedAlarms
	//	delta_val	not set for shelvedAlarms
	
	shelvedalarms->set_default_properties(shelvedalarms_prop);
	//	Not Polled
	shelvedalarms->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	shelvedalarms->set_change_event(true, true);
	shelvedalarms->set_archive_event(true, true);
	att_list.push_back(shelvedalarms);

	//	Attribute : outOfServiceAlarms
	outOfServiceAlarmsAttrib	*outofservicealarms = new outOfServiceAlarmsAttrib();
	Tango::UserDefaultAttrProp	outofservicealarms_prop;
	outofservicealarms_prop.set_description("List of alarms in out of service state");
	//	label	not set for outOfServiceAlarms
	//	unit	not set for outOfServiceAlarms
	//	standard_unit	not set for outOfServiceAlarms
	//	display_unit	not set for outOfServiceAlarms
	//	format	not set for outOfServiceAlarms
	//	max_value	not set for outOfServiceAlarms
	//	min_value	not set for outOfServiceAlarms
	//	max_alarm	not set for outOfServiceAlarms
	//	min_alarm	not set for outOfServiceAlarms
	//	max_warning	not set for outOfServiceAlarms
	//	min_warning	not set for outOfServiceAlarms
	//	delta_t	not set for outOfServiceAlarms
	//	delta_val	not set for outOfServiceAlarms
	
	outofservicealarms->set_default_properties(outofservicealarms_prop);
	//	Not Polled
	outofservicealarms->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	outofservicealarms->set_change_event(true, true);
	outofservicealarms->set_archive_event(true, true);
	att_list.push_back(outofservicealarms);

	//	Attribute : silencedAlarms
	silencedAlarmsAttrib	*silencedalarms = new silencedAlarmsAttrib();
	Tango::UserDefaultAttrProp	silencedalarms_prop;
	silencedalarms_prop.set_description("List of alarms in silenced state");
	//	label	not set for silencedAlarms
	//	unit	not set for silencedAlarms
	//	standard_unit	not set for silencedAlarms
	//	display_unit	not set for silencedAlarms
	//	format	not set for silencedAlarms
	//	max_value	not set for silencedAlarms
	//	min_value	not set for silencedAlarms
	//	max_alarm	not set for silencedAlarms
	//	min_alarm	not set for silencedAlarms
	//	max_warning	not set for silencedAlarms
	//	min_warning	not set for silencedAlarms
	//	delta_t	not set for silencedAlarms
	//	delta_val	not set for silencedAlarms
	
	silencedalarms->set_default_properties(silencedalarms_prop);
	//	Not Polled
	silencedalarms->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	silencedalarms->set_change_event(true, true);
	silencedalarms->set_archive_event(true, true);
	att_list.push_back(silencedalarms);

	//	Attribute : listAlarms
	listAlarmsAttrib	*listalarms = new listAlarmsAttrib();
	Tango::UserDefaultAttrProp	listalarms_prop;
	listalarms_prop.set_description("List of all alarms");
	//	label	not set for listAlarms
	//	unit	not set for listAlarms
	//	standard_unit	not set for listAlarms
	//	display_unit	not set for listAlarms
	//	format	not set for listAlarms
	//	max_value	not set for listAlarms
	//	min_value	not set for listAlarms
	//	max_alarm	not set for listAlarms
	//	min_alarm	not set for listAlarms
	//	max_warning	not set for listAlarms
	//	min_warning	not set for listAlarms
	//	delta_t	not set for listAlarms
	//	delta_val	not set for listAlarms
	
	listalarms->set_default_properties(listalarms_prop);
	//	Not Polled
	listalarms->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	listalarms->set_change_event(true, true);
	listalarms->set_archive_event(true, true);
	att_list.push_back(listalarms);

	//	Attribute : frequencyAlarms
	frequencyAlarmsAttrib	*frequencyalarms = new frequencyAlarmsAttrib();
	Tango::UserDefaultAttrProp	frequencyalarms_prop;
	frequencyalarms_prop.set_description("List of frequency of evaluation of all alarms");
	//	label	not set for frequencyAlarms
	//	unit	not set for frequencyAlarms
	//	standard_unit	not set for frequencyAlarms
	//	display_unit	not set for frequencyAlarms
	//	format	not set for frequencyAlarms
	//	max_value	not set for frequencyAlarms
	//	min_value	not set for frequencyAlarms
	//	max_alarm	not set for frequencyAlarms
	//	min_alarm	not set for frequencyAlarms
	//	max_warning	not set for frequencyAlarms
	//	min_warning	not set for frequencyAlarms
	//	delta_t	not set for frequencyAlarms
	//	delta_val	not set for frequencyAlarms
	
	frequencyalarms->set_default_properties(frequencyalarms_prop);
	//	Not Polled
	frequencyalarms->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	frequencyalarms->set_change_event(true, true);
	frequencyalarms->set_archive_event(true, true);
	att_list.push_back(frequencyalarms);


	//	Create a list of static attributes
	create_static_attribute_list(get_class_attr()->get_attr_list());
	/*----- PROTECTED REGION ID(AlarmHandlerClass::attribute_factory_after) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	AlarmHandlerClass::attribute_factory_after
}
//--------------------------------------------------------
/**
 *	Method      : AlarmHandlerClass::pipe_factory()
 *	Description : Create the pipe object(s)
 *                and store them in the pipe list
 */
//--------------------------------------------------------
void AlarmHandlerClass::pipe_factory()
{
	/*----- PROTECTED REGION ID(AlarmHandlerClass::pipe_factory_before) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	AlarmHandlerClass::pipe_factory_before
	/*----- PROTECTED REGION ID(AlarmHandlerClass::pipe_factory_after) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	AlarmHandlerClass::pipe_factory_after
}
//--------------------------------------------------------
/**
 *	Method      : AlarmHandlerClass::command_factory()
 *	Description : Create the command object(s)
 *                and store them in the command list
 */
//--------------------------------------------------------
void AlarmHandlerClass::command_factory()
{
	/*----- PROTECTED REGION ID(AlarmHandlerClass::command_factory_before) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	AlarmHandlerClass::command_factory_before
	//	Call command_factory for inherited class
	LMCDevice_ns::LMCDeviceClass::command_factory();



























	//	Command Ack
	AckClass	*pAckCmd =
		new AckClass("Ack",
			Tango::DEVVAR_STRINGARRAY, Tango::DEV_VOID,
			"String array containing the alarms to be acknowledged",
			"",
			Tango::OPERATOR);
	command_list.push_back(pAckCmd);

	//	Command Load
	LoadClass	*pLoadCmd =
		new LoadClass("Load",
			Tango::DEV_STRING, Tango::DEV_VOID,
			"Alarm entry",
			"",
			Tango::OPERATOR);
	command_list.push_back(pLoadCmd);

	//	Command Remove
	RemoveClass	*pRemoveCmd =
		new RemoveClass("Remove",
			Tango::DEV_STRING, Tango::DEV_VOID,
			"Alarm name",
			"",
			Tango::OPERATOR);
	command_list.push_back(pRemoveCmd);

	//	Command SearchAlarm
	SearchAlarmClass	*pSearchAlarmCmd =
		new SearchAlarmClass("SearchAlarm",
			Tango::DEV_STRING, Tango::DEVVAR_STRINGARRAY,
			"String containing a filter for output, if empty or * return all alarms",
			"Configured alarms",
			Tango::OPERATOR);
	command_list.push_back(pSearchAlarmCmd);

	//	Command StopAudible
	StopAudibleClass	*pStopAudibleCmd =
		new StopAudibleClass("StopAudible",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pStopAudibleCmd);

	//	Command Silence
	SilenceClass	*pSilenceCmd =
		new SilenceClass("Silence",
			Tango::DEVVAR_STRINGARRAY, Tango::DEV_VOID,
			"String array containing the alarms to be silenced",
			"",
			Tango::OPERATOR);
	command_list.push_back(pSilenceCmd);

	//	Command Modify
	ModifyClass	*pModifyCmd =
		new ModifyClass("Modify",
			Tango::DEV_STRING, Tango::DEV_VOID,
			"Alarm entry",
			"",
			Tango::OPERATOR);
	command_list.push_back(pModifyCmd);

	//	Command Shelve
	ShelveClass	*pShelveCmd =
		new ShelveClass("Shelve",
			Tango::DEVVAR_STRINGARRAY, Tango::DEV_VOID,
			"String array containing alarm to be shelved",
			"",
			Tango::OPERATOR);
	command_list.push_back(pShelveCmd);

	//	Command Enable
	EnableClass	*pEnableCmd =
		new EnableClass("Enable",
			Tango::DEV_STRING, Tango::DEV_VOID,
			"Alarm name",
			"",
			Tango::OPERATOR);
	command_list.push_back(pEnableCmd);

	//	Command Disable
	DisableClass	*pDisableCmd =
		new DisableClass("Disable",
			Tango::DEV_STRING, Tango::DEV_VOID,
			"Alarm name",
			"",
			Tango::OPERATOR);
	command_list.push_back(pDisableCmd);

	//	Command ResetStatistics
	ResetStatisticsClass	*pResetStatisticsCmd =
		new ResetStatisticsClass("ResetStatistics",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pResetStatisticsCmd);

	//	Command StopNew
	StopNewClass	*pStopNewCmd =
		new StopNewClass("StopNew",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pStopNewCmd);

	//	Command GetAlarmInfo
	GetAlarmInfoClass	*pGetAlarmInfoCmd =
		new GetAlarmInfoClass("GetAlarmInfo",
			Tango::DEV_STRING, Tango::DEVVAR_STRINGARRAY,
			"Alarm name",
			"Complete attribute info as an array of key=value",
			Tango::OPERATOR);
	command_list.push_back(pGetAlarmInfoCmd);

	//	Command RemoveAlarmAttrs
	RemoveAlarmAttrsClass	*pRemoveAlarmAttrsCmd =
		new RemoveAlarmAttrsClass("RemoveAlarmAttrs",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pRemoveAlarmAttrsCmd);


	/*----- PROTECTED REGION ID(AlarmHandlerClass::command_factory_after) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	AlarmHandlerClass::command_factory_after
}

//===================================================================
//	Dynamic attributes related methods
//===================================================================

//--------------------------------------------------------
/**
 * method : 		AlarmHandlerClass::create_static_attribute_list
 * description : 	Create the a list of static attributes
 *
 * @param	att_list	the ceated attribute list
 */
//--------------------------------------------------------
void AlarmHandlerClass::create_static_attribute_list(vector<Tango::Attr *> &att_list)
{
	for (unsigned long i=0 ; i<att_list.size() ; i++)
	{
		string att_name(att_list[i]->get_name());
		transform(att_name.begin(), att_name.end(), att_name.begin(), ::tolower);
		defaultAttList.push_back(att_name);
	}

	cout2 << defaultAttList.size() << " attributes in default list" << endl;

	/*----- PROTECTED REGION ID(AlarmHandlerClass::create_static_att_list) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	AlarmHandlerClass::create_static_att_list
}


//--------------------------------------------------------
/**
 * method : 		AlarmHandlerClass::erase_dynamic_attributes
 * description : 	delete the dynamic attributes if any.
 *
 * @param	devlist_ptr	the device list pointer
 * @param	list of all attributes
 */
//--------------------------------------------------------
void AlarmHandlerClass::erase_dynamic_attributes(const Tango::DevVarStringArray *devlist_ptr, vector<Tango::Attr *> &att_list)
{
	Tango::Util *tg = Tango::Util::instance();

	for (unsigned long i=0 ; i<devlist_ptr->length() ; i++)
	{
		Tango::DeviceImpl *dev_impl = tg->get_device_by_name(((string)(*devlist_ptr)[i]).c_str());
		AlarmHandler *dev = static_cast<AlarmHandler *> (dev_impl);

		vector<Tango::Attribute *> &dev_att_list = dev->get_device_attr()->get_attribute_list();
		vector<Tango::Attribute *>::iterator ite_att;
		for (ite_att=dev_att_list.begin() ; ite_att != dev_att_list.end() ; ++ite_att)
		{
			string att_name((*ite_att)->get_name_lower());
			if ((att_name == "state") || (att_name == "status"))
				continue;
			vector<string>::iterator ite_str = find(defaultAttList.begin(), defaultAttList.end(), att_name);
			if (ite_str == defaultAttList.end())
			{
				cout2 << att_name << " is a UNWANTED dynamic attribute for device " << (*devlist_ptr)[i] << endl;
				Tango::Attribute &att = dev->get_device_attr()->get_attr_by_name(att_name.c_str());
				dev->remove_attribute(att_list[att.get_attr_idx()], true, false);
				--ite_att;
			}
		}
	}
	/*----- PROTECTED REGION ID(AlarmHandlerClass::erase_dynamic_attributes) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	AlarmHandlerClass::erase_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Method      : AlarmHandlerClass::get_attr_by_name()
 *	Description : returns Tango::Attr * object found by name
 */
//--------------------------------------------------------
Tango::Attr *AlarmHandlerClass::get_attr_object_by_name(vector<Tango::Attr *> &att_list, string attname)
{
	vector<Tango::Attr *>::iterator it;
	for (it=att_list.begin() ; it<att_list.end() ; ++it)
		if ((*it)->get_name()==attname)
			return (*it);
	//	Attr does not exist
	return NULL;
}


/*----- PROTECTED REGION ID(AlarmHandlerClass::Additional Methods) ENABLED START -----*/

/*----- PROTECTED REGION END -----*/	//	AlarmHandlerClass::Additional Methods
} //	namespace
