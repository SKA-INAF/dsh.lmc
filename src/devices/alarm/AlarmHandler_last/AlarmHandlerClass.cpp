/*----- PROTECTED REGION ID(AlarmHandlerClass.cpp) ENABLED START -----*/
//=============================================================================
//
// file :        AlarmHandlerClass.cpp
//
// description : C++ source for the AlarmHandlerClass.
//               A singleton class derived from DeviceClass.
//               It implements the command and attribute list
//               and all properties and methods required
//               by the AlarmHandler once per process.
//
// project :     AlarmHandler
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
//
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <AlarmHandlerClass.h>

/*----- PROTECTED REGION END -----*/	//	AlarmHandlerClass.cpp

//-------------------------------------------------------------------
/**
 *	Create AlarmHandlerClass singleton and
 *	return it in a C function for Python usage
 */
//-------------------------------------------------------------------
extern "C" {
#ifdef _TG_WINDOWS_

__declspec(dllexport)

#endif

	Tango::DeviceClass *_create_AlarmHandler_class(const char *name) {
		return AlarmHandler_ns::AlarmHandlerClass::init(name);
	}
}

namespace AlarmHandler_ns
{
//===================================================================
//	Initialize pointer for singleton pattern
//===================================================================
AlarmHandlerClass *AlarmHandlerClass::_instance = NULL;

//--------------------------------------------------------
/**
 * method : 		AlarmHandlerClass::AlarmHandlerClass(string &s)
 * description : 	constructor for the AlarmHandlerClass
 *
 * @param s	The class name
 */
//--------------------------------------------------------
AlarmHandlerClass::AlarmHandlerClass(string &s):LMCDevice_ns::LMCDeviceClass(s)
{
	cout2 << "Entering AlarmHandlerClass constructor" << endl;
	set_default_property();
	write_class_property();

	/*----- PROTECTED REGION ID(AlarmHandlerClass::constructor) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	AlarmHandlerClass::constructor

	cout2 << "Leaving AlarmHandlerClass constructor" << endl;
}

//--------------------------------------------------------
/**
 * method : 		AlarmHandlerClass::~AlarmHandlerClass()
 * description : 	destructor for the AlarmHandlerClass
 */
//--------------------------------------------------------
AlarmHandlerClass::~AlarmHandlerClass()
{
	/*----- PROTECTED REGION ID(AlarmHandlerClass::destructor) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	AlarmHandlerClass::destructor

	_instance = NULL;
}


//--------------------------------------------------------
/**
 * method : 		AlarmHandlerClass::init
 * description : 	Create the object if not already done.
 *                  Otherwise, just return a pointer to the object
 *
 * @param	name	The class name
 */
//--------------------------------------------------------
AlarmHandlerClass *AlarmHandlerClass::init(const char *name)
{
	if (_instance == NULL)
	{
		try
		{
			string s(name);
			_instance = new AlarmHandlerClass(s);
		}
		catch (bad_alloc &)
		{
			throw;
		}
	}
	return _instance;
}

//--------------------------------------------------------
/**
 * method : 		AlarmHandlerClass::instance
 * description : 	Check if object already created,
 *                  and return a pointer to the object
 */
//--------------------------------------------------------
AlarmHandlerClass *AlarmHandlerClass::instance()
{
	if (_instance == NULL)
	{
		cerr << "Class is not initialised !!" << endl;
		exit(-1);
	}
	return _instance;
}



//===================================================================
//	Command execution method calls
//===================================================================
//--------------------------------------------------------
/**
 * method : 		AckClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *AckClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "AckClass::execute(): arrived" << endl;
	const Tango::DevVarStringArray *argin;
	extract(in_any, argin);
	((static_cast<AlarmHandler *>(device))->ack(argin));
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		LoadClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *LoadClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "LoadClass::execute(): arrived" << endl;
	Tango::DevString argin;
	extract(in_any, argin);
	((static_cast<AlarmHandler *>(device))->load(argin));
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		RemoveClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *RemoveClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "RemoveClass::execute(): arrived" << endl;
	Tango::DevString argin;
	extract(in_any, argin);
	((static_cast<AlarmHandler *>(device))->remove(argin));
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		SearchAlarmClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *SearchAlarmClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "SearchAlarmClass::execute(): arrived" << endl;
	Tango::DevString argin;
	extract(in_any, argin);
	return insert((static_cast<AlarmHandler *>(device))->search_alarm(argin));
}

//--------------------------------------------------------
/**
 * method : 		StopAudibleClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *StopAudibleClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "StopAudibleClass::execute(): arrived" << endl;
	((static_cast<AlarmHandler *>(device))->stop_audible());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		SilenceClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *SilenceClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "SilenceClass::execute(): arrived" << endl;
	const Tango::DevVarStringArray *argin;
	extract(in_any, argin);
	((static_cast<AlarmHandler *>(device))->silence(argin));
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		ModifyClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *ModifyClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "ModifyClass::execute(): arrived" << endl;
	Tango::DevString argin;
	extract(in_any, argin);
	((static_cast<AlarmHandler *>(device))->modify(argin));
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		ShelveClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *ShelveClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "ShelveClass::execute(): arrived" << endl;
	const Tango::DevVarStringArray *argin;
	extract(in_any, argin);
	((static_cast<AlarmHandler *>(device))->shelve(argin));
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		EnableClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *EnableClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "EnableClass::execute(): arrived" << endl;
	Tango::DevString argin;
	extract(in_any, argin);
	((static_cast<AlarmHandler *>(device))->enable(argin));
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		DisableClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *DisableClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "DisableClass::execute(): arrived" << endl;
	Tango::DevString argin;
	extract(in_any, argin);
	((static_cast<AlarmHandler *>(device))->disable(argin));
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		ResetStatisticsClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *ResetStatisticsClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "ResetStatisticsClass::execute(): arrived" << endl;
	((static_cast<AlarmHandler *>(device))->reset_statistics());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		StopNewClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *StopNewClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "StopNewClass::execute(): arrived" << endl;
	((static_cast<AlarmHandler *>(device))->stop_new());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		GetAlarmInfoClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *GetAlarmInfoClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "GetAlarmInfoClass::execute(): arrived" << endl;
	const Tango::DevVarStringArray *argin;
	extract(in_any, argin);
	return insert((static_cast<AlarmHandler *>(device))->get_alarm_info(argin));
}

//--------------------------------------------------------
/**
 * method : 		RemoveAlarmAttrsClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *RemoveAlarmAttrsClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "RemoveAlarmAttrsClass::execute(): arrived" << endl;
	((static_cast<AlarmHandler *>(device))->remove_alarm_attrs());
	return new CORBA::Any();
}


//===================================================================
//	Properties management
//===================================================================
//--------------------------------------------------------
/**
 *	Method      : AlarmHandlerClass::get_class_property()
 *	Description : Get the class property for specified name.
 */
//--------------------------------------------------------
Tango::DbDatum AlarmHandlerClass::get_class_property(string &prop_name)
{
	for (unsigned int i=0 ; i<cl_prop.size() ; i++)
		if (cl_prop[i].name == prop_name)
			return cl_prop[i];
	//	if not found, returns  an empty DbDatum
	return Tango::DbDatum(prop_name);
}

//--------------------------------------------------------
/**
 *	Method      : AlarmHandlerClass::get_default_device_property()
 *	Description : Return the default value for device property.
 */
//--------------------------------------------------------
Tango::DbDatum AlarmHandlerClass::get_default_device_property(string &prop_name)
{
	for (unsigned int i=0 ; i<dev_def_prop.size() ; i++)
		if (dev_def_prop[i].name == prop_name)
			return dev_def_prop[i];
	//	if not found, return  an empty DbDatum
	return Tango::DbDatum(prop_name);
}

//--------------------------------------------------------
/**
 *	Method      : AlarmHandlerClass::get_default_class_property()
 *	Description : Return the default value for class property.
 */
//--------------------------------------------------------
Tango::DbDatum AlarmHandlerClass::get_default_class_property(string &prop_name)
{
	for (unsigned int i=0 ; i<cl_def_prop.size() ; i++)
		if (cl_def_prop[i].name == prop_name)
			return cl_def_prop[i];
	//	if not found, return  an empty DbDatum
	return Tango::DbDatum(prop_name);
}


//--------------------------------------------------------
/**
 *	Method      : AlarmHandlerClass::set_default_property()
 *	Description : Set default property (class and device) for wizard.
 *                For each property, add to wizard property name and description.
 *                If default value has been set, add it to wizard property and
 *                store it in a DbDatum.
 */
//--------------------------------------------------------
void AlarmHandlerClass::set_default_property()
{
	string	prop_name;
	string	prop_desc;
	string	prop_def;
	vector<string>	vect_data;

	//	Set Default Class Properties

	//	Set Default device Properties
	prop_name = "GroupNames";
	prop_desc = "Labels for Group mask, first is for mask 0x00 so ?none? is the default label \nassociated to it. Second label is associated to the mask 0x1, \nthird to the mask 0x2, ...\nOnly labels defined here can be used as group names in the \nalarm configuration.";
	prop_def  = "none";
	vect_data.clear();
	vect_data.push_back("none");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "SubscribeRetryPeriod";
	prop_desc = "Change event retry subscription period in seconds. Every time this period expires AlarmHandler tries to re-subscript all \nfaulty attributes";
	prop_def  = "30";
	vect_data.clear();
	vect_data.push_back("30");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "StatisticsTimeWindow";
	prop_desc = "Time window to compute statistics in seconds. Frequency of \nevents is computed using this period. Statistics are reset \nwith the ResetStatistics command";
	prop_def  = "60";
	vect_data.clear();
	vect_data.push_back("60");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
}

//--------------------------------------------------------
/**
 *	Method      : AlarmHandlerClass::write_class_property()
 *	Description : Set class description fields as property in database
 */
//--------------------------------------------------------
void AlarmHandlerClass::write_class_property()
{
	//	First time, check if database used
	if (Tango::Util::_UseDb == false)
		return;

	Tango::DbData	data;
	string	classname = get_name();
	string	header;
	string::size_type	start, end;

	//	Put title
	Tango::DbDatum	title("ProjectTitle");
	string	str_title("AlarmHandler");
	title << str_title;
	data.push_back(title);

	//	Put Description
	Tango::DbDatum	description("Description");
	vector<string>	str_desc;
	str_desc.push_back("AlarmHandler device. Fork of Tango ELETTRA Alarm System.");
	description << str_desc;
	data.push_back(description);

	//  Put inheritance
	Tango::DbDatum	inher_datum("InheritedFrom");
	vector<string> inheritance;
	inheritance.push_back("TANGO_BASE_CLASS");
	inher_datum << inheritance;
	data.push_back(inher_datum);

	//	Call database and and values
	get_db_class()->put_property(data);
}

//===================================================================
//	Factory methods
//===================================================================

//--------------------------------------------------------
/**
 *	Method      : AlarmHandlerClass::device_factory()
 *	Description : Create the device object(s)
 *                and store them in the device list
 */
//--------------------------------------------------------
void AlarmHandlerClass::device_factory(const Tango::DevVarStringArray *devlist_ptr)
{
	/*----- PROTECTED REGION ID(AlarmHandlerClass::device_factory_before) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	AlarmHandlerClass::device_factory_before

	//	Create devices and add it into the device list
	for (unsigned long i=0 ; i<devlist_ptr->length() ; i++)
	{
		cout4 << "Device name : " << (*devlist_ptr)[i].in() << endl;
		device_list.push_back(new AlarmHandler(this, (*devlist_ptr)[i]));
	}

	//	Manage dynamic attributes if any
	erase_dynamic_attributes(devlist_ptr, get_class_attr()->get_attr_list());

	//	Export devices to the outside world
	for (unsigned long i=1 ; i<=devlist_ptr->length() ; i++)
	{
		//	Add dynamic attributes if any
		AlarmHandler *dev = static_cast<AlarmHandler *>(device_list[device_list.size()-i]);
		dev->add_dynamic_attributes();

		//	Check before if database used.
		if ((Tango::Util::_UseDb == true) && (Tango::Util::_FileDb == false))
			export_device(dev);
		else
			export_device(dev, dev->get_name().c_str());
	}

	/*----- PROTECTED REGION ID(AlarmHandlerClass::device_factory_after) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	AlarmHandlerClass::device_factory_after
}
//--------------------------------------------------------
/**
 *	Method      : AlarmHandlerClass::attribute_factory()
 *	Description : Create the attribute object(s)
 *                and store them in the attribute list
 */
//--------------------------------------------------------
void AlarmHandlerClass::attribute_factory(vector<Tango::Attr *> &att_list)
{
	/*----- PROTECTED REGION ID(AlarmHandlerClass::attribute_factory_before) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	AlarmHandlerClass::attribute_factory_before
	//	Call atribute_factory for inherited class
	LMCDevice_ns::LMCDeviceClass::attribute_factory(att_list);

	//	Attribute : loggingLevelCentral - Check if not concrete in inherited class
	Tango::Attr *loggingLevelCentralAttr = get_attr_object_by_name(att_list, "loggingLevelCentral");
	if (loggingLevelCentralAttr == NULL)
	{
	}

	//	Attribute : loggingLevelElement - Check if not concrete in inherited class
	Tango::Attr *loggingLevelElementAttr = get_attr_object_by_name(att_list, "loggingLevelElement");
	if (loggingLevelElementAttr == NULL)
	{
	}

	//	Attribute : loggingLevelStorage - Check if not concrete in inherited class
	Tango::Attr *loggingLevelStorageAttr = get_attr_object_by_name(att_list, "loggingLevelStorage");
	if (loggingLevelStorageAttr == NULL)
	{
	}

	//	Attribute : loggingLevelConsole - Check if not concrete in inherited class
	Tango::Attr *loggingLevelConsoleAttr = get_attr_object_by_name(att_list, "loggingLevelConsole");
	if (loggingLevelConsoleAttr == NULL)
	{
	}

	//	Attribute : buildState - Check if not concrete in inherited class
	Tango::Attr *buildStateAttr = get_attr_object_by_name(att_list, "buildState");
	if (buildStateAttr == NULL)
	{
	}

	//	Attribute : centralLoggerStatus - Check if not concrete in inherited class
	Tango::Attr *centralLoggerStatusAttr = get_attr_object_by_name(att_list, "centralLoggerStatus");
	if (centralLoggerStatusAttr == NULL)
	{
	}

	//	Attribute : elementLoggerStatus - Check if not concrete in inherited class
	Tango::Attr *elementLoggerStatusAttr = get_attr_object_by_name(att_list, "elementLoggerStatus");
	if (elementLoggerStatusAttr == NULL)
	{
	}

	//	Attribute : storageLoggerStatus - Check if not concrete in inherited class
	Tango::Attr *storageLoggerStatusAttr = get_attr_object_by_name(att_list, "storageLoggerStatus");
	if (storageLoggerStatusAttr == NULL)
	{
	}

	//	Attribute : eventRate - Check if not concrete in inherited class
	Tango::Attr *eventRateAttr = get_attr_object_by_name(att_list, "eventRate");
	if (eventRateAttr == NULL)
	{
	}

	//	Attribute : exceptionRate - Check if not concrete in inherited class
	Tango::Attr *exceptionRateAttr = get_attr_object_by_name(att_list, "exceptionRate");
	if (exceptionRateAttr == NULL)
	{
	}

	//	Attribute : fwdAttrInitStatus - Check if not concrete in inherited class
	Tango::Attr *fwdAttrInitStatusAttr = get_attr_object_by_name(att_list, "fwdAttrInitStatus");
	if (fwdAttrInitStatusAttr == NULL)
	{
	}

	//	Attribute : alarmAudible
	alarmAudibleAttrib	*alarmaudible = new alarmAudibleAttrib();
	Tango::UserDefaultAttrProp	alarmaudible_prop;
	alarmaudible_prop.set_description("True if there is at least one alarm that needs audible indication on the GUI");
	//	label	not set for alarmAudible
	//	unit	not set for alarmAudible
	//	standard_unit	not set for alarmAudible
	//	display_unit	not set for alarmAudible
	//	format	not set for alarmAudible
	//	max_value	not set for alarmAudible
	//	min_value	not set for alarmAudible
	//	max_alarm	not set for alarmAudible
	//	min_alarm	not set for alarmAudible
	//	max_warning	not set for alarmAudible
	//	min_warning	not set for alarmAudible
	//	delta_t	not set for alarmAudible
	//	delta_val	not set for alarmAudible
	
	alarmaudible->set_default_properties(alarmaudible_prop);
	//	Not Polled
	alarmaudible->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	alarmaudible->set_change_event(true, false);
	alarmaudible->set_archive_event(true, false);
	att_list.push_back(alarmaudible);

	//	Attribute : StatisticsResetTime
	StatisticsResetTimeAttrib	*statisticsresettime = new StatisticsResetTimeAttrib();
	Tango::UserDefaultAttrProp	statisticsresettime_prop;
	statisticsresettime_prop.set_description("Time elapsed in seconds since last Resetstatistics");
	//	label	not set for StatisticsResetTime
	statisticsresettime_prop.set_unit("s");
	statisticsresettime_prop.set_standard_unit("1");
	statisticsresettime_prop.set_display_unit("s");
	//	format	not set for StatisticsResetTime
	//	max_value	not set for StatisticsResetTime
	//	min_value	not set for StatisticsResetTime
	//	max_alarm	not set for StatisticsResetTime
	//	min_alarm	not set for StatisticsResetTime
	//	max_warning	not set for StatisticsResetTime
	//	min_warning	not set for StatisticsResetTime
	//	delta_t	not set for StatisticsResetTime
	//	delta_val	not set for StatisticsResetTime
	
	statisticsresettime->set_default_properties(statisticsresettime_prop);
	//	Not Polled
	statisticsresettime->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(statisticsresettime);

	//	Attribute : centralLoggerEnabled - Check if not concrete in inherited class
	Tango::Attr *centralLoggerEnabledAttr = get_attr_object_by_name(att_list, "centralLoggerEnabled");
	if (centralLoggerEnabledAttr == NULL)
	{
	}

	//	Attribute : elementLoggerEnabled - Check if not concrete in inherited class
	Tango::Attr *elementLoggerEnabledAttr = get_attr_object_by_name(att_list, "elementLoggerEnabled");
	if (elementLoggerEnabledAttr == NULL)
	{
	}

	//	Attribute : storageLoggerEnabled - Check if not concrete in inherited class
	Tango::Attr *storageLoggerEnabledAttr = get_attr_object_by_name(att_list, "storageLoggerEnabled");
	if (storageLoggerEnabledAttr == NULL)
	{
	}

	//	Attribute : loggingTargetCentral - Check if not concrete in inherited class
	Tango::Attr *loggingTargetCentralAttr = get_attr_object_by_name(att_list, "loggingTargetCentral");
	if (loggingTargetCentralAttr == NULL)
	{
	}

	//	Attribute : loggingTargetElement - Check if not concrete in inherited class
	Tango::Attr *loggingTargetElementAttr = get_attr_object_by_name(att_list, "loggingTargetElement");
	if (loggingTargetElementAttr == NULL)
	{
	}

	//	Attribute : loggingTargetStorage - Check if not concrete in inherited class
	Tango::Attr *loggingTargetStorageAttr = get_attr_object_by_name(att_list, "loggingTargetStorage");
	if (loggingTargetStorageAttr == NULL)
	{
	}

	//	Attribute : attrRandomizationEnabled - Check if not concrete in inherited class
	Tango::Attr *attrRandomizationEnabledAttr = get_attr_object_by_name(att_list, "attrRandomizationEnabled");
	if (attrRandomizationEnabledAttr == NULL)
	{
	}

	//	Attribute : attrRandomizationPeriod - Check if not concrete in inherited class
	Tango::Attr *attrRandomizationPeriodAttr = get_attr_object_by_name(att_list, "attrRandomizationPeriod");
	if (attrRandomizationPeriodAttr == NULL)
	{
	}

	//	Attribute : alarm
	alarmAttrib	*alarm = new alarmAttrib();
	Tango::UserDefaultAttrProp	alarm_prop;
	//	description	not set for alarm
	//	label	not set for alarm
	//	unit	not set for alarm
	//	standard_unit	not set for alarm
	//	display_unit	not set for alarm
	//	format	not set for alarm
	//	max_value	not set for alarm
	//	min_value	not set for alarm
	//	max_alarm	not set for alarm
	//	min_alarm	not set for alarm
	//	max_warning	not set for alarm
	//	min_warning	not set for alarm
	//	delta_t	not set for alarm
	//	delta_val	not set for alarm
	
	alarm->set_default_properties(alarm_prop);
	//	Not Polled
	alarm->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(alarm);

	//	Attribute : alarmNormal
	alarmNormalAttrib	*alarmnormal = new alarmNormalAttrib();
	Tango::UserDefaultAttrProp	alarmnormal_prop;
	alarmnormal_prop.set_description("List of alarms in normal state");
	//	label	not set for alarmNormal
	//	unit	not set for alarmNormal
	//	standard_unit	not set for alarmNormal
	//	display_unit	not set for alarmNormal
	//	format	not set for alarmNormal
	//	max_value	not set for alarmNormal
	//	min_value	not set for alarmNormal
	//	max_alarm	not set for alarmNormal
	//	min_alarm	not set for alarmNormal
	//	max_warning	not set for alarmNormal
	//	min_warning	not set for alarmNormal
	//	delta_t	not set for alarmNormal
	//	delta_val	not set for alarmNormal
	
	alarmnormal->set_default_properties(alarmnormal_prop);
	//	Not Polled
	alarmnormal->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	alarmnormal->set_change_event(true, true);
	alarmnormal->set_archive_event(true, true);
	att_list.push_back(alarmnormal);

	//	Attribute : alarmUnacknowledged
	alarmUnacknowledgedAttrib	*alarmunacknowledged = new alarmUnacknowledgedAttrib();
	Tango::UserDefaultAttrProp	alarmunacknowledged_prop;
	alarmunacknowledged_prop.set_description("List of alarms in unacknowledged state");
	//	label	not set for alarmUnacknowledged
	//	unit	not set for alarmUnacknowledged
	//	standard_unit	not set for alarmUnacknowledged
	//	display_unit	not set for alarmUnacknowledged
	//	format	not set for alarmUnacknowledged
	//	max_value	not set for alarmUnacknowledged
	//	min_value	not set for alarmUnacknowledged
	//	max_alarm	not set for alarmUnacknowledged
	//	min_alarm	not set for alarmUnacknowledged
	//	max_warning	not set for alarmUnacknowledged
	//	min_warning	not set for alarmUnacknowledged
	//	delta_t	not set for alarmUnacknowledged
	//	delta_val	not set for alarmUnacknowledged
	
	alarmunacknowledged->set_default_properties(alarmunacknowledged_prop);
	//	Not Polled
	alarmunacknowledged->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	alarmunacknowledged->set_change_event(true, true);
	alarmunacknowledged->set_archive_event(true, true);
	att_list.push_back(alarmunacknowledged);

	//	Attribute : alarmAcknowledged
	alarmAcknowledgedAttrib	*alarmacknowledged = new alarmAcknowledgedAttrib();
	Tango::UserDefaultAttrProp	alarmacknowledged_prop;
	alarmacknowledged_prop.set_description("List of alarms in acknowledged state");
	//	label	not set for alarmAcknowledged
	//	unit	not set for alarmAcknowledged
	//	standard_unit	not set for alarmAcknowledged
	//	display_unit	not set for alarmAcknowledged
	//	format	not set for alarmAcknowledged
	//	max_value	not set for alarmAcknowledged
	//	min_value	not set for alarmAcknowledged
	//	max_alarm	not set for alarmAcknowledged
	//	min_alarm	not set for alarmAcknowledged
	//	max_warning	not set for alarmAcknowledged
	//	min_warning	not set for alarmAcknowledged
	//	delta_t	not set for alarmAcknowledged
	//	delta_val	not set for alarmAcknowledged
	
	alarmacknowledged->set_default_properties(alarmacknowledged_prop);
	//	Not Polled
	alarmacknowledged->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	alarmacknowledged->set_change_event(true, true);
	alarmacknowledged->set_archive_event(true, true);
	att_list.push_back(alarmacknowledged);

	//	Attribute : alarmUnacknowledgedNormal
	alarmUnacknowledgedNormalAttrib	*alarmunacknowledgednormal = new alarmUnacknowledgedNormalAttrib();
	Tango::UserDefaultAttrProp	alarmunacknowledgednormal_prop;
	alarmunacknowledgednormal_prop.set_description("List of alarms in unacknowledged normal state");
	//	label	not set for alarmUnacknowledgedNormal
	//	unit	not set for alarmUnacknowledgedNormal
	//	standard_unit	not set for alarmUnacknowledgedNormal
	//	display_unit	not set for alarmUnacknowledgedNormal
	//	format	not set for alarmUnacknowledgedNormal
	//	max_value	not set for alarmUnacknowledgedNormal
	//	min_value	not set for alarmUnacknowledgedNormal
	//	max_alarm	not set for alarmUnacknowledgedNormal
	//	min_alarm	not set for alarmUnacknowledgedNormal
	//	max_warning	not set for alarmUnacknowledgedNormal
	//	min_warning	not set for alarmUnacknowledgedNormal
	//	delta_t	not set for alarmUnacknowledgedNormal
	//	delta_val	not set for alarmUnacknowledgedNormal
	
	alarmunacknowledgednormal->set_default_properties(alarmunacknowledgednormal_prop);
	//	Not Polled
	alarmunacknowledgednormal->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	alarmunacknowledgednormal->set_change_event(true, true);
	alarmunacknowledgednormal->set_archive_event(true, true);
	att_list.push_back(alarmunacknowledgednormal);

	//	Attribute : alarmShelved
	alarmShelvedAttrib	*alarmshelved = new alarmShelvedAttrib();
	Tango::UserDefaultAttrProp	alarmshelved_prop;
	alarmshelved_prop.set_description("List of alarms in shelved state");
	//	label	not set for alarmShelved
	//	unit	not set for alarmShelved
	//	standard_unit	not set for alarmShelved
	//	display_unit	not set for alarmShelved
	//	format	not set for alarmShelved
	//	max_value	not set for alarmShelved
	//	min_value	not set for alarmShelved
	//	max_alarm	not set for alarmShelved
	//	min_alarm	not set for alarmShelved
	//	max_warning	not set for alarmShelved
	//	min_warning	not set for alarmShelved
	//	delta_t	not set for alarmShelved
	//	delta_val	not set for alarmShelved
	
	alarmshelved->set_default_properties(alarmshelved_prop);
	//	Not Polled
	alarmshelved->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	alarmshelved->set_change_event(true, true);
	alarmshelved->set_archive_event(true, true);
	att_list.push_back(alarmshelved);

	//	Attribute : alarmOutOfService
	alarmOutOfServiceAttrib	*alarmoutofservice = new alarmOutOfServiceAttrib();
	Tango::UserDefaultAttrProp	alarmoutofservice_prop;
	alarmoutofservice_prop.set_description("List of alarms in out of service state");
	//	label	not set for alarmOutOfService
	//	unit	not set for alarmOutOfService
	//	standard_unit	not set for alarmOutOfService
	//	display_unit	not set for alarmOutOfService
	//	format	not set for alarmOutOfService
	//	max_value	not set for alarmOutOfService
	//	min_value	not set for alarmOutOfService
	//	max_alarm	not set for alarmOutOfService
	//	min_alarm	not set for alarmOutOfService
	//	max_warning	not set for alarmOutOfService
	//	min_warning	not set for alarmOutOfService
	//	delta_t	not set for alarmOutOfService
	//	delta_val	not set for alarmOutOfService
	
	alarmoutofservice->set_default_properties(alarmoutofservice_prop);
	//	Not Polled
	alarmoutofservice->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	alarmoutofservice->set_change_event(true, true);
	alarmoutofservice->set_archive_event(true, true);
	att_list.push_back(alarmoutofservice);

	//	Attribute : alarmSilenced
	alarmSilencedAttrib	*alarmsilenced = new alarmSilencedAttrib();
	Tango::UserDefaultAttrProp	alarmsilenced_prop;
	alarmsilenced_prop.set_description("List of alarms in silenced state");
	//	label	not set for alarmSilenced
	//	unit	not set for alarmSilenced
	//	standard_unit	not set for alarmSilenced
	//	display_unit	not set for alarmSilenced
	//	format	not set for alarmSilenced
	//	max_value	not set for alarmSilenced
	//	min_value	not set for alarmSilenced
	//	max_alarm	not set for alarmSilenced
	//	min_alarm	not set for alarmSilenced
	//	max_warning	not set for alarmSilenced
	//	min_warning	not set for alarmSilenced
	//	delta_t	not set for alarmSilenced
	//	delta_val	not set for alarmSilenced
	
	alarmsilenced->set_default_properties(alarmsilenced_prop);
	//	Not Polled
	alarmsilenced->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	alarmsilenced->set_change_event(true, true);
	alarmsilenced->set_archive_event(true, true);
	att_list.push_back(alarmsilenced);

	//	Attribute : alarmList
	alarmListAttrib	*alarmlist = new alarmListAttrib();
	Tango::UserDefaultAttrProp	alarmlist_prop;
	alarmlist_prop.set_description("List of all alarms");
	//	label	not set for alarmList
	//	unit	not set for alarmList
	//	standard_unit	not set for alarmList
	//	display_unit	not set for alarmList
	//	format	not set for alarmList
	//	max_value	not set for alarmList
	//	min_value	not set for alarmList
	//	max_alarm	not set for alarmList
	//	min_alarm	not set for alarmList
	//	max_warning	not set for alarmList
	//	min_warning	not set for alarmList
	//	delta_t	not set for alarmList
	//	delta_val	not set for alarmList
	
	alarmlist->set_default_properties(alarmlist_prop);
	//	Not Polled
	alarmlist->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	alarmlist->set_change_event(true, true);
	alarmlist->set_archive_event(true, true);
	att_list.push_back(alarmlist);

	//	Attribute : alarmFrequency
	alarmFrequencyAttrib	*alarmfrequency = new alarmFrequencyAttrib();
	Tango::UserDefaultAttrProp	alarmfrequency_prop;
	alarmfrequency_prop.set_description("List of frequency of evaluation of all alarms");
	//	label	not set for alarmFrequency
	//	unit	not set for alarmFrequency
	//	standard_unit	not set for alarmFrequency
	//	display_unit	not set for alarmFrequency
	//	format	not set for alarmFrequency
	//	max_value	not set for alarmFrequency
	//	min_value	not set for alarmFrequency
	//	max_alarm	not set for alarmFrequency
	//	min_alarm	not set for alarmFrequency
	//	max_warning	not set for alarmFrequency
	//	min_warning	not set for alarmFrequency
	//	delta_t	not set for alarmFrequency
	//	delta_val	not set for alarmFrequency
	
	alarmfrequency->set_default_properties(alarmfrequency_prop);
	//	Not Polled
	alarmfrequency->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	alarmfrequency->set_change_event(true, true);
	alarmfrequency->set_archive_event(true, true);
	att_list.push_back(alarmfrequency);

	//	Attribute : alarmSummary
	alarmSummaryAttrib	*alarmsummary = new alarmSummaryAttrib();
	Tango::UserDefaultAttrProp	alarmsummary_prop;
	//	description	not set for alarmSummary
	//	label	not set for alarmSummary
	//	unit	not set for alarmSummary
	//	standard_unit	not set for alarmSummary
	//	display_unit	not set for alarmSummary
	//	format	not set for alarmSummary
	//	max_value	not set for alarmSummary
	//	min_value	not set for alarmSummary
	//	max_alarm	not set for alarmSummary
	//	min_alarm	not set for alarmSummary
	//	max_warning	not set for alarmSummary
	//	min_warning	not set for alarmSummary
	//	delta_t	not set for alarmSummary
	//	delta_val	not set for alarmSummary
	
	alarmsummary->set_default_properties(alarmsummary_prop);
	//	Not Polled
	alarmsummary->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	alarmsummary->set_change_event(true, true);
	alarmsummary->set_archive_event(true, true);
	att_list.push_back(alarmsummary);


	//	Create a list of static attributes
	create_static_attribute_list(get_class_attr()->get_attr_list());
	/*----- PROTECTED REGION ID(AlarmHandlerClass::attribute_factory_after) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	AlarmHandlerClass::attribute_factory_after
}
//--------------------------------------------------------
/**
 *	Method      : AlarmHandlerClass::pipe_factory()
 *	Description : Create the pipe object(s)
 *                and store them in the pipe list
 */
//--------------------------------------------------------
void AlarmHandlerClass::pipe_factory()
{
	/*----- PROTECTED REGION ID(AlarmHandlerClass::pipe_factory_before) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	AlarmHandlerClass::pipe_factory_before
	/*----- PROTECTED REGION ID(AlarmHandlerClass::pipe_factory_after) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	AlarmHandlerClass::pipe_factory_after
}
//--------------------------------------------------------
/**
 *	Method      : AlarmHandlerClass::command_factory()
 *	Description : Create the command object(s)
 *                and store them in the command list
 */
//--------------------------------------------------------
void AlarmHandlerClass::command_factory()
{
	/*----- PROTECTED REGION ID(AlarmHandlerClass::command_factory_before) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	AlarmHandlerClass::command_factory_before
	//	Call command_factory for inherited class
	LMCDevice_ns::LMCDeviceClass::command_factory();



























	//	Command Ack
	AckClass	*pAckCmd =
		new AckClass("Ack",
			Tango::DEVVAR_STRINGARRAY, Tango::DEV_VOID,
			"String array containing the alarms to be acknowledged",
			"",
			Tango::OPERATOR);
	command_list.push_back(pAckCmd);

	//	Command Load
	LoadClass	*pLoadCmd =
		new LoadClass("Load",
			Tango::DEV_STRING, Tango::DEV_VOID,
			"Alarm entry",
			"",
			Tango::OPERATOR);
	command_list.push_back(pLoadCmd);

	//	Command Remove
	RemoveClass	*pRemoveCmd =
		new RemoveClass("Remove",
			Tango::DEV_STRING, Tango::DEV_VOID,
			"Alarm name",
			"",
			Tango::OPERATOR);
	command_list.push_back(pRemoveCmd);

	//	Command SearchAlarm
	SearchAlarmClass	*pSearchAlarmCmd =
		new SearchAlarmClass("SearchAlarm",
			Tango::DEV_STRING, Tango::DEVVAR_STRINGARRAY,
			"String containing a filter for output, if empty or * return all alarms",
			"Configured alarms",
			Tango::OPERATOR);
	command_list.push_back(pSearchAlarmCmd);

	//	Command StopAudible
	StopAudibleClass	*pStopAudibleCmd =
		new StopAudibleClass("StopAudible",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pStopAudibleCmd);

	//	Command Silence
	SilenceClass	*pSilenceCmd =
		new SilenceClass("Silence",
			Tango::DEVVAR_STRINGARRAY, Tango::DEV_VOID,
			"String array containing the alarms to be silenced",
			"",
			Tango::OPERATOR);
	command_list.push_back(pSilenceCmd);

	//	Command Modify
	ModifyClass	*pModifyCmd =
		new ModifyClass("Modify",
			Tango::DEV_STRING, Tango::DEV_VOID,
			"Alarm entry",
			"",
			Tango::OPERATOR);
	command_list.push_back(pModifyCmd);

	//	Command Shelve
	ShelveClass	*pShelveCmd =
		new ShelveClass("Shelve",
			Tango::DEVVAR_STRINGARRAY, Tango::DEV_VOID,
			"String array containing alarm to be shelved",
			"",
			Tango::OPERATOR);
	command_list.push_back(pShelveCmd);

	//	Command Enable
	EnableClass	*pEnableCmd =
		new EnableClass("Enable",
			Tango::DEV_STRING, Tango::DEV_VOID,
			"Alarm name",
			"",
			Tango::OPERATOR);
	command_list.push_back(pEnableCmd);

	//	Command Disable
	DisableClass	*pDisableCmd =
		new DisableClass("Disable",
			Tango::DEV_STRING, Tango::DEV_VOID,
			"Alarm name",
			"",
			Tango::OPERATOR);
	command_list.push_back(pDisableCmd);

	//	Command ResetStatistics
	ResetStatisticsClass	*pResetStatisticsCmd =
		new ResetStatisticsClass("ResetStatistics",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pResetStatisticsCmd);

	//	Command StopNew
	StopNewClass	*pStopNewCmd =
		new StopNewClass("StopNew",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pStopNewCmd);

	//	Command GetAlarmInfo
	GetAlarmInfoClass	*pGetAlarmInfoCmd =
		new GetAlarmInfoClass("GetAlarmInfo",
			Tango::DEVVAR_STRINGARRAY, Tango::DEVVAR_STRINGARRAY,
			"Alarm name followed optionally by wanted key names",
			"Complete attribute info as an array of key=value",
			Tango::OPERATOR);
	command_list.push_back(pGetAlarmInfoCmd);

	//	Command RemoveAlarmAttrs
	RemoveAlarmAttrsClass	*pRemoveAlarmAttrsCmd =
		new RemoveAlarmAttrsClass("RemoveAlarmAttrs",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pRemoveAlarmAttrsCmd);





	/*----- PROTECTED REGION ID(AlarmHandlerClass::command_factory_after) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	AlarmHandlerClass::command_factory_after
}

//===================================================================
//	Dynamic attributes related methods
//===================================================================

//--------------------------------------------------------
/**
 * method : 		AlarmHandlerClass::create_static_attribute_list
 * description : 	Create the a list of static attributes
 *
 * @param	att_list	the ceated attribute list
 */
//--------------------------------------------------------
void AlarmHandlerClass::create_static_attribute_list(vector<Tango::Attr *> &att_list)
{
	for (unsigned long i=0 ; i<att_list.size() ; i++)
	{
		string att_name(att_list[i]->get_name());
		transform(att_name.begin(), att_name.end(), att_name.begin(), ::tolower);
		defaultAttList.push_back(att_name);
	}

	cout2 << defaultAttList.size() << " attributes in default list" << endl;

	/*----- PROTECTED REGION ID(AlarmHandlerClass::create_static_att_list) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	AlarmHandlerClass::create_static_att_list
}


//--------------------------------------------------------
/**
 * method : 		AlarmHandlerClass::erase_dynamic_attributes
 * description : 	delete the dynamic attributes if any.
 *
 * @param	devlist_ptr	the device list pointer
 * @param	list of all attributes
 */
//--------------------------------------------------------
void AlarmHandlerClass::erase_dynamic_attributes(const Tango::DevVarStringArray *devlist_ptr, vector<Tango::Attr *> &att_list)
{
	Tango::Util *tg = Tango::Util::instance();

	for (unsigned long i=0 ; i<devlist_ptr->length() ; i++)
	{
		Tango::DeviceImpl *dev_impl = tg->get_device_by_name(((string)(*devlist_ptr)[i]).c_str());
		AlarmHandler *dev = static_cast<AlarmHandler *> (dev_impl);

		vector<Tango::Attribute *> &dev_att_list = dev->get_device_attr()->get_attribute_list();
		vector<Tango::Attribute *>::iterator ite_att;
		for (ite_att=dev_att_list.begin() ; ite_att != dev_att_list.end() ; ++ite_att)
		{
			string att_name((*ite_att)->get_name_lower());
			if ((att_name == "state") || (att_name == "status"))
				continue;
			vector<string>::iterator ite_str = find(defaultAttList.begin(), defaultAttList.end(), att_name);
			if (ite_str == defaultAttList.end())
			{
				cout2 << att_name << " is a UNWANTED dynamic attribute for device " << (*devlist_ptr)[i] << endl;
				Tango::Attribute &att = dev->get_device_attr()->get_attr_by_name(att_name.c_str());
				dev->remove_attribute(att_list[att.get_attr_idx()], true, false);
				--ite_att;
			}
		}
	}
	/*----- PROTECTED REGION ID(AlarmHandlerClass::erase_dynamic_attributes) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	AlarmHandlerClass::erase_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Method      : AlarmHandlerClass::get_attr_by_name()
 *	Description : returns Tango::Attr * object found by name
 */
//--------------------------------------------------------
Tango::Attr *AlarmHandlerClass::get_attr_object_by_name(vector<Tango::Attr *> &att_list, string attname)
{
	vector<Tango::Attr *>::iterator it;
	for (it=att_list.begin() ; it<att_list.end() ; ++it)
		if ((*it)->get_name()==attname)
			return (*it);
	//	Attr does not exist
	return NULL;
}


/*----- PROTECTED REGION ID(AlarmHandlerClass::Additional Methods) ENABLED START -----*/

/*----- PROTECTED REGION END -----*/	//	AlarmHandlerClass::Additional Methods
} //	namespace
