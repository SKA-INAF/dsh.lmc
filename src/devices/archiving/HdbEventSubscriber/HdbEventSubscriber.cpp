/*----- PROTECTED REGION ID(HdbEventSubscriber.cpp) ENABLED START -----*/
//=============================================================================
//
// file :        HdbEventSubscriber.cpp
//
// description : C++ source for the HdbEventSubscriber class and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               HdbEventSubscriber are implemented in this file.
//
// project :     Tango Device Server
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
//
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================

#include <tango.h>


#include "HdbEventSubscriber.h"
#include "HdbEventSubscriberClass.h"

#include "SubscribeThread.h"
#include "StatsThread.h"
#include "PushThread.h"

#include "HdbDevice.h"

#include <ArchivedData.h>
#include <DevConfigParser.h>
#include <libhdb++/LibHdb++.h>

/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber.cpp

/**
 *  HdbEventSubscriber class description:
 *    This class is able to subscribe on archive events and store value in Historical DB
 *    NB: Adapted by Simone for SKA Dish LMC
 */

//================================================================
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name            |  Method name
//================================================================
//  State                   |  Inherited (no method)
//  Status                  |  Inherited (no method)
//  InitializeLoggers       |  Inherited (no method)
//  InitializeFwdAttrs      |  Inherited (no method)
//  RandomizeDynAttrs       |  Inherited (no method)
//  InitializeDevProxies    |  Inherited (no method)
//  GetRegisteredProxies    |  Inherited (no method)
//  GetRegisteredEvents     |  Inherited (no method)
//  GetRegisteredFormulas   |  Inherited (no method)
//  GetInitializedFormulas  |  Inherited (no method)
//  GetNRunningTasks        |  Inherited (no method)
//  GetNQueuedTasks         |  Inherited (no method)
//  GetNIdleTasks           |  Inherited (no method)
//  GetNTasks               |  Inherited (no method)
//  GetNFailedTasks         |  Inherited (no method)
//  GetNTotFailedTasks      |  Inherited (no method)
//  IsTaskQuotaReached      |  Inherited (no method)
//  FlushTaskQueue          |  Inherited (no method)
//  GetQueuedTaskInfo       |  Inherited (no method)
//  GetTaskInfo             |  Inherited (no method)
//  ClearTasks              |  Inherited (no method)
//  UpdateFormulaAttrs      |  Inherited (no method)
//  UpdateStatusAttrs       |  Inherited (no method)
//  MonitorProxies          |  Inherited (no method)
//  RevokeTask              |  Inherited (no method)
//  GetFormulaData          |  Inherited (no method)
//  SendTestLogMsg          |  Inherited (no method)
//  AttributeAdd            |  attribute_add
//  AttributeRemove         |  attribute_remove
//  AttributeStatus         |  attribute_status
//  Start                   |  start
//  Stop                    |  stop
//  AttributeStart          |  attribute_start
//  AttributeStop           |  attribute_stop
//  ResetStatistics         |  reset_statistics
//  Pause                   |  pause
//  AttributePause          |  attribute_pause
//  SetAttributeStrategy    |  set_attribute_strategy
//  GetAttributeStrategy    |  get_attribute_strategy
//  StopFaulty              |  stop_faulty
//  SetAttributeTTL         |  set_attribute_ttl
//  GetAttributeTTL         |  get_attribute_ttl
//  RevokeTaskSequence      |  Inherited (no method)
//  ClearTaskHistory        |  Inherited (no method)
//  GetLogAppenderInfo      |  Inherited (no method)
//================================================================

//================================================================
//  Attributes managed are:
//================================================================
//  loggingLevelCentral         |  Tango::DevLong	Scalar
//  loggingLevelElement         |  Tango::DevLong	Scalar
//  loggingLevelStorage         |  Tango::DevLong	Scalar
//  loggingLevelConsole         |  Tango::DevLong	Scalar
//  buildState                  |  Tango::DevString	Scalar
//  centralLoggerStatus         |  Tango::DevEnum	Scalar
//  elementLoggerStatus         |  Tango::DevEnum	Scalar
//  storageLoggerStatus         |  Tango::DevEnum	Scalar
//  eventRate                   |  Tango::DevFloat	Scalar
//  exceptionRate               |  Tango::DevFloat	Scalar
//  fwdAttrInitStatus           |  Tango::DevEnum	Scalar
//  centralLoggerEnabled        |  Tango::DevBoolean	Scalar
//  elementLoggerEnabled        |  Tango::DevBoolean	Scalar
//  storageLoggerEnabled        |  Tango::DevBoolean	Scalar
//  loggingTargetCentral        |  Tango::DevString	Scalar
//  loggingTargetElement        |  Tango::DevString	Scalar
//  loggingTargetStorage        |  Tango::DevString	Scalar
//  AttributeOkNumber           |  Tango::DevLong	Scalar
//  AttributeNokNumber          |  Tango::DevLong	Scalar
//  AttributePendingNumber      |  Tango::DevLong	Scalar
//  AttributeNumber             |  Tango::DevLong	Scalar
//  AttributeMaxStoreTime       |  Tango::DevDouble	Scalar
//  AttributeMinStoreTime       |  Tango::DevDouble	Scalar
//  AttributeMaxProcessingTime  |  Tango::DevDouble	Scalar
//  AttributeMinProcessingTime  |  Tango::DevDouble	Scalar
//  AttributeRecordFreq         |  Tango::DevDouble	Scalar
//  AttributeFailureFreq        |  Tango::DevDouble	Scalar
//  AttributeStartedNumber      |  Tango::DevLong	Scalar
//  AttributeStoppedNumber      |  Tango::DevLong	Scalar
//  AttributeMaxPendingNumber   |  Tango::DevLong	Scalar
//  StatisticsResetTime         |  Tango::DevDouble	Scalar
//  AttributePausedNumber       |  Tango::DevLong	Scalar
//  Context                     |  Tango::DevString	Scalar
//  attrRandomizationEnabled    |  Tango::DevBoolean	Scalar
//  attrRandomizationPeriod     |  Tango::DevULong	Scalar
//  AttributeList               |  Tango::DevString	Spectrum  ( max = 10000)
//  AttributeOkList             |  Tango::DevString	Spectrum  ( max = 10000)
//  AttributeNokList            |  Tango::DevString	Spectrum  ( max = 10000)
//  AttributePendingList        |  Tango::DevString	Spectrum  ( max = 10000)
//  AttributeRecordFreqList     |  Tango::DevDouble	Spectrum  ( max = 10000)
//  AttributeFailureFreqList    |  Tango::DevDouble	Spectrum  ( max = 10000)
//  AttributeStartedList        |  Tango::DevString	Spectrum  ( max = 10000)
//  AttributeStoppedList        |  Tango::DevString	Spectrum  ( max = 10000)
//  AttributeEventNumberList    |  Tango::DevLong	Spectrum  ( max = 10000)
//  AttributeErrorList          |  Tango::DevString	Spectrum  ( max = 10000)
//  AttributePausedList         |  Tango::DevString	Spectrum  ( max = 10000)
//  AttributeStrategyList       |  Tango::DevString	Spectrum  ( max = 10000)
//  ContextsList                |  Tango::DevString	Spectrum  ( max = 1000)
//  AttributeTTLList            |  Tango::DevULong	Spectrum  ( max = 10000)
//================================================================

namespace HdbEventSubscriber_ns
{
/*----- PROTECTED REGION ID(HdbEventSubscriber::namespace_starting) ENABLED START -----*/

//	static initializations

/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::namespace_starting

//--------------------------------------------------------
/**
 *	Method      : HdbEventSubscriber::HdbEventSubscriber()
 *	Description : Constructors for a Tango device
 *                implementing the classHdbEventSubscriber
 */
//--------------------------------------------------------
HdbEventSubscriber::HdbEventSubscriber(Tango::DeviceClass *cl, string &s)
 : LMCDevice(cl, s.c_str())
{
	/*----- PROTECTED REGION ID(HdbEventSubscriber::constructor_1) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::constructor_1
}
//--------------------------------------------------------
HdbEventSubscriber::HdbEventSubscriber(Tango::DeviceClass *cl, const char *s)
 : LMCDevice(cl, s)
{
	/*----- PROTECTED REGION ID(HdbEventSubscriber::constructor_2) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::constructor_2
}
//--------------------------------------------------------
HdbEventSubscriber::HdbEventSubscriber(Tango::DeviceClass *cl, const char *s, const char *d)
 : LMCDevice(cl, s, d)
{
	/*----- PROTECTED REGION ID(HdbEventSubscriber::constructor_3) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::constructor_3
}

//--------------------------------------------------------
/**
 *	Method      : HdbEventSubscriber::delete_device()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void HdbEventSubscriber::delete_device()
{
	DEBUG_STREAM << "HdbEventSubscriber::delete_device() " << device_name << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::delete_device) ENABLED START -----*/
	
	//	Delete device allocated objects
	INFO_STREAM << "-------- Delete device's allocated object --------" << endl;
	pause();
	delete hdb_dev;

	
	//#####  ADDED BY SIMONE RIGGI ###
	if(m_mdb) {
		delete m_mdb;
		m_mdb= 0;
	}

	//## Remove cfg archived attr list
	_DEBUG_LOG("Deleting archived attr list parsed from config file...");
	for(size_t i=0;i<m_archivedAttrs.size();i++){
		if(m_archivedAttrs[i]){
			delete m_archivedAttrs[i];
			m_archivedAttrs[i]= 0;
		}
	}
	m_archivedAttrs.clear();
	//###########################

	INFO_STREAM << "-------- Delete device's allocated object done !--------" << endl;
	//Tango::client_leavefunc();


	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::delete_device
	delete[] attr_StatisticsResetTime_read;
	delete[] attr_Context_read;
	delete[] attr_ContextsList_read;

	if (Tango::Util::instance()->is_svr_shutting_down()==false  &&
		Tango::Util::instance()->is_device_restarting(device_name)==false &&
		Tango::Util::instance()->is_svr_starting()==false)
	{
		//	If not shutting down call delete device for inherited object
		LMCDevice_ns::LMCDevice::delete_device();
	}
}

//--------------------------------------------------------
/**
 *	Method      : HdbEventSubscriber::init_device()
 *	Description : will be called at device initialization.
 */
//--------------------------------------------------------
void HdbEventSubscriber::init_device()
{
	DEBUG_STREAM << "HdbEventSubscriber::init_device() create device " << device_name << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::init_device_before) ENABLED START -----*/
	
	//	Initialization before get_device_property() call
	
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::init_device_before
	
	if (Tango::Util::instance()->is_svr_starting() == false  &&
		Tango::Util::instance()->is_device_restarting(device_name)==false)
	{
		//	If not starting up call init device for inherited object
		LMCDevice_ns::LMCDevice::init_device();
	}

	//	Get the device properties from database
	get_device_property();
	
	attr_StatisticsResetTime_read = new Tango::DevDouble[1];
	attr_Context_read = new Tango::DevString[1];
	attr_ContextsList_read = new Tango::DevString[1000];
	//	No longer if mandatory property not set. 
	if (mandatoryNotDefined)
		return;

	/*----- PROTECTED REGION ID(HdbEventSubscriber::init_device) ENABLED START -----*/
	
	//	Initialize device

	initialized = false;
	set_state(Tango::MOVING);
	set_status("Initializing....");

	//	Create one event handler by HDB access device
	INFO_STREAM << "HdbEventSubscriber id="<<omni_thread::self()->id()<<endl;
	string	status("");
	hdb_dev = new HdbDevice(subscribeRetryPeriod, pollingThreadPeriod, statisticsTimeWindow, checkPeriodicTimeoutDelay, this);
	uint8_t index=0;
	for(vector<string>::iterator it = contextsList.begin(); it != contextsList.end(); it++)
	{
		vector<string> res;
		hdb_dev->string_explode(*it, ":", &res);
		if(res.size()==2)
		{
			string context_upper(res[0]);
			std::transform(context_upper.begin(), context_upper.end(), context_upper.begin(), (int(*)(int))toupper);		//transform to uppercase
			INFO_STREAM << "CONFIGURING CONTEXTS: adding " << res[0] << " <-> " << (int)index;
			hdb_dev->contexts_map.insert(make_pair(res[0], res[1]));
			hdb_dev->contexts_map_upper.insert(make_pair(context_upper, res[0]));
			string context_list_element = *it;
			ContextsList_str[index]=context_list_element;
			attr_ContextsList_read[index] = const_cast<char*>(ContextsList_str[index].c_str());
			index++;
		}
	}
	if(hdb_dev->contexts_map_upper.find(ALWAYS_CONTEXT) == hdb_dev->contexts_map_upper.end())
	{
		INFO_STREAM << "CONFIGURING CONTEXTS: adding " << ALWAYS_CONTEXT << " <-> " << (int)index;
		hdb_dev->contexts_map.insert(make_pair(ALWAYS_CONTEXT, ALWAYS_CONTEXT_DESC));
		hdb_dev->contexts_map_upper.insert(make_pair(ALWAYS_CONTEXT, ALWAYS_CONTEXT));
		string context_list_element = string(ALWAYS_CONTEXT) + ": " + string(ALWAYS_CONTEXT_DESC);
		ContextsList_str[index]=context_list_element;
		attr_ContextsList_read[index] = const_cast<char*>(ContextsList_str[index].c_str());
		index++;
		contextsList.push_back(context_list_element);
	}
	defaultStrategy_upper = defaultStrategy;
	std::transform(defaultStrategy_upper.begin(), defaultStrategy_upper.end(), defaultStrategy_upper.begin(), (int(*)(int))toupper);		//transform to uppercase
	hdb_dev->defaultStrategy = defaultStrategy_upper;
	map<string, string>::iterator it = hdb_dev->contexts_map_upper.find(defaultStrategy_upper);
	if(it != hdb_dev->contexts_map_upper.end())
	{		
		context_read = it->second.c_str();
		*attr_Context_read = const_cast<char*>(context_read.c_str());
		context_set = it->first;
		INFO_STREAM << "Setting context attribute to "<<context_read<<" (context_set="<<context_set<<")";
	}
	else
	{
		ERROR_STREAM << "HdbEventSubscriber::init_device(): FAILED due to bad DefaultStrategy configuration: " << defaultStrategy << " is not present in ContextsList";
		exit(-1);
	}

	attr_AttributeRecordFreq_read = &hdb_dev->AttributeRecordFreq;
	attr_AttributeFailureFreq_read = &hdb_dev->AttributeFailureFreq;
	attr_AttributeRecordFreqList_read = &hdb_dev->AttributeRecordFreqList[0];
	attr_AttributeFailureFreqList_read = &hdb_dev->AttributeFailureFreqList[0];
	attr_AttributeEventNumberList_read = &hdb_dev->AttributeEventNumberList[0];

	try
	{
		hdb_dev->initialize();
	}
	catch(Tango::DevFailed &e)
	{
		status += "PushThread:\n";
		status += e.errors[0].desc;
	}
	//	Check if WARNING
	if (hdb_dev->status.length()>0)
	{
		status += "PushThread:\n";
		status += hdb_dev->status;
	}
	//	Set state and status if something wrong
	if (status.length()>0)
	{
		set_state(Tango::ALARM);
		set_status(status);
		INFO_STREAM << status << endl;
	}
	timespec now;
	clock_gettime(CLOCK_MONOTONIC, &now);
	double dnow = (now.tv_sec) + ((double)(now.tv_nsec))/1000000000;
	last_statistics_reset_time = dnow;


	//###### ADDED BY SIMONE ########
	//## Create HdbClient
	INFO_STREAM<<"Initializing HdbClient ptr..."<<endl;
	m_mdb = 0;
	try
	{
		m_mdb = new HdbClient(libConfiguration);
	}
	catch (Tango::DevFailed &err)
	{
		stringstream tmp;
		tmp << "Error initializing Hdb++ library: " << err.errors[0].desc;
		ERROR_STREAM << __func__ << ": " << tmp.str() << endl;
		set_state(Tango::FAULT);
		set_status(tmp.str());
	}

	//================================================
	//     LOAD ARCHIVED ATTRS FROM FILE
	//================================================
	if(enableConfigFromFile){
		int status= 0;
		try{
			status= LoadArchivedAttrsFromFile(configFile);
		}
		catch(Tango::DevFailed& e){
			std::string reason(e.errors[0].desc.in());
			std::stringstream ss;
			ss<<"Exception occurred while loading archived attrs from config file "<<configFile<<" (reason="<<reason<<")";
			_ERROR_LOG(ss.str());
			set_status(ss.str().c_str());
			set_state(Tango::FAULT);
		}

		if(status<0){
			std::stringstream ss;
			ss<<"One/more errors occurred while loading archived attrs from config file "<<configFile<<"!";
			_ERROR_LOG(ss.str());
			set_status(ss.str().c_str());
			set_state(Tango::FAULT);
		}

	}//close if
	//#####################


	initialized = true;
	
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::init_device
}

//--------------------------------------------------------
/**
 *	Method      : HdbEventSubscriber::get_device_property()
 *	Description : Read database to initialize property data members.
 */
//--------------------------------------------------------
void HdbEventSubscriber::get_device_property()
{
	/*----- PROTECTED REGION ID(HdbEventSubscriber::get_device_property_before) ENABLED START -----*/
	
	//	Initialize property data members
	subscribeRetryPeriod = 60;

	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::get_device_property_before

	mandatoryNotDefined = false;

	//	Read device properties from database.
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("CentralLoggerEnabledDefault"));
	dev_prop.push_back(Tango::DbDatum("ElementLoggerEnabledDefault"));
	dev_prop.push_back(Tango::DbDatum("StorageLoggerEnabledDefault"));
	dev_prop.push_back(Tango::DbDatum("LoggingTargetCentralDefault"));
	dev_prop.push_back(Tango::DbDatum("LoggingTargetElementDefault"));
	dev_prop.push_back(Tango::DbDatum("LoggingTargetStorageDefault"));
	dev_prop.push_back(Tango::DbDatum("SkaLevel"));
	dev_prop.push_back(Tango::DbDatum("SyslogFacility"));
	dev_prop.push_back(Tango::DbDatum("SyslogHost"));
	dev_prop.push_back(Tango::DbDatum("LoggingLevelCentralDefault"));
	dev_prop.push_back(Tango::DbDatum("LoggingLevelElementDefault"));
	dev_prop.push_back(Tango::DbDatum("LoggingLevelStorageDefault"));
	dev_prop.push_back(Tango::DbDatum("ConfigFile"));
	dev_prop.push_back(Tango::DbDatum("EnableConfigFromFile"));
	dev_prop.push_back(Tango::DbDatum("EnableDynAttrCleanup"));
	dev_prop.push_back(Tango::DbDatum("EnableDynAttrRandomize"));
	dev_prop.push_back(Tango::DbDatum("DynAttrRandomizePeriod"));
	dev_prop.push_back(Tango::DbDatum("ProxyDevices"));
	dev_prop.push_back(Tango::DbDatum("FormulaVarMaxTimeInterval"));
	dev_prop.push_back(Tango::DbDatum("EnableProxyMonitoring"));
	dev_prop.push_back(Tango::DbDatum("ProxyMonitoringPeriod"));
	dev_prop.push_back(Tango::DbDatum("ProxyStatusAttrPollPeriod"));
	dev_prop.push_back(Tango::DbDatum("ProxyStatusAttrPeriodicEventPeriod"));
	dev_prop.push_back(Tango::DbDatum("ProxyStatusAttrArchiveEventPeriod"));
	dev_prop.push_back(Tango::DbDatum("ProxyTimeout"));
	dev_prop.push_back(Tango::DbDatum("EventSubscriptions"));
	dev_prop.push_back(Tango::DbDatum("EventHandlers"));
	dev_prop.push_back(Tango::DbDatum("MaxQueueableTask"));
	dev_prop.push_back(Tango::DbDatum("MaxTrackableTasks"));
	dev_prop.push_back(Tango::DbDatum("TaskHistoryTimeDepth"));
	dev_prop.push_back(Tango::DbDatum("DefaultTaskTimeout"));
	dev_prop.push_back(Tango::DbDatum("TaskSequenceStatusAttrList"));
	dev_prop.push_back(Tango::DbDatum("TaskStatusAttrList"));
	dev_prop.push_back(Tango::DbDatum("EnableEventRateMonitoring"));
	dev_prop.push_back(Tango::DbDatum("EnableLoggerInitPolling"));
	dev_prop.push_back(Tango::DbDatum("LoggerInitPollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableDevProxyInitPolling"));
	dev_prop.push_back(Tango::DbDatum("DevProxyInitPollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableFwdAttrInitPolling"));
	dev_prop.push_back(Tango::DbDatum("FwdAttrInitPollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableFormulaAttrUpdatePolling"));
	dev_prop.push_back(Tango::DbDatum("FormulaAttrUpdatePollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableStatusAttrUpdatePolling"));
	dev_prop.push_back(Tango::DbDatum("StatusAttrUpdatePollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableClearTaskPolling"));
	dev_prop.push_back(Tango::DbDatum("ClearTaskPollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableProxyStatusAttrCreation"));
	dev_prop.push_back(Tango::DbDatum("EnableAutoAdminProxyRegistration"));
	dev_prop.push_back(Tango::DbDatum("ProcessEventsInQueueThread"));
	dev_prop.push_back(Tango::DbDatum("SubscribeRetryPeriod"));
	dev_prop.push_back(Tango::DbDatum("StatisticsTimeWindow"));
	dev_prop.push_back(Tango::DbDatum("CheckPeriodicTimeoutDelay"));
	dev_prop.push_back(Tango::DbDatum("PollingThreadPeriod"));
	dev_prop.push_back(Tango::DbDatum("LibConfiguration"));
	dev_prop.push_back(Tango::DbDatum("ContextsList"));
	dev_prop.push_back(Tango::DbDatum("DefaultStrategy"));
	dev_prop.push_back(Tango::DbDatum("AttributeList"));

	//	is there at least one property to be read ?
	if (dev_prop.size()>0)
	{
		//	Call database and extract values
		if (Tango::Util::instance()->_UseDb==true)
			get_db_device()->get_property(dev_prop);
	
		//	get instance on HdbEventSubscriberClass to get class property
		Tango::DbDatum	def_prop, cl_prop;
		HdbEventSubscriberClass	*ds_class =
			(static_cast<HdbEventSubscriberClass *>(get_device_class()));
		int	i = -1;

		//	Try to initialize CentralLoggerEnabledDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  centralLoggerEnabledDefault;
		else {
			//	Try to initialize CentralLoggerEnabledDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  centralLoggerEnabledDefault;
		}
		//	And try to extract CentralLoggerEnabledDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  centralLoggerEnabledDefault;

		//	Try to initialize ElementLoggerEnabledDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  elementLoggerEnabledDefault;
		else {
			//	Try to initialize ElementLoggerEnabledDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  elementLoggerEnabledDefault;
		}
		//	And try to extract ElementLoggerEnabledDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  elementLoggerEnabledDefault;

		//	Try to initialize StorageLoggerEnabledDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  storageLoggerEnabledDefault;
		else {
			//	Try to initialize StorageLoggerEnabledDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  storageLoggerEnabledDefault;
		}
		//	And try to extract StorageLoggerEnabledDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  storageLoggerEnabledDefault;

		//	Try to initialize LoggingTargetCentralDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingTargetCentralDefault;
		else {
			//	Try to initialize LoggingTargetCentralDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingTargetCentralDefault;
		}
		//	And try to extract LoggingTargetCentralDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingTargetCentralDefault;

		//	Try to initialize LoggingTargetElementDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingTargetElementDefault;
		else {
			//	Try to initialize LoggingTargetElementDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingTargetElementDefault;
		}
		//	And try to extract LoggingTargetElementDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingTargetElementDefault;

		//	Try to initialize LoggingTargetStorageDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingTargetStorageDefault;
		else {
			//	Try to initialize LoggingTargetStorageDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingTargetStorageDefault;
		}
		//	And try to extract LoggingTargetStorageDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingTargetStorageDefault;

		//	Try to initialize SkaLevel from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  skaLevel;
		else {
			//	Try to initialize SkaLevel from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  skaLevel;
		}
		//	And try to extract SkaLevel value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  skaLevel;

		//	Try to initialize SyslogFacility from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  syslogFacility;
		else {
			//	Try to initialize SyslogFacility from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  syslogFacility;
		}
		//	And try to extract SyslogFacility value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  syslogFacility;

		//	Try to initialize SyslogHost from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  syslogHost;
		else {
			//	Try to initialize SyslogHost from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  syslogHost;
		}
		//	And try to extract SyslogHost value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  syslogHost;

		//	Try to initialize LoggingLevelCentralDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingLevelCentralDefault;
		else {
			//	Try to initialize LoggingLevelCentralDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingLevelCentralDefault;
		}
		//	And try to extract LoggingLevelCentralDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingLevelCentralDefault;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize LoggingLevelElementDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingLevelElementDefault;
		else {
			//	Try to initialize LoggingLevelElementDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingLevelElementDefault;
		}
		//	And try to extract LoggingLevelElementDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingLevelElementDefault;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize LoggingLevelStorageDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingLevelStorageDefault;
		else {
			//	Try to initialize LoggingLevelStorageDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingLevelStorageDefault;
		}
		//	And try to extract LoggingLevelStorageDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingLevelStorageDefault;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize ConfigFile from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  configFile;
		else {
			//	Try to initialize ConfigFile from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  configFile;
		}
		//	And try to extract ConfigFile value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  configFile;

		//	Try to initialize EnableConfigFromFile from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableConfigFromFile;
		else {
			//	Try to initialize EnableConfigFromFile from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableConfigFromFile;
		}
		//	And try to extract EnableConfigFromFile value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableConfigFromFile;

		//	Try to initialize EnableDynAttrCleanup from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableDynAttrCleanup;
		else {
			//	Try to initialize EnableDynAttrCleanup from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableDynAttrCleanup;
		}
		//	And try to extract EnableDynAttrCleanup value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableDynAttrCleanup;

		//	Try to initialize EnableDynAttrRandomize from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableDynAttrRandomize;
		else {
			//	Try to initialize EnableDynAttrRandomize from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableDynAttrRandomize;
		}
		//	And try to extract EnableDynAttrRandomize value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableDynAttrRandomize;

		//	Try to initialize DynAttrRandomizePeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  dynAttrRandomizePeriod;
		else {
			//	Try to initialize DynAttrRandomizePeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  dynAttrRandomizePeriod;
		}
		//	And try to extract DynAttrRandomizePeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  dynAttrRandomizePeriod;

		//	Try to initialize ProxyDevices from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyDevices;
		else {
			//	Try to initialize ProxyDevices from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyDevices;
		}
		//	And try to extract ProxyDevices value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyDevices;

		//	Try to initialize FormulaVarMaxTimeInterval from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  formulaVarMaxTimeInterval;
		else {
			//	Try to initialize FormulaVarMaxTimeInterval from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  formulaVarMaxTimeInterval;
		}
		//	And try to extract FormulaVarMaxTimeInterval value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  formulaVarMaxTimeInterval;

		//	Try to initialize EnableProxyMonitoring from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableProxyMonitoring;
		else {
			//	Try to initialize EnableProxyMonitoring from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableProxyMonitoring;
		}
		//	And try to extract EnableProxyMonitoring value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableProxyMonitoring;

		//	Try to initialize ProxyMonitoringPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyMonitoringPeriod;
		else {
			//	Try to initialize ProxyMonitoringPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyMonitoringPeriod;
		}
		//	And try to extract ProxyMonitoringPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyMonitoringPeriod;

		//	Try to initialize ProxyStatusAttrPollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyStatusAttrPollPeriod;
		else {
			//	Try to initialize ProxyStatusAttrPollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyStatusAttrPollPeriod;
		}
		//	And try to extract ProxyStatusAttrPollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyStatusAttrPollPeriod;

		//	Try to initialize ProxyStatusAttrPeriodicEventPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyStatusAttrPeriodicEventPeriod;
		else {
			//	Try to initialize ProxyStatusAttrPeriodicEventPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyStatusAttrPeriodicEventPeriod;
		}
		//	And try to extract ProxyStatusAttrPeriodicEventPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyStatusAttrPeriodicEventPeriod;

		//	Try to initialize ProxyStatusAttrArchiveEventPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyStatusAttrArchiveEventPeriod;
		else {
			//	Try to initialize ProxyStatusAttrArchiveEventPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyStatusAttrArchiveEventPeriod;
		}
		//	And try to extract ProxyStatusAttrArchiveEventPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyStatusAttrArchiveEventPeriod;

		//	Try to initialize ProxyTimeout from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyTimeout;
		else {
			//	Try to initialize ProxyTimeout from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyTimeout;
		}
		//	And try to extract ProxyTimeout value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyTimeout;

		//	Try to initialize EventSubscriptions from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  eventSubscriptions;
		else {
			//	Try to initialize EventSubscriptions from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  eventSubscriptions;
		}
		//	And try to extract EventSubscriptions value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  eventSubscriptions;

		//	Try to initialize EventHandlers from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  eventHandlers;
		else {
			//	Try to initialize EventHandlers from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  eventHandlers;
		}
		//	And try to extract EventHandlers value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  eventHandlers;

		//	Try to initialize MaxQueueableTask from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  maxQueueableTask;
		else {
			//	Try to initialize MaxQueueableTask from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  maxQueueableTask;
		}
		//	And try to extract MaxQueueableTask value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  maxQueueableTask;

		//	Try to initialize MaxTrackableTasks from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  maxTrackableTasks;
		else {
			//	Try to initialize MaxTrackableTasks from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  maxTrackableTasks;
		}
		//	And try to extract MaxTrackableTasks value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  maxTrackableTasks;

		//	Try to initialize TaskHistoryTimeDepth from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  taskHistoryTimeDepth;
		else {
			//	Try to initialize TaskHistoryTimeDepth from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  taskHistoryTimeDepth;
		}
		//	And try to extract TaskHistoryTimeDepth value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  taskHistoryTimeDepth;

		//	Try to initialize DefaultTaskTimeout from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  defaultTaskTimeout;
		else {
			//	Try to initialize DefaultTaskTimeout from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  defaultTaskTimeout;
		}
		//	And try to extract DefaultTaskTimeout value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  defaultTaskTimeout;

		//	Try to initialize TaskSequenceStatusAttrList from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  taskSequenceStatusAttrList;
		else {
			//	Try to initialize TaskSequenceStatusAttrList from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  taskSequenceStatusAttrList;
		}
		//	And try to extract TaskSequenceStatusAttrList value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  taskSequenceStatusAttrList;

		//	Try to initialize TaskStatusAttrList from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  taskStatusAttrList;
		else {
			//	Try to initialize TaskStatusAttrList from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  taskStatusAttrList;
		}
		//	And try to extract TaskStatusAttrList value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  taskStatusAttrList;

		//	Try to initialize EnableEventRateMonitoring from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableEventRateMonitoring;
		else {
			//	Try to initialize EnableEventRateMonitoring from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableEventRateMonitoring;
		}
		//	And try to extract EnableEventRateMonitoring value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableEventRateMonitoring;

		//	Try to initialize EnableLoggerInitPolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableLoggerInitPolling;
		else {
			//	Try to initialize EnableLoggerInitPolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableLoggerInitPolling;
		}
		//	And try to extract EnableLoggerInitPolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableLoggerInitPolling;

		//	Try to initialize LoggerInitPollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggerInitPollPeriod;
		else {
			//	Try to initialize LoggerInitPollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggerInitPollPeriod;
		}
		//	And try to extract LoggerInitPollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggerInitPollPeriod;

		//	Try to initialize EnableDevProxyInitPolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableDevProxyInitPolling;
		else {
			//	Try to initialize EnableDevProxyInitPolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableDevProxyInitPolling;
		}
		//	And try to extract EnableDevProxyInitPolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableDevProxyInitPolling;

		//	Try to initialize DevProxyInitPollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  devProxyInitPollPeriod;
		else {
			//	Try to initialize DevProxyInitPollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  devProxyInitPollPeriod;
		}
		//	And try to extract DevProxyInitPollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  devProxyInitPollPeriod;

		//	Try to initialize EnableFwdAttrInitPolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableFwdAttrInitPolling;
		else {
			//	Try to initialize EnableFwdAttrInitPolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableFwdAttrInitPolling;
		}
		//	And try to extract EnableFwdAttrInitPolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableFwdAttrInitPolling;

		//	Try to initialize FwdAttrInitPollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  fwdAttrInitPollPeriod;
		else {
			//	Try to initialize FwdAttrInitPollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  fwdAttrInitPollPeriod;
		}
		//	And try to extract FwdAttrInitPollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  fwdAttrInitPollPeriod;

		//	Try to initialize EnableFormulaAttrUpdatePolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableFormulaAttrUpdatePolling;
		else {
			//	Try to initialize EnableFormulaAttrUpdatePolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableFormulaAttrUpdatePolling;
		}
		//	And try to extract EnableFormulaAttrUpdatePolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableFormulaAttrUpdatePolling;

		//	Try to initialize FormulaAttrUpdatePollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  formulaAttrUpdatePollPeriod;
		else {
			//	Try to initialize FormulaAttrUpdatePollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  formulaAttrUpdatePollPeriod;
		}
		//	And try to extract FormulaAttrUpdatePollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  formulaAttrUpdatePollPeriod;

		//	Try to initialize EnableStatusAttrUpdatePolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableStatusAttrUpdatePolling;
		else {
			//	Try to initialize EnableStatusAttrUpdatePolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableStatusAttrUpdatePolling;
		}
		//	And try to extract EnableStatusAttrUpdatePolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableStatusAttrUpdatePolling;

		//	Try to initialize StatusAttrUpdatePollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  statusAttrUpdatePollPeriod;
		else {
			//	Try to initialize StatusAttrUpdatePollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  statusAttrUpdatePollPeriod;
		}
		//	And try to extract StatusAttrUpdatePollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  statusAttrUpdatePollPeriod;

		//	Try to initialize EnableClearTaskPolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableClearTaskPolling;
		else {
			//	Try to initialize EnableClearTaskPolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableClearTaskPolling;
		}
		//	And try to extract EnableClearTaskPolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableClearTaskPolling;

		//	Try to initialize ClearTaskPollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  clearTaskPollPeriod;
		else {
			//	Try to initialize ClearTaskPollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  clearTaskPollPeriod;
		}
		//	And try to extract ClearTaskPollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  clearTaskPollPeriod;

		//	Try to initialize EnableProxyStatusAttrCreation from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableProxyStatusAttrCreation;
		else {
			//	Try to initialize EnableProxyStatusAttrCreation from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableProxyStatusAttrCreation;
		}
		//	And try to extract EnableProxyStatusAttrCreation value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableProxyStatusAttrCreation;

		//	Try to initialize EnableAutoAdminProxyRegistration from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableAutoAdminProxyRegistration;
		else {
			//	Try to initialize EnableAutoAdminProxyRegistration from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableAutoAdminProxyRegistration;
		}
		//	And try to extract EnableAutoAdminProxyRegistration value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableAutoAdminProxyRegistration;

		//	Try to initialize ProcessEventsInQueueThread from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  processEventsInQueueThread;
		else {
			//	Try to initialize ProcessEventsInQueueThread from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  processEventsInQueueThread;
		}
		//	And try to extract ProcessEventsInQueueThread value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  processEventsInQueueThread;

		//	Try to initialize SubscribeRetryPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  subscribeRetryPeriod;
		else {
			//	Try to initialize SubscribeRetryPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  subscribeRetryPeriod;
		}
		//	And try to extract SubscribeRetryPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  subscribeRetryPeriod;

		//	Try to initialize StatisticsTimeWindow from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  statisticsTimeWindow;
		else {
			//	Try to initialize StatisticsTimeWindow from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  statisticsTimeWindow;
		}
		//	And try to extract StatisticsTimeWindow value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  statisticsTimeWindow;

		//	Try to initialize CheckPeriodicTimeoutDelay from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  checkPeriodicTimeoutDelay;
		else {
			//	Try to initialize CheckPeriodicTimeoutDelay from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  checkPeriodicTimeoutDelay;
		}
		//	And try to extract CheckPeriodicTimeoutDelay value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  checkPeriodicTimeoutDelay;

		//	Try to initialize PollingThreadPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  pollingThreadPeriod;
		else {
			//	Try to initialize PollingThreadPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  pollingThreadPeriod;
		}
		//	And try to extract PollingThreadPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  pollingThreadPeriod;

		//	Try to initialize LibConfiguration from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  libConfiguration;
		else {
			//	Try to initialize LibConfiguration from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  libConfiguration;
		}
		//	And try to extract LibConfiguration value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  libConfiguration;

		//	Try to initialize ContextsList from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  contextsList;
		else {
			//	Try to initialize ContextsList from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  contextsList;
		}
		//	And try to extract ContextsList value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  contextsList;

		//	Try to initialize DefaultStrategy from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  defaultStrategy;
		else {
			//	Try to initialize DefaultStrategy from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  defaultStrategy;
		}
		//	And try to extract DefaultStrategy value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  defaultStrategy;

		//	Try to initialize AttributeList from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  attributeList;
		else {
			//	Try to initialize AttributeList from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  attributeList;
		}
		//	And try to extract AttributeList value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  attributeList;

	}

	/*----- PROTECTED REGION ID(HdbEventSubscriber::get_device_property_after) ENABLED START -----*/
	
	//	Check device property data members init
	//DEBUG_STREAM << "hdbAccessDevice      = " << hdbAccessDevice << endl;
	DEBUG_STREAM << "subscribeRetryPeriod = " << subscribeRetryPeriod << endl;

	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::get_device_property_after
}
//--------------------------------------------------------
/**
 *	Method      : HdbEventSubscriber::check_mandatory_property()
 *	Description : For mandatory properties check if defined in database.
 */
//--------------------------------------------------------
void HdbEventSubscriber::check_mandatory_property(Tango::DbDatum &class_prop, Tango::DbDatum &dev_prop)
{
	//	Check if all properties are empty
	if (class_prop.is_empty() && dev_prop.is_empty())
	{
		TangoSys_OMemStream	tms;
		tms << endl <<"Property \'" << dev_prop.name;
		if (Tango::Util::instance()->_UseDb==true)
			tms << "\' is mandatory but not defined in database";
		else
			tms << "\' is mandatory but cannot be defined without database";
		string	status(get_status());
		status += tms.str();
		set_status(status);
		mandatoryNotDefined = true;
		/*----- PROTECTED REGION ID(HdbEventSubscriber::check_mandatory_property) ENABLED START -----*/
		cerr << tms.str() << " for " << device_name << endl;
		
		/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::check_mandatory_property
	}
}


//--------------------------------------------------------
/**
 *	Method      : HdbEventSubscriber::always_executed_hook()
 *	Description : method always executed before any command is executed
 */
//--------------------------------------------------------
void HdbEventSubscriber::always_executed_hook()
{
	DEBUG_STREAM << "HdbEventSubscriber::always_executed_hook()  " << device_name << endl;
	if (mandatoryNotDefined)
	{
		string	status(get_status());
		Tango::Except::throw_exception(
					(const char *)"PROPERTY_NOT_SET",
					status.c_str(),
					(const char *)"HdbEventSubscriber::always_executed_hook()");
	}
	/*----- PROTECTED REGION ID(HdbEventSubscriber::always_executed_hook) ENABLED START -----*/
	
	//	code always executed before all requests
	//	Do not check state before end ofinitializing phase
	if (initialized)
	{
		Tango::DevState	state = hdb_dev->subcribing_state();
		set_state(state);

		if (state==Tango::ON)
			set_status("Everything is OK");
		else
			set_status("At least, one signal is faulty");
	}

	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::always_executed_hook
}

//--------------------------------------------------------
/**
 *	Method      : HdbEventSubscriber::read_attr_hardware()
 *	Description : Hardware acquisition for attributes
 */
//--------------------------------------------------------
void HdbEventSubscriber::read_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "HdbEventSubscriber::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::read_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::read_attr_hardware
}
//--------------------------------------------------------
/**
 *	Method      : HdbEventSubscriber::write_attr_hardware()
 *	Description : Hardware writing for attributes
 */
//--------------------------------------------------------
void HdbEventSubscriber::write_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "HdbEventSubscriber::write_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::write_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::write_attr_hardware
}

//--------------------------------------------------------
/**
 *	Read attribute AttributeOkNumber related method
 *	Description: Number of archived attributes not in error
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void HdbEventSubscriber::read_AttributeOkNumber(Tango::Attribute &attr)
{
	DEBUG_STREAM << "HdbEventSubscriber::read_AttributeOkNumber(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::read_AttributeOkNumber) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(&hdb_dev->attr_AttributeOkNumber_read);

	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::read_AttributeOkNumber
}
//--------------------------------------------------------
/**
 *	Read attribute AttributeNokNumber related method
 *	Description: Number of archived attributes in error
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void HdbEventSubscriber::read_AttributeNokNumber(Tango::Attribute &attr)
{
	DEBUG_STREAM << "HdbEventSubscriber::read_AttributeNokNumber(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::read_AttributeNokNumber) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(&hdb_dev->attr_AttributeNokNumber_read);

	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::read_AttributeNokNumber
}
//--------------------------------------------------------
/**
 *	Read attribute AttributePendingNumber related method
 *	Description: Number of attributes waiting to be archived
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void HdbEventSubscriber::read_AttributePendingNumber(Tango::Attribute &attr)
{
	DEBUG_STREAM << "HdbEventSubscriber::read_AttributePendingNumber(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::read_AttributePendingNumber) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(&hdb_dev->AttributePendingNumber);
	
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::read_AttributePendingNumber
}
//--------------------------------------------------------
/**
 *	Read attribute AttributeNumber related method
 *	Description: Number of configured attributes
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void HdbEventSubscriber::read_AttributeNumber(Tango::Attribute &attr)
{
	DEBUG_STREAM << "HdbEventSubscriber::read_AttributeNumber(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::read_AttributeNumber) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(&hdb_dev->attr_AttributeNumber_read);
	
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::read_AttributeNumber
}
//--------------------------------------------------------
/**
 *	Read attribute AttributeMaxStoreTime related method
 *	Description: Maximum storing time
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void HdbEventSubscriber::read_AttributeMaxStoreTime(Tango::Attribute &attr)
{
	DEBUG_STREAM << "HdbEventSubscriber::read_AttributeMaxStoreTime(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::read_AttributeMaxStoreTime) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(&hdb_dev->attr_AttributeMaxStoreTime_read);
	
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::read_AttributeMaxStoreTime
}
//--------------------------------------------------------
/**
 *	Read attribute AttributeMinStoreTime related method
 *	Description: Minimum storing time
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void HdbEventSubscriber::read_AttributeMinStoreTime(Tango::Attribute &attr)
{
	DEBUG_STREAM << "HdbEventSubscriber::read_AttributeMinStoreTime(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::read_AttributeMinStoreTime) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(&hdb_dev->attr_AttributeMinStoreTime_read);
	
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::read_AttributeMinStoreTime
}
//--------------------------------------------------------
/**
 *	Read attribute AttributeMaxProcessingTime related method
 *	Description: Maximum processing (from event reception to storage) time
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void HdbEventSubscriber::read_AttributeMaxProcessingTime(Tango::Attribute &attr)
{
	DEBUG_STREAM << "HdbEventSubscriber::read_AttributeMaxProcessingTime(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::read_AttributeMaxProcessingTime) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(&hdb_dev->attr_AttributeMaxProcessingTime_read);
	
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::read_AttributeMaxProcessingTime
}
//--------------------------------------------------------
/**
 *	Read attribute AttributeMinProcessingTime related method
 *	Description: Minimum processing (from event reception to storage) time
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void HdbEventSubscriber::read_AttributeMinProcessingTime(Tango::Attribute &attr)
{
	DEBUG_STREAM << "HdbEventSubscriber::read_AttributeMinProcessingTime(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::read_AttributeMinProcessingTime) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(&hdb_dev->attr_AttributeMinProcessingTime_read);
	
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::read_AttributeMinProcessingTime
}
//--------------------------------------------------------
/**
 *	Read attribute AttributeRecordFreq related method
 *	Description: Record frequency
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void HdbEventSubscriber::read_AttributeRecordFreq(Tango::Attribute &attr)
{
	DEBUG_STREAM << "HdbEventSubscriber::read_AttributeRecordFreq(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::read_AttributeRecordFreq) ENABLED START -----*/
	//	Set the attribute value
	if(*attr_AttributeRecordFreq_read == -1)
		attr.set_quality(Tango::ATTR_INVALID);
	else
		attr.set_value_date_quality(attr_AttributeRecordFreq_read, hdb_dev->stats_thread->last_stat, Tango::ATTR_VALID);
	
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::read_AttributeRecordFreq
}
//--------------------------------------------------------
/**
 *	Read attribute AttributeFailureFreq related method
 *	Description: Failure frequency
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void HdbEventSubscriber::read_AttributeFailureFreq(Tango::Attribute &attr)
{
	DEBUG_STREAM << "HdbEventSubscriber::read_AttributeFailureFreq(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::read_AttributeFailureFreq) ENABLED START -----*/
	//	Set the attribute value
	if(*attr_AttributeFailureFreq_read == -1)
		attr.set_quality(Tango::ATTR_INVALID);
	else
		attr.set_value_date_quality(attr_AttributeFailureFreq_read, hdb_dev->stats_thread->last_stat, Tango::ATTR_VALID);
	
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::read_AttributeFailureFreq
}
//--------------------------------------------------------
/**
 *	Read attribute AttributeStartedNumber related method
 *	Description: Number of archived attributes started
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void HdbEventSubscriber::read_AttributeStartedNumber(Tango::Attribute &attr)
{
	DEBUG_STREAM << "HdbEventSubscriber::read_AttributeStartedNumber(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::read_AttributeStartedNumber) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(&hdb_dev->attr_AttributeStartedNumber_read);
	
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::read_AttributeStartedNumber
}
//--------------------------------------------------------
/**
 *	Read attribute AttributeStoppedNumber related method
 *	Description: Number of archived attributes stopped
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void HdbEventSubscriber::read_AttributeStoppedNumber(Tango::Attribute &attr)
{
	DEBUG_STREAM << "HdbEventSubscriber::read_AttributeStoppedNumber(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::read_AttributeStoppedNumber) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(&hdb_dev->attr_AttributeStoppedNumber_read);
	
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::read_AttributeStoppedNumber
}
//--------------------------------------------------------
/**
 *	Read attribute AttributeMaxPendingNumber related method
 *	Description: Max number of attributes waiting to be archived
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void HdbEventSubscriber::read_AttributeMaxPendingNumber(Tango::Attribute &attr)
{
	DEBUG_STREAM << "HdbEventSubscriber::read_AttributeMaxPendingNumber(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::read_AttributeMaxPendingNumber) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(&hdb_dev->AttributeMaxPendingNumber);
	
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::read_AttributeMaxPendingNumber
}
//--------------------------------------------------------
/**
 *	Read attribute StatisticsResetTime related method
 *	Description: Seconds elapsed since the last statistics reset
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void HdbEventSubscriber::read_StatisticsResetTime(Tango::Attribute &attr)
{
	DEBUG_STREAM << "HdbEventSubscriber::read_StatisticsResetTime(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::read_StatisticsResetTime) ENABLED START -----*/
	//	Set the attribute value
	timespec now;
	clock_gettime(CLOCK_MONOTONIC, &now);
	double dnow = (now.tv_sec) + ((double)(now.tv_nsec))/1000000000;
	*attr_StatisticsResetTime_read = dnow - last_statistics_reset_time;
	//	Set the attribute value
	attr.set_value(attr_StatisticsResetTime_read);
	
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::read_StatisticsResetTime
}
//--------------------------------------------------------
/**
 *	Read attribute AttributePausedNumber related method
 *	Description: Number of archived attributes paused
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void HdbEventSubscriber::read_AttributePausedNumber(Tango::Attribute &attr)
{
	DEBUG_STREAM << "HdbEventSubscriber::read_AttributePausedNumber(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::read_AttributePausedNumber) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(&hdb_dev->attr_AttributePausedNumber_read);
	
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::read_AttributePausedNumber
}
//--------------------------------------------------------
/**
 *	Read attribute Context related method
 *	Description: 
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void HdbEventSubscriber::read_Context(Tango::Attribute &attr)
{
	DEBUG_STREAM << "HdbEventSubscriber::read_Context(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::read_Context) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_Context_read);
	
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::read_Context
}
//--------------------------------------------------------
/**
 *	Write attribute Context related method
 *	Description: 
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void HdbEventSubscriber::write_Context(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "HdbEventSubscriber::write_Context(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevString	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(HdbEventSubscriber::write_Context) ENABLED START -----*/
	string argin(w_val);
	string argin_upper(w_val);
	std::transform(argin_upper.begin(), argin_upper.end(), argin_upper.begin(), (int(*)(int))toupper);		//transform to uppercase
	map<string, string>::iterator itmap = hdb_dev->contexts_map_upper.find(argin_upper);
	if(itmap == hdb_dev->contexts_map_upper.end())
	{
		Tango::Except::throw_exception(
					(const char *)"BadContext",
					"Context " + argin + " NOT DEFINED",
					(const char *)__func__);
	}
	context_set = itmap->first;
	context_read = itmap->second.c_str();
	*attr_Context_read = const_cast<char*>(context_read.c_str());
	
	vector<string> att_list_tmp;
	hdb_dev->get_sig_list(att_list_tmp);
	for (unsigned int i=0 ; i<att_list_tmp.size() ; i++)
	{
		bool is_current_context;
		try
		{
			hdb_dev->shared->veclock.readerIn();
			is_current_context = hdb_dev->shared->is_current_context(att_list_tmp[i], context_set);
			DEBUG_STREAM << "HdbEventSubscriber::write_Context="<<context_set<<" : " << att_list_tmp[i] << " is_current_context=" << (is_current_context ? "Y" : "N") << endl;
			hdb_dev->shared->veclock.readerOut();
		}
		catch(Tango::DevFailed &e)
		{
			hdb_dev->shared->veclock.readerOut();
			INFO_STREAM << __func__ << ": Failed to check is_current_context for " << att_list_tmp[i];
			Tango::Except::re_throw_exception(e,
						(const char *)"BadSignalName",
						"Signal " + att_list_tmp[i] + " NOT subscribed",
						(const char *)__func__);
		}
		if(is_current_context)
			attribute_start((Tango::DevString)att_list_tmp[i].c_str());
		else
			attribute_stop((Tango::DevString)att_list_tmp[i].c_str());
	}
	
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::write_Context
}
//--------------------------------------------------------
/**
 *	Read attribute AttributeList related method
 *	Description: Returns the configured attribute list
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 10000
 */
//--------------------------------------------------------
void HdbEventSubscriber::read_AttributeList(Tango::Attribute &attr)
{
	DEBUG_STREAM << "HdbEventSubscriber::read_AttributeList(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::read_AttributeList) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(hdb_dev->attr_AttributeList_read, hdb_dev->attribute_list_str_size);
	
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::read_AttributeList
}
//--------------------------------------------------------
/**
 *	Read attribute AttributeOkList related method
 *	Description: Returns the attributes not on error list
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 10000
 */
//--------------------------------------------------------
void HdbEventSubscriber::read_AttributeOkList(Tango::Attribute &attr)
{
	DEBUG_STREAM << "HdbEventSubscriber::read_AttributeOkList(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::read_AttributeOkList) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(hdb_dev->attr_AttributeOkList_read, hdb_dev->attribute_ok_list_str_size);

	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::read_AttributeOkList
}
//--------------------------------------------------------
/**
 *	Read attribute AttributeNokList related method
 *	Description: Returns the attributes on error list
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 10000
 */
//--------------------------------------------------------
void HdbEventSubscriber::read_AttributeNokList(Tango::Attribute &attr)
{
	DEBUG_STREAM << "HdbEventSubscriber::read_AttributeNokList(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::read_AttributeNokList) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(hdb_dev->attr_AttributeNokList_read, hdb_dev->attribute_nok_list_str_size);
	
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::read_AttributeNokList
}
//--------------------------------------------------------
/**
 *	Read attribute AttributePendingList related method
 *	Description: Returns the list attributes waiting to be archived
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 10000
 */
//--------------------------------------------------------
void HdbEventSubscriber::read_AttributePendingList(Tango::Attribute &attr)
{
	DEBUG_STREAM << "HdbEventSubscriber::read_AttributePendingList(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::read_AttributePendingList) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(hdb_dev->attr_AttributePendingList_read, hdb_dev->attribute_pending_list_str_size);
	
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::read_AttributePendingList
}
//--------------------------------------------------------
/**
 *	Read attribute AttributeRecordFreqList related method
 *	Description: Returns the list of record frequencies
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Spectrum max = 10000
 */
//--------------------------------------------------------
void HdbEventSubscriber::read_AttributeRecordFreqList(Tango::Attribute &attr)
{
	DEBUG_STREAM << "HdbEventSubscriber::read_AttributeRecordFreqList(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::read_AttributeRecordFreqList) ENABLED START -----*/
	//	Set the attribute value
	if(*attr_AttributeRecordFreq_read == -1)
		attr.set_quality(Tango::ATTR_INVALID);
	//	Set the attribute value
	attr.set_value_date_quality(attr_AttributeRecordFreqList_read, hdb_dev->stats_thread->last_stat, Tango::ATTR_VALID, hdb_dev->attr_AttributeNumber_read);
	
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::read_AttributeRecordFreqList
}
//--------------------------------------------------------
/**
 *	Read attribute AttributeFailureFreqList related method
 *	Description: Returns the list of failure frequencies
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Spectrum max = 10000
 */
//--------------------------------------------------------
void HdbEventSubscriber::read_AttributeFailureFreqList(Tango::Attribute &attr)
{
	DEBUG_STREAM << "HdbEventSubscriber::read_AttributeFailureFreqList(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::read_AttributeFailureFreqList) ENABLED START -----*/
	//	Set the attribute value
	if(*attr_AttributeFailureFreq_read == -1)
		attr.set_quality(Tango::ATTR_INVALID);
	//	Set the attribute value
	attr.set_value_date_quality(attr_AttributeFailureFreqList_read, hdb_dev->stats_thread->last_stat, Tango::ATTR_VALID, hdb_dev->attr_AttributeNumber_read);
	
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::read_AttributeFailureFreqList
}
//--------------------------------------------------------
/**
 *	Read attribute AttributeStartedList related method
 *	Description: Returns the attributes started list
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 10000
 */
//--------------------------------------------------------
void HdbEventSubscriber::read_AttributeStartedList(Tango::Attribute &attr)
{
	DEBUG_STREAM << "HdbEventSubscriber::read_AttributeStartedList(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::read_AttributeStartedList) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(hdb_dev->attr_AttributeStartedList_read, hdb_dev->attribute_started_list_str_size);
	
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::read_AttributeStartedList
}
//--------------------------------------------------------
/**
 *	Read attribute AttributeStoppedList related method
 *	Description: Returns the attributes stopped list
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 10000
 */
//--------------------------------------------------------
void HdbEventSubscriber::read_AttributeStoppedList(Tango::Attribute &attr)
{
	DEBUG_STREAM << "HdbEventSubscriber::read_AttributeStoppedList(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::read_AttributeStoppedList) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(hdb_dev->attr_AttributeStoppedList_read, hdb_dev->attribute_stopped_list_str_size);
	
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::read_AttributeStoppedList
}
//--------------------------------------------------------
/**
 *	Read attribute AttributeEventNumberList related method
 *	Description: Returns the list of numbers of events received
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Spectrum max = 10000
 */
//--------------------------------------------------------
void HdbEventSubscriber::read_AttributeEventNumberList(Tango::Attribute &attr)
{
	DEBUG_STREAM << "HdbEventSubscriber::read_AttributeEventNumberList(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::read_AttributeEventNumberList) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_AttributeEventNumberList_read, hdb_dev->attr_AttributeNumber_read);
	
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::read_AttributeEventNumberList
}
//--------------------------------------------------------
/**
 *	Read attribute AttributeErrorList related method
 *	Description: Returns the list of attribute errors
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 10000
 */
//--------------------------------------------------------
void HdbEventSubscriber::read_AttributeErrorList(Tango::Attribute &attr)
{
	DEBUG_STREAM << "HdbEventSubscriber::read_AttributeErrorList(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::read_AttributeErrorList) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(hdb_dev->attr_AttributeErrorList_read, hdb_dev->attribute_error_list_str_size);
	
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::read_AttributeErrorList
}
//--------------------------------------------------------
/**
 *	Read attribute AttributePausedList related method
 *	Description: Returns the attributes stopped list
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 10000
 */
//--------------------------------------------------------
void HdbEventSubscriber::read_AttributePausedList(Tango::Attribute &attr)
{
	DEBUG_STREAM << "HdbEventSubscriber::read_AttributePausedList(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::read_AttributePausedList) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(hdb_dev->attr_AttributePausedList_read, hdb_dev->attribute_paused_list_str_size);
	
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::read_AttributePausedList
}
//--------------------------------------------------------
/**
 *	Read attribute AttributeStrategyList related method
 *	Description: Returns the list of attribute strategy
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 10000
 */
//--------------------------------------------------------
void HdbEventSubscriber::read_AttributeStrategyList(Tango::Attribute &attr)
{
	DEBUG_STREAM << "HdbEventSubscriber::read_AttributeStrategyList(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::read_AttributeStrategyList) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(hdb_dev->attr_AttributeContextList_read, hdb_dev->attribute_context_list_str_size);
	
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::read_AttributeStrategyList
}
//--------------------------------------------------------
/**
 *	Read attribute ContextsList related method
 *	Description: 
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 1000
 */
//--------------------------------------------------------
void HdbEventSubscriber::read_ContextsList(Tango::Attribute &attr)
{
	DEBUG_STREAM << "HdbEventSubscriber::read_ContextsList(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::read_ContextsList) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_ContextsList_read, contextsList.size());
	
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::read_ContextsList
}
//--------------------------------------------------------
/**
 *	Read attribute AttributeTTLList related method
 *	Description: Returns the list of attribute strategy
 *
 *	Data type:	Tango::DevULong
 *	Attr type:	Spectrum max = 10000
 */
//--------------------------------------------------------
void HdbEventSubscriber::read_AttributeTTLList(Tango::Attribute &attr)
{
	DEBUG_STREAM << "HdbEventSubscriber::read_AttributeTTLList(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::read_AttributeTTLList) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(hdb_dev->attr_AttributeTTLList_read, hdb_dev->attr_AttributeNumber_read);
	
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::read_AttributeTTLList
}

//--------------------------------------------------------
/**
 *	Method      : HdbEventSubscriber::add_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *                for specified device.
 */
//--------------------------------------------------------
void HdbEventSubscriber::add_dynamic_attributes()
{
	/*----- PROTECTED REGION ID(HdbEventSubscriber::add_dynamic_attributes) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic attributes if any
	LMCDevice::add_dynamic_attributes();

	/*
	//Add dynamic attributes from config file
	if(AddDynAttrs()<0){
		std::string errMsg("Failed to create dyn attributes!");
		_ERROR_LOG(errMsg);
		set_status(errMsg.c_str());
		set_state(Tango::FAULT);
		return;
	}
	
	//Configure state machine for cmd & attrs
	if(InitCmdAttrStateMachine()<0){
		std::string errMsg("Failed to create cmd & attr state machines for dyn attributes!");
		_ERROR_LOG(errMsg);
		set_status(errMsg.c_str());
		set_state(Tango::FAULT);
		return;
	}	
	*/

	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::add_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Command AttributeAdd related method
 *	Description: Add a new attribute to archive in HDB.
 *
 *	@param argin Attribute name, strategy, ttl
 */
//--------------------------------------------------------
void HdbEventSubscriber::attribute_add(const Tango::DevVarStringArray *argin)
{
	DEBUG_STREAM << "HdbEventSubscriber::AttributeAdd()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::attribute_add) ENABLED START -----*/
	
	//	Add your own code
	string	signame;
	vector<string> contexts;
	Tango::DevULong ttl=DEFAULT_TTL;
	bool context_error = false;
	string requested_strategy("");
	string applied_strategy("");
	if(argin->length() > 0)
	{
		signame = string((*argin)[0]);
	}

	if(argin->length() > 1)
	{
		string context((*argin)[1]);
		if(context.length() > 0)
		{
			requested_strategy += context;

			vector<string> res;
			hdb_dev->string_explode(context, "|", &res);
			for(vector<string>::iterator its=res.begin(); its!=res.end(); its++)
			{
				string context_upper(*its);
				std::transform(context_upper.begin(), context_upper.end(), context_upper.begin(), (int(*)(int))toupper);		//transform to uppercase
				map<string, string>::iterator it = hdb_dev->contexts_map_upper.find(context_upper);
				if(it == hdb_dev->contexts_map_upper.end())
				{
					context_error = true;
				}
				else
				{
					contexts.push_back(it->second);
				}
			}
		}
	}
	if(contexts.size()==0)
		contexts.push_back(defaultStrategy);
	if(argin->length() > 2)
	{
		string s_ttl((*argin)[2]);
		try
		{
			stringstream val;
			val << s_ttl;
			val >> ttl;
		}
		catch(...)
		{
			DEBUG_STREAM << __func__ << ": error extracting ttl from '" << s_ttl << "'";
		}
	}

	hdb_dev->add(signame, contexts, ttl);
    
	// since ttl is a parameter to this function, we should also
	// update this value inside the subscriber and database
	hdb_dev->updatettl(signame, ttl);

	bool is_current_context;
	try
	{
		hdb_dev->shared->veclock.readerIn();
		is_current_context = hdb_dev->shared->is_current_context(signame, context_set);
		hdb_dev->shared->veclock.readerOut();
	}
	catch(Tango::DevFailed &e)
	{
		hdb_dev->shared->veclock.readerOut();
		INFO_STREAM << __func__ << ": Failed to check is_current_context for " << signame;
		Tango::Except::re_throw_exception(e,
					(const char *)"BadSignalName",
					"Signal " + signame + " NOT subscribed",
					(const char *)__func__);
	}
	if(is_current_context)
		attribute_start((Tango::DevString)signame.c_str());
	else
		attribute_stop((Tango::DevString)signame.c_str());

	if(context_error)
	{
		for(vector<string>::iterator its=contexts.begin(); its!=contexts.end(); its++)
		{
			applied_strategy += *its;
			if(its != contexts.end()-1)
				applied_strategy += string("|");
		}
		Tango::Except::throw_exception(
			(const char *)"BadStrategy",
				"Requested strategy: " + requested_strategy + "\nApplied strategy: " + applied_strategy,
				(const char *)__func__);
	}
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::attribute_add
}
//--------------------------------------------------------
/**
 *	Command AttributeRemove related method
 *	Description: Remove attribute from configuration.
 *
 *	@param argin Attribute name
 */
//--------------------------------------------------------
void HdbEventSubscriber::attribute_remove(Tango::DevString argin)
{
	DEBUG_STREAM << "HdbEventSubscriber::AttributeRemove()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::attribute_remove) ENABLED START -----*/
	
	//	Add your own code
	string	signame(argin);
	hdb_dev->fix_tango_host(signame);

	bool is_running;
	bool is_paused;
	try
	{
		hdb_dev->shared->veclock.readerIn();
		is_running = hdb_dev->shared->is_running(signame);
		is_paused = hdb_dev->shared->is_paused(signame);
		hdb_dev->shared->veclock.readerOut();
	}
	catch(Tango::DevFailed &e)
	{
		hdb_dev->shared->veclock.readerOut();
		INFO_STREAM << __func__ << ": Failed to check is_running or is_paused for " << signame;
		Tango::Except::re_throw_exception(e,
					(const char *)"BadSignalName",
					"Signal " + signame + " NOT subscribed",
					(const char *)__func__);
	}
	if(is_running || is_paused)
	{
		hdb_dev->shared->stop(signame);
		hdb_dev->push_shared->stop_attr(signame);
	}
	hdb_dev->remove(signame);
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::attribute_remove
}
//--------------------------------------------------------
/**
 *	Command AttributeStatus related method
 *	Description: Read a attribute status.
 *
 *	@param argin The attribute name
 *	@returns The attribute status.
 */
//--------------------------------------------------------
Tango::DevString HdbEventSubscriber::attribute_status(Tango::DevString argin)
{
	Tango::DevString argout;
	DEBUG_STREAM << "HdbEventSubscriber::AttributeStatus()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::attribute_status) ENABLED START -----*/
	
	//	Add your own code
	//	Add your own code
	struct timeval tv;
	struct tm *nowtm;
	char buf[64];
	size_t strfret;

	time_t nowtime;
	string	signame(argin);
	hdb_dev->fix_tango_host(signame);

	stringstream attr_status;
	attr_status << "Event status       : "<<hdb_dev->get_sig_status(signame);
	attr_status << endl;
	attr_status << "Events engine      : "<<(hdb_dev->shared->get_sig_source(signame) ? "ZMQ" : "Notifd");
	attr_status << endl;
	bool is_running;
	bool is_paused;
	try
	{
		hdb_dev->shared->veclock.readerIn();
		is_running = hdb_dev->shared->is_running(signame);
		is_paused = hdb_dev->shared->is_paused(signame);
		attr_status << "Archiving          : "<<((is_running && !is_paused) ? "Started" : (is_paused ? "Paused" : "Stopped"));
		hdb_dev->shared->veclock.readerOut();
	}
	catch(Tango::DevFailed &e)
	{
		hdb_dev->shared->veclock.readerOut();
		INFO_STREAM << __func__ << ": Failed to check is_running or is_paused for " << signame;
		Tango::Except::re_throw_exception(e,
					(const char *)"BadSignalName",
					"Signal " + signame + " NOT subscribed",
					(const char *)__func__);
	}
	attr_status << endl;

	tv = hdb_dev->shared->get_last_okev(signame);
	nowtime = tv.tv_sec;
	nowtm = localtime(&nowtime);
	uint32_t ok_ev = hdb_dev->shared->get_ok_event(signame);
	if(ok_ev != 0)
	{
		memset(buf, 0,  sizeof(buf));
		strfret = strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", nowtm);
		snprintf(&buf[strfret], sizeof(buf)-strfret, ".%06ld", tv.tv_usec);
	}
	else
	{
		strcpy(buf,"YYYY-MM-DD HH:MM:SS.UUUUUU");
	}
	attr_status << "Event OK counter   : "<<ok_ev<<" - "<<buf;
	attr_status << endl;

	tv = hdb_dev->shared->get_last_nokev(signame);
	nowtime = tv.tv_sec;
	nowtm = localtime(&nowtime);
	uint32_t nok_ev = hdb_dev->shared->get_nok_event(signame);
	if(nok_ev != 0)
	{
		memset(buf, 0,  sizeof(buf));
		strfret = strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", nowtm);
		snprintf(&buf[strfret], sizeof(buf)-strfret, ".%06ld", tv.tv_usec);
	}
	else
	{
		strcpy(buf,"YYYY-MM-DD HH:MM:SS.UUUUUU");
	}
	attr_status << "Event NOK counter  : "<<nok_ev<<" - "<<buf;
	attr_status << endl;

	tv = hdb_dev->push_shared->get_last_nokdb(signame);
	nowtime = tv.tv_sec;
	nowtm = localtime(&nowtime);
	uint32_t nok_db = hdb_dev->push_shared->get_nok_db(signame);
	if(nok_db != 0)
	{
		memset(buf, 0,  sizeof(buf));
		strfret = strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", nowtm);
		snprintf(&buf[strfret], sizeof(buf)-strfret, ".%06ld", tv.tv_usec);
	}
	else
	{
		strcpy(buf,"YYYY-MM-DD HH:MM:SS.UUUUUU");
	}
	attr_status << "DB ERRORS counter  : "<<nok_db<<" - "<<buf;
	attr_status << endl;

	attr_status << "Storing time AVG   : "<<fixed<<hdb_dev->push_shared->get_avg_store_time(signame)<<"s";
	attr_status << endl;
	attr_status << "Processing time AVG: "<<fixed<<hdb_dev->push_shared->get_avg_process_time(signame)<<"s";
	argout  = new char[attr_status.str().length()+1];
	strcpy(argout, attr_status.str().c_str());

/*
	vector<string>	names   = hdb_dev->shared->get_sig_list();
	vector<bool>	sources = hdb_dev->shared->get_sig_source_list();	//1=ZMQ, 0=notifd
	argout = new Tango::DevVarLongStringArray();
	argout->svalue.length(names.size());
	argout->lvalue.length(names.size());
	for (unsigned int i=0 ; i<names.size() ; i++)
	{
		argout->svalue[i] = CORBA::string_dup(names[i].c_str());
		argout->lvalue[i] = sources[i];
	}
 */
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::attribute_status
	return argout;
}
//--------------------------------------------------------
/**
 *	Command Start related method
 *	Description: Start archiving
 *
 */
//--------------------------------------------------------
void HdbEventSubscriber::start()
{
	DEBUG_STREAM << "HdbEventSubscriber::Start()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::start) ENABLED START -----*/
	
	//	Add your own code
	vector<string> att_list_tmp;
	hdb_dev->get_sig_list(att_list_tmp);
	for (unsigned int i=0 ; i<att_list_tmp.size() ; i++)
	{
		bool is_current_context = false;
		try
		{
			hdb_dev->shared->veclock.readerIn();
			is_current_context = hdb_dev->shared->is_current_context(att_list_tmp[i], context_set);
			DEBUG_STREAM << "HdbEventSubscriber::start="<<context_set<<" : " << att_list_tmp[i] << " is_current_context=" << (is_current_context ? "Y" : "N") << endl;
			hdb_dev->shared->veclock.readerOut();
		}
		catch(Tango::DevFailed &e)
		{
			hdb_dev->shared->veclock.readerOut();
			INFO_STREAM << __func__ << ": Failed to check is_current_context for " << att_list_tmp[i];
			Tango::Except::re_throw_exception(e,
						(const char *)"BadSignalName",
						"Signal " + att_list_tmp[i] + " NOT subscribed",
						(const char *)__func__);
		}
		if(is_current_context)
			attribute_start((Tango::DevString)att_list_tmp[i].c_str());
	}
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::start
}
//--------------------------------------------------------
/**
 *	Command Stop related method
 *	Description: Stop archiving
 *
 */
//--------------------------------------------------------
void HdbEventSubscriber::stop()
{
	DEBUG_STREAM << "HdbEventSubscriber::Stop()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::stop) ENABLED START -----*/
	
	//	Add your own code
	#if 0
	hdb_dev->shared->stop_all();
	hdb_dev->push_shared->stop_all();
#else
	vector<string> att_list_tmp;
	hdb_dev->get_sig_list(att_list_tmp);
	for (unsigned int i=0 ; i<att_list_tmp.size() ; i++)
		attribute_stop((Tango::DevString)att_list_tmp[i].c_str());
#endif
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::stop
}
//--------------------------------------------------------
/**
 *	Command AttributeStart related method
 *	Description: Start archiving single attribute
 *
 *	@param argin Attribute name
 */
//--------------------------------------------------------
void HdbEventSubscriber::attribute_start(Tango::DevString argin)
{
	DEBUG_STREAM << "HdbEventSubscriber::AttributeStart()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::attribute_start) ENABLED START -----*/
	
	//	Add your own code
	string	signame(argin);
	hdb_dev->fix_tango_host(signame);
	bool is_paused;
	bool is_stopped;
	try
	{
		hdb_dev->shared->veclock.readerIn();
		is_paused = hdb_dev->shared->is_paused(signame);
		is_stopped = hdb_dev->shared->is_stopped(signame);
		hdb_dev->shared->veclock.readerOut();
	}
	catch(Tango::DevFailed &e)
	{
		hdb_dev->shared->veclock.readerOut();
		INFO_STREAM << __func__ << ": Failed to check is_stopped or is_paused for " << signame;
		Tango::Except::re_throw_exception(e,
					(const char *)"BadSignalName",
					"Signal " + signame + " NOT subscribed",
					(const char *)__func__);
	}
	if(is_paused || is_stopped)
	{
		hdb_dev->push_shared->start_attr(signame);
		hdb_dev->shared->start(signame);
	}
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::attribute_start
}
//--------------------------------------------------------
/**
 *	Command AttributeStop related method
 *	Description: Stop archiving single attribute
 *
 *	@param argin 
 */
//--------------------------------------------------------
void HdbEventSubscriber::attribute_stop(Tango::DevString argin)
{
	DEBUG_STREAM << "HdbEventSubscriber::AttributeStop()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::attribute_stop) ENABLED START -----*/
	
	//	Add your own code
	string	signame(argin);
	hdb_dev->fix_tango_host(signame);
	bool is_running;
	bool is_paused;
	try
	{
		hdb_dev->shared->veclock.readerIn();
		is_running = hdb_dev->shared->is_running(signame);
		is_paused = hdb_dev->shared->is_paused(signame);
		hdb_dev->shared->veclock.readerOut();
	}
	catch(Tango::DevFailed &e)
	{
		hdb_dev->shared->veclock.readerOut();
		INFO_STREAM << __func__ << ": Failed to check is_running or is_paused for " << signame;
		Tango::Except::re_throw_exception(e,
					(const char *)"BadSignalName",
					"Signal " + signame + " NOT subscribed",
					(const char *)__func__);
	}
	if(is_running || is_paused)
	{
		hdb_dev->shared->stop(signame);
		hdb_dev->push_shared->stop_attr(signame);
	}
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::attribute_stop
}
//--------------------------------------------------------
/**
 *	Command ResetStatistics related method
 *	Description: Reset statistic counters
 *
 */
//--------------------------------------------------------
void HdbEventSubscriber::reset_statistics()
{
	DEBUG_STREAM << "HdbEventSubscriber::ResetStatistics()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::reset_statistics) ENABLED START -----*/
	
	//	Add your own code
	hdb_dev->reset_statistics();
	timespec now;
	clock_gettime(CLOCK_MONOTONIC, &now);
	double dnow = (now.tv_sec) + ((double)(now.tv_nsec))/1000000000;
	last_statistics_reset_time = dnow;
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::reset_statistics
}
//--------------------------------------------------------
/**
 *	Command Pause related method
 *	Description: Pause archiving
 *
 */
//--------------------------------------------------------
void HdbEventSubscriber::pause()
{
	DEBUG_STREAM << "HdbEventSubscriber::Pause()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::pause) ENABLED START -----*/
	
	//	Add your own code
	#if 0
	hdb_dev->shared->pause_all();
	hdb_dev->push_shared->pause_all();
#else
	vector<string> att_list_tmp;
	hdb_dev->get_sig_list(att_list_tmp);
	for (unsigned int i=0 ; i<att_list_tmp.size() ; i++)
	{
		bool is_running;
		try
		{
			hdb_dev->shared->veclock.readerIn();
			is_running = hdb_dev->shared->is_running(att_list_tmp[i]);
			hdb_dev->shared->veclock.readerOut();
		}
		catch(Tango::DevFailed &e)
		{
			hdb_dev->shared->veclock.readerOut();
			INFO_STREAM << __func__ << ": Failed to check is_running for " << att_list_tmp[i];
			continue;
		}
		if(is_running)
		{
			try
			{
				attribute_pause((Tango::DevString)att_list_tmp[i].c_str());
			}
			catch(Tango::DevFailed &e)
			{}
		}
	}
#endif
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::pause
}
//--------------------------------------------------------
/**
 *	Command AttributePause related method
 *	Description: Pause archiving single attribute
 *
 *	@param argin Attribute name
 */
//--------------------------------------------------------
void HdbEventSubscriber::attribute_pause(Tango::DevString argin)
{
	DEBUG_STREAM << "HdbEventSubscriber::AttributePause()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::attribute_pause) ENABLED START -----*/
	
	//	Add your own code
	string	signame(argin);
	hdb_dev->fix_tango_host(signame);
	bool is_running;
	try
	{
		hdb_dev->shared->veclock.readerIn();
		is_running = hdb_dev->shared->is_running(signame);
		hdb_dev->shared->veclock.readerOut();
	}
	catch(Tango::DevFailed &e)
	{
		hdb_dev->shared->veclock.readerOut();
		INFO_STREAM << __func__ << ": Failed to check is_running for " << signame;
		Tango::Except::re_throw_exception(e,
					(const char *)"BadSignalName",
					"Signal " + signame + " NOT subscribed",
					(const char *)__func__);
	}
	if(is_running)
	{
		hdb_dev->shared->pause(signame);
		hdb_dev->push_shared->pause_attr(signame);
	}
	else
	{
		Tango::Except::throw_exception(
					(const char *)"Not started",
					"Signal " + signame + " NOT started",
					(const char *)"attribute_pause");
	}
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::attribute_pause
}
//--------------------------------------------------------
/**
 *	Command SetAttributeStrategy related method
 *	Description: Update strategy associated to an already archived attribute.
 *
 *	@param argin Attribute name, strategy
 */
//--------------------------------------------------------
void HdbEventSubscriber::set_attribute_strategy(const Tango::DevVarStringArray *argin)
{
	DEBUG_STREAM << "HdbEventSubscriber::SetAttributeStrategy()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::set_attribute_strategy) ENABLED START -----*/
	
	//	Add your own code
	string	signame;
	vector<string> contexts;
	bool context_error = false;
	string requested_strategy("");
	string applied_strategy("");
	if(argin->length() > 0)
	{
		signame = string((*argin)[0]);
	}
	for(size_t i = 0; i < argin->length() -1; i++)
	{
		string context((*argin)[i+1]);
		if(context.length() > 0)
		{
			requested_strategy += context;
			if(i != argin->length() -2)
				requested_strategy += string("|");
			vector<string> res;
			hdb_dev->string_explode(context, "|", &res);

			for(vector<string>::iterator its=res.begin(); its!=res.end(); its++)
			{
				string context_upper(*its);
				std::transform(context_upper.begin(), context_upper.end(), context_upper.begin(), (int(*)(int))toupper);		//transform to uppercase
				map<string, string>::iterator it = hdb_dev->contexts_map_upper.find(context_upper);
				if(it == hdb_dev->contexts_map_upper.end())
				{
					context_error = true;
				}
				else
				{
					contexts.push_back(it->second);
				}
			}
		}
	}
	if(contexts.size()==0)
		contexts.push_back(defaultStrategy);
	hdb_dev->update(signame, contexts);

	bool is_current_context;
	try
	{
		hdb_dev->shared->veclock.readerIn();
		is_current_context = hdb_dev->shared->is_current_context(signame, context_set);
		hdb_dev->shared->veclock.readerOut();
	}
	catch(Tango::DevFailed &e)
	{
		hdb_dev->shared->veclock.readerOut();
		INFO_STREAM << __func__ << ": Failed to check is_current_context for " << signame;
		Tango::Except::re_throw_exception(e,
					(const char *)"BadSignalName",
					"Signal " + signame + " NOT subscribed",
					(const char *)__func__);
	}
	if(is_current_context)
		attribute_start((Tango::DevString)signame.c_str());
	else
		attribute_stop((Tango::DevString)signame.c_str());

	if(context_error)
	{
		for(vector<string>::iterator its=contexts.begin(); its!=contexts.end(); its++)
		{
			applied_strategy += *its;
			if(its != contexts.end()-1)
				applied_strategy += string("|");
		}
		Tango::Except::throw_exception(
			(const char *)"BadStrategy",
				"Requested strategy: " + requested_strategy + "\nApplied strategy: " + applied_strategy,
				(const char *)__func__);
	}
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::set_attribute_strategy
}
//--------------------------------------------------------
/**
 *	Command GetAttributeStrategy related method
 *	Description: Read a attribute contexts.
 *
 *	@param argin The attribute name
 *	@returns The attribute contexts.
 */
//--------------------------------------------------------
Tango::DevString HdbEventSubscriber::get_attribute_strategy(Tango::DevString argin)
{
	Tango::DevString argout;
	DEBUG_STREAM << "HdbEventSubscriber::GetAttributeStrategy()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::get_attribute_strategy) ENABLED START -----*/
	
	//	Add your own code
	string	signame(argin);
	hdb_dev->fix_tango_host(signame);

	stringstream attr_context;
	attr_context << hdb_dev->shared->get_sig_context(signame);

	argout  = new char[attr_context.str().length()+1];
	strcpy(argout, attr_context.str().c_str());
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::get_attribute_strategy
	return argout;
}
//--------------------------------------------------------
/**
 *	Command StopFaulty related method
 *	Description: Stop archiving faulty attributes
 *
 */
//--------------------------------------------------------
void HdbEventSubscriber::stop_faulty()
{
	DEBUG_STREAM << "HdbEventSubscriber::StopFaulty()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::stop_faulty) ENABLED START -----*/
	
	//	Add your own code
	vector<string> att_list_tmp;
	hdb_dev->get_sig_on_error_list(att_list_tmp);
	for (unsigned int i=0 ; i<att_list_tmp.size() ; i++)
	{
		attribute_stop((Tango::DevString)att_list_tmp[i].c_str());
	}
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::stop_faulty
}
//--------------------------------------------------------
/**
 *	Command SetAttributeTTL related method
 *	Description: Update TTL associated to an already archived attribute.
 *
 *	@param argin Attribute name, TTL
 */
//--------------------------------------------------------
void HdbEventSubscriber::set_attribute_ttl(const Tango::DevVarStringArray *argin)
{
	DEBUG_STREAM << "HdbEventSubscriber::SetAttributeTTL()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::set_attribute_ttl) ENABLED START -----*/
	
	//	Add your own code
	string	signame;
	Tango::DevULong ttl = DEFAULT_TTL;
	if(argin->length() > 0)
	{
		signame = string((*argin)[0]);
	}
	if(argin->length() > 1)
	{
		string s_ttl = string((*argin)[1]);
		try
		{
			stringstream val;
			val << s_ttl;
			val >> ttl;
		}
		catch(...)
		{
			DEBUG_STREAM << __func__ << ": error extracting ttl from '" << s_ttl << "'";
		}
	}
	DEBUG_STREAM << __func__<<": before updatettl name="<<signame<<" ttl="<<ttl;
	hdb_dev->updatettl(signame, ttl);
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::set_attribute_ttl
}
//--------------------------------------------------------
/**
 *	Command GetAttributeTTL related method
 *	Description: Read an attribute TTL.
 *
 *	@param argin The attribute name
 *	@returns The attribute TTL.
 */
//--------------------------------------------------------
Tango::DevULong HdbEventSubscriber::get_attribute_ttl(Tango::DevString argin)
{
	Tango::DevULong argout;
	DEBUG_STREAM << "HdbEventSubscriber::GetAttributeTTL()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::get_attribute_ttl) ENABLED START -----*/
	
	//	Add your own code
	string	signame(argin);
	hdb_dev->fix_tango_host(signame);

	argout = hdb_dev->shared->get_sig_ttl(signame);
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::get_attribute_ttl
	return argout;
}
//--------------------------------------------------------
/**
 *	Command dummyDynCmd related method
 *	Description: 
 *
 */
//--------------------------------------------------------
void HdbEventSubscriber::dummy_dyn_cmd(Tango::Command &command)
{
	DEBUG_STREAM << "HdbEventSubscriber::" << command.get_name() << "  - " << device_name << endl;
	/*----- PROTECTED REGION ID(HdbEventSubscriber::dummy_dyn_cmd) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::dummy_dyn_cmd
}
//--------------------------------------------------------
/**
 *	Method      : HdbEventSubscriber::add_dynamic_commands()
 *	Description : Create the dynamic commands if any
 *                for specified device.
 */
//--------------------------------------------------------
void HdbEventSubscriber::add_dynamic_commands()
{
	//	Example to add dynamic command:
	//	Copy inside the folowing protected area to instanciate at startup.
	//	add_dummyDynCmd_dynamic_command("MydummyDynCmdCommand", true);
	
	/*----- PROTECTED REGION ID(HdbEventSubscriber::add_dynamic_commands) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic commands if any
	LMCDevice::add_dynamic_commands();

	/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::add_dynamic_commands
}

/*----- PROTECTED REGION ID(HdbEventSubscriber::namespace_ending) ENABLED START -----*/

//	Additional Methods


int HdbEventSubscriber::LoadArchivedAttrsFromFile(std::string& cfg_file){

	//==================================================
	//==        CHECK XML config file
	//==================================================
	//Check if empty string given
	if(cfg_file==""){
		std::string errMsg("Empty configuration file given!");
		_ERROR_LOG(errMsg);
		_THROW_RECORDED_TANGO_EXCEPTION("LOAD_ARCHIVED_ATTRS_FROM_FILE_FAILED",errMsg);
	}
	_DEBUG_LOG("Configuring archived attributes from config file "<<cfg_file<<" ...");

	//First check file as it is
	Utils_ns::FileInfo file_info;
	if(Utils_ns::SysUtils::CheckFile(cfg_file,file_info)<0){
		_WARN_LOG("Archiving config file "<<cfg_file<<" not found in current directory, trying to search in filesystem config dir (if set)...");
		
		//Get config dir env var
		std::string configDir= Utils_ns::SysUtils::GetEnvVar("DSHLMC_CONFIG");
		if(configDir==""){
			std::string errMsg= "$DSHLMC_CONFIG env var is not set, cannot find config file!";
			_ERROR_LOG(errMsg);
			_THROW_RECORDED_TANGO_EXCEPTION("LOAD_ARCHIVED_ATTRS_FROM_FILE_FAILED",errMsg);
		}//close if check env dir

		std::string configFileFull= configDir + std::string("/") + cfg_file;		
		if(Utils_ns::SysUtils::CheckFile(configFileFull,file_info)<0){
			std::stringstream ss;
			ss<<"Cannot find config file "<<configFileFull<<"!";
			_ERROR_LOG(ss.str());
			_THROW_RECORDED_TANGO_EXCEPTION("LOAD_ARCHIVED_ATTRS_FROM_FILE_FAILED",ss.str());
		}
		cfg_file= configFileFull;
	}//close if

	_INFO_LOG("Reading archived attrs from XML config file "<<cfg_file<<"...");
	
	// Parse archived attrs from XML
	std::vector<Utils_ns::ArchivedData*> archivedAttrCollection;	
	bool readFromFile= true;
	if(Utils_ns::DevConfigParser::ParseArchivedAttrs(archivedAttrCollection,cfg_file,readFromFile)<0){
		std::string errMsg= "Failed to parse the archived attr configuration file!";
		_ERROR_LOG(errMsg);
		for(size_t i=0;i<archivedAttrCollection.size();i++){
			if(archivedAttrCollection[i]){
				delete archivedAttrCollection[i];
				archivedAttrCollection[i]= 0;
			}
		}
		archivedAttrCollection.clear();
		_THROW_RECORDED_TANGO_EXCEPTION("LOAD_ARCHIVED_ATTRS_FROM_FILE_FAILED",errMsg);
	}

	_INFO_LOG("#"<<archivedAttrCollection.size()<<" archived attr found in config file "<<cfg_file);

	//## Loop over parsed archived attr list and load them in device
	int archivedAttrLoadStatus= 0;

	for(size_t i=0;i<archivedAttrCollection.size();i++){
		//Insert archived attr to list	
		m_archivedAttrs.push_back(archivedAttrCollection[i]);
	
		//Get archived attr info
		std::string archived_attr_name= archivedAttrCollection[i]->GetName();
		std::string attr_archive_strategy= "";
		archivedAttrCollection[i]->GetEncodedStrategyStr(attr_archive_strategy);
		unsigned int ttl= archivedAttrCollection[i]->GetTTL();
		
		//Load archived attr 
		_INFO_LOG("Loading archived attr "<<archived_attr_name<<" in device...");	
		try {
			RegisterArchivedAttr(archived_attr_name,attr_archive_strategy,ttl);
		}
		catch(Tango::DevFailed& e){
			Tango::Except::print_exception(e);
			_ERROR_LOG("Failed to load archived attr "<<archived_attr_name<<"!");
			continue;
		}
	}//end loop archived attrs	
	
	return 0;

}//close LoadArchivedAttrsFromFile()


void HdbEventSubscriber::RegisterArchivedAttr(std::string full_attr_name,std::string attr_archive_strategy,unsigned int ttl)
{
	//## Check if HdbClient was created
	if(!m_mdb) {
		Tango::Except::throw_exception( \
					(const char*)"NO Hdb++ Library", \
					(const char*)"Failed initialization of Hdb++ Library", \
					(const char*)__func__);
	}


	//## Check if attribute exists and get properties
	string::size_type idx = full_attr_name.find_last_of("/");
	if (idx==string::npos) Tango::Except::throw_exception((const char *)"SyntaxError","Syntax error in signal name",(const char *)__func__);
	
	std::string devname = full_attr_name.substr(0, idx);
	std::string attname = full_attr_name.substr(idx+1);
	Tango::DeviceProxy* dp = new Tango::DeviceProxy(devname);

	Tango::AttributeInfo	info = dp->get_attribute_config(attname);
	int data_type = info.data_type;
	int data_format = info.data_format;
	int write_type = info.writable;
	INFO_STREAM << "HdbEventSubscriber::AttributeAdd()  - data_type=" << data_type<<" Tango::DEV_STATE="<<Tango::DEV_STATE<< " Tango::DEV_BOOLEAN="<<Tango::DEV_BOOLEAN<< endl;
	
	//## Configure DB
	try {
		m_mdb->configure_Attr(full_attr_name, data_type, data_format, write_type, ttl);
	}
	catch(Tango::DevFailed &e){
		ERROR_STREAM << __func__<<": Error configuring attribute: " << full_attr_name << endl;
		stringstream error_desc;
		error_desc << "Failed to configure the attribute: " << full_attr_name << " in the database" << endl;
		Tango::Except::re_throw_exception(e, "Attribute Configuration Query Error", error_desc.str(), __func__);
	}

	//## Add attribute
	Tango::DevVarStringArray* add_argin= new Tango::DevVarStringArray;
	add_argin->length(3);
	(*add_argin)[0] = CORBA::string_dup(full_attr_name.c_str());
	(*add_argin)[1] = CORBA::string_dup(attr_archive_strategy.c_str());
	
	std::stringstream tmpttl;
	tmpttl << ttl;
	(*add_argin)[2] = CORBA::string_dup(tmpttl.str().c_str());

	attribute_add(add_argin);

}//close RegisterArchivedAttr()

/*----- PROTECTED REGION END -----*/	//	HdbEventSubscriber::namespace_ending
} //	namespace
