/*----- PROTECTED REGION ID(LMCDevice.cpp) ENABLED START -----*/
static const char *RcsId = "$Id:  $";
//=============================================================================
//
// file :        LMCDevice.cpp
//
// description : C++ source for the LMCDevice class and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               LMCDevice are implemented in this file.
//
// project :     LMCDevice
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
// $Author:  $
//
// $Revision:  $
// $Date:  $
//
// $HeadURL:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <LMCDevice.h>
#include <LMCDeviceClass.h>

#ifndef _EVENT_CALLBACK_H
	#include <EventCallBack.h>
#endif

//Tango headers
#include <PogoHelper.h>

//- YAT/YAT4TANGO
#include <yat4tango/InnerAppender.h>
#include <yat4tango/DynamicAttributeManager.h>
#include <yat/utils/XString.h>
#include <yat4tango/Types.h>

#ifndef _CODE_UTILS_h
	#include <CodeUtils.h>
#endif

#ifndef _LOGGER_h
	#include <Logger.h>
#endif

#ifndef _DEV_CONFIG_PARSER_H
	#include <DevConfigParser.h>
#endif

#ifndef _TANGO_PROXY_MANAGER_h
	#include <TangoProxyManager.h>
#endif

#ifndef _ATTR_DATA_h
	#include <AttrData.h>
#endif

#ifndef _FORMULA_DATA_h
	#include <FormulaData.h>
#endif

#ifndef _FORMULA_MANAGER_h
	#include <FormulaManager.h>
#endif

#ifndef _PROXY_MONITOR_TASK_H_
	#include <ProxyMonitorTask.h>
#endif

#ifndef _ATTR_RANDOMIZER_THREAD_h
	#include <AttrRandomizerThread.h>
#endif

#include <EventHandlerTask.h>
#include <Task.h>
#include <TaskManager.h>
#include <TaskThread.h>

//using namespace Utils_ns;


/*----- PROTECTED REGION END -----*/	//	LMCDevice.cpp

/**
 *  LMCDevice class description:
 *    This class represents the base device class for SKA Dish LMC. 
 *    All LMC Tango devices inherit from this basic functionalities, 
 *    among them:
 *    
 *    - logging configuration (level/target)
 *    - proxy registration and monitoring utilities
 *    - event handler registration utilities
 *    - dynamic attribute creation from XML configuration file
 *    - formula attributes
 *    - task command queue management
 *    
 *    More details are reported in the Dish LMC repository wiki page.
 */

//================================================================
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name            |  Method name
//================================================================
//  State                   |  Inherited (no method)
//  Status                  |  Inherited (no method)
//  InitializeLoggers       |  initialize_loggers
//  InitializeFwdAttrs      |  initialize_fwd_attrs
//  RandomizeDynAttrs       |  randomize_dyn_attrs
//  InitializeDevProxies    |  initialize_dev_proxies
//  GetRegisteredProxies    |  get_registered_proxies
//  GetRegisteredEvents     |  get_registered_events
//  GetRegisteredFormulas   |  get_registered_formulas
//  GetInitializedFormulas  |  get_initialized_formulas
//  GetNRunningTasks        |  get_nrunning_tasks
//  GetNQueuedTasks         |  get_nqueued_tasks
//  GetNIdleTasks           |  get_nidle_tasks
//  GetNTasks               |  get_ntasks
//  GetNFailedTasks         |  get_nfailed_tasks
//  GetNTotFailedTasks      |  get_ntot_failed_tasks
//  IsTaskQuotaReached      |  is_task_quota_reached
//  FlushTaskQueue          |  flush_task_queue
//  GetQueuedTaskInfo       |  get_queued_task_info
//  GetTaskInfo             |  get_task_info
//  ClearTasks              |  clear_tasks
//  UpdateFormulaAttrs      |  update_formula_attrs
//  UpdateStatusAttrs       |  update_status_attrs
//  MonitorProxies          |  monitor_proxies
//  RevokeTask              |  revoke_task
//  RevokeTaskSequence      |  revoke_task_sequence
//  GetFormulaData          |  get_formula_data
//  SendTestLogMsg          |  send_test_log_msg
//  ClearTaskHistory        |  clear_task_history
//  GetLogAppenderInfo      |  get_log_appender_info
//================================================================

//================================================================
//  Attributes managed are:
//================================================================
//  loggingLevelCentral       |  Tango::DevLong	Scalar
//  loggingLevelElement       |  Tango::DevLong	Scalar
//  loggingLevelStorage       |  Tango::DevLong	Scalar
//  loggingLevelConsole       |  Tango::DevLong	Scalar
//  buildState                |  Tango::DevString	Scalar
//  centralLoggerStatus       |  Tango::DevEnum	Scalar
//  elementLoggerStatus       |  Tango::DevEnum	Scalar
//  storageLoggerStatus       |  Tango::DevEnum	Scalar
//  eventRate                 |  Tango::DevFloat	Scalar
//  exceptionRate             |  Tango::DevFloat	Scalar
//  fwdAttrInitStatus         |  Tango::DevEnum	Scalar
//  centralLoggerEnabled      |  Tango::DevBoolean	Scalar
//  elementLoggerEnabled      |  Tango::DevBoolean	Scalar
//  storageLoggerEnabled      |  Tango::DevBoolean	Scalar
//  loggingTargetCentral      |  Tango::DevString	Scalar
//  loggingTargetElement      |  Tango::DevString	Scalar
//  loggingTargetStorage      |  Tango::DevString	Scalar
//  attrRandomizationEnabled  |  Tango::DevBoolean	Scalar
//  attrRandomizationPeriod   |  Tango::DevULong	Scalar
//================================================================

namespace LMCDevice_ns
{
/*----- PROTECTED REGION ID(LMCDevice::namespace_starting) ENABLED START -----*/

//	static initializations

/*----- PROTECTED REGION END -----*/	//	LMCDevice::namespace_starting

//--------------------------------------------------------
/**
 *	Method      : LMCDevice::LMCDevice()
 *	Description : Constructors for a Tango device
 *                implementing the classLMCDevice
 */
//--------------------------------------------------------
LMCDevice::LMCDevice(Tango::DeviceClass *cl, string &s)
 : TANGO_BASE_CLASS(cl, s.c_str())
{
	/*----- PROTECTED REGION ID(LMCDevice::constructor_1) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	LMCDevice::constructor_1
}
//--------------------------------------------------------
LMCDevice::LMCDevice(Tango::DeviceClass *cl, const char *s)
 : TANGO_BASE_CLASS(cl, s)
{
	/*----- PROTECTED REGION ID(LMCDevice::constructor_2) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	LMCDevice::constructor_2
}
//--------------------------------------------------------
LMCDevice::LMCDevice(Tango::DeviceClass *cl, const char *s, const char *d)
 : TANGO_BASE_CLASS(cl, s, d)
{
	/*----- PROTECTED REGION ID(LMCDevice::constructor_3) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	LMCDevice::constructor_3
}

//--------------------------------------------------------
/**
 *	Method      : LMCDevice::delete_device()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void LMCDevice::delete_device()
{
	DEBUG_STREAM << "LMCDevice::delete_device() " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCDevice::delete_device) ENABLED START -----*/
	
	//	Delete device allocated objects
	
	//## Clear event handler task: notify wait cond & exit
	if(ClearEventHandlerTask()<0){
		_ERROR_LOG("Failed to clearup event handler task thread");
	}

	//## Cleanup event callback
	if(m_eventCallBack){
		_DEBUG_LOG("Deleting event callback...");
		delete m_eventCallBack;
		m_eventCallBack= 0;
	}

	//## Remove attr formula manager
	if(m_formulaManager){
		_DEBUG_LOG("Deleting formula manager...");
		delete m_formulaManager;
		m_formulaManager= 0;
	}

	//## Remove proxy manager
	if(m_proxyManager){
		_DEBUG_LOG("Deleting proxy manager...");
		delete m_proxyManager;
		m_proxyManager= 0;
	}


	//## Clear randomizer thread
	if(m_attrRandomizerThread){
		_DEBUG_LOG("Shutting down attr randomizer thread...");	
		m_attrRandomizerThread->Stop();
		_DEBUG_LOG("Deleting attr randomizer thread...");	
		delete m_attrRandomizerThread;
		m_attrRandomizerThread = 0;
		_DEBUG_LOG("Attr randomizer thread cleared!");	
	}

	//## Clear task thread
	if(m_taskThread){
		if(m_taskManager) {//Signal first task manager
			_DEBUG_LOG("Signalling END to task manager...");	
			m_taskManager->End();
		}
		_DEBUG_LOG("Shutting down task thread...");	
		m_taskThread->Stop();
		_DEBUG_LOG("Deleting task thread...");	
		delete m_taskThread;
		m_taskThread = 0;
		_DEBUG_LOG("Task thread cleared!");	
	}

	//## Delete task manager
	if(m_taskManager){
		_DEBUG_LOG("Deleting task manager...");
		delete m_taskManager;
		m_taskManager= 0;
	}	
	

	//## Delete dyn attr data
	if(EraseDynAttrData()<0){
		_ERROR_LOG("Failed to remove allocated dyn attr data!");
	}

	if(EraseDynAttrManager()<0){
		_ERROR_LOG("Failed to cleanup dyn attr manager...");
	}
	

	/*----- PROTECTED REGION END -----*/	//	LMCDevice::delete_device
	delete[] attr_loggingLevelCentral_read;
	delete[] attr_loggingLevelElement_read;
	delete[] attr_loggingLevelStorage_read;
	delete[] attr_loggingLevelConsole_read;
	delete[] attr_buildState_read;
	delete[] attr_centralLoggerStatus_read;
	delete[] attr_elementLoggerStatus_read;
	delete[] attr_storageLoggerStatus_read;
	delete[] attr_eventRate_read;
	delete[] attr_exceptionRate_read;
	delete[] attr_fwdAttrInitStatus_read;
	delete[] attr_centralLoggerEnabled_read;
	delete[] attr_elementLoggerEnabled_read;
	delete[] attr_storageLoggerEnabled_read;
	delete[] attr_loggingTargetCentral_read;
	delete[] attr_loggingTargetElement_read;
	delete[] attr_loggingTargetStorage_read;
	delete[] attr_attrRandomizationEnabled_read;
	delete[] attr_attrRandomizationPeriod_read;
}

//--------------------------------------------------------
/**
 *	Method      : LMCDevice::init_device()
 *	Description : will be called at device initialization.
 */
//--------------------------------------------------------
void LMCDevice::init_device()
{
	DEBUG_STREAM << "LMCDevice::init_device() create device " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCDevice::init_device_before) ENABLED START -----*/
	
	//	Initialization before get_device_property() call
	
	/*----- PROTECTED REGION END -----*/	//	LMCDevice::init_device_before
	

	//	Get the device properties from database
	get_device_property();
	
	attr_loggingLevelCentral_read = new Tango::DevLong[1];
	attr_loggingLevelElement_read = new Tango::DevLong[1];
	attr_loggingLevelStorage_read = new Tango::DevLong[1];
	attr_loggingLevelConsole_read = new Tango::DevLong[1];
	attr_buildState_read = new Tango::DevString[1];
	attr_centralLoggerStatus_read = new centralLoggerStatusEnum[1];
	attr_elementLoggerStatus_read = new elementLoggerStatusEnum[1];
	attr_storageLoggerStatus_read = new storageLoggerStatusEnum[1];
	attr_eventRate_read = new Tango::DevFloat[1];
	attr_exceptionRate_read = new Tango::DevFloat[1];
	attr_fwdAttrInitStatus_read = new fwdAttrInitStatusEnum[1];
	attr_centralLoggerEnabled_read = new Tango::DevBoolean[1];
	attr_elementLoggerEnabled_read = new Tango::DevBoolean[1];
	attr_storageLoggerEnabled_read = new Tango::DevBoolean[1];
	attr_loggingTargetCentral_read = new Tango::DevString[1];
	attr_loggingTargetElement_read = new Tango::DevString[1];
	attr_loggingTargetStorage_read = new Tango::DevString[1];
	attr_attrRandomizationEnabled_read = new Tango::DevBoolean[1];
	attr_attrRandomizationPeriod_read = new Tango::DevULong[1];
	//	No longer if mandatory property not set. 
	if (mandatoryNotDefined)
		return;

	/*----- PROTECTED REGION ID(LMCDevice::init_device) ENABLED START -----*/
	
	//	Initialize device
	INFO_STREAM<<"LMCDevice::init_device() - Initializing LMCDevice base device..."<<endl;

	//## Set init device state
	set_state(Tango::INIT);
	set_status("Device " + device_name + " is initializing...");

	//## Init vars
	//m_elementLogAppender= 0;
	//m_centralLogAppender= 0;
	m_dam = 0;
	m_eventCallBack= 0;
	m_proxyManager= 0;
	m_formulaManager= 0;
	m_attrRandomizerThread= 0;

	//Init event counter & rate attr
	m_eventCounter= 0.;
	*attr_eventRate_read= 0;
	m_eventRateSamplingTimer.restart();//restart the timer

	//Init exception counter & rate attr
	m_exceptionCounter= 0.;
	*attr_exceptionRate_read= 0;
	m_exceptionRateSamplingTimer.restart();//restart the timer

	//Init randomization attr
	*attr_attrRandomizationEnabled_read= enableDynAttrRandomize;
	*attr_attrRandomizationPeriod_read= dynAttrRandomizePeriod;
	get_device_attr()->get_w_attr_by_name("attrRandomizationEnabled").set_write_value(enableDynAttrRandomize);
	get_device_attr()->get_w_attr_by_name("attrRandomizationPeriod").set_write_value(dynAttrRandomizePeriod);
	

	//Init fwd attr init status attr
	*attr_fwdAttrInitStatus_read= fwdAttrInitStatusEnum::_UNKNOWN;

	//Initialize build status attribute to cmake project var
	std::stringstream buildStatusStream;
	buildStatusStream<<"v"<<VERSION<<"_release"<<RELEASE;
	*attr_buildState_read= Tango::string_dup(buildStatusStream.str().c_str());

	//Initialize dyn attr manager
	if(!m_dam) m_dam = new yat4tango::DynamicAttributeManager(this);

	// Initialize random engine
	_DEBUG_LOG("Initialize random generator...");
	std::random_device rd;
  m_randGenerator= std::mt19937(rd());

	//Initialize memorized attr (logging targets)	
	_INFO_LOG("Initialize memorized attributes...");	
	try{
		InitMemorizedAttrs();
	}
	catch(...){
		std::string errMsg("Failed to initialize one/more memorized attributes!");
		_ERROR_LOG(errMsg);
		set_status(errMsg.c_str());
		set_state(Tango::FAULT);
	}

	//Initialize logger (need to be done after setting the memorized attrs)
	_INFO_LOG("Initialize loggers...");
	try{
		//Init logger pars (level, target, enabled)
		InitLoggerPars();

		//Init loggers
		if(InitLoggers()<0){
			_WARN_LOG("One/more errors occurred while initializing loggers (e.g. log consumers offline), will retry later...");
		}
	}
	catch(...){
		std::string errMsg= "Failed to initialize loggers!";
		_ERROR_LOG(errMsg);
		set_status(errMsg.c_str());
		set_state(Tango::FAULT);
	}

	//Initialize proxy manager
	if(!m_proxyManager) {
		_INFO_LOG("Initialize proxy manager...");
		m_proxyManager= new Utils_ns::TangoProxyManager(this);
	}

	//Initialize formula attr manager
	if(!m_formulaManager) {
		_INFO_LOG("Initialize formula attribute manager...");
		m_formulaManager= new Utils_ns::FormulaManager(this,m_proxyManager);
	}

	// Configure cmd polling 
	_INFO_LOG("Configuring command polling...");
	if(ConfigureCmdPolling()<0){
		std::string errMsg= "Failures occurred while configuring polling in commands!";
		_ERROR_LOG(errMsg);
		set_status(errMsg.c_str());
		set_state(Tango::FAULT);
	}
	
	// Initialize and start device event handler task thread
	_INFO_LOG("Initializing and starting event handler task thread...");
	if(InitEventHandlerTask()<0){
		_ERROR_LOG("Failed to initialize and start event handler task!");
	}

	// Initialize and start device task thread
	_INFO_LOG("Initializing task manager and starting task thread...");
	if(InitTaskThread()<0){
		_ERROR_LOG("Failed to initialize task manager and/or task thread!");
	}

	/*----- PROTECTED REGION END -----*/	//	LMCDevice::init_device
}

//--------------------------------------------------------
/**
 *	Method      : LMCDevice::get_device_property()
 *	Description : Read database to initialize property data members.
 */
//--------------------------------------------------------
void LMCDevice::get_device_property()
{
	/*----- PROTECTED REGION ID(LMCDevice::get_device_property_before) ENABLED START -----*/
	
	//	Initialize property data members
	
	/*----- PROTECTED REGION END -----*/	//	LMCDevice::get_device_property_before

	mandatoryNotDefined = false;

	//	Read device properties from database.
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("CentralLoggerEnabledDefault"));
	dev_prop.push_back(Tango::DbDatum("ElementLoggerEnabledDefault"));
	dev_prop.push_back(Tango::DbDatum("StorageLoggerEnabledDefault"));
	dev_prop.push_back(Tango::DbDatum("LoggingTargetCentralDefault"));
	dev_prop.push_back(Tango::DbDatum("LoggingTargetElementDefault"));
	dev_prop.push_back(Tango::DbDatum("LoggingTargetStorageDefault"));
	dev_prop.push_back(Tango::DbDatum("SkaLevel"));
	dev_prop.push_back(Tango::DbDatum("SyslogFacility"));
	dev_prop.push_back(Tango::DbDatum("SyslogHost"));
	dev_prop.push_back(Tango::DbDatum("LoggingLevelCentralDefault"));
	dev_prop.push_back(Tango::DbDatum("LoggingLevelElementDefault"));
	dev_prop.push_back(Tango::DbDatum("LoggingLevelStorageDefault"));
	dev_prop.push_back(Tango::DbDatum("ConfigFile"));
	dev_prop.push_back(Tango::DbDatum("EnableConfigFromFile"));
	dev_prop.push_back(Tango::DbDatum("EnableDynAttrCleanup"));
	dev_prop.push_back(Tango::DbDatum("EnableDynAttrRandomize"));
	dev_prop.push_back(Tango::DbDatum("DynAttrRandomizePeriod"));
	dev_prop.push_back(Tango::DbDatum("ProxyDevices"));
	dev_prop.push_back(Tango::DbDatum("FormulaVarMaxTimeInterval"));
	dev_prop.push_back(Tango::DbDatum("EnableProxyMonitoring"));
	dev_prop.push_back(Tango::DbDatum("ProxyMonitoringPeriod"));
	dev_prop.push_back(Tango::DbDatum("ProxyStatusAttrPollPeriod"));
	dev_prop.push_back(Tango::DbDatum("ProxyStatusAttrPeriodicEventPeriod"));
	dev_prop.push_back(Tango::DbDatum("ProxyStatusAttrArchiveEventPeriod"));
	dev_prop.push_back(Tango::DbDatum("ProxyTimeout"));
	dev_prop.push_back(Tango::DbDatum("EventSubscriptions"));
	dev_prop.push_back(Tango::DbDatum("EventHandlers"));
	dev_prop.push_back(Tango::DbDatum("MaxQueueableTask"));
	dev_prop.push_back(Tango::DbDatum("MaxTrackableTasks"));
	dev_prop.push_back(Tango::DbDatum("TaskHistoryTimeDepth"));
	dev_prop.push_back(Tango::DbDatum("DefaultTaskTimeout"));
	dev_prop.push_back(Tango::DbDatum("TaskSequenceStatusAttrList"));
	dev_prop.push_back(Tango::DbDatum("TaskStatusAttrList"));
	dev_prop.push_back(Tango::DbDatum("EnableEventRateMonitoring"));
	dev_prop.push_back(Tango::DbDatum("EnableLoggerInitPolling"));
	dev_prop.push_back(Tango::DbDatum("LoggerInitPollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableDevProxyInitPolling"));
	dev_prop.push_back(Tango::DbDatum("DevProxyInitPollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableFwdAttrInitPolling"));
	dev_prop.push_back(Tango::DbDatum("FwdAttrInitPollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableFormulaAttrUpdatePolling"));
	dev_prop.push_back(Tango::DbDatum("FormulaAttrUpdatePollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableStatusAttrUpdatePolling"));
	dev_prop.push_back(Tango::DbDatum("StatusAttrUpdatePollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableClearTaskPolling"));
	dev_prop.push_back(Tango::DbDatum("ClearTaskPollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableProxyStatusAttrCreation"));
	dev_prop.push_back(Tango::DbDatum("EnableAutoAdminProxyRegistration"));
	dev_prop.push_back(Tango::DbDatum("ProcessEventsInQueueThread"));

	//	is there at least one property to be read ?
	if (dev_prop.size()>0)
	{
		//	Call database and extract values
		if (Tango::Util::instance()->_UseDb==true)
			get_db_device()->get_property(dev_prop);
	
		//	get instance on LMCDeviceClass to get class property
		Tango::DbDatum	def_prop, cl_prop;
		LMCDeviceClass	*ds_class =
			(static_cast<LMCDeviceClass *>(get_device_class()));
		int	i = -1;

		//	Try to initialize CentralLoggerEnabledDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  centralLoggerEnabledDefault;
		else {
			//	Try to initialize CentralLoggerEnabledDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  centralLoggerEnabledDefault;
		}
		//	And try to extract CentralLoggerEnabledDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  centralLoggerEnabledDefault;

		//	Try to initialize ElementLoggerEnabledDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  elementLoggerEnabledDefault;
		else {
			//	Try to initialize ElementLoggerEnabledDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  elementLoggerEnabledDefault;
		}
		//	And try to extract ElementLoggerEnabledDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  elementLoggerEnabledDefault;

		//	Try to initialize StorageLoggerEnabledDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  storageLoggerEnabledDefault;
		else {
			//	Try to initialize StorageLoggerEnabledDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  storageLoggerEnabledDefault;
		}
		//	And try to extract StorageLoggerEnabledDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  storageLoggerEnabledDefault;

		//	Try to initialize LoggingTargetCentralDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingTargetCentralDefault;
		else {
			//	Try to initialize LoggingTargetCentralDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingTargetCentralDefault;
		}
		//	And try to extract LoggingTargetCentralDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingTargetCentralDefault;

		//	Try to initialize LoggingTargetElementDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingTargetElementDefault;
		else {
			//	Try to initialize LoggingTargetElementDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingTargetElementDefault;
		}
		//	And try to extract LoggingTargetElementDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingTargetElementDefault;

		//	Try to initialize LoggingTargetStorageDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingTargetStorageDefault;
		else {
			//	Try to initialize LoggingTargetStorageDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingTargetStorageDefault;
		}
		//	And try to extract LoggingTargetStorageDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingTargetStorageDefault;

		//	Try to initialize SkaLevel from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  skaLevel;
		else {
			//	Try to initialize SkaLevel from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  skaLevel;
		}
		//	And try to extract SkaLevel value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  skaLevel;

		//	Try to initialize SyslogFacility from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  syslogFacility;
		else {
			//	Try to initialize SyslogFacility from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  syslogFacility;
		}
		//	And try to extract SyslogFacility value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  syslogFacility;

		//	Try to initialize SyslogHost from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  syslogHost;
		else {
			//	Try to initialize SyslogHost from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  syslogHost;
		}
		//	And try to extract SyslogHost value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  syslogHost;

		//	Try to initialize LoggingLevelCentralDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingLevelCentralDefault;
		else {
			//	Try to initialize LoggingLevelCentralDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingLevelCentralDefault;
		}
		//	And try to extract LoggingLevelCentralDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingLevelCentralDefault;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize LoggingLevelElementDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingLevelElementDefault;
		else {
			//	Try to initialize LoggingLevelElementDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingLevelElementDefault;
		}
		//	And try to extract LoggingLevelElementDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingLevelElementDefault;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize LoggingLevelStorageDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingLevelStorageDefault;
		else {
			//	Try to initialize LoggingLevelStorageDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingLevelStorageDefault;
		}
		//	And try to extract LoggingLevelStorageDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingLevelStorageDefault;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize ConfigFile from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  configFile;
		else {
			//	Try to initialize ConfigFile from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  configFile;
		}
		//	And try to extract ConfigFile value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  configFile;

		//	Try to initialize EnableConfigFromFile from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableConfigFromFile;
		else {
			//	Try to initialize EnableConfigFromFile from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableConfigFromFile;
		}
		//	And try to extract EnableConfigFromFile value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableConfigFromFile;

		//	Try to initialize EnableDynAttrCleanup from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableDynAttrCleanup;
		else {
			//	Try to initialize EnableDynAttrCleanup from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableDynAttrCleanup;
		}
		//	And try to extract EnableDynAttrCleanup value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableDynAttrCleanup;

		//	Try to initialize EnableDynAttrRandomize from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableDynAttrRandomize;
		else {
			//	Try to initialize EnableDynAttrRandomize from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableDynAttrRandomize;
		}
		//	And try to extract EnableDynAttrRandomize value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableDynAttrRandomize;

		//	Try to initialize DynAttrRandomizePeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  dynAttrRandomizePeriod;
		else {
			//	Try to initialize DynAttrRandomizePeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  dynAttrRandomizePeriod;
		}
		//	And try to extract DynAttrRandomizePeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  dynAttrRandomizePeriod;

		//	Try to initialize ProxyDevices from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyDevices;
		else {
			//	Try to initialize ProxyDevices from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyDevices;
		}
		//	And try to extract ProxyDevices value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyDevices;

		//	Try to initialize FormulaVarMaxTimeInterval from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  formulaVarMaxTimeInterval;
		else {
			//	Try to initialize FormulaVarMaxTimeInterval from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  formulaVarMaxTimeInterval;
		}
		//	And try to extract FormulaVarMaxTimeInterval value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  formulaVarMaxTimeInterval;

		//	Try to initialize EnableProxyMonitoring from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableProxyMonitoring;
		else {
			//	Try to initialize EnableProxyMonitoring from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableProxyMonitoring;
		}
		//	And try to extract EnableProxyMonitoring value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableProxyMonitoring;

		//	Try to initialize ProxyMonitoringPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyMonitoringPeriod;
		else {
			//	Try to initialize ProxyMonitoringPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyMonitoringPeriod;
		}
		//	And try to extract ProxyMonitoringPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyMonitoringPeriod;

		//	Try to initialize ProxyStatusAttrPollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyStatusAttrPollPeriod;
		else {
			//	Try to initialize ProxyStatusAttrPollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyStatusAttrPollPeriod;
		}
		//	And try to extract ProxyStatusAttrPollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyStatusAttrPollPeriod;

		//	Try to initialize ProxyStatusAttrPeriodicEventPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyStatusAttrPeriodicEventPeriod;
		else {
			//	Try to initialize ProxyStatusAttrPeriodicEventPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyStatusAttrPeriodicEventPeriod;
		}
		//	And try to extract ProxyStatusAttrPeriodicEventPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyStatusAttrPeriodicEventPeriod;

		//	Try to initialize ProxyStatusAttrArchiveEventPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyStatusAttrArchiveEventPeriod;
		else {
			//	Try to initialize ProxyStatusAttrArchiveEventPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyStatusAttrArchiveEventPeriod;
		}
		//	And try to extract ProxyStatusAttrArchiveEventPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyStatusAttrArchiveEventPeriod;

		//	Try to initialize ProxyTimeout from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyTimeout;
		else {
			//	Try to initialize ProxyTimeout from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyTimeout;
		}
		//	And try to extract ProxyTimeout value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyTimeout;

		//	Try to initialize EventSubscriptions from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  eventSubscriptions;
		else {
			//	Try to initialize EventSubscriptions from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  eventSubscriptions;
		}
		//	And try to extract EventSubscriptions value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  eventSubscriptions;

		//	Try to initialize EventHandlers from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  eventHandlers;
		else {
			//	Try to initialize EventHandlers from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  eventHandlers;
		}
		//	And try to extract EventHandlers value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  eventHandlers;

		//	Try to initialize MaxQueueableTask from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  maxQueueableTask;
		else {
			//	Try to initialize MaxQueueableTask from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  maxQueueableTask;
		}
		//	And try to extract MaxQueueableTask value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  maxQueueableTask;

		//	Try to initialize MaxTrackableTasks from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  maxTrackableTasks;
		else {
			//	Try to initialize MaxTrackableTasks from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  maxTrackableTasks;
		}
		//	And try to extract MaxTrackableTasks value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  maxTrackableTasks;

		//	Try to initialize TaskHistoryTimeDepth from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  taskHistoryTimeDepth;
		else {
			//	Try to initialize TaskHistoryTimeDepth from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  taskHistoryTimeDepth;
		}
		//	And try to extract TaskHistoryTimeDepth value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  taskHistoryTimeDepth;

		//	Try to initialize DefaultTaskTimeout from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  defaultTaskTimeout;
		else {
			//	Try to initialize DefaultTaskTimeout from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  defaultTaskTimeout;
		}
		//	And try to extract DefaultTaskTimeout value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  defaultTaskTimeout;

		//	Try to initialize TaskSequenceStatusAttrList from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  taskSequenceStatusAttrList;
		else {
			//	Try to initialize TaskSequenceStatusAttrList from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  taskSequenceStatusAttrList;
		}
		//	And try to extract TaskSequenceStatusAttrList value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  taskSequenceStatusAttrList;

		//	Try to initialize TaskStatusAttrList from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  taskStatusAttrList;
		else {
			//	Try to initialize TaskStatusAttrList from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  taskStatusAttrList;
		}
		//	And try to extract TaskStatusAttrList value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  taskStatusAttrList;

		//	Try to initialize EnableEventRateMonitoring from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableEventRateMonitoring;
		else {
			//	Try to initialize EnableEventRateMonitoring from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableEventRateMonitoring;
		}
		//	And try to extract EnableEventRateMonitoring value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableEventRateMonitoring;

		//	Try to initialize EnableLoggerInitPolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableLoggerInitPolling;
		else {
			//	Try to initialize EnableLoggerInitPolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableLoggerInitPolling;
		}
		//	And try to extract EnableLoggerInitPolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableLoggerInitPolling;

		//	Try to initialize LoggerInitPollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggerInitPollPeriod;
		else {
			//	Try to initialize LoggerInitPollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggerInitPollPeriod;
		}
		//	And try to extract LoggerInitPollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggerInitPollPeriod;

		//	Try to initialize EnableDevProxyInitPolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableDevProxyInitPolling;
		else {
			//	Try to initialize EnableDevProxyInitPolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableDevProxyInitPolling;
		}
		//	And try to extract EnableDevProxyInitPolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableDevProxyInitPolling;

		//	Try to initialize DevProxyInitPollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  devProxyInitPollPeriod;
		else {
			//	Try to initialize DevProxyInitPollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  devProxyInitPollPeriod;
		}
		//	And try to extract DevProxyInitPollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  devProxyInitPollPeriod;

		//	Try to initialize EnableFwdAttrInitPolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableFwdAttrInitPolling;
		else {
			//	Try to initialize EnableFwdAttrInitPolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableFwdAttrInitPolling;
		}
		//	And try to extract EnableFwdAttrInitPolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableFwdAttrInitPolling;

		//	Try to initialize FwdAttrInitPollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  fwdAttrInitPollPeriod;
		else {
			//	Try to initialize FwdAttrInitPollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  fwdAttrInitPollPeriod;
		}
		//	And try to extract FwdAttrInitPollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  fwdAttrInitPollPeriod;

		//	Try to initialize EnableFormulaAttrUpdatePolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableFormulaAttrUpdatePolling;
		else {
			//	Try to initialize EnableFormulaAttrUpdatePolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableFormulaAttrUpdatePolling;
		}
		//	And try to extract EnableFormulaAttrUpdatePolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableFormulaAttrUpdatePolling;

		//	Try to initialize FormulaAttrUpdatePollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  formulaAttrUpdatePollPeriod;
		else {
			//	Try to initialize FormulaAttrUpdatePollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  formulaAttrUpdatePollPeriod;
		}
		//	And try to extract FormulaAttrUpdatePollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  formulaAttrUpdatePollPeriod;

		//	Try to initialize EnableStatusAttrUpdatePolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableStatusAttrUpdatePolling;
		else {
			//	Try to initialize EnableStatusAttrUpdatePolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableStatusAttrUpdatePolling;
		}
		//	And try to extract EnableStatusAttrUpdatePolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableStatusAttrUpdatePolling;

		//	Try to initialize StatusAttrUpdatePollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  statusAttrUpdatePollPeriod;
		else {
			//	Try to initialize StatusAttrUpdatePollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  statusAttrUpdatePollPeriod;
		}
		//	And try to extract StatusAttrUpdatePollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  statusAttrUpdatePollPeriod;

		//	Try to initialize EnableClearTaskPolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableClearTaskPolling;
		else {
			//	Try to initialize EnableClearTaskPolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableClearTaskPolling;
		}
		//	And try to extract EnableClearTaskPolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableClearTaskPolling;

		//	Try to initialize ClearTaskPollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  clearTaskPollPeriod;
		else {
			//	Try to initialize ClearTaskPollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  clearTaskPollPeriod;
		}
		//	And try to extract ClearTaskPollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  clearTaskPollPeriod;

		//	Try to initialize EnableProxyStatusAttrCreation from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableProxyStatusAttrCreation;
		else {
			//	Try to initialize EnableProxyStatusAttrCreation from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableProxyStatusAttrCreation;
		}
		//	And try to extract EnableProxyStatusAttrCreation value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableProxyStatusAttrCreation;

		//	Try to initialize EnableAutoAdminProxyRegistration from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableAutoAdminProxyRegistration;
		else {
			//	Try to initialize EnableAutoAdminProxyRegistration from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableAutoAdminProxyRegistration;
		}
		//	And try to extract EnableAutoAdminProxyRegistration value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableAutoAdminProxyRegistration;

		//	Try to initialize ProcessEventsInQueueThread from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  processEventsInQueueThread;
		else {
			//	Try to initialize ProcessEventsInQueueThread from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  processEventsInQueueThread;
		}
		//	And try to extract ProcessEventsInQueueThread value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  processEventsInQueueThread;

	}

	/*----- PROTECTED REGION ID(LMCDevice::get_device_property_after) ENABLED START -----*/
	
	//	Check device property data members init
	
	/*----- PROTECTED REGION END -----*/	//	LMCDevice::get_device_property_after
}
//--------------------------------------------------------
/**
 *	Method      : LMCDevice::check_mandatory_property()
 *	Description : For mandatory properties check if defined in database.
 */
//--------------------------------------------------------
void LMCDevice::check_mandatory_property(Tango::DbDatum &class_prop, Tango::DbDatum &dev_prop)
{
	//	Check if all properties are empty
	if (class_prop.is_empty() && dev_prop.is_empty())
	{
		TangoSys_OMemStream	tms;
		tms << endl <<"Property \'" << dev_prop.name;
		if (Tango::Util::instance()->_UseDb==true)
			tms << "\' is mandatory but not defined in database";
		else
			tms << "\' is mandatory but cannot be defined without database";
		string	status(get_status());
		status += tms.str();
		set_status(status);
		mandatoryNotDefined = true;
		/*----- PROTECTED REGION ID(LMCDevice::check_mandatory_property) ENABLED START -----*/
		cerr << tms.str() << " for " << device_name << endl;
		
		/*----- PROTECTED REGION END -----*/	//	LMCDevice::check_mandatory_property
	}
}


//--------------------------------------------------------
/**
 *	Method      : LMCDevice::always_executed_hook()
 *	Description : method always executed before any command is executed
 */
//--------------------------------------------------------
void LMCDevice::always_executed_hook()
{
	DEBUG_STREAM << "LMCDevice::always_executed_hook()  " << device_name << endl;
	if (mandatoryNotDefined)
	{
		string	status(get_status());
		Tango::Except::throw_exception(
					(const char *)"PROPERTY_NOT_SET",
					status.c_str(),
					(const char *)"LMCDevice::always_executed_hook()");
	}
	/*----- PROTECTED REGION ID(LMCDevice::always_executed_hook) ENABLED START -----*/
	
	//	code always executed before all requests
	
	/*----- PROTECTED REGION END -----*/	//	LMCDevice::always_executed_hook
}

//--------------------------------------------------------
/**
 *	Method      : LMCDevice::read_attr_hardware()
 *	Description : Hardware acquisition for attributes
 */
//--------------------------------------------------------
void LMCDevice::read_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "LMCDevice::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(LMCDevice::read_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	LMCDevice::read_attr_hardware
}
//--------------------------------------------------------
/**
 *	Method      : LMCDevice::write_attr_hardware()
 *	Description : Hardware writing for attributes
 */
//--------------------------------------------------------
void LMCDevice::write_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "LMCDevice::write_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(LMCDevice::write_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	LMCDevice::write_attr_hardware
}

//--------------------------------------------------------
/**
 *	Read attribute loggingLevelCentral related method
 *	Description: Current  logging level to Central logging target for this device
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void LMCDevice::read_loggingLevelCentral(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LMCDevice::read_loggingLevelCentral(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(LMCDevice::read_loggingLevelCentral) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_loggingLevelCentral_read);
	
	Tango::DevLong* w_val= new Tango::DevLong;
	std::string attr_name= attr.get_assoc_name();
	get_device_attr()->get_w_attr_by_name(attr_name.c_str()).get_write_value(*w_val);
	attr.set_value(w_val,1,0,true);

	/*----- PROTECTED REGION END -----*/	//	LMCDevice::read_loggingLevelCentral
}
//--------------------------------------------------------
/**
 *	Write attribute loggingLevelCentral related method
 *	Description: Current  logging level to Central logging target for this device
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void LMCDevice::write_loggingLevelCentral(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "LMCDevice::write_loggingLevelCentral(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevLong	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(LMCDevice::write_loggingLevelCentral) ENABLED START -----*/
	attr.get_write_value(attr_loggingLevelCentral_write);

	//Change log level 
	if(attr_centralLoggerEnabled_write){
		//If given central log level is higher than other log level update main logger
		if(attr_loggingLevelCentral_write>std::max(attr_loggingLevelElement_write,attr_loggingLevelStorage_write)){
			try{
				initialize_loggers();
			}
			catch(...){
				throw;
			}
		}//close if
		else{//simply set appender level
			std::string loggingTargetCentral= std::string(attr_loggingTargetCentral_write);
			std::string central_log_target= std::string("device::") + loggingTargetCentral;
			std::transform(central_log_target.begin(), central_log_target.end(),central_log_target.begin(), ::tolower);

			if( SetAppenderLogLevel(central_log_target,attr_loggingLevelCentral_write)<0 ){
				std::string errMsg= "Failed to set log level in central log target!";
				_ERROR_LOG(errMsg);
				_THROW_TANGO_EXCEPTION("WRITE_ATTR_FAILED",errMsg);	
			}
		}//close else
	}//close if central logger enabled

	/*----- PROTECTED REGION END -----*/	//	LMCDevice::write_loggingLevelCentral
}
//--------------------------------------------------------
/**
 *	Read attribute loggingLevelElement related method
 *	Description: Current  logging level to Element logging target for this device
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void LMCDevice::read_loggingLevelElement(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LMCDevice::read_loggingLevelElement(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(LMCDevice::read_loggingLevelElement) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_loggingLevelElement_read);
	
	Tango::DevLong* w_val= new Tango::DevLong;
	std::string attr_name= attr.get_assoc_name();
	get_device_attr()->get_w_attr_by_name(attr_name.c_str()).get_write_value(*w_val);
	attr.set_value(w_val,1,0,true);

	/*----- PROTECTED REGION END -----*/	//	LMCDevice::read_loggingLevelElement
}
//--------------------------------------------------------
/**
 *	Write attribute loggingLevelElement related method
 *	Description: Current  logging level to Element logging target for this device
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void LMCDevice::write_loggingLevelElement(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "LMCDevice::write_loggingLevelElement(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevLong	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(LMCDevice::write_loggingLevelElement) ENABLED START -----*/
	attr.get_write_value(attr_loggingLevelElement_write);

	//Change log level
	if(attr_elementLoggerEnabled_write){
		//If given element log level is higher than other log level update main logger
		if(attr_loggingLevelElement_write>std::max(attr_loggingLevelCentral_write,attr_loggingLevelStorage_write)){
			try{
				initialize_loggers();
			}
			catch(...){
				throw;
			}
		}//close if
		else{
			//std::string loggingTargetElement= std::string(attr_loggingTargetElement_write);
			std::string loggingTargetElement= attr_loggingTargetElement_write;
			std::string element_log_target= std::string("device::") + loggingTargetElement;	
			std::transform(element_log_target.begin(), element_log_target.end(),element_log_target.begin(), ::tolower);

			if( SetAppenderLogLevel(element_log_target,attr_loggingLevelElement_write)<0 ){
				std::string errMsg= "Failed to set log level in element log target!";
				_ERROR_LOG(errMsg);
				_THROW_TANGO_EXCEPTION("WRITE_ATTR_FAILED",errMsg);
			}
		}//close else
	}//close if element logger enabled

	/*----- PROTECTED REGION END -----*/	//	LMCDevice::write_loggingLevelElement
}
//--------------------------------------------------------
/**
 *	Read attribute loggingLevelStorage related method
 *	Description: Current  logging level to Syslog for this device
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void LMCDevice::read_loggingLevelStorage(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LMCDevice::read_loggingLevelStorage(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(LMCDevice::read_loggingLevelStorage) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_loggingLevelStorage_read);
	
	Tango::DevLong* w_val= new Tango::DevLong;
	std::string attr_name= attr.get_assoc_name();
	get_device_attr()->get_w_attr_by_name(attr_name.c_str()).get_write_value(*w_val);
	attr.set_value(w_val,1,0,true);
	/*----- PROTECTED REGION END -----*/	//	LMCDevice::read_loggingLevelStorage
}
//--------------------------------------------------------
/**
 *	Write attribute loggingLevelStorage related method
 *	Description: Current  logging level to Syslog for this device
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void LMCDevice::write_loggingLevelStorage(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "LMCDevice::write_loggingLevelStorage(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevLong	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(LMCDevice::write_loggingLevelStorage) ENABLED START -----*/
	attr.get_write_value(attr_loggingLevelStorage_write);

	//Change log level
	if(attr_storageLoggerEnabled_write){
		//If given element log level is higher than other log level update main logger
		if(attr_loggingLevelStorage_write>std::max(attr_loggingLevelCentral_write,attr_loggingLevelElement_write)){
			try{
				initialize_loggers();
			}
			catch(...){
				throw;
			}
		}//close if
		else{
			if(Utils_ns::LoggerManager::Instance().SetLogLevel(attr_loggingLevelStorage_write)<0){
				std::string errMsg= "Failed to set log level in storage log target!";
				_ERROR_LOG(errMsg);
				_THROW_TANGO_EXCEPTION("WRITE_ATTR_FAILED",errMsg);
			}
		}//close else
	}//close if storage logger enabled
	
	/*----- PROTECTED REGION END -----*/	//	LMCDevice::write_loggingLevelStorage
}
//--------------------------------------------------------
/**
 *	Read attribute loggingLevelConsole related method
 *	Description: 
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void LMCDevice::read_loggingLevelConsole(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LMCDevice::read_loggingLevelConsole(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(LMCDevice::read_loggingLevelConsole) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_loggingLevelConsole_read);
	
	Tango::DevLong* w_val= new Tango::DevLong;
	std::string attr_name= attr.get_assoc_name();
	get_device_attr()->get_w_attr_by_name(attr_name.c_str()).get_write_value(*w_val);
	attr.set_value(w_val,1,0,true);

	/*----- PROTECTED REGION END -----*/	//	LMCDevice::read_loggingLevelConsole
}
//--------------------------------------------------------
/**
 *	Write attribute loggingLevelConsole related method
 *	Description: 
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void LMCDevice::write_loggingLevelConsole(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "LMCDevice::write_loggingLevelConsole(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevLong	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(LMCDevice::write_loggingLevelConsole) ENABLED START -----*/
	
	attr.get_write_value(attr_loggingLevelConsole_write);

	//Change log level
	std::string console_log_target= "console::cout";
	
	if( SetAppenderLogLevel(console_log_target,attr_loggingLevelConsole_write)<0 ){
		std::string errMsg= "Failed to set log level in console log target!";
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("WRITE_ATTR_FAILED",errMsg);
	}
	
	/*----- PROTECTED REGION END -----*/	//	LMCDevice::write_loggingLevelConsole
}
//--------------------------------------------------------
/**
 *	Read attribute buildState related method
 *	Description: Build state of this device
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void LMCDevice::read_buildState(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LMCDevice::read_buildState(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(LMCDevice::read_buildState) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_buildState_read);
	
	/*----- PROTECTED REGION END -----*/	//	LMCDevice::read_buildState
}
//--------------------------------------------------------
/**
 *	Read attribute centralLoggerStatus related method
 *	Description: Central logging target status. Possible values are:
 *               
 *               UNKNOWN: Typically set at device startup
 *               DISABLED: When central logging target is disabled (see device properties)
 *               OK: When central logging target is initialized with success
 *               FAILED: When central logging target initialization fails, e.g. logger is offline or proxy name invalid 
 *
 *	Data type:	Tango::DevEnum (centralLoggerStatusEnum)
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void LMCDevice::read_centralLoggerStatus(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LMCDevice::read_centralLoggerStatus(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(LMCDevice::read_centralLoggerStatus) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_centralLoggerStatus_read);
	
	/*----- PROTECTED REGION END -----*/	//	LMCDevice::read_centralLoggerStatus
}
//--------------------------------------------------------
/**
 *	Read attribute elementLoggerStatus related method
 *	Description: Element logging target status. Possible values are:
 *               
 *               UNKNOWN: Typically set at device startup
 *               DISABLED: When element logging target is disabled (see device properties)
 *               OK: When element logging target is initialized with success
 *               FAILED: When element logging target initialization fails, e.g. logger is offline or proxy name invalid 
 *
 *	Data type:	Tango::DevEnum (elementLoggerStatusEnum)
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void LMCDevice::read_elementLoggerStatus(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LMCDevice::read_elementLoggerStatus(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(LMCDevice::read_elementLoggerStatus) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_elementLoggerStatus_read);
	
	/*----- PROTECTED REGION END -----*/	//	LMCDevice::read_elementLoggerStatus
}
//--------------------------------------------------------
/**
 *	Read attribute storageLoggerStatus related method
 *	Description: Storage logging target status. Possible values are:
 *               
 *               UNKNOWN: Typically set at device startup
 *               DISABLED: When storage logging target is disabled (see device properties)
 *               OK: When storage logging target is initialized with success
 *               FAILED: When storage logging target initialization fails, e.g. logger is offline or proxy name invalid 
 *
 *	Data type:	Tango::DevEnum (storageLoggerStatusEnum)
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void LMCDevice::read_storageLoggerStatus(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LMCDevice::read_storageLoggerStatus(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(LMCDevice::read_storageLoggerStatus) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_storageLoggerStatus_read);
	
	/*----- PROTECTED REGION END -----*/	//	LMCDevice::read_storageLoggerStatus
}
//--------------------------------------------------------
/**
 *	Read attribute eventRate related method
 *	Description: Rate in Hz of events received from the device.
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void LMCDevice::read_eventRate(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LMCDevice::read_eventRate(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(LMCDevice::read_eventRate) ENABLED START -----*/
	//	Set the attribute value

	//Compute event rate
	double dt= m_eventRateSamplingTimer.elapsed_sec();
	float rate= 0;	
	if(dt>0) rate= m_eventCounter/dt;
	*attr_eventRate_read= rate;

	//Set attribute value
	attr.set_value(attr_eventRate_read);
	
	//Reset event counters & timer
	m_eventCounter= 0;
	m_eventRateSamplingTimer.restart();

	/*----- PROTECTED REGION END -----*/	//	LMCDevice::read_eventRate
}
//--------------------------------------------------------
/**
 *	Read attribute exceptionRate related method
 *	Description: Rate of internal exceptions thrown in the device
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void LMCDevice::read_exceptionRate(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LMCDevice::read_exceptionRate(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(LMCDevice::read_exceptionRate) ENABLED START -----*/
	//	Set the attribute value

	//Compute event rate
	double dt= m_exceptionRateSamplingTimer.elapsed_sec();
	float rate= 0;	
	if(dt>0) rate= m_exceptionCounter/dt;
	*attr_exceptionRate_read= rate;

	//Set attribute value
	attr.set_value(attr_exceptionRate_read);
	
	//Reset event counters & timer
	m_exceptionCounter= 0;
	m_exceptionRateSamplingTimer.restart();
	
	/*----- PROTECTED REGION END -----*/	//	LMCDevice::read_exceptionRate
}
//--------------------------------------------------------
/**
 *	Read attribute fwdAttrInitStatus related method
 *	Description: Initialization status of fwd attributes in device. 
 *               
 *               UNKNOWN: typically at startup
 *               OK: All fwd attributes initialized or no fwd attributes present in device
 *               FAILED: One/more fwd attributes not initialized yet (e.g. root device down)
 *
 *	Data type:	Tango::DevEnum (fwdAttrInitStatusEnum)
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void LMCDevice::read_fwdAttrInitStatus(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LMCDevice::read_fwdAttrInitStatus(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(LMCDevice::read_fwdAttrInitStatus) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_fwdAttrInitStatus_read);
	
	/*----- PROTECTED REGION END -----*/	//	LMCDevice::read_fwdAttrInitStatus
}
//--------------------------------------------------------
/**
 *	Read attribute centralLoggerEnabled related method
 *	Description: Enable/disable the central logger in device.
 *               NB: Attribute is not persisted after device restart.
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void LMCDevice::read_centralLoggerEnabled(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LMCDevice::read_centralLoggerEnabled(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(LMCDevice::read_centralLoggerEnabled) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_centralLoggerEnabled_read);
	
	Tango::DevBoolean* w_val= new Tango::DevBoolean;
	std::string attr_name= attr.get_assoc_name();
	get_device_attr()->get_w_attr_by_name(attr_name.c_str()).get_write_value(*w_val);
	attr.set_value(w_val,1,0,true);

	/*----- PROTECTED REGION END -----*/	//	LMCDevice::read_centralLoggerEnabled
}
//--------------------------------------------------------
/**
 *	Write attribute centralLoggerEnabled related method
 *	Description: Enable/disable the central logger in device.
 *               NB: Attribute is not persisted after device restart.
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void LMCDevice::write_centralLoggerEnabled(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "LMCDevice::write_centralLoggerEnabled(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(LMCDevice::write_centralLoggerEnabled) ENABLED START -----*/
	
	if(w_val){//enable central logger
		try{
			EnableCentralLogger();
		}
		catch(...){
			throw;
		}
		//*attr_centralLoggerEnabled_read= true;
		attr.get_write_value(attr_centralLoggerEnabled_write);
	}
	else{//disable central logger
		try{
			DisableCentralLogger();
		}
		catch(...){
			throw;	
		}
		
		attr.get_write_value(attr_centralLoggerEnabled_write);
	}
	
	/*----- PROTECTED REGION END -----*/	//	LMCDevice::write_centralLoggerEnabled
}
//--------------------------------------------------------
/**
 *	Read attribute elementLoggerEnabled related method
 *	Description: Enable/disable the central logger in device.
 *               NB: Attribute is not persisted after device restart.
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void LMCDevice::read_elementLoggerEnabled(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LMCDevice::read_elementLoggerEnabled(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(LMCDevice::read_elementLoggerEnabled) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_elementLoggerEnabled_read);
	
	Tango::DevBoolean* w_val= new Tango::DevBoolean;
	std::string attr_name= attr.get_assoc_name();
	get_device_attr()->get_w_attr_by_name(attr_name.c_str()).get_write_value(*w_val);
	attr.set_value(w_val,1,0,true);

	/*----- PROTECTED REGION END -----*/	//	LMCDevice::read_elementLoggerEnabled
}
//--------------------------------------------------------
/**
 *	Write attribute elementLoggerEnabled related method
 *	Description: Enable/disable the central logger in device.
 *               NB: Attribute is not persisted after device restart.
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void LMCDevice::write_elementLoggerEnabled(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "LMCDevice::write_elementLoggerEnabled(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(LMCDevice::write_elementLoggerEnabled) ENABLED START -----*/
	
	if(w_val){//enable Element logger
		try{
			EnableElementLogger();
		}
		catch(...){
			throw;
		}
		attr.get_write_value(attr_elementLoggerEnabled_write);
	}
	else{//disable Element logger
		try{
			DisableElementLogger();
		}
		catch(...){
			throw;	
		}
		attr.get_write_value(attr_elementLoggerEnabled_write);
	}

	
	/*----- PROTECTED REGION END -----*/	//	LMCDevice::write_elementLoggerEnabled
}
//--------------------------------------------------------
/**
 *	Read attribute storageLoggerEnabled related method
 *	Description: Enable/disable the storage logger in device.
 *               NB: Attribute is not persisted after device restart.
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void LMCDevice::read_storageLoggerEnabled(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LMCDevice::read_storageLoggerEnabled(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(LMCDevice::read_storageLoggerEnabled) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_storageLoggerEnabled_read);
	
	Tango::DevBoolean* w_val= new Tango::DevBoolean;
	std::string attr_name= attr.get_assoc_name();
	get_device_attr()->get_w_attr_by_name(attr_name.c_str()).get_write_value(*w_val);
	attr.set_value(w_val,1,0,true);

	/*----- PROTECTED REGION END -----*/	//	LMCDevice::read_storageLoggerEnabled
}
//--------------------------------------------------------
/**
 *	Write attribute storageLoggerEnabled related method
 *	Description: Enable/disable the storage logger in device.
 *               NB: Attribute is not persisted after device restart.
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void LMCDevice::write_storageLoggerEnabled(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "LMCDevice::write_storageLoggerEnabled(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(LMCDevice::write_storageLoggerEnabled) ENABLED START -----*/
	
	if(w_val){//enable storage logger
		try{
			EnableStorageLogger();
		}
		catch(...){
			throw;
		}
		attr.get_write_value(attr_storageLoggerEnabled_write);
	}
	else{//disable storage logger
		try{
			DisableStorageLogger();
		}
		catch(...){
			throw;	
		}
		attr.get_write_value(attr_storageLoggerEnabled_write);
	}

	/*----- PROTECTED REGION END -----*/	//	LMCDevice::write_storageLoggerEnabled
}
//--------------------------------------------------------
/**
 *	Read attribute loggingTargetCentral related method
 *	Description: Current Central logging target
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void LMCDevice::read_loggingTargetCentral(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LMCDevice::read_loggingTargetCentral(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(LMCDevice::read_loggingTargetCentral) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_loggingTargetCentral_read);
	
	Tango::DevString w_val;
	std::string attr_name= attr.get_assoc_name();
	get_device_attr()->get_w_attr_by_name(attr_name.c_str()).get_write_value(w_val);

	Tango::DevString* attr_val= new Tango::DevString;
	*attr_val= Tango::string_dup(w_val);
	attr.set_value(attr_val,1,0,true);


	/*----- PROTECTED REGION END -----*/	//	LMCDevice::read_loggingTargetCentral
}
//--------------------------------------------------------
/**
 *	Write attribute loggingTargetCentral related method
 *	Description: Current Central logging target
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void LMCDevice::write_loggingTargetCentral(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "LMCDevice::write_loggingTargetCentral(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevString	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(LMCDevice::write_loggingTargetCentral) ENABLED START -----*/
	
	//If logger is enabled re-initialize logger
	if(attr_centralLoggerEnabled_write){
		//Disable logger with current target
		_INFO_LOG("Disabling Central log target "<<attr_loggingTargetCentral_write<<" ...");
		try{
			DisableCentralLogger();
		}
		catch(...){
			throw;
		}	

		//If success, update write attr value
		//attr.get_write_value(attr_loggingTargetCentral_write);
		attr_loggingTargetCentral_write= std::string(w_val);
	
		//Enable logger	with new target
		try{
			EnableCentralLogger();
		}
		catch(...){
			throw;
		}
	}//close if
	else{
		//Just set w attr
		//attr.get_write_value(attr_loggingTargetCentral_write);
		attr_loggingTargetCentral_write= std::string(w_val);
	}
	
	/*----- PROTECTED REGION END -----*/	//	LMCDevice::write_loggingTargetCentral
}
//--------------------------------------------------------
/**
 *	Read attribute loggingTargetElement related method
 *	Description: Current Element logging target
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void LMCDevice::read_loggingTargetElement(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LMCDevice::read_loggingTargetElement(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(LMCDevice::read_loggingTargetElement) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_loggingTargetElement_read);
	
	Tango::DevString w_val;
	std::string attr_name= attr.get_assoc_name();
	get_device_attr()->get_w_attr_by_name(attr_name.c_str()).get_write_value(w_val);

	Tango::DevString* attr_val= new Tango::DevString;
	*attr_val= Tango::string_dup(w_val);
	attr.set_value(attr_val,1,0,true);

	/*----- PROTECTED REGION END -----*/	//	LMCDevice::read_loggingTargetElement
}
//--------------------------------------------------------
/**
 *	Write attribute loggingTargetElement related method
 *	Description: Current Element logging target
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void LMCDevice::write_loggingTargetElement(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "LMCDevice::write_loggingTargetElement(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevString	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(LMCDevice::write_loggingTargetElement) ENABLED START -----*/
	
	//If logger is enabled re-initialize logger
	if(attr_elementLoggerEnabled_write){
		//Disable logger with current target
		_INFO_LOG("Disabling Element log target "<<attr_loggingTargetElement_write<<" ...");
		try{
			DisableElementLogger();
		}
		catch(...){
			throw;
		}	

		//If success, update write attr value
		//attr.get_write_value(attr_loggingTargetElement_write);
		attr_loggingTargetElement_write= std::string(w_val);

		//Enable logger	with new target	
		_INFO_LOG("Enabling Element log target "<<attr_loggingTargetElement_write<<" ...");
		try{
			EnableElementLogger();
		}
		catch(...){
			throw;
		}
	}//close if
	else{
		//Just set w attr
		//attr.get_write_value(attr_loggingTargetElement_write);
		attr_loggingTargetElement_write= std::string(w_val);
	}
	
	/*----- PROTECTED REGION END -----*/	//	LMCDevice::write_loggingTargetElement
}
//--------------------------------------------------------
/**
 *	Read attribute loggingTargetStorage related method
 *	Description: Current storage logging target
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void LMCDevice::read_loggingTargetStorage(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LMCDevice::read_loggingTargetStorage(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(LMCDevice::read_loggingTargetStorage) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_loggingTargetStorage_read);
	
	Tango::DevString w_val;
	std::string attr_name= attr.get_assoc_name();
	get_device_attr()->get_w_attr_by_name(attr_name.c_str()).get_write_value(w_val);

	Tango::DevString* attr_val= new Tango::DevString;
	*attr_val= Tango::string_dup(w_val);
	attr.set_value(attr_val,1,0,true);


	/*----- PROTECTED REGION END -----*/	//	LMCDevice::read_loggingTargetStorage
}
//--------------------------------------------------------
/**
 *	Write attribute loggingTargetStorage related method
 *	Description: Current storage logging target
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void LMCDevice::write_loggingTargetStorage(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "LMCDevice::write_loggingTargetStorage(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevString	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(LMCDevice::write_loggingTargetStorage) ENABLED START -----*/
	
	//If logger is enabled re-initialize logger
	if(attr_storageLoggerEnabled_write){
		//Disable logger with current target
		_INFO_LOG("Disabling storage logger "<<attr_loggingTargetStorage_write<<" ...");
		try{
			DisableStorageLogger();
		}
		catch(...){
			throw;
		}	

		//If success, update write attr value
		//attr.get_write_value(attr_loggingTargetStorage_write);
		attr_loggingTargetStorage_write= std::string(w_val);

		//Enable logger	with new target
		try{
			EnableStorageLogger();
		}
		catch(...){
			throw;
		}
	}//close if
	else{
		//Just set w attr
		//attr.get_write_value(attr_loggingTargetStorage_write);
		attr_loggingTargetStorage_write= std::string(w_val);
	}
	/*----- PROTECTED REGION END -----*/	//	LMCDevice::write_loggingTargetStorage
}
//--------------------------------------------------------
/**
 *	Read attribute attrRandomizationEnabled related method
 *	Description: 
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void LMCDevice::read_attrRandomizationEnabled(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LMCDevice::read_attrRandomizationEnabled(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(LMCDevice::read_attrRandomizationEnabled) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_attrRandomizationEnabled_read);
	
	/*----- PROTECTED REGION END -----*/	//	LMCDevice::read_attrRandomizationEnabled
}
//--------------------------------------------------------
/**
 *	Write attribute attrRandomizationEnabled related method
 *	Description: 
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void LMCDevice::write_attrRandomizationEnabled(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "LMCDevice::write_attrRandomizationEnabled(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(LMCDevice::write_attrRandomizationEnabled) ENABLED START -----*/
	
	if(w_val){//Enable randomization + start thread (if not started yet)
		if(!m_attrRandomizerThread->IsStarted()) m_attrRandomizerThread->Start();
		m_attrRandomizerThread->EnableRandomization();
	}
	else{//Disable randomization
		m_attrRandomizerThread->DisableRandomization();
	}

	//Set randomizer flag
	*attr_attrRandomizationEnabled_read= m_attrRandomizerThread->GetRandomizationFlag();
	
	/*----- PROTECTED REGION END -----*/	//	LMCDevice::write_attrRandomizationEnabled
}
//--------------------------------------------------------
/**
 *	Read attribute attrRandomizationPeriod related method
 *	Description: 
 *
 *	Data type:	Tango::DevULong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void LMCDevice::read_attrRandomizationPeriod(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LMCDevice::read_attrRandomizationPeriod(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(LMCDevice::read_attrRandomizationPeriod) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_attrRandomizationPeriod_read);
	
	/*----- PROTECTED REGION END -----*/	//	LMCDevice::read_attrRandomizationPeriod
}
//--------------------------------------------------------
/**
 *	Write attribute attrRandomizationPeriod related method
 *	Description: 
 *
 *	Data type:	Tango::DevULong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void LMCDevice::write_attrRandomizationPeriod(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "LMCDevice::write_attrRandomizationPeriod(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevULong	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(LMCDevice::write_attrRandomizationPeriod) ENABLED START -----*/
	
	//Set randomizer flag
	m_attrRandomizerThread->SetRandomizationPeriod(static_cast<long>(w_val));
	*attr_attrRandomizationPeriod_read= m_attrRandomizerThread->GetRandomizationPeriod();
	
	/*----- PROTECTED REGION END -----*/	//	LMCDevice::write_attrRandomizationPeriod
}

//--------------------------------------------------------
/**
 *	Method      : LMCDevice::add_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *                for specified device.
 */
//--------------------------------------------------------
void LMCDevice::add_dynamic_attributes()
{
	/*----- PROTECTED REGION ID(LMCDevice::add_dynamic_attributes) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic attributes if any

	//## Initialize dyn attr manager
	m_dam= 0;
	m_dam= new yat4tango::DynamicAttributeManager(this);

	//#######  DEBUG (REMOVE IF NOT WORKING) ###############
	//## Register device proxies
	_INFO_LOG("Registering device proxies in device...");
	if(DoProxyRegistration()<0){
		std::string errMsg("Failed to register proxies in device (proxy names invalid or not found?)!");
		_ERROR_LOG(errMsg);
		set_status(errMsg.c_str());
		set_state(Tango::FAULT);
	}
	
	
	//## Register event subscriptions in device
	_INFO_LOG("Registering event subscriptions in device...");
	if(DoEventSubscriptionRegistration()<0){
		std::string errMsg("Failed to register event subscriptions in device (invalid event info?)!");
		_ERROR_LOG(errMsg);
		set_status(errMsg.c_str());
		set_state(Tango::FAULT);
	}
	
	/*
	//## Register event handlers in device (moved after dyn attr creation)
	_INFO_LOG("Registering event handlers in device...");
	if(DoEventHandlersRegistration()<0){
		std::string errMsg("Failed to register event handlers (cmd handler(s) not found?)!");
		_ERROR_LOG(errMsg);
		set_status(errMsg.c_str());
		set_state(Tango::FAULT);
	}
	*/
	
	//## Try to initialize proxy devices (proxies can be offline, so initialization will be periodically performed)
	//## NB: to be performed after proxy & event registration!
	_INFO_LOG("Initialize and subscribe device proxies...");
	if(InitDevProxies()<0){
		std::string errMsg("Failed to initialize device proxies (proxies offline?), will retry later...");
		_WARN_LOG(errMsg);
	}
	

	//## Register attr formulas
	//...
	//...

	//##############################


	//###### DEBUG 2 (REMOVE IF NOT WORKING) ###############
	//Add dynamic attributes from config file
	_INFO_LOG("Adding dynamic attributes from config file...");
	if(AddDynAttrs()<0){
		std::string errMsg("Failed to create dyn attributes!");
		_ERROR_LOG(errMsg);
		set_status(errMsg.c_str());
		set_state(Tango::FAULT);
		return;
	}
	
	//Configure state machine for cmd & attrs
	_INFO_LOG("Configuring cmd/attr state machine rules...");
	if(InitCmdAttrStateMachine()<0){
		std::string errMsg("Failed to create cmd & attr state machines for dyn attributes!");
		_ERROR_LOG(errMsg);
		set_status(errMsg.c_str());
		set_state(Tango::FAULT);
		return;
	}
	//########################################################


	//###### DEBUG 3 (REMOVE IF NOT WORKING) ###############
	
	//## Register event handlers in device
	_INFO_LOG("Registering event handlers in device...");
	if(DoEventHandlersRegistration()<0){
		std::string errMsg("Failed to register event handlers (cmd handler(s) not found?)!");
		_ERROR_LOG(errMsg);
		set_status(errMsg.c_str());
		set_state(Tango::FAULT);
	}

	
	/*----- PROTECTED REGION END -----*/	//	LMCDevice::add_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Command InitializeLoggers related method
 *	Description: Initialize loggers
 *
 */
//--------------------------------------------------------
void LMCDevice::initialize_loggers()
{
	DEBUG_STREAM << "LMCDevice::InitializeLoggers()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCDevice::initialize_loggers) ENABLED START -----*/
	
	//	Add your own code

	//List all appenders
	log4tango::AppenderList appenders= get_logger()->get_all_appenders();
	_DEBUG_LOG("#"<<appenders.size()<<" appenders present...");
		
	for(unsigned int i=0;i<appenders.size();i++){
		std::string this_appender_name= appenders[i]->get_name();
		int log_target= Utils_ns::TangoUtils::GetLogAppenderType(appenders[i]);
		
		//Get log4tango appender level
		log4tango::Level::Value log4tango_level= appenders[i]->get_level();
		bool isLevelEnabled= this->get_logger()->is_level_enabled(log4tango_level);

		//Convert log4tango log level to Tango log level
		Tango::LogLevel tango_level= Tango::Logging::log4tango_to_tango_level(log4tango_level);
		int log_level= static_cast<Tango::DevLong>(tango_level);

		_DEBUG_LOG("Appender no. "<<i<<", name="<<this_appender_name<<", type="<<log_target<<", log_level="<<log_level<<" (log4tango_level="<<log4tango_level<<"), isLevelEnabled? "<<isLevelEnabled);
	}

	//Initialize loggers
	try{
		if(InitLoggers()<0){
			_WARN_LOG("One/more errors occurred while initializing loggers (e.g. log consumers offline), will retry later...");
		}
	}
	catch(...){
		std::string errMsg= "Exception occurred while initializing loggers!";
		_ERROR_LOG(errMsg);
		set_status(errMsg.c_str());
		set_state(Tango::FAULT);
		_THROW_TANGO_EXCEPTION("INITIALIZE_LOGGERS_FAILED",errMsg);
	}

	/*----- PROTECTED REGION END -----*/	//	LMCDevice::initialize_loggers
}
//--------------------------------------------------------
/**
 *	Command InitializeFwdAttrs related method
 *	Description: Initialize fwd attributes. 
 *               Fwd attributes are dynamically added at device startup. 
 *               However when the root device server is down the initialization
 *               fails. This command is supposed to be run periodically to
 *               ensure fwd are created if the root device comes online.
 *
 */
//--------------------------------------------------------
void LMCDevice::initialize_fwd_attrs()
{
	DEBUG_STREAM << "LMCDevice::InitializeFwdAttrs()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCDevice::initialize_fwd_attrs) ENABLED START -----*/
	
	//	Add your own code
	//Check if device has dyn attrs
	size_t nDynAttrs= m_device_attr.size();
	if(nDynAttrs<=0) return;

	//Loop over all dynamic attributes and initialize their values
	int status= 0;
	for(size_t i=0;i<nDynAttrs;i++){
		if(!m_device_attr[i]) continue;
		std::string attr_name= m_device_attr[i]->GetAttr()->get_name();
		bool isForwarded= m_device_attr[i]->IsForwarded(); 		
		if(!isForwarded) continue;

		_DEBUG_LOG("Creating fwd attr "<<attr_name<<"...");
		/*
		if(AddDynFwdAttr(m_device_attr[i],false)<0){
			_WARN_LOG("Failed to create dyn fwd attr "<<attr_name<<"!");
			continue;
		}
		*/

		try{
			AddDynFwdAttr(m_device_attr[i],false);
		}
		catch(...){
			_WARN_LOG("Failed to create dyn fwd attr "<<attr_name<<"!");
			status= -1;
			continue;
		}

	}//end loop dyn attrs

	if(status==0){
		*attr_fwdAttrInitStatus_read= fwdAttrInitStatusEnum::_OK;
	}	
	else{
		*attr_fwdAttrInitStatus_read= fwdAttrInitStatusEnum::_FAILED;
	}

	/*----- PROTECTED REGION END -----*/	//	LMCDevice::initialize_fwd_attrs
}
//--------------------------------------------------------
/**
 *	Command RandomizeDynAttrs related method
 *	Description: Randomize dynamical attribute (if enabled)
 *
 */
//--------------------------------------------------------
void LMCDevice::randomize_dyn_attrs()
{
	DEBUG_STREAM << "LMCDevice::RandomizeDynAttrs()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCDevice::randomize_dyn_attrs) ENABLED START -----*/
	
	//	Add your own code
	//Check if device has dyn attrs
	if(!enableDynAttrRandomize){
		std::string errMsg("Dyn attribute randomization is disabled (if you want this feature, enable the property)!");
		_WARN_LOG(errMsg);	
		_THROW_RECORDED_TANGO_EXCEPTION("RANDOMIZE_DYN_ATTR_FAILED",errMsg);	
		return;
	}	

	size_t nDynAttrs= m_device_attr.size();
	if(nDynAttrs<=0) return;

	//Loop over all dynamic attributes and randomize their values
	for(size_t i=0;i<nDynAttrs;i++){
		if(!m_device_attr[i]) continue;
		std::string attr_name= m_device_attr[i]->GetAttr()->get_name();
		bool isForwarded= m_device_attr[i]->IsForwarded(); 		
		if(isForwarded) continue;

		_DEBUG_LOG("Randomizing dyn attr "<<attr_name<<"...");
		if(RandomizeDynAttrValue(attr_name)<0){
			_WARN_LOG("Failed to randomize value of attribute "<<attr_name<<"!");
			continue;
		}
	}//end loop dyn attrs

	/*----- PROTECTED REGION END -----*/	//	LMCDevice::randomize_dyn_attrs
}
//--------------------------------------------------------
/**
 *	Command InitializeDevProxies related method
 *	Description: Initialize device proxies. This command is periodically polled.
 *
 */
//--------------------------------------------------------
void LMCDevice::initialize_dev_proxies()
{
	DEBUG_STREAM << "LMCDevice::InitializeDevProxies()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCDevice::initialize_dev_proxies) ENABLED START -----*/
	
	//	Add your own code
	try{
		if(InitDevProxies()<0){
			std::string errMsg("Failed to initialize device proxies (proxies offline?), will retry later...");
			_WARN_LOG(errMsg);
		}
	}
	catch(Tango::DevFailed& e){
		std::string errMsg("Failed to initialize device proxies (wrong name syntax?)!");
		_ERROR_LOG(errMsg);
		set_status(errMsg.c_str());
		set_state(Tango::FAULT);
		throw;
	}

	/*----- PROTECTED REGION END -----*/	//	LMCDevice::initialize_dev_proxies
}
//--------------------------------------------------------
/**
 *	Command GetRegisteredProxies related method
 *	Description: Return list of device proxies registered in device
 *
 *	@returns 
 */
//--------------------------------------------------------
Tango::DevVarStringArray *LMCDevice::get_registered_proxies()
{
	Tango::DevVarStringArray *argout;
	DEBUG_STREAM << "LMCDevice::GetRegisteredProxies()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCDevice::get_registered_proxies) ENABLED START -----*/
	
	//	Add your own code
	
	//## Get list of registered proxies from manager	
	if(!m_proxyManager){
		std::string errMsg("Proxy manager was not initialized!");
		_WARN_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("GET_REGISTERED_PROXIES_FAILED",errMsg);			
	}
	std::vector<std::string> proxy_names= m_proxyManager->GetRegisteredProxyNames();
	//if(proxy_names.empty()) return argout;
	
	_DEBUG_LOG("#"<<proxy_names.size()<<" proxies registered...");

	argout= new Tango::DevVarStringArray();
	argout->length(proxy_names.size());	
	for(unsigned int i=0;i<proxy_names.size();i++){
		_DEBUG_LOG("--> Proxy no. "<<i<<": "<<proxy_names[i]);
		(*argout)[i]= CORBA::string_dup(proxy_names[i].c_str());
	}

	/*----- PROTECTED REGION END -----*/	//	LMCDevice::get_registered_proxies
	return argout;
}
//--------------------------------------------------------
/**
 *	Command GetRegisteredEvents related method
 *	Description: Get list of registered events in device
 *
 *	@returns 
 */
//--------------------------------------------------------
Tango::DevVarStringArray *LMCDevice::get_registered_events()
{
	Tango::DevVarStringArray *argout;
	DEBUG_STREAM << "LMCDevice::GetRegisteredEvents()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCDevice::get_registered_events) ENABLED START -----*/
	
	//	Add your own code

	//## Get list of registered proxies from manager	
	if(!m_proxyManager){
		std::string errMsg("Proxy manager was not initialized!");
		_WARN_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("GET_REGISTERED_EVENTS_FAILED",errMsg);			
	}
	std::vector<std::string> event_names= m_proxyManager->GetRegisteredEventNames();
	_DEBUG_LOG("#"<<event_names.size()<<" events registered...");
	//if(event_names.empty()) return argout;
	
	argout= new Tango::DevVarStringArray();
	argout->length(event_names.size());	
	for(unsigned int i=0;i<event_names.size();i++){
		(*argout)[i]= CORBA::string_dup(event_names[i].c_str());
	}

	/*----- PROTECTED REGION END -----*/	//	LMCDevice::get_registered_events
	return argout;
}
//--------------------------------------------------------
/**
 *	Command GetRegisteredFormulas related method
 *	Description: Returns a list of attr formulas currently registered in 
 *               device and expressed in json format.
 *
 *	@returns The list of attr formulas currently registered in device 
 *           and expressed in json format.
 */
//--------------------------------------------------------
Tango::DevVarStringArray *LMCDevice::get_registered_formulas()
{
	Tango::DevVarStringArray *argout;
	DEBUG_STREAM << "LMCDevice::GetRegisteredFormulas()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCDevice::get_registered_formulas) ENABLED START -----*/
	
	//	Add your own code
	if(!m_proxyManager || !m_formulaManager){
		std::string errMsg("Proxy and/or formula manager was not initialized!");
		_WARN_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("GET_REGISTERED_FORMULAS_FAILED",errMsg);			
	}

	std::vector<std::string> registered_formulas;
	m_formulaManager->GetRegisteredFormulasInJson(registered_formulas);
	//if(registered_formulas.empty()) return argout;
	
	argout= new Tango::DevVarStringArray();
	argout->length(registered_formulas.size());	
	for(unsigned int i=0;i<registered_formulas.size();i++){
		(*argout)[i]= CORBA::string_dup(registered_formulas[i].c_str());
	}

	/*----- PROTECTED REGION END -----*/	//	LMCDevice::get_registered_formulas
	return argout;
}
//--------------------------------------------------------
/**
 *	Command GetInitializedFormulas related method
 *	Description: 
 *
 *	@returns 
 */
//--------------------------------------------------------
Tango::DevVarStringArray *LMCDevice::get_initialized_formulas()
{
	Tango::DevVarStringArray *argout;
	DEBUG_STREAM << "LMCDevice::GetInitializedFormulas()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCDevice::get_initialized_formulas) ENABLED START -----*/
	
	//	Add your own code
	if(!m_proxyManager || !m_formulaManager){
		std::string errMsg("Proxy and/or formula manager was not initialized!");
		_WARN_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("GET_REGISTERED_FORMULAS_FAILED",errMsg);			
	}

	std::vector<std::string> initialized_formulas;
	m_formulaManager->GetInitializedFormulasInJson(initialized_formulas);
	//if(initialized_formulas.empty()) return argout;
	
	argout= new Tango::DevVarStringArray();
	argout->length(initialized_formulas.size());	
	for(unsigned int i=0;i<initialized_formulas.size();i++){
		(*argout)[i]= CORBA::string_dup(initialized_formulas[i].c_str());
	}

	/*----- PROTECTED REGION END -----*/	//	LMCDevice::get_initialized_formulas
	return argout;
}
//--------------------------------------------------------
/**
 *	Command GetNRunningTasks related method
 *	Description: Get number of running tasks present in list
 *
 *	@returns The number of running tasks
 */
//--------------------------------------------------------
Tango::DevLong LMCDevice::get_nrunning_tasks()
{
	Tango::DevLong argout;
	DEBUG_STREAM << "LMCDevice::GetNRunningTasks()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCDevice::get_nrunning_tasks) ENABLED START -----*/
	
	//	Add your own code
	//Check if task manager is instantiated, otherwise throw exception
	if(!m_taskManager){
		std::string errMsg("Task manager was not initialized!");
		_WARN_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("GET_N_RUNNING_TASKS_FAILED",errMsg);	
	}

	//Returns number of tasks in RUNNING state
	//argout= m_taskManager->GetNRunningTasks();
	argout= m_taskManager->GetNRunningSequenceTasks();
	
	/*----- PROTECTED REGION END -----*/	//	LMCDevice::get_nrunning_tasks
	return argout;
}
//--------------------------------------------------------
/**
 *	Command GetNQueuedTasks related method
 *	Description: Get the number of tasks currently present in the queue
 *               (not in the list)
 *               
 *               NB: The list contains a cache of lately performed tasks and
 *               therefore stores also completed, running, failed tasks.
 *               The queue contains typically only IDLE tasks.
 *
 *	@returns The number of queued tasks
 */
//--------------------------------------------------------
Tango::DevLong LMCDevice::get_nqueued_tasks()
{
	Tango::DevLong argout;
	DEBUG_STREAM << "LMCDevice::GetNQueuedTasks()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCDevice::get_nqueued_tasks) ENABLED START -----*/
	
	//	Add your own code
	//Check if task manager is instantiated, otherwise throw exception
	if(!m_taskManager){
		std::string errMsg("Task manager was not initialized!");
		_WARN_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("GET_N_QUEUED_TASKS_FAILED",errMsg);	
	}

	//Returns number of tasks present in the queue (all states)
	argout= m_taskManager->GetNTasksInQueue();
	
	/*----- PROTECTED REGION END -----*/	//	LMCDevice::get_nqueued_tasks
	return argout;
}
//--------------------------------------------------------
/**
 *	Command GetNIdleTasks related method
 *	Description: Get number of tasks in IDLE state present in list
 *
 *	@returns 
 */
//--------------------------------------------------------
Tango::DevLong LMCDevice::get_nidle_tasks()
{
	Tango::DevLong argout;
	DEBUG_STREAM << "LMCDevice::GetNIdleTasks()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCDevice::get_nidle_tasks) ENABLED START -----*/
	
	//	Add your own code
	//Check if task manager is instantiated, otherwise throw exception
	if(!m_taskManager){
		std::string errMsg("Task manager was not initialized!");
		_WARN_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("GET_N_IDLE_TASKS_FAILED",errMsg);	
	}

	//Returns number of tasks present in the queue (all states)
	//argout= m_taskManager->GetNIdleTasks();
	argout= m_taskManager->GetNIdleSequenceTasks();

	/*----- PROTECTED REGION END -----*/	//	LMCDevice::get_nidle_tasks
	return argout;
}
//--------------------------------------------------------
/**
 *	Command GetNTasks related method
 *	Description: Get the number of tasks currently present in the list
 *               (not in the queue)
 *               
 *               NB: The list contains a cache of lately performed tasks and
 *               therefore stores also completed, running, failed tasks.
 *               The queue contains typically only IDLE tasks.
 *
 *	@returns Number of tasks
 */
//--------------------------------------------------------
Tango::DevLong LMCDevice::get_ntasks()
{
	Tango::DevLong argout;
	DEBUG_STREAM << "LMCDevice::GetNTasks()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCDevice::get_ntasks) ENABLED START -----*/
	
	//	Add your own code
	//Check if task manager is instantiated, otherwise throw exception
	if(!m_taskManager){
		std::string errMsg("Task manager was not initialized!");
		_WARN_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("GET_N_TASKS_FAILED",errMsg);	
	}

	//Returns number of tasks present in the queue (all states)
	//argout= m_taskManager->GetNTasks();
	argout= m_taskManager->GetNSequenceTasks();

	/*----- PROTECTED REGION END -----*/	//	LMCDevice::get_ntasks
	return argout;
}
//--------------------------------------------------------
/**
 *	Command GetNFailedTasks related method
 *	Description: Get the number of tasks in FAILED state present in the list
 *
 *	@returns 
 */
//--------------------------------------------------------
Tango::DevLong LMCDevice::get_nfailed_tasks()
{
	Tango::DevLong argout;
	DEBUG_STREAM << "LMCDevice::GetNFailedTasks()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCDevice::get_nfailed_tasks) ENABLED START -----*/
	
	//	Add your own code
	//Check if task manager is instantiated, otherwise throw exception
	if(!m_taskManager){
		std::string errMsg("Task manager was not initialized!");
		_WARN_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("GET_N_FAILED_TASKS_FAILED",errMsg);	
	}

	//Returns number of tasks present in the queue (all states)
	//argout= m_taskManager->GetNFailedTasks();
	argout= m_taskManager->GetNFailedSequenceTasks();

	/*----- PROTECTED REGION END -----*/	//	LMCDevice::get_nfailed_tasks
	return argout;
}
//--------------------------------------------------------
/**
 *	Command GetNTotFailedTasks related method
 *	Description: Get the number of total tasks FAILED (including also 
 *               EXPIRED and ABORTED)
 *
 *	@returns 
 */
//--------------------------------------------------------
Tango::DevLong LMCDevice::get_ntot_failed_tasks()
{
	Tango::DevLong argout;
	DEBUG_STREAM << "LMCDevice::GetNTotFailedTasks()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCDevice::get_ntot_failed_tasks) ENABLED START -----*/
	
	//	Add your own code
	//Check if task manager is instantiated, otherwise throw exception
	if(!m_taskManager){
		std::string errMsg("Task manager was not initialized!");
		_WARN_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("GET_N_TOT_FAILED_TASKS_FAILED",errMsg);	
	}

	//Returns number of tasks present in the queue (all states)
	//argout= m_taskManager->GetNTotFailedTasks();
	argout= m_taskManager->GetNTotFailedSequenceTasks();

	/*----- PROTECTED REGION END -----*/	//	LMCDevice::get_ntot_failed_tasks
	return argout;
}
//--------------------------------------------------------
/**
 *	Command IsTaskQuotaReached related method
 *	Description: Return true if task quota is reached in device and 
 *               false otherwise.
 *               Task quota parameters can be modified in device properties.
 *
 *	@returns The task quota flag
 */
//--------------------------------------------------------
Tango::DevBoolean LMCDevice::is_task_quota_reached()
{
	Tango::DevBoolean argout;
	DEBUG_STREAM << "LMCDevice::IsTaskQuotaReached()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCDevice::is_task_quota_reached) ENABLED START -----*/
	
	//	Add your own code
	//Check if task manager is instantiated, otherwise throw exception
	if(!m_taskManager){
		std::string errMsg("Task manager was not initialized!");
		_WARN_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("IS_TASK_QUOTA_REACHED_FAILED",errMsg);	
	}

	//Returns number of tasks present in the queue (all states)
	argout= m_taskManager->IsTaskQuotaReached();


	/*----- PROTECTED REGION END -----*/	//	LMCDevice::is_task_quota_reached
	return argout;
}
//--------------------------------------------------------
/**
 *	Command FlushTaskQueue related method
 *	Description: Remove all tasks from the queue
 *
 */
//--------------------------------------------------------
void LMCDevice::flush_task_queue()
{
	DEBUG_STREAM << "LMCDevice::FlushTaskQueue()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCDevice::flush_task_queue) ENABLED START -----*/
	
	//	Add your own code
	//Check if task manager is instantiated, otherwise throw exception
	if(!m_taskManager){
		std::string errMsg("Task manager was not initialized!");
		_WARN_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("FLUSH_QUEUE_FAILED",errMsg);	
	}

	//Remove all tasks present in the queue and remove IDLE tasks in list
	if(m_taskManager->FlushQueue()<0){
		std::string errMsg("Failed to flush the task queue!");
		_WARN_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("FLUSH_QUEUE_FAILED",errMsg);	
	}

	/*----- PROTECTED REGION END -----*/	//	LMCDevice::flush_task_queue
}
//--------------------------------------------------------
/**
 *	Command GetQueuedTaskInfo related method
 *	Description: Return the queued task info
 *
 *	@returns 
 */
//--------------------------------------------------------
Tango::DevVarStringArray *LMCDevice::get_queued_task_info()
{
	Tango::DevVarStringArray *argout;
	DEBUG_STREAM << "LMCDevice::GetQueuedTaskInfo()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCDevice::get_queued_task_info) ENABLED START -----*/
	
	//	Add your own code
	
	//Check if task manager is instantiated, otherwise throw exception
	if(!m_taskManager){
		std::string errMsg("Task manager was not initialized!");
		_WARN_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("GET_QUEUED_TASK_INFO_FAILED",errMsg);	
	}

	//Get queued task info from manager
	std::vector<std::string> info;
	m_taskManager->GetQueuedTaskInfo(info);

	//Fill argout
	argout= new Tango::DevVarStringArray;
	argout->length(info.size());
	for(unsigned int i=0;i<info.size();i++){
		(*argout)[i] = CORBA::string_dup(info[i].c_str());
	}

	/*----- PROTECTED REGION END -----*/	//	LMCDevice::get_queued_task_info
	return argout;
}
//--------------------------------------------------------
/**
 *	Command GetTaskInfo related method
 *	Description: Return the task info for tasks present in the list
 *
 *	@returns 
 */
//--------------------------------------------------------
Tango::DevVarStringArray *LMCDevice::get_task_info()
{
	Tango::DevVarStringArray *argout;
	DEBUG_STREAM << "LMCDevice::GetTaskInfo()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCDevice::get_task_info) ENABLED START -----*/
	
	//	Add your own code
	//Check if task manager is instantiated, otherwise throw exception
	if(!m_taskManager){
		std::string errMsg("Task manager was not initialized!");
		_WARN_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("GET_TASK_INFO_FAILED",errMsg);	
	}

	//Get task info from manager
	std::vector<std::string> info;
	//m_taskManager->GetTaskInfo(info);
	m_taskManager->GetSequenceTaskInfo(info);

	//Fill argout
	argout= new Tango::DevVarStringArray;
	argout->length(info.size());
	for(size_t i=0;i<info.size();i++){
		(*argout)[i] = CORBA::string_dup(info[i].c_str());
	}

	/*----- PROTECTED REGION END -----*/	//	LMCDevice::get_task_info
	return argout;
}
//--------------------------------------------------------
/**
 *	Command ClearTasks related method
 *	Description: Clear tasks older than the specified time depth property
 *
 */
//--------------------------------------------------------
void LMCDevice::clear_tasks()
{
	DEBUG_STREAM << "LMCDevice::ClearTasks()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCDevice::clear_tasks) ENABLED START -----*/
	
	//	Add your own code
	//Check if task manager is instantiated, otherwise throw exception
	if(!m_taskManager){
		std::string errMsg("Task manager was not initialized!");
		_WARN_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("CLEAR_TASKS_FAILED",errMsg);	
	}

	bool keepRunningTasks= true;
	bool useUTC= false;
	if(m_taskManager->ClearSequenceTasks(taskHistoryTimeDepth,keepRunningTasks,useUTC)<0){
		std::string errMsg("Failed to clear tasks");
		_WARN_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("CLEAR_TASKS_FAILED",errMsg);	
	}	

	/*----- PROTECTED REGION END -----*/	//	LMCDevice::clear_tasks
}
//--------------------------------------------------------
/**
 *	Command UpdateFormulaAttrs related method
 *	Description: Initialize and update attr formula registered in device. 
 *               This is needed since device proxies specified in attr formula
 *               may be offline when the formula is initially registered and 
 *               initialized. This command is periodically executed to ensure
 *               that when proxies are online the formula is initialized.
 *               It is also used to trigger switching of formula attr quality
 *               factor to INVALID when one/more formula vars are old (e.g.
 *               proxy down or events not received).
 *
 */
//--------------------------------------------------------
void LMCDevice::update_formula_attrs()
{
	DEBUG_STREAM << "LMCDevice::UpdateFormulaAttrs()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCDevice::update_formula_attrs) ENABLED START -----*/
	
	//	Add your own code
	
	//Get formula data registered
	std::vector<std::string> formula_attr_names;
	std::vector<Utils_ns::FormulaData*> formula_data_list;
	m_formulaManager->GetFormulaDataList(formula_attr_names,formula_data_list);
	if(formula_data_list.empty()){
		_DEBUG_LOG("No formulas registered, nothing to be initialized...");
		return;
	}	
	_DEBUG_LOG("Trying to initialize "<<formula_data_list.size()<<" registered formulas ...");

	bool emit_event= false;

	for(unsigned int i=0;i<formula_data_list.size();i++){

		//First try to initialize formula (if not already done)
		if(InitializeFormula(formula_attr_names[i],formula_data_list[i])<0){
			_WARN_LOG("Failed to initialize formula for attr "<<formula_attr_names[i]<<", skip to next formula attr...");
			continue;
		}

		//If formula is initialized evaluate it
		//NB: This is to refresh attr value and trigger quality factor switching to INVALID
		//when one/more formula vars are "old" (e.g. proxy down, events not received, etc)
		if(SetDynAttrValueFromFormula(formula_attr_names[i],formula_data_list[i],emit_event)<0){
			_WARN_LOG("Failed to set attr "<<formula_attr_names[i]<<" from formula, skip to next formula attr...");
			continue;
		}
		
	}//end loop formula attrs
	
	/*----- PROTECTED REGION END -----*/	//	LMCDevice::update_formula_attrs
}
//--------------------------------------------------------
/**
 *	Command UpdateStatusAttrs related method
 *	Description: Update status attribute values from task manager info
 *
 */
//--------------------------------------------------------
void LMCDevice::update_status_attrs()
{
	DEBUG_STREAM << "LMCDevice::UpdateStatusAttrs()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCDevice::update_status_attrs) ENABLED START -----*/
	
	//	Add your own code
	//## Check task manager
	if(!m_taskManager){
		std::string errMsg("Task manager was not initialized!");
		_WARN_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("UPDATE_TASK_STATUS_ATTRS_FAILED",errMsg);	
	}

	//## Iterate over status attr and update their status reading it from the TaskManager
	_DEBUG_LOG("#"<<taskSequenceStatusAttrList.size()<<" status attr present in device...");

	for(unsigned int i=0;i<taskSequenceStatusAttrList.size();i++){
		std::string attr_name= taskSequenceStatusAttrList[i];

		_DEBUG_LOG("Updating status attr "<<attr_name<<"...");

		//Get task sequence info
		std::vector<Utils_ns::TaskInfo> status_info_list;
		if(m_taskManager->GetTaskSequenceStatusInfo(status_info_list,true,attr_name)<0){
			_WARN_LOG("Failed to get task sequence info to update attr "<<attr_name<<", skip to next attr...");
			continue;
		}
		if(status_info_list.empty()){
			_DEBUG_LOG("No task status info present for attr "<<attr_name<<", nothing to be done, skip to next status attr...");
			continue;
		}
		
		//If more than one info is present update attr with the most recent timestamp
		_DEBUG_LOG("#"<<status_info_list.size()<<" task info corresponding to status attr "<<attr_name<<"...");
		int mostRecentTaskIndex= -1;
		double mostRecentTaskTimestamp= -1.e+99;
		for(unsigned int i=0;i<status_info_list.size();i++){
			double t= status_info_list[i].creation_timestamp;
			if(t>mostRecentTaskTimestamp){
				mostRecentTaskTimestamp= t;
				mostRecentTaskIndex= i;
			}
		}//end loop status info list

		if(mostRecentTaskIndex<0){
			_WARN_LOG("Failed to find task index (should not occur), skip to next attr...");
			continue;
		}

		//Get dyn attr value
		std::vector<std::string> attr_values;
		if(GetDynAttrValue(attr_values,attr_name)<0){
			_WARN_LOG("Failed to get dyn attr "<<attr_name<<" value, skip to next attr...");
			continue;
		}

		//Update dyn attr value field with status info
		//[0]: task name (do not touch)
		//[1]: task status (update!)
		//[2]: task status info (update!)
		int status= status_info_list[mostRecentTaskIndex].status;
		std::string status_str= "";
		if(Utils_ns::TaskManager::GetTaskStatusString(status_str,status)<0){
			_WARN_LOG("Failed to convert task status code ("<<status<<") to string (invalid status code?), skip to next attr...");
			continue;
		}
		std::string status_info= status_info_list[mostRecentTaskIndex].status_info;
		
		//attr_values[1]= status_info_list[mostRecentTaskIndex].status;
		//attr_values[2]= status_info_list[mostRecentTaskIndex].status_info;
		//_DEBUG_LOG("Status attr "<<attr_name<<" updated value: {status="<<attr_values[1]<<", info="<<attr_values[2]<<"}");
		attr_values[0]= status_str;
		attr_values[1]= status_info;
		_DEBUG_LOG("Status attr "<<attr_name<<" updated value: {status="<<attr_values[0]<<", info="<<attr_values[1]<<"}");
	

		bool emit_event= false;
		Tango::AttrQuality attr_quality= Tango::ATTR_VALID;
		if(SetDynAttrValue<std::string>(attr_values,attr_name,attr_quality,emit_event)<0){
			_WARN_LOG("Failed to update attr "<<attr_name<<" with latest task info (status="<<status_str<<", info="<<status_info<<", skip to next attr...");
			continue;
		}

	}//end loop status attributes

	
	/*----- PROTECTED REGION END -----*/	//	LMCDevice::update_status_attrs
}
//--------------------------------------------------------
/**
 *	Command MonitorProxies related method
 *	Description: Monitor list of registered proxies
 *
 */
//--------------------------------------------------------
void LMCDevice::monitor_proxies()
{
	DEBUG_STREAM << "LMCDevice::MonitorProxies()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCDevice::monitor_proxies) ENABLED START -----*/
	
	//	Add your own code

	//## Check proxy manager
	if(!m_proxyManager){
		_DEBUG_LOG("Null ptr to proxy manager (did you initialize it?)!");
		return;
	}
	
	//## Get list of registered proxies and store name of expcted proxy attr inf device
	std::vector<std::string> proxy_names= m_proxyManager->GetRegisteredProxyNames();
	if(proxy_names.empty()) return; 

	_DEBUG_LOG("#"<<proxy_names.size()<<" to be monitored...");
	
	//## Monitor proxies and update proxy attr values
	for(unsigned int i=0;i<proxy_names.size();i++){
		_DEBUG_LOG("Monitoring proxy "<<proxy_names[i]<<"...");
		
		//## Monitor proxy and get proxy updated info
		//## Behavior: Manager finds proxy helper and then call Monitor() on it
		//## NB: Proxy helper mutex is locked 
		std::vector<std::string> proxy_info;
		if(m_proxyManager->MonitorProxy(proxy_names[i],proxy_info)<0){
			_WARN_LOG("Failed to monitor proxy "<<proxy_names[i]<<", skip to next proxy in list...");
			continue;
		}
		_DEBUG_LOG("Proxy monitoring info: runStatus="<<proxy_info[0]<<", info="<<proxy_info[1]);

		//If monitoring succeeded set proxy info to device attribute
		//First Parse proxy name to get domain, family and device name
		if(enableProxyStatusAttrCreation){
			std::string proxy_facility_name= "";
			std::string proxy_domain_name= "";
			std::string proxy_family_name= "";
			std::string proxy_member_name= "";
			if(Utils_ns::TangoUtils::ParseFullProxyName(proxy_facility_name,proxy_domain_name,proxy_family_name,proxy_member_name,proxy_names[i])<0){
				_WARN_LOG("Failed to parse proxy name "<<proxy_names[i]<<" (will not update proxy attr value), skip to next proxy in list...");	
				continue;
			}
			std::string proxy_dyn_attr_name= std::string("proxyRunStatus_") + 
				proxy_domain_name + std::string("_") + 
				proxy_family_name + std::string("_") +
				proxy_member_name;		
		
			//Set dyn proxy attr value
			if(SetDynAttrValue<std::string>(proxy_info,proxy_dyn_attr_name)<0){
				_WARN_LOG("Failed to set proxy info in device attr "<<proxy_dyn_attr_name<<" (will not update proxy attr value), skip to next proxy in list...");	
				//continue;
			}

			//Process proxy run status
			int proxy_run_status= Utils_ns::TangoProxyHelper::GetProxyRunStatusFromString(proxy_info[0]);
			if(ProcessProxyRunStatusInfo(proxy_names[i],proxy_run_status)<0){
				_WARN_LOG("Failed to process proxy "<<proxy_names[i]<<" run status info, skip to next proxy in list...");
				//continue;
			}
		}//close if enableProxyStatusAttrCreation

	}//end loop proxies to be monitored
	/*----- PROTECTED REGION END -----*/	//	LMCDevice::monitor_proxies
}
//--------------------------------------------------------
/**
 *	Command RevokeTask related method
 *	Description: Find all tasks with matching name and remove
 *               them from the queue. 
 *               Set removed tasks (IDLE status) to CANCELED and update
 *               corresponding task sequence status.
 *
 *	@param argin Name of task to be canceled
 */
//--------------------------------------------------------
void LMCDevice::revoke_task(Tango::DevString argin)
{
	DEBUG_STREAM << "LMCDevice::RevokeTask()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCDevice::revoke_task) ENABLED START -----*/
	
	//	Add your own code
	//## Check task manager
	if(!m_taskManager){
		std::string errMsg("Task manager was not initialized!");
		_WARN_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("REVOKE_TASK_FAILED",errMsg);	
	}

	//## Check argin
	std::string task_name(argin);
	if(task_name==""){
		std::string errMsg("Empty task sequence name given as argument!");
		_WARN_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("REVOKE_TASK_FAILED",errMsg);	
	}

	//## Revoke task
	if(m_taskManager->RevokeTask(task_name)<0){
		std::stringstream ss;
		ss<<"Failed to revoke task "<<task_name<<"!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("REVOKE_TASK_FAILED",ss.str());	
	}

	/*----- PROTECTED REGION END -----*/	//	LMCDevice::revoke_task
}
//--------------------------------------------------------
/**
 *	Command RevokeTaskSequence related method
 *	Description: Find all sequence tasks with matching name and remove
 *               tasks belonging to the sequence from the queue. 
 *               Set removed tasks (IDLE status) to CANCELED.
 *
 *	@param argin Name of task sequence to be revoked.
 */
//--------------------------------------------------------
void LMCDevice::revoke_task_sequence(Tango::DevString argin)
{
	DEBUG_STREAM << "LMCDevice::RevokeTaskSequence()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCDevice::revoke_task_sequence) ENABLED START -----*/
	
	//	Add your own code
	//## Check task manager
	if(!m_taskManager){
		std::string errMsg("Task manager was not initialized!");
		_WARN_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("REVOKE_TASK_SEQUENCE_FAILED",errMsg);	
	}

	//## Check argin
	std::string task_seq_name(argin);
	if(task_seq_name==""){
		std::string errMsg("Empty task sequence name given as argument!");
		_WARN_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("REVOKE_TASK_SEQUENCE_FAILED",errMsg);	
	}

	//## Revoke task sequence
	if(m_taskManager->RevokeTaskSequence(task_seq_name)<0){
		std::stringstream ss;
		ss<<"Failed to revoke task sequence "<<task_seq_name<<"!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("REVOKE_TASK_SEQUENCE",ss.str());	
	}
	/*----- PROTECTED REGION END -----*/	//	LMCDevice::revoke_task_sequence
}
//--------------------------------------------------------
/**
 *	Command GetFormulaData related method
 *	Description: Find formula with given arg name and return formula var data
 *               encoded in json string format.
 *
 *	@param argin Formula attr name
 *	@returns Formula data encoded in json string
 */
//--------------------------------------------------------
Tango::DevString LMCDevice::get_formula_data(Tango::DevString argin)
{
	Tango::DevString argout;
	DEBUG_STREAM << "LMCDevice::GetFormulaData()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCDevice::get_formula_data) ENABLED START -----*/
	
	//	Add your own code
	//Check if formula manager was initialized
	if(!m_formulaManager){
		std::string errMsg("FormulaManager was not initialized!");
		_WARN_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("GET_FORMULA_DATA_FAILED",errMsg);	
	}

	//Check arg
	std::string formula_attr_name= argin;
	if(formula_attr_name==""){
		std::string errMsg("Given formula attr name argument is empty!");
		_WARN_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("GET_FORMULA_DATA_FAILED",errMsg);	
	}

	//Get formula data from manager
	std::string formula_data_str= "";
	bool include_formula_expr= false; 
	if(m_formulaManager->GetFormulaDataAsJsonString(formula_data_str,formula_attr_name,include_formula_expr)<0){
		std::stringstream ss;
		ss<<"Failed to get data for formula attr "<<formula_attr_name<<" from manager (hint: check if attr name is correct and if formula is registered/has data)";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("GET_FORMULA_DATA_FAILED",ss.str());
	}
		
	//Set output argument
	argout= Tango::string_dup(formula_data_str.c_str());

	/*----- PROTECTED REGION END -----*/	//	LMCDevice::get_formula_data
	return argout;
}
//--------------------------------------------------------
/**
 *	Command SendTestLogMsg related method
 *	Description: Generate a log in the device according to the given level.
 *               Used for testing purposes.
 *
 *	@param argin Long arg
 *               [0]: Level of log message
 *               (0=OFF, 1=FATAL, 2=ERROR, 3=WARNING, 4=INFO, 5=DEBUG)
 *               
 *               String arg
 *               [0]: log message
 */
//--------------------------------------------------------
void LMCDevice::send_test_log_msg(const Tango::DevVarLongStringArray *argin)
{
	DEBUG_STREAM << "LMCDevice::SendTestLogMsg()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCDevice::send_test_log_msg) ENABLED START -----*/
	
	//	Add your own code
	//Check args
	int nArgs_s= (int)((argin->svalue).length());
	int nArgs_l= (int)((argin->lvalue).length());
	if(nArgs_s<=0 || nArgs_l<=0){
		std::string errMsg("No arguments specified!");
		_THROW_TANGO_EXCEPTION("SEND_TEST_LOG_MSG_FAILED",errMsg);	
	}

	//Generate a log message
	Tango::DevLong log_level= (argin->lvalue)[0];
	std::string log_level_str= Utils_ns::TangoUtils::GetStringMappedLogLevel(log_level);	
	std::string log_msg( (argin->svalue)[0] );
	_INFO_LOG("Logging a test message (msg="<<log_msg<<") with level "<<log_level<<" ("<<log_level_str<<")...");
	_DEV_LOG(log_level_str,log_msg);

	/*----- PROTECTED REGION END -----*/	//	LMCDevice::send_test_log_msg
}
//--------------------------------------------------------
/**
 *	Command ClearTaskHistory related method
 *	Description: Removed all tasks present in the list (including RUNNING
 *               tasks).
 *
 */
//--------------------------------------------------------
void LMCDevice::clear_task_history()
{
	DEBUG_STREAM << "LMCDevice::ClearTaskHistory()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCDevice::clear_task_history) ENABLED START -----*/
	
	//	Add your own code
	//Check if task manager is instantiated, otherwise throw exception
	if(!m_taskManager){
		std::string errMsg("Task manager was not initialized!");
		_WARN_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("CLEAR_TASK_HISTORY_FAILED",errMsg);	
	}

	//Clear task history
	if(m_taskManager->ClearAllSequenceTasks()<0){
		std::string errMsg("Failed to clear task history!");
		_WARN_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("CLEAR_TASK_HISTORY_FAILED",errMsg);	
	}	

	/*----- PROTECTED REGION END -----*/	//	LMCDevice::clear_task_history
}
//--------------------------------------------------------
/**
 *	Command GetLogAppenderInfo related method
 *	Description: Return list of all log appenders with log levels
 *
 *	@returns 
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *LMCDevice::get_log_appender_info()
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "LMCDevice::GetLogAppenderInfo()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCDevice::get_log_appender_info) ENABLED START -----*/
	
	//	Add your own code

	//Get log appender list	
	log4tango::AppenderList appenders= get_logger()->get_all_appenders();
		
	//Init output argument
	argout= new Tango::DevVarLongStringArray;
	argout->svalue.length(appenders.size());
	argout->lvalue.length(appenders.size());	

	for(size_t i=0;i<appenders.size();i++){
		std::string this_appender_name= appenders[i]->get_name();
		int log_target= Utils_ns::TangoUtils::GetLogAppenderType(appenders[i]);
		
		//Get log4tango appender level
		log4tango::Level::Value log4tango_level= appenders[i]->get_level();
		bool isLevelEnabled= this->get_logger()->is_level_enabled(log4tango_level);

		//Convert log4tango log level to Tango log level
		Tango::LogLevel tango_level= Tango::Logging::log4tango_to_tango_level(log4tango_level);
		int log_level= static_cast<Tango::DevLong>(tango_level);

		_DEBUG_LOG("Appender no. "<<i<<", name="<<this_appender_name<<", type="<<log_target<<", log_level="<<log_level<<" (log4tango_level="<<log4tango_level<<"), isLevelEnabled? "<<isLevelEnabled);

		argout->svalue[i] = CORBA::string_dup(this_appender_name.c_str());	
		argout->lvalue[i] = log_level;
	}

	/*----- PROTECTED REGION END -----*/	//	LMCDevice::get_log_appender_info
	return argout;
}
//--------------------------------------------------------
/**
 *	Command dummyDynCmd related method
 *	Description: 
 *
 */
//--------------------------------------------------------
void LMCDevice::dummy_dyn_cmd(Tango::Command &command)
{
	DEBUG_STREAM << "LMCDevice::" << command.get_name() << "  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCDevice::dummy_dyn_cmd) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	LMCDevice::dummy_dyn_cmd
}
//--------------------------------------------------------
/**
 *	Method      : LMCDevice::add_dynamic_commands()
 *	Description : Create the dynamic commands if any
 *                for specified device.
 */
//--------------------------------------------------------
void LMCDevice::add_dynamic_commands()
{
	//	Example to add dynamic command:
	//	Copy inside the folowing protected area to instanciate at startup.
	//	add_dummyDynCmd_dynamic_command("MydummyDynCmdCommand", true);
	
	/*----- PROTECTED REGION ID(LMCDevice::add_dynamic_commands) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic commands if any
	
	//#############################################
	//## Invoke commands at startup
	//#############################################

	/*
	//## Register device proxies
	_INFO_LOG("Registering device proxies in device...");
	if(DoProxyRegistration()<0){
		std::string errMsg("Failed to register proxies in device (proxy names invalid or not found?)!");
		_ERROR_LOG(errMsg);
		set_status(errMsg.c_str());
		set_state(Tango::FAULT);
	}
	
	//## Register event subscriptions in device
	_INFO_LOG("Registering event subscriptions in device...");
	if(DoEventSubscriptionRegistration()<0){
		std::string errMsg("Failed to register event subscriptions in device (invalid event info?)!");
		_ERROR_LOG(errMsg);
		set_status(errMsg.c_str());
		set_state(Tango::FAULT);
	}
	
	//## Register event handlers in device
	_INFO_LOG("Registering event handlers in device...");
	if(DoEventHandlersRegistration()<0){
		std::string errMsg("Failed to register event handlers (cmd handler(s) not found?)!");
		_ERROR_LOG(errMsg);
		set_status(errMsg.c_str());
		set_state(Tango::FAULT);
	}
	
	
	//## Try to initialize proxy devices (proxies can be offline, so initialization will be periodically performed)
	//## NB: to be performed after proxy & event registration!
	_INFO_LOG("Initialize and subscribe device proxies...");
	if(InitDevProxies()<0){
		std::string errMsg("Failed to initialize device proxies (proxies offline?), will retry later...");
		_WARN_LOG(errMsg);
	}

	//## Register attr formulas
	//...
	//...
	*/

	/*----- PROTECTED REGION END -----*/	//	LMCDevice::add_dynamic_commands
}

/*----- PROTECTED REGION ID(LMCDevice::namespace_ending) ENABLED START -----*/

//	Additional Methods
int LMCDevice::DoProxyRegistration(){

	//Register TangoDB by default
	m_db_dev_name= "";
	try {
		m_db_dev_name= Tango::Util::instance()->get_database()->get_dbase()->name();
			
		//Register Db dev proxy
		if(_REGISTER_PROXY(m_db_dev_name)<0){
			std::stringstream ss;
			ss<<"Failed to register TangoDB dev proxy "<<m_db_dev_name<<" in device (proxy names invalid or not found?)!";
			_ERROR_LOG(ss.str());
			set_status(ss.str().c_str());
			set_state(Tango::FAULT);
		}
	}//close try block
	catch(Tango::DevFailed& e){
		std::stringstream ss;
		ss<<"Tango exception while retrieving Db name device name!";
		_ERROR_LOG(ss.str());
		set_status(ss.str().c_str());
		set_state(Tango::FAULT);
	}
	catch(...){
		std::stringstream ss;
		ss<<"Unknown exception while retrieving Db name device name!";
		_ERROR_LOG(ss.str());
		set_status(ss.str().c_str());
		set_state(Tango::FAULT);
	}
	

	//First register proxies specified in properties
	for(unsigned int i=0;i<proxyDevices.size();i++){
		//Register proxy
		if(_REGISTER_PROXY(proxyDevices[i])<0){
			std::stringstream ss;
			ss<<"Failed to register proxy "<<proxyDevices[i]<<" in device (proxy names invalid or not found?)!";
			_ERROR_LOG(ss.str());
			set_status(ss.str().c_str());
			set_state(Tango::FAULT);
			return -1;
		}

		//If enable, register the corresponding adm proxy	
		if(enableAutoAdminProxyRegistration && _REGISTER_ADMIN_PROXY(proxyDevices[i])<0){
			std::stringstream ss;
			ss<<"Failed to register admin proxy of proxy "<<proxyDevices[i]<<" in device (proxy names invalid or not found?)!";
			_ERROR_LOG(ss.str());
			set_status(ss.str().c_str());
			set_state(Tango::FAULT);
			return -1;
		}

	}//end loop proxy devices

	//Register proxies specified with macros (this is overridden by derived class)
	//NB: Derived class code is executed here if you override the base class method
	if(RegisterProxies()<0){
		std::string errMsg("Failed to register proxies in device (proxy names invalid or not found?)!");
		_ERROR_LOG(errMsg);
		set_status(errMsg.c_str());
		set_state(Tango::FAULT);
		return -1;
	}

	return 0;

}//close DoProxyRegistration()


int LMCDevice::DoEventSubscriptionRegistration(){

	//Register events defined in properties (if not empty)
	if(!eventSubscriptions.empty()){
		//Check if eventSubscriptions is correctly specified
		//NB: It must be multiple of 2
		_DEBUG_LOG("#"<<eventSubscriptions.size()%2<<" event subscriptions present in properties...");
		if(eventSubscriptions.size()%2!=0){
			std::string errMsg("Invalid event subscription property value specified (it must contain pairs of attr_name-event_type, see property description)!");
			_ERROR_LOG(errMsg);
			set_status(errMsg.c_str());
			set_state(Tango::FAULT);
			return -1;
		}

		//First register events specified in properties
		for(unsigned int i=0;i<eventSubscriptions.size()-1;i+=2){
			std::string full_attr_name= eventSubscriptions[i];	
			std::string evt_type_str= eventSubscriptions[i+1];

			//Extract proxy/attr name
			std::string domain_name= "";
			std::string proxy_name= "";
			std::string attr_name= "";
			bool hasQualityTag= false;
			if(Utils_ns::TangoUtils::ParseFullAttrName(domain_name,proxy_name,attr_name,hasQualityTag,full_attr_name)<0){
				std::string errMsg("Invalid event subscription property value specified (failed to parse event attr name)!");
				_ERROR_LOG(errMsg);
				set_status(errMsg.c_str());
				set_state(Tango::FAULT);
				return -1;
			}
			if(domain_name==""){
				std::string errMsg("Invalid event subscription property value specified (please use FQDN when specifying property value)!");
				_ERROR_LOG(errMsg);
				set_status(errMsg.c_str());
				set_state(Tango::FAULT);
				return -1;
			}

			//Get Tango::EventType from string label
			Tango::EventType evt_type;
			if(Utils_ns::TangoUtils::GetEventTypeFromString(evt_type,evt_type_str)<0){
				std::stringstream ss;
				ss<<"Invalid event type label found (evt_type="<<evt_type_str<<")";
				_ERROR_LOG(ss.str());
				set_status(ss.str().c_str());
				set_state(Tango::FAULT);
				return -1;
			}
	
			//Register event subscription
			std::string full_proxy_name= domain_name + std::string("/") + proxy_name;
			_DEBUG_LOG("Registering event (proxy="<<full_proxy_name<<", attr="<<attr_name<<", evt_type_str="<<evt_type_str<<") in device...");
			if(_REGISTER_EVT_SUBSCRIPTIONS(full_proxy_name,attr_name,{evt_type})<0){
				std::stringstream ss;
				ss<<"Failed to register subscription to event (proxy="<<full_proxy_name<<", attr="<<attr_name<<", evt_type_str="<<evt_type_str<<"), check event info!";
				_ERROR_LOG(ss.str());
				set_status(ss.str().c_str());
				set_state(Tango::FAULT);
				return -1;				
			}
		}//end loop event subscriptions
	}//close if properties not empty	

	//Register event subscriptions (this is overridden by derived class)
	//NB: Derived class code is executed here if you override the base class method
	if(RegisterEventSubscriptions()<0){
		std::string errMsg("Failed to register event subscriptions in device (invalid event info?)!");
		_ERROR_LOG(errMsg);
		set_status(errMsg.c_str());
		set_state(Tango::FAULT);
		return -1;
	}

	return 0;

}//close DoEventSubscriptionRegistration()


int LMCDevice::DoEventHandlersRegistration(){

	//Register event handlers defined in properties
	if(!eventHandlers.empty()){
		//Check if event handlers are correctly specified
		//NB: It must be multiple of 5
		if(eventHandlers.size()%5!=0){
			std::string errMsg("Invalid event handler property value specified (it must contain triple of attr_name-event_type-cmd_handler, see property description)!");
			_ERROR_LOG(errMsg);
			set_status(errMsg.c_str());
			set_state(Tango::FAULT);
			return -1;
		}

		//First register events specified in properties
		for(unsigned int i=0;i<eventHandlers.size()-4;i+=5){
			std::string full_attr_name= eventHandlers[i];	
			std::string evt_type_str= eventHandlers[i+1];
			std::string cmd_handler= eventHandlers[i+2];
			std::string execution_delay_str= eventHandlers[i+3];
			std::string priority_str= eventHandlers[i+4];

			std::stringstream ss(execution_delay_str);
			long int execution_delay;
			ss >> execution_delay;
			if(!ss){
				std::string errMsg("Failed to convert execution_delay from string!");
				_ERROR_LOG(errMsg);
				set_status(errMsg.c_str());
				set_state(Tango::FAULT);
				return -1;
			}

			std::stringstream ss2(priority_str);
			int priority;
			ss2 >> priority;
			if(!ss2){
				std::string errMsg("Failed to convert priority from string!");
				_ERROR_LOG(errMsg);
				set_status(errMsg.c_str());
				set_state(Tango::FAULT);
				return -1;
			}

			//Extract proxy/attr name
			std::string domain_name= "";
			std::string proxy_name= "";
			std::string attr_name= "";
			bool hasQualityTag= false;
			if(Utils_ns::TangoUtils::ParseFullAttrName(domain_name,proxy_name,attr_name,hasQualityTag,full_attr_name)<0){
				std::string errMsg("Invalid event handler property value specified (failed to parse event attr name)!");
				_ERROR_LOG(errMsg);
				set_status(errMsg.c_str());
				set_state(Tango::FAULT);
				return -1;
			}
			if(domain_name==""){
				std::string errMsg("Invalid event handler property value specified (please use FQDN when specifying property value)!");
				_ERROR_LOG(errMsg);
				set_status(errMsg.c_str());
				set_state(Tango::FAULT);
				return -1;
			}

			//Get Tango::EventType from string label
			Tango::EventType evt_type;
			if(Utils_ns::TangoUtils::GetEventTypeFromString(evt_type,evt_type_str)<0){
				std::stringstream ss;
				ss<<"Invalid event type label found (evt_type="<<evt_type_str<<")";
				_ERROR_LOG(ss.str());
				set_status(ss.str().c_str());
				set_state(Tango::FAULT);
				return -1;
			}
		
			//Register event handler
			std::string full_proxy_name= domain_name + std::string("/") + proxy_name;
			_DEBUG_LOG("Registering event handler "<<cmd_handler<<" (proxy="<<full_proxy_name<<", attr="<<attr_name<<", evt_type_str="<<evt_type_str<<") in device...");
			
			if(_REGISTER_EVT_HANDLERS(full_proxy_name,attr_name,evt_type,{cmd_handler},execution_delay,priority)<0){
				std::stringstream ss;
				ss<<"Failed to register cmd handler "<<cmd_handler<<" to event (proxy="<<full_proxy_name<<", attr="<<attr_name<<", evt_type_str="<<evt_type_str<<"), check property info!";
				_ERROR_LOG(ss.str());
				set_status(ss.str().c_str());
				set_state(Tango::FAULT);
				return -1;				
			}
		}//end loop event subscriptions
	}//close if has properties

	//Register event handlers (this is overridden by derived class)
	//NB: Derived class code is executed here if you override the base class method
	if(RegisterEventHandlers()<0){
		std::string errMsg("Failed to register event handlers (cmd handler(s) not found?)!");
		_ERROR_LOG(errMsg);
		set_status(errMsg.c_str());
		set_state(Tango::FAULT);
	}

	return 0;

}//close DoEventHandlersRegistration()


void LMCDevice::dyn_attr_read_cb(yat4tango::DynamicAttributeReadCallbackData& rcb) {

	auto tstart = std::chrono::high_resolution_clock::now();

	//## Check args
	if(!rcb.dya || !rcb.tga){
		std::string errMsg("Null ptr to dyn attr!");
		_ERROR_LOG(errMsg);
		_THROW_RECORDED_TANGO_EXCEPTION("READ_DYN_ATTR_FAILED",errMsg);
	}

	//## Get attr info
	std::string attr_name= rcb.dya->get_name();
	int data_format= rcb.dya->get_tango_data_format();
	int data_type = rcb.dya->get_tango_data_type();
	
	//## Check if attribute read is allowed
	auto tstart_sm = std::chrono::high_resolution_clock::now();
	/*
	//DEBUG
	try{
		IsAttrReadAllowed(attr_name,false);
	}
	catch(...){
		throw;
	}
	*/
	auto tstop_sm = std::chrono::high_resolution_clock::now();
	double dt_sm= std::chrono::duration<double, std::milli>(tstop_sm-tstart_sm).count();
	

	//## Set attr value
	auto tstart_set = std::chrono::high_resolution_clock::now();
	try {
  	if(data_format==Tango::SCALAR){			
	  	switch (data_type) {
				case Tango::DEV_FLOAT: 
					SetScalarDynAttr<Tango::DevFloat>(rcb.dya,rcb.tga);
					break;
				case Tango::DEV_DOUBLE: 
					SetScalarDynAttr<Tango::DevDouble>(rcb.dya,rcb.tga);
					break;
				case Tango::DEV_LONG: 
					SetScalarDynAttr<Tango::DevLong>(rcb.dya,rcb.tga);
					break;
				case Tango::DEV_SHORT: 
					SetScalarDynAttr<Tango::DevShort>(rcb.dya,rcb.tga);
					break;
				#if TANGO_VERSION_MAJOR >= 9
				case Tango::DEV_ENUM: 
					SetScalarDynAttr<Tango::DevShort>(rcb.dya,rcb.tga);
					break;
				#endif
				case Tango::DEV_STRING: 
					SetScalarDynAttr<std::string>(rcb.dya,rcb.tga);
					break;
				case Tango::DEV_BOOLEAN: 
					SetScalarDynAttr<Tango::DevBoolean>(rcb.dya,rcb.tga);
					break;
				case Tango::DEV_STATE: 
					SetScalarDynAttr<Tango::DevState>(rcb.dya,rcb.tga);
					break;
				default:
				{
					std::stringstream ss;
					ss<<"Unsupported data type ("<<data_type<<") for attribute "<<attr_name<<"!";
					_ERROR_LOG(ss.str());
	      	_THROW_TANGO_EXCEPTION("READ_DYN_ATTR_FAILED",ss.str());
        	break;
				}			
			}//close switch
		}//SCALAR ATTR
		else if(data_format==Tango::SPECTRUM){	
	  	switch (data_type) {
	  	  case Tango::DEV_FLOAT: 
					SetSpectrumDynAttr<Tango::DevFloat>(rcb.dya,rcb.tga);
					break;
				case Tango::DEV_DOUBLE: 
					SetSpectrumDynAttr<Tango::DevDouble>(rcb.dya,rcb.tga);
					break;
				case Tango::DEV_LONG: 
					SetSpectrumDynAttr<Tango::DevLong>(rcb.dya,rcb.tga);
					break;
				case Tango::DEV_SHORT: 
					SetSpectrumDynAttr<Tango::DevShort>(rcb.dya,rcb.tga);
					break;
				#if TANGO_VERSION_MAJOR >= 9
				case Tango::DEV_ENUM: 
					SetSpectrumDynAttr<Tango::DevShort>(rcb.dya,rcb.tga);
					break;
				#endif
				case Tango::DEV_STRING: 
					SetSpectrumDynAttr<std::string>(rcb.dya,rcb.tga);
					break;
				case Tango::DEV_BOOLEAN: 
					SetSpectrumDynAttr<Tango::DevBoolean>(rcb.dya,rcb.tga);
					break;
				case Tango::DEV_STATE: 
					SetSpectrumDynAttr<Tango::DevState>(rcb.dya,rcb.tga);
					break;
				default:
				{
					std::stringstream ss;
					ss<<"Unsupported data type ("<<data_type<<") for attribute "<<attr_name<<"!";
					_ERROR_LOG(ss.str());
	      	_THROW_TANGO_EXCEPTION("READ_DYN_ATTR_FAILED",ss.str());
        	break;
				}
			}//close switch
		}//SPECTRUM ATTR
		else {
			std::stringstream ss;
			ss<<"Unsupported data format ("<<data_format<<") for attribute "<<attr_name<<"!";
			_ERROR_LOG(ss.str());
	    _THROW_TANGO_EXCEPTION("READ_DYN_ATTR_FAILED",ss.str());
		}
	}//close try block
	catch(Tango::DevFailed& e){
		//Tango::Except::print_exception(e);
		std::string reason(e.errors[0].desc.in());
		std::stringstream ss;
		ss<<"Tango exception (reason="<<reason<<") occurred while reading dyn attr "<<attr_name;
		_ERROR_LOG(ss.str());
		_THROW_RECORDED_TANGO_EXCEPTION("READ_DYN_ATTR_FAILED",ss.str());
		//throw;
	}
	catch(std::exception& e){
		std::stringstream ss;
		ss<<"C++ exception (err="<<e.what()<<") occurred while reading dyn attr "<<attr_name;
		_ERROR_LOG(ss.str());
		_THROW_RECORDED_TANGO_EXCEPTION("READ_DYN_ATTR_FAILED",ss.str());
		//throw;
	}
	catch(...){
		std::stringstream ss;
		ss<<"Unknown exception occurred while reading dyn attr "<<attr_name;
		_ERROR_LOG(ss.str());
		_THROW_RECORDED_TANGO_EXCEPTION("READ_DYN_ATTR_FAILED",ss.str());
		//throw;
	}

	auto tstop_set = std::chrono::high_resolution_clock::now();
	double dt_set= std::chrono::duration<double, std::milli>(tstop_set-tstart_set).count();

	auto tstop = std::chrono::high_resolution_clock::now();
	//double dt = std::chrono::duration_cast<std::chrono::milliseconds>(tstop-tstart).count();
	double dt= std::chrono::duration<double, std::milli>(tstop-tstart).count();
	_DEBUG_LOG("ReadCB (attr="<<attr_name<<") time(ms)="<<dt<<" (smCheck="<<dt_sm/dt*100.<<"%"<<", write="<<dt_set/dt*100.<<"%)");
	

}//close dyn_attr_read_cb()


void LMCDevice::dyn_attr_write_cb(yat4tango::DynamicAttributeWriteCallbackData& wcb) {

	auto tstart = std::chrono::high_resolution_clock::now();

	//## Check args
	if(!wcb.dya || !wcb.tga){
		std::string errMsg("Null ptr to dyn attribute and/or WAttribute!");
		_ERROR_LOG(errMsg);
		_THROW_RECORDED_TANGO_EXCEPTION("WRITE_DYN_ATTR_FAILED",errMsg);
	}

	//## Get attr info
	std::string attr_name= wcb.dya->get_name();
	int data_format= wcb.dya->get_tango_data_format();
	int data_type = wcb.dya->get_tango_data_type();
	
	//## Check if attribute write is allowed
	auto tstart_sm = std::chrono::high_resolution_clock::now();
	try{
		IsAttrWriteAllowed(attr_name,false);
	}
	catch(...){
		throw;
	}
	auto tstop_sm = std::chrono::high_resolution_clock::now();
	double dt_sm= std::chrono::duration<double, std::milli>(tstop_sm-tstart_sm).count();


	//## Execute attribute write pre-actions
	try{
		ExecuteAttrWriteActions(attr_name,true,false);
	}
	catch(...){
		throw;
	}

	//## Set write attribute value	
	auto tstart_set = std::chrono::high_resolution_clock::now();
	try {
  	if(data_format==Tango::SCALAR){			
	  	switch (data_type) {
				case Tango::DEV_FLOAT: 
					SetScalarDynWAttr<Tango::DevFloat>(wcb.dya,wcb.tga);
					break;
				case Tango::DEV_DOUBLE: 
					SetScalarDynWAttr<Tango::DevDouble>(wcb.dya,wcb.tga);
					break;
				case Tango::DEV_LONG: 
					SetScalarDynWAttr<Tango::DevLong>(wcb.dya,wcb.tga);
					break;
				case Tango::DEV_SHORT: 
					SetScalarDynWAttr<Tango::DevShort>(wcb.dya,wcb.tga);
					break;
				#if TANGO_VERSION_MAJOR >= 9
				case Tango::DEV_ENUM: 
					SetScalarDynWAttr<Tango::DevShort>(wcb.dya,wcb.tga);
					break;
				#endif
				case Tango::DEV_STRING: 
					SetScalarDynWAttr<std::string>(wcb.dya,wcb.tga);
					break;
				case Tango::DEV_BOOLEAN: 
					SetScalarDynWAttr<Tango::DevBoolean>(wcb.dya,wcb.tga);
					break;
				case Tango::DEV_STATE: 
					SetScalarDynWAttr<Tango::DevState>(wcb.dya,wcb.tga);
					break;
				default:
				{
					std::stringstream ss;
					ss<<"Unsupported data type ("<<data_type<<") for attribute "<<attr_name<<"!";
					_ERROR_LOG(ss.str());
					_THROW_TANGO_EXCEPTION("WRITE_DYN_ATTR_FAILED",ss.str());
        	break;
				}			
			}//close switch
		}//SCALAR ATTR
		else if(data_format==Tango::SPECTRUM){	
	  	switch (data_type) {
	  	  case Tango::DEV_FLOAT: 
					SetSpectrumDynWAttr<Tango::DevFloat>(wcb.dya,wcb.tga);
					break;
				case Tango::DEV_DOUBLE: 
					SetSpectrumDynWAttr<Tango::DevDouble>(wcb.dya,wcb.tga);
					break;
				case Tango::DEV_LONG: 
					SetSpectrumDynWAttr<Tango::DevLong>(wcb.dya,wcb.tga);
					break;
				case Tango::DEV_SHORT: 
					SetSpectrumDynWAttr<Tango::DevShort>(wcb.dya,wcb.tga);
					break;
				#if TANGO_VERSION_MAJOR >= 9
				case Tango::DEV_ENUM: 
					SetSpectrumDynWAttr<Tango::DevShort>(wcb.dya,wcb.tga);
					break;
				#endif
				case Tango::DEV_STRING: 
					SetSpectrumDynWAttr<std::string>(wcb.dya,wcb.tga);
					break;
				case Tango::DEV_BOOLEAN: 
					SetSpectrumDynWAttr<Tango::DevBoolean>(wcb.dya,wcb.tga);
					break;
				case Tango::DEV_STATE: 
					SetSpectrumDynWAttr<Tango::DevState>(wcb.dya,wcb.tga);
					break;
				default:
				{
					std::stringstream ss;
					ss<<"Unsupported data type ("<<data_type<<") for attribute "<<attr_name<<"!";
					_ERROR_LOG(ss.str());
	      	_THROW_TANGO_EXCEPTION("WRITE_DYN_ATTR_FAILED",ss.str());
        	break;
				}
			}//close switch
		}//SPECTRUM ATTR
		else {
			std::stringstream ss;
			ss<<"Unsupported data format ("<<data_format<<") for attribute "<<attr_name<<"!";
			_ERROR_LOG(ss.str());
	    _THROW_TANGO_EXCEPTION("WRITE_DYN_ATTR_FAILED",ss.str());
		}
	}//close try block
	catch(Tango::DevFailed& e){
		std::string reason(e.errors[0].desc.in());
		std::stringstream ss;
		ss<<"Tango exception (reason="<<reason<<") occurred while writing dyn attr "<<attr_name;
		_ERROR_LOG(ss.str());
		_THROW_RECORDED_TANGO_EXCEPTION("WRITE_DYN_ATTR_FAILED",ss.str());
		//throw;
	}
	catch(std::exception& e){
		std::stringstream ss;
		ss<<"C++ exception (err="<<e.what()<<") occurred while writing dyn attr "<<attr_name;
		_ERROR_LOG(ss.str());
		_THROW_RECORDED_TANGO_EXCEPTION("WRITE_DYN_ATTR_FAILED",ss.str());
		//throw;
	}
	catch(...){
		std::stringstream ss;
		ss<<"Unknown exception occurred while writing dyn attr "<<attr_name;
		_ERROR_LOG(ss.str());
		_THROW_RECORDED_TANGO_EXCEPTION("WRITE_DYN_ATTR_FAILED",ss.str());
		//throw;
	}
	auto tstop_set = std::chrono::high_resolution_clock::now();
	double dt_set= std::chrono::duration<double, std::milli>(tstop_set-tstart_set).count();

	auto tstop = std::chrono::high_resolution_clock::now();
	double dt= std::chrono::duration<double, std::milli>(tstop-tstart).count();
	_DEBUG_LOG("WriteCB (attr="<<attr_name<<") time(ms)="<<dt<<" (smCheck="<<dt_sm/dt*100.<<"%"<<", write="<<dt_set/dt*100.<<"%)");
	
	//## Execute attribute write post-actions
	try{
		ExecuteAttrWriteActions(attr_name,false,false);
	}
	catch(...){
		throw;
	}

}//close dyn_attr_write_cb()



int LMCDevice::AddDynAttrs(){

	//## Initialize dyn attr manager
	if(!m_dam) m_dam = new yat4tango::DynamicAttributeManager(this);

	//## Configure device attribute from file?
	if(!enableConfigFromFile){
		_WARN_LOG("Dynamic attr configuration from file disabled, nothing to be done...");
		return 0;
	}

	//## Configure device attribute from file
	try{
		ConfigureAttr(configFile);
	}
	catch(Tango::DevFailed& e){
		std::string reason(e.errors[0].desc.in());
		std::stringstream ss;
		ss<<"Failed to configure dyn attributes from config file "<<configFile<<" (reason="<<reason<<")!";
		_ERROR_LOG(ss.str());
		set_status(ss.str().c_str());
		set_state(Tango::FAULT);
		return -1;
	}
	catch(...){
		std::stringstream ss;
		ss<<"Failed to configure dyn attributes from config file "<<configFile<<" (unknown exception)!";
		_ERROR_LOG(ss.str());
		set_status(ss.str().c_str());
		set_state(Tango::FAULT);	
		return -1;
	}

	//## Start dyn attribute randomization (if enabled)
	if(enableDynAttrRandomize){

		//== NEW VERSION (STANDALONE THREAD)
		// Initialize and start randomizer thread (if enabled)
		if(!m_attrRandomizerThread) {
			_DEBUG_LOG("Initialize attr randomizer thread...");
			m_attrRandomizerThread= new AttrRandomizerThread(this); 
			m_attrRandomizerThread->SetRandomizationFlag(enableDynAttrRandomize);
			m_attrRandomizerThread->SetRandomizationPeriod(dynAttrRandomizePeriod);
			if(enableDynAttrRandomize) {	
				_INFO_LOG("Starting attr randomizer thread...");
				m_attrRandomizerThread->Start();
			}
		}

		/*
		//== OLD VERSION (POLLED COMMAND)
		try{
			//First stop polling if active
			std::string cmd_name= "RandomizeDynAttrs"; 
			if(is_command_polled(cmd_name) ){
				stop_poll_command(cmd_name);
			}

			//Set polling period and start polling cmd
			poll_command(cmd_name,dynAttrRandomizePeriod);

		}//close try
		catch(Tango::DevFailed& e){
			Tango::Except::print_exception(e);
			std::string errMsg= "Polling initialization of RandomizeDynAttrs command failed!";
			_ERROR_LOG(errMsg);
			_THROW_TANGO_EXCEPTION("INIT_DYN_ATTRS_FAILED",errMsg);
		}
		*/

	}//close if

	return 0;

}//close AddDynAttrs()

void LMCDevice::AddDynFwdAttr(Utils_ns::DeviceAttr* device_attr,bool resetAttr){

	//Check input attr parsed from config
	if(!device_attr) {
		std::string errMsg("Null ptr to input attr given!");
		_ERROR_LOG(errMsg);
		_THROW_RECORDED_TANGO_EXCEPTION("ADD_DYN_FWD_ATTR_FAILED",errMsg);
	}
	
	//Get device attr info
	bool isForwarded= device_attr->IsForwarded();	 
	if(!isForwarded) {
		std::string errMsg("Attribute is not a forwarded attr!");
		_ERROR_LOG(errMsg);
		_THROW_RECORDED_TANGO_EXCEPTION("ADD_DYN_FWD_ATTR_FAILED",errMsg);
	}

	Tango::FwdAttr* attr= dynamic_cast<Tango::FwdAttr*>(device_attr->GetAttr());	
	std::string attr_name= attr->get_name();
	std::string url= attr->get_full_root_att();	
	std::string label= "";

	//Strip all tango:// pattern present in url
	//NB: fwd attr url does not want the tango::// prefix!!!
	Utils_ns::CodeUtils::StripPatternFromString(url,"tango://");

	try {
		label= attr->get_label_from_default_properties();
	}
	catch(...){};
	_DEBUG_LOG("Adding/modifying fwd attribute: name="<<attr_name<<", url="<<url<<", label="<<label);
	
	//Check if attribute is already present in the attribute list
	bool hasAttr= false;
	try{
		get_device_attr()->get_attr_by_name(attr_name.c_str());
		hasAttr= true;
		_DEBUG_LOG("Attribute "<<attr_name<<" already exist in the list, update it!");
	}
	catch(Tango::DevFailed &e){//an exception is thrown if the attribute is not existing
		hasAttr= false;
		_DEBUG_LOG("Attribute "<<attr_name<<" is not present is the list, adding it!");	
	}
	catch(...){//an exception is thrown if the attribute is not existing
		hasAttr= false;
		_INFO_LOG("Unknown exception catched, attribute "<<attr_name<<" is not present is the list, adding it!");
	}

	//Set attribute info
	yat4tango::ForwardedAttributeInfo dai;
	dai.dev = this;
  dai.url = url;
	dai.lan = attr_name;
	dai.rdo= false;	
	
	//If has attr & reset, remove from device (SEEMS THE ONLY WAY TO UPDATE IT!)
	if(hasAttr && resetAttr) {
		_DEBUG_LOG("Fwd attr "<<attr_name<<" is already present in device, removing it...");
		try{
			m_dam->remove_attribute(attr_name);	
		}
		catch(Tango::DevFailed &e){
			//Tango::Except::print_exception(e);
			std::stringstream ss;
			ss<<"Failed to remove fwd attr "<<attr_name<<" already present in device!";
			_ERROR_LOG(ss.str());
			//return -1;
			_THROW_RECORDED_TANGO_EXCEPTION("ADD_DYN_FWD_ATTR_FAILED",ss.str());
		}
		hasAttr= false;
	}//close if

	//Add fwd attribute in device
	if(!hasAttr){
		try{
			_DEBUG_LOG("Adding fwd attr "<<attr_name<<"...");
			m_dam->add_attribute(dai);
		}
		catch(Tango::DevFailed &e){
			//Tango::Except::print_exception(e);
			std::stringstream ss;
			ss<<"Failed to add fwd attr "<<attr_name<<"!";
			_ERROR_LOG(ss.str());
		
			//Remove the attribute if created
			try{
				m_dam->remove_attribute(attr_name);
			}
			catch(...){}
			//return -1;
			_THROW_RECORDED_TANGO_EXCEPTION("ADD_DYN_FWD_ATTR_FAILED",ss.str());
		}
		catch(...){
			std::stringstream ss;
			ss<<"Failed to add fwd attr "<<attr_name<<" (unknown exception)!";
			_ERROR_LOG(ss.str());
			try{
				m_dam->remove_attribute(attr_name);
			}
			catch(...){}
			//return -1;
			_THROW_RECORDED_TANGO_EXCEPTION("ADD_DYN_FWD_ATTR_FAILED",ss.str());
		}

		//Add attribute to list if not already present (ADDED!!!!!)
		int pos= -1;
		if(!Utils_ns::CodeUtils::FindItem(m_dynAttrList,attr_name,pos)) {
			m_dynAttrList.push_back( attr_name );
		}

	}//close if

	//Update label
	//Tango::UserDefaultFwdAttrProp attr_prop;
	Tango::UserDefaultAttrProp attr_prop;
	attr_prop.set_label(attr_name.c_str());

	try{
		_DEBUG_LOG("Setting label in fwd attribute "<<attr_name<<" ...");
		//Tango::FwdAttr& fwd_attr= static_cast<Tango::FwdAttr&>(this->get_device_class()->get_class_attr()->get_attr(attr_name));
		//fwd_attr.set_default_properties(attr_prop);
		Tango::Attr& attr= this->get_device_class()->get_class_attr()->get_attr(attr_name);
		attr.set_default_properties(attr_prop);
	}
	catch(Tango::DevFailed &e){//an exception is thrown if the attribute is not existing
		std::stringstream ss;
		ss<<"Tango exception received while setting fwd attribute "<<attr_name<<" label!";
		_WARN_LOG(ss.str());
		//return -1;
		_THROW_RECORDED_TANGO_EXCEPTION("ADD_DYN_FWD_ATTR_FAILED",ss.str());
	}
	catch(std::exception &e){//an exception is thrown if the attribute is not existing
		std::stringstream ss;
		ss<<"C++ exception (err="<<e.what()<<") received while setting attribute "<<attr_name<<" label!";
		_WARN_LOG(ss.str());	
		//return -1;
		_THROW_RECORDED_TANGO_EXCEPTION("ADD_DYN_FWD_ATTR_FAILED",ss.str());
	}

	//Poll attribute
	_DEBUG_LOG("Start polling on attribute "<<attr_name<<"? "<<device_attr->IsPolled()<<" (poll period="<<attr->get_polling_period()<<") ...");
	if(device_attr->IsPolled()){
		poll_attribute(attr_name,attr->get_polling_period());
	}

}//close AddDynFwdAttr()


void LMCDevice::AddDynAttr(Utils_ns::DeviceAttr* device_attr)
{
	//Check input attr parsed from config
	if(!device_attr) {
		std::string errMsg("Null ptr to input attr given!");
		_ERROR_LOG(errMsg);
		_THROW_RECORDED_TANGO_EXCEPTION("ADD_DYN_ATTR_FAILED",errMsg);
	}
	Tango::Attr* attr= device_attr->GetAttr();	
	if(!attr){
		std::string errMsg("Failed to get Tango::Attr from device_attr!");
		_ERROR_LOG(errMsg);
		_THROW_RECORDED_TANGO_EXCEPTION("ADD_DYN_ATTR_FAILED",errMsg);
	}

	//Get basic attr info
	bool isMemorized= device_attr->IsMemorized();	
	long int data_type= attr->get_type();
	std::string attr_name= attr->get_name();		
	_DEBUG_LOG("Adding/modifying attribute: name="<<attr_name<<", data_type="<<data_type<<" isMemorized?"<<isMemorized);
	
	
	//=======================================
	//==    CREATE DYN ATTR              ====
	//=======================================
	try{	
		switch (data_type) {
			case Tango::DEV_FLOAT: 
				CreateAndInitDynAttr<Tango::DevFloat,Tango::DevFloat>(device_attr);
				break;
			case Tango::DEV_DOUBLE: 
				CreateAndInitDynAttr<Tango::DevDouble,Tango::DevDouble>(device_attr);
				break;
			case Tango::DEV_LONG: 
				CreateAndInitDynAttr<Tango::DevLong,Tango::DevLong>(device_attr);
				break;
			case Tango::DEV_SHORT: 
				CreateAndInitDynAttr<Tango::DevShort,Tango::DevShort>(device_attr);
				break;	
			#if TANGO_VERSION_MAJOR >= 9
			case Tango::DEV_ENUM: 
				CreateAndInitDynAttr<Tango::DevShort,Tango::DevEnum>(device_attr);
				break;
			#endif
			case Tango::DEV_STRING: 
				CreateAndInitDynAttr<std::string,Tango::DevString>(device_attr);
				break;
			case Tango::DEV_BOOLEAN: 
				CreateAndInitDynAttr<Tango::DevBoolean,Tango::DevBoolean>(device_attr);
				break;
			case Tango::DEV_STATE: 
				CreateAndInitDynAttr<Tango::DevState,Tango::DevState>(device_attr);
				break;
			default:
			{
				std::stringstream ss;
				ss<<"Unsupported data type ("<<data_type<<") for attribute "<<attr_name<<"!";
				_ERROR_LOG(ss.str());
	      _THROW_TANGO_EXCEPTION("ADD_DYN_ATTR_FAILED",ss.str());
        break;
			}	
		}//close switch		
	}//close try block
	catch(Tango::DevFailed &e){
		std::string reason(e.errors[0].desc.in());
		std::stringstream ss;
		ss<<"Tango exception (reason="<<reason<<") occurred while adding attr "<<attr_name<<" to device!";
		_ERROR_LOG(ss.str());
		_THROW_RECORDED_TANGO_EXCEPTION("ADD_DYN_ATTR_FAILED",ss.str());
	}
	catch(std::exception& e){
		std::stringstream ss;
		ss<<"C++ exception (err="<<e.what()<<") occurred while adding attr "<<attr_name<<" to device!";
		_ERROR_LOG(ss.str());
		_THROW_RECORDED_TANGO_EXCEPTION("ADD_DYN_ATTR_FAILED",ss.str());
	}
	catch(...){
		std::stringstream ss;
		ss<<"Unknown exception occurred while adding attr "<<attr_name<<" to device!";
		_ERROR_LOG(ss.str());
		_THROW_RECORDED_TANGO_EXCEPTION("ADD_DYN_ATTR_FAILED",ss.str());
	}

	//Add attribute to list if not present already (ADDED!!!!!)
	int pos= -1;
	if(!Utils_ns::CodeUtils::FindItem(m_dynAttrList,attr_name,pos)) {
		m_dynAttrList.push_back( attr_name );
	}


	//==================================================
	//==    INIT DYN ATTR VALUE (ADDED!!!!)         ====
	//==================================================
	try{
		InitDynAttrValue(attr_name);
	}
	catch(Tango::DevFailed &e){
		std::string reason(e.errors[0].desc.in());
		std::stringstream ss;
		ss<<"Tango exception (reason="<<reason<<") occurred while initializing dyn attr "<<attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_RECORDED_TANGO_EXCEPTION("ADD_DYN_ATTR_FAILED",ss.str());
	}
	catch(std::exception& e){
		std::stringstream ss;
		ss<<"C++ exception (reason="<<e.what()<<") occurred while initializing dyn attr "<<attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_RECORDED_TANGO_EXCEPTION("ADD_DYN_ATTR_FAILED",ss.str());
	}
	catch(...){
		std::stringstream ss;
		ss<<"Unknown exception occurred while initializing dyn attr "<<attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_RECORDED_TANGO_EXCEPTION("ADD_DYN_ATTR_FAILED",ss.str());
	}
	
}//close AddDynAttr()



void LMCDevice::ConfigureAttr(std::string cfg_file) {

	//##################################################
	//## Configure device from XML config file
	//##################################################
	//Check if empty string given
	if(cfg_file==""){
		std::string errMsg("Empty configuration file given!");
		_ERROR_LOG(errMsg);
		_THROW_RECORDED_TANGO_EXCEPTION("CONFIGURE_ATTR_FAILED",errMsg);
	}
	_DEBUG_LOG("Configuring device attrs from config file "<<cfg_file<<" ...");

	//First check file as it is
	Utils_ns::FileInfo file_info;
	if(Utils_ns::SysUtils::CheckFile(cfg_file,file_info)<0){
		_WARN_LOG("Config file "<<cfg_file<<" not found in current directory, trying to search in filesystem config dir (if set)...");
		
		//Get config dir env var
		std::string configDir= Utils_ns::SysUtils::GetEnvVar("DSHLMC_CONFIG");
		if(configDir==""){
			std::string errMsg= "$DSHLMC_CONFIG env var is not set, cannot find config file!";
			_ERROR_LOG(errMsg);
			_THROW_RECORDED_TANGO_EXCEPTION("CONFIGURE_ATTR_FAILED",errMsg);
		}//close if check env dir

		std::string configFileFull= configDir + std::string("/") + cfg_file;		
		if(Utils_ns::SysUtils::CheckFile(configFileFull,file_info)<0){
			std::stringstream ss;
			ss<<"Cannot find config file "<<configFileFull<<"!";
			_ERROR_LOG(ss.str());
			_THROW_RECORDED_TANGO_EXCEPTION("CONFIGURE_ATTR_FAILED",ss.str());
		}
		cfg_file= configFileFull;
	}//close if

	_INFO_LOG("Parsing device configuration from XML config file "<<cfg_file<<"...");
	
	// Parse attributes from XML
	std::vector<Utils_ns::DeviceAttr*> attrCollection;	
	bool readFromFile= true;
	int status= Utils_ns::DevConfigParser::Parse(attrCollection,cfg_file,readFromFile);
	if(status<0){
		std::string errMsg= "Failed to parse the device configuration file!";
		_ERROR_LOG(errMsg);
		for(unsigned int i=0;i<attrCollection.size();i++){
			if(attrCollection[i]){
				delete attrCollection[i];
				attrCollection[i]= 0;
			}
		}
		attrCollection.clear();
		_THROW_RECORDED_TANGO_EXCEPTION("CONFIGURE_ATTR_FAILED",errMsg);
	}

	_DEBUG_LOG("#"<<attrCollection.size()<<" attrs found in config file...");

	//## Loop over attributes and create attribute dynamically
	int fwd_status= 0;

	for(unsigned int i=0;i<attrCollection.size();i++){
		m_device_attr.push_back(attrCollection[i]);
		bool isForwarded= attrCollection[i]->IsForwarded(); 		

		//NB: For forwarded attr do not set attr initialization as failed. This is because fwd root device may be down at startup 
		//(that's why fwd attr initialization will be re-tried periodically). For fwd attr init failures instead set a special attribute status: fwdAttrInitStatus 
		if(isForwarded){
			try{
				AddDynFwdAttr(attrCollection[i]);
			}
			catch(...){
				_ERROR_LOG("Failed to add fwd dyn attr "<<attrCollection[i]->GetAttr()->get_name()<<", skip to next attr in list...");
				fwd_status= -1;
				continue;
			}
		}//close if fwd attr
		else{
			try{
				AddDynAttr(attrCollection[i]);
			}
			catch(...){
				_ERROR_LOG("Failed to add dyn attr "<<attrCollection[i]->GetAttr()->get_name()<<", skip to next attr in list...");
				status= -1;
				continue;
			}
		}//close else standard attr

	}//end loop

	if(fwd_status==0){
		*attr_fwdAttrInitStatus_read= fwdAttrInitStatusEnum::_OK;
	}
	else {
		*attr_fwdAttrInitStatus_read= fwdAttrInitStatusEnum::_FAILED;
	}

	if(status<0){
		std::string errMsg("Failures occurred while adding one/more dyn attributes in device!");
		_THROW_RECORDED_TANGO_EXCEPTION("CONFIGURE_ATTR_FAILED",errMsg);
	}

}//close ConfigureAttr()


void LMCDevice::InitDynAttrValues(){

	//Check if device has dyn attrs
	size_t nDynAttrs= m_dynAttrList.size();
	if(nDynAttrs<=0) return;

	//Loop over all dynamic attributes and initialize their values
	int status= 0;

	for(size_t i=0;i<nDynAttrs;i++){
		std::string attr_name= m_dynAttrList[i];

		try{
			InitDynAttrValue(attr_name);
		}
		catch(Tango::DevFailed &e){
			std::string reason(e.errors[0].desc.in());
			std::stringstream ss;
			ss<<"Tango exception (reason="<<reason<<") occurred while initializing dyn attr "<<attr_name<<" value!";
			_ERROR_LOG(ss.str());
			status= -1;
			continue;
		}
		catch(std::exception& e){
			std::stringstream ss;
			ss<<"C++ exception (reason="<<e.what()<<") occurred while initializing dyn attr "<<attr_name<<" value!";
			_ERROR_LOG(ss.str());
			status= -1;
			continue;
		}
		catch(...){
			std::stringstream ss;
			ss<<"Unknown exception occurred while initializing dyn attr "<<attr_name<<" value!";
			_ERROR_LOG(ss.str());
			status= -1;
			continue;
		}

	}//end loop dyn attrs

	if(status<0){
		std::string errMsg("Failures occurred when initializing one/more dyn attr values!");	
		_THROW_TANGO_EXCEPTION("INIT_DYN_ATTR_VALUES_FAILED",errMsg);
	}

}//close InitDynAttrValues()


void LMCDevice::InitDynAttrValue(std::string& attr_name){

	//Check if attribute exists
	long attr_data_type;
	Tango::AttrDataFormat attr_data_format;
	long attr_data_size= 0;	
	bool hasWriteAssociation= false;
	bool isMemorized= false;
	//bool isForwarded= false;
	try{
		Tango::Attribute& attr= get_device_attr()->get_attr_by_name(attr_name.c_str());
		attr_data_type= attr.get_data_type();
		attr_data_format= attr.get_data_format();
		attr_data_size= attr.get_max_dim_x();
		hasWriteAssociation= attr.is_writ_associated();
		//isForwarded= attr.is_fwd_att();//not working in YAT4TANGO??
		if(hasWriteAssociation){
			isMemorized= get_device_attr()->get_w_attr_by_name(attr_name.c_str()).is_memorized();
		}
	}
	catch(Tango::DevFailed &e){//an exception is thrown if the attribute is not existing
		std::stringstream ss;
		ss<<"Attribute "<<attr_name<<" does not exist in device!";
		_THROW_RECORDED_TANGO_EXCEPTION("INIT_DYN_ATTR_VALUE_FAILED",ss.str());
	}
	

	//Check if forwarded 	
	bool isDynAttrForwarded= false;
	try {
		yat4tango::DynamicAttribute& dyn_attr = m_dam->get_attribute(attr_name);
		isDynAttrForwarded= dyn_attr.is_forwarded();
	}
	catch(Tango::DevFailed &e){//an exception is thrown if the attribute is not existing
		std::stringstream ss;
		ss<<"Attribute "<<attr_name<<" is not found in dynamic attribute manager!";
		_THROW_RECORDED_TANGO_EXCEPTION("INIT_DYN_ATTR_VALUE_FAILED",ss.str());
	}
	

	//Check data size
	if(attr_data_size<=0){	
		std::stringstream ss;
		ss<<"Attribute "<<attr_name<<" has invalid max_x size!";
		_THROW_RECORDED_TANGO_EXCEPTION("INIT_DYN_ATTR_VALUE_FAILED",ss.str());
	}

	//Skip initialization for fwd attributes
	if(isDynAttrForwarded){
		_DEBUG_LOG("Attribute "<<attr_name<<" is forwarded, no initialization needed...");
		return;
	}

	//Init memorized attr?
	if(isMemorized){
		_DEBUG_LOG("Attr "<<attr_name<<" is memorized, initializing...");
		try{ 
			InitMemorizedAttr(attr_name);
		}
		catch(Tango::DevFailed& e){
			std::string reason(e.errors[0].desc.in());
			std::stringstream ss;
			ss<<"Failed to initialize memorized attribute "<<attr_name<<" (err="<<reason<<")";
			_THROW_RECORDED_TANGO_EXCEPTION("INIT_DYN_ATTR_VALUE_FAILED",ss.str());
		}
		catch(std::exception& e){
			std::stringstream ss;
			ss<<"Failed to initialize memorized attribute "<<attr_name<<" (err="<<e.what()<<")";
			_THROW_RECORDED_TANGO_EXCEPTION("INIT_DYN_ATTR_VALUE_FAILED",ss.str());
		}
		catch(...){
			std::stringstream ss;
			ss<<"Unknown exception occurred while initializing memorized attribute "<<attr_name;
			_THROW_RECORDED_TANGO_EXCEPTION("INIT_DYN_ATTR_VALUE_FAILED",ss.str());
		}
	}//close if isMemorized
	
	//## Initialize normal attr
	//Get access to attribute properties
	try {
		Tango::DbData db_data;
		db_data.push_back(Tango::DbDatum(attr_name.c_str()));
		get_db_device()->get_attribute_property(db_data);
	
		long nb_prop;
		db_data[0] >> nb_prop;

		//Get init value
		bool hasInitValue= false;
		bool hasMemorizedValue= false;
		Tango::DbDatum genModelData_init;
		Tango::DbDatum mem_data;
		for (int k=0;k<nb_prop;k++) {
    	std::string& prop_name = db_data[k+1].name;
			if (prop_name == "genInitValue") {
				hasInitValue= true;	
				genModelData_init= db_data[k+1];
			}
			if (prop_name == "__value") {
				hasMemorizedValue= true;	
				mem_data= db_data[k+1];
			}
		}//end loop attr properties 
	
		//Check if has init value set in DB
		if(!hasInitValue){
			std::stringstream ss;
			ss<<"Attribute "<<attr_name<<" has no init value property set in DB for attr const update!";
			_THROW_TANGO_EXCEPTION("INIT_DYN_ATTR_VALUE_FAILED",ss.str());
		}

		//Set attr value
		Tango::DbData genModelParData;
		if(isMemorized && hasMemorizedValue) genModelParData.push_back(mem_data);//Set to memorized data
		else genModelParData.push_back(genModelData_init);

		try{
			SetDynAttrValueFromDbDatum(genModelParData[0],attr_name,attr_data_type,attr_data_format,attr_data_size);
		}
		catch(...){
			throw;
		}

	}//close try
	catch(Tango::DevFailed& e){
		std::string reason(e.errors[0].desc.in());	
		std::stringstream ss;
		ss<<"Init attr "<<attr_name<<" from DB properties failed (err="<<reason<<")";
		_THROW_RECORDED_TANGO_EXCEPTION("INIT_DYN_ATTR_VALUE_FAILED",ss.str());
	}

}//close InitDynAttrValue()


void LMCDevice::SetDynAttrValueFromDbDatum(Tango::DbDatum& db_datum,std::string& attr_name,long data_type,Tango::AttrDataFormat data_format,long data_size){

	//Check db_data
	if(db_datum.is_empty()){
		_THROW_TANGO_EXCEPTION("SET_DYN_ATTR_FROM_DBDATUM_FAILED","Empty input db_datum given!");
	}

	//Set attr value from dbdatum
	try{	
		if(data_format==Tango::SCALAR){	
			switch (data_type) {
				case Tango::DEV_FLOAT: 
					SetScalarDynAttrValueFromDbDatum<Tango::DevFloat,Tango::DevFloat>(db_datum,attr_name);
					break;
				case Tango::DEV_DOUBLE: 
					SetScalarDynAttrValueFromDbDatum<Tango::DevDouble,Tango::DevDouble>(db_datum,attr_name);
					break;
				case Tango::DEV_LONG: 
					SetScalarDynAttrValueFromDbDatum<Tango::DevLong,Tango::DevLong>(db_datum,attr_name);
					break;
				case Tango::DEV_SHORT: 
					SetScalarDynAttrValueFromDbDatum<Tango::DevShort,Tango::DevShort>(db_datum,attr_name);
					break;
				#if TANGO_VERSION_MAJOR >= 9
				case Tango::DEV_ENUM: 
					SetScalarDynAttrValueFromDbDatum<Tango::DevShort,Tango::DevEnum>(db_datum,attr_name);
					break;
				#endif
				case Tango::DEV_STRING: 
					SetScalarDynAttrValueFromDbDatum<std::string,std::string>(db_datum,attr_name);
					break;
				case Tango::DEV_BOOLEAN: 
					SetScalarDynAttrValueFromDbDatum<Tango::DevBoolean,Tango::DevBoolean>(db_datum,attr_name);
					break;
				case Tango::DEV_STATE: 
					SetScalarDynAttrValueFromDbDatum<Tango::DevShort,Tango::DevState>(db_datum,attr_name);
					break;
				default:
				{
					std::stringstream ss;
					ss<<"Unsupported data type ("<<data_type<<") for attribute "<<attr_name<<"!";
					_THROW_TANGO_EXCEPTION("SET_DYN_ATTR_FROM_DBDATUM_FAILED",ss.str());
       	 	break;
				}	
			}//close switch	
		}//SCALAR
	
		else if(data_format==Tango::SPECTRUM){
			switch (data_type) {
				case Tango::DEV_FLOAT: 
					SetSpectrumDynAttrValueFromDbDatum<Tango::DevFloat,Tango::DevFloat>(db_datum,attr_name,data_size);
					break;
				case Tango::DEV_DOUBLE: 
					SetSpectrumDynAttrValueFromDbDatum<Tango::DevDouble,Tango::DevDouble>(db_datum,attr_name,data_size);
					break;
				case Tango::DEV_LONG: 
					SetSpectrumDynAttrValueFromDbDatum<Tango::DevLong,Tango::DevLong>(db_datum,attr_name,data_size);
					break;
				case Tango::DEV_SHORT: 
					SetSpectrumDynAttrValueFromDbDatum<Tango::DevShort,Tango::DevShort>(db_datum,attr_name,data_size);
					break;
				#if TANGO_VERSION_MAJOR >= 9
				case Tango::DEV_ENUM: 
					SetSpectrumDynAttrValueFromDbDatum<Tango::DevShort,Tango::DevEnum>(db_datum,attr_name,data_size);
					break;
				#endif
				case Tango::DEV_STRING: 
					SetSpectrumDynAttrValueFromDbDatum<std::string,std::string>(db_datum,attr_name,data_size);
					break;
				case Tango::DEV_BOOLEAN: 
					SetSpectrumDynAttrValueFromDbDatum<Tango::DevBoolean,Tango::DevBoolean>(db_datum,attr_name,data_size);
					break;
				case Tango::DEV_STATE: 
					SetSpectrumDynAttrValueFromDbDatum<Tango::DevShort,Tango::DevState>(db_datum,attr_name,data_size);
					break;
				default:
				{
					std::stringstream ss;
					ss<<"Unsupported data type ("<<data_type<<") for attribute "<<attr_name<<"!";
					_THROW_TANGO_EXCEPTION("SET_DYN_ATTR_FROM_DBDATUM_FAILED",ss.str());
       	 	break;
				}	
			}//close switch	
		}//SPECTRUM

		else{
			std::string errMsg= "Invalid/unsupported attr data format!";
			_THROW_TANGO_EXCEPTION("SET_DYN_ATTR_FROM_DBDATUM_FAILED",errMsg);					
		}
	}//close try
	catch(Tango::DevFailed& e){
		throw;
	}
	catch(...){
		throw;
	}	
		
}//close SetDynAttrValueFromDbDatum()


int LMCDevice::SetDynAttrValueFromFormula(std::string attr_name,Utils_ns::FormulaData* formula_data,bool emit_event){

	//Check if formula is initialized
	if(!formula_data) {
		_WARN_LOG("Null ptr to formula data for attr "<<attr_name<<"!");
		return -1;
	}
	if(!formula_data->IsInitialized()){
		_WARN_LOG("Formula for attr "<<attr_name<<" is not initialized yet (some proxy offline?), will evaluate formula with init values...");
	}

	//Check if attribute exists
	long data_type;
	Tango::AttrDataFormat data_format;
	long data_size;
	try{
		Tango::Attribute& attr= get_device_attr()->get_attr_by_name(attr_name.c_str());
		data_type= attr.get_data_type();
		data_format= attr.get_data_format();
		data_size= attr.get_max_dim_x();
	}
	catch(Tango::DevFailed &e){//an exception is thrown if the attribute is not existing
		_ERROR_LOG("Attribute "<<attr_name<<" does not exist in device!");
		return -1;
	}
	catch(...){//an exception is thrown if the attribute is not existing
		_ERROR_LOG("Attribute "<<attr_name<<" does not exist in device!");
		return -1;
	}

	//Set value
	try{	
		if(data_format==Tango::SCALAR){	
			switch (data_type) {
				case Tango::DEV_FLOAT: 
					SetFormulaScalarDynAttrValue<Tango::DevFloat>(attr_name,formula_data,emit_event);
					break;
				case Tango::DEV_DOUBLE: 
					SetFormulaScalarDynAttrValue<Tango::DevDouble>(attr_name,formula_data,emit_event);
					break;
				case Tango::DEV_LONG: 
					SetFormulaScalarDynAttrValue<Tango::DevLong>(attr_name,formula_data,emit_event);
					break;
				case Tango::DEV_SHORT: 
					SetFormulaScalarDynAttrValue<Tango::DevShort>(attr_name,formula_data,emit_event);
					break;
				#if TANGO_VERSION_MAJOR >= 9
				case Tango::DEV_ENUM: 
					SetFormulaScalarDynAttrValue<Tango::DevEnum>(attr_name,formula_data,emit_event);
					break;
				#endif
				case Tango::DEV_STRING: 
					SetFormulaScalarDynAttrValue<std::string>(attr_name,formula_data,emit_event);
					break;
				case Tango::DEV_BOOLEAN: 
					SetFormulaScalarDynAttrValue<Tango::DevBoolean>(attr_name,formula_data,emit_event);
					break;
				case Tango::DEV_STATE: 
					SetFormulaScalarDynAttrValue<Tango::DevState>(attr_name,formula_data,emit_event);
					break;
				default:
				{
					std::stringstream ss;
					ss<<"Unsupported data type ("<<data_type<<") for attribute "<<attr_name<<"!";
					_ERROR_LOG(ss.str());
	      	_THROW_TANGO_EXCEPTION("SET_DYN_ATTR_FROM_DBDATUM_FAILED",ss.str());
       	 	break;
				}	
			}//close switch	
		}//SCALAR
	
		else if(data_format==Tango::SPECTRUM){
			switch (data_type) {
				case Tango::DEV_FLOAT: 
					SetFormulaSpectrumDynAttrValue<Tango::DevFloat>(attr_name,formula_data,data_size,emit_event);
					break;
				case Tango::DEV_DOUBLE: 
					SetFormulaSpectrumDynAttrValue<Tango::DevDouble>(attr_name,formula_data,data_size,emit_event);
					break;
				case Tango::DEV_LONG: 
					SetFormulaSpectrumDynAttrValue<Tango::DevLong>(attr_name,formula_data,data_size,emit_event);
					break;
				case Tango::DEV_SHORT: 
					SetFormulaSpectrumDynAttrValue<Tango::DevShort>(attr_name,formula_data,data_size,emit_event);
					break;
				#if TANGO_VERSION_MAJOR >= 9
				case Tango::DEV_ENUM: 
					SetFormulaSpectrumDynAttrValue<Tango::DevEnum>(attr_name,formula_data,data_size,emit_event);
					break;	
				#endif
				case Tango::DEV_STRING: 
					SetFormulaSpectrumDynAttrValue<std::string>(attr_name,formula_data,data_size,emit_event);
					break;
				case Tango::DEV_BOOLEAN: 
					SetFormulaSpectrumDynAttrValue<Tango::DevBoolean>(attr_name,formula_data,data_size,emit_event);
					break;
				case Tango::DEV_STATE: 
					SetFormulaSpectrumDynAttrValue<Tango::DevState>(attr_name,formula_data,data_size,emit_event);
					break;
				default:
				{
					std::stringstream ss;
					ss<<"Unsupported data type ("<<data_type<<") for attribute "<<attr_name<<"!";
					_ERROR_LOG(ss.str());
	      	_THROW_TANGO_EXCEPTION("SET_DYN_ATTR_FROM_FORMULA_FAILED",ss.str());
       	 	break;
				}	
			}//close switch	
		}//SPECTRUM

		else{
			std::string errMsg= "Invalid/unsupported attr data format!";
			_THROW_TANGO_EXCEPTION("SET_DYN_ATTR_FROM_FORMULA_FAILED",errMsg);					
		}
	}//close try
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Tango exception occurred while setting dyn attr "<<attr_name<<" value from formula!");
		return -1;
	}
	catch(...){
		_ERROR_LOG("Unknown exception occurred while setting dyn attr "<<attr_name<<" value from formula!");
		return -1;
	}	

	return 0;

}//close SetDynAttrValueFromFormula()

int LMCDevice::SetDynAttrToSafeValue(std::string attr_name,bool changeAttrQuality,Tango::AttrQuality attr_quality,bool emit_event){

	//Check if attribute exists
	long data_type;
	Tango::AttrDataFormat data_format;
	try{
		Tango::Attribute& attr= get_device_attr()->get_attr_by_name(attr_name.c_str());
		data_type= attr.get_data_type();
		data_format= attr.get_data_format();
	}
	catch(Tango::DevFailed &e){//an exception is thrown if the attribute is not existing
		_ERROR_LOG("Attribute "<<attr_name<<" does not exist in device!");
		return -1;
	}
	catch(...){//an exception is thrown if the attribute is not existing
		_ERROR_LOG("Attribute "<<attr_name<<" does not exist in device!");
		return -1;
	}

	//Set value
	try{	
		if(data_format==Tango::SCALAR){	
			switch (data_type) {
				case Tango::DEV_FLOAT: 
					SetScalarDynAttrToSafeValue<Tango::DevFloat>(attr_name,changeAttrQuality,attr_quality,emit_event);
					break;
				case Tango::DEV_DOUBLE: 
					SetScalarDynAttrToSafeValue<Tango::DevDouble>(attr_name,changeAttrQuality,attr_quality,emit_event);
					break;
				case Tango::DEV_LONG: 
					SetScalarDynAttrToSafeValue<Tango::DevLong>(attr_name,changeAttrQuality,attr_quality,emit_event);
					break;
				case Tango::DEV_SHORT: 
					SetScalarDynAttrToSafeValue<Tango::DevShort>(attr_name,changeAttrQuality,attr_quality,emit_event);
					break;
				#if TANGO_VERSION_MAJOR >= 9	
				case Tango::DEV_ENUM: 
					SetScalarDynAttrToSafeValue<Tango::DevEnum>(attr_name,changeAttrQuality,attr_quality,emit_event);
					break;
				#endif
				case Tango::DEV_STRING: 
					SetScalarDynAttrToSafeValue<std::string>(attr_name,changeAttrQuality,attr_quality,emit_event);
					break;
				case Tango::DEV_BOOLEAN: 
					SetScalarDynAttrToSafeValue<Tango::DevBoolean>(attr_name,changeAttrQuality,attr_quality,emit_event);
					break;
				case Tango::DEV_STATE: 
					SetScalarDynAttrToSafeValue<Tango::DevState>(attr_name,changeAttrQuality,attr_quality,emit_event);
					break;
				default:
				{
					std::stringstream ss;
					ss<<"Unsupported data type ("<<data_type<<") for attribute "<<attr_name<<"!";
					_ERROR_LOG(ss.str());
	      	_THROW_TANGO_EXCEPTION("SET_DYN_ATTR_TO_SAFE_VALUE_FAILED",ss.str());
       	 	break;
				}	
			}//close switch	
		}//SCALAR
	
		else if(data_format==Tango::SPECTRUM){
			switch (data_type) {
				case Tango::DEV_FLOAT: 
					SetSpectrumDynAttrToSafeValue<Tango::DevFloat>(attr_name,changeAttrQuality,attr_quality,emit_event);
					break;
				case Tango::DEV_DOUBLE: 
					SetSpectrumDynAttrToSafeValue<Tango::DevDouble>(attr_name,changeAttrQuality,attr_quality,emit_event);
					break;
				case Tango::DEV_LONG: 
					SetSpectrumDynAttrToSafeValue<Tango::DevLong>(attr_name,changeAttrQuality,attr_quality,emit_event);
					break;
				case Tango::DEV_SHORT: 
					SetSpectrumDynAttrToSafeValue<Tango::DevShort>(attr_name,changeAttrQuality,attr_quality,emit_event);
					break;
				#if TANGO_VERSION_MAJOR >= 9
				case Tango::DEV_ENUM: 
					SetSpectrumDynAttrToSafeValue<Tango::DevEnum>(attr_name,changeAttrQuality,attr_quality,emit_event);
					break;
				#endif
				case Tango::DEV_STRING: 
					SetSpectrumDynAttrToSafeValue<std::string>(attr_name,changeAttrQuality,attr_quality,emit_event);
					break;
				case Tango::DEV_BOOLEAN: 
					SetSpectrumDynAttrToSafeValue<Tango::DevBoolean>(attr_name,changeAttrQuality,attr_quality,emit_event);
					break;
				case Tango::DEV_STATE: 
					SetSpectrumDynAttrToSafeValue<Tango::DevBoolean>(attr_name,changeAttrQuality,attr_quality,emit_event);
					break;
				default:
				{
					std::stringstream ss;
					ss<<"Unsupported data type ("<<data_type<<") for attribute "<<attr_name<<"!";
					_ERROR_LOG(ss.str());
	      	_THROW_TANGO_EXCEPTION("SET_DYN_ATTR_TO_SAFE_VALUE_FAILED",ss.str());
       	 	break;
				}	
			}//close switch	
		}//SPECTRUM

		else{
			std::string errMsg= "Invalid/unsupported attr data format!";
			_THROW_TANGO_EXCEPTION("SET_DYN_ATTR_TO_SAFE_VALUE_FAILED",errMsg);					
		}
	}//close try
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Tango exception occurred while setting dyn attr "<<attr_name<<" safe value!");
		return -1;
	}
	catch(...){
		_ERROR_LOG("Unknown exception occurred while setting dyn attr "<<attr_name<<" safe value!");
		return -1;
	}	

	return 0;

}//close SetDynAttrToSafeValue()

void LMCDevice::InitCentralLogger(log4tango::Logger* logger,bool setLogLevels){

	//Check given logger
	if(!logger){
		_THROW_RECORDED_TANGO_EXCEPTION("INIT_CENTRAL_LOGGER_FAILED","Null ptr to logger given in input!");
	}

	//Get current logging target & level
	/*
	std::string loggingTargetCentral= "";
	try{
		get_device_attr()->get_w_attr_by_name("loggingLevelCentral").get_write_value(attr_loggingLevelCentral_write);
		get_device_attr()->get_w_attr_by_name("loggingTargetCentral").get_write_value(attr_loggingTargetCentral_write);
	}
	catch(...){
		_THROW_RECORDED_TANGO_EXCEPTION("INIT_CENTRAL_LOGGER_FAILED","Failed to get writable attr loggingLevelCentral/loggingTargetCentral values!");
	}
	loggingTargetCentral= std::string(attr_loggingTargetCentral_write);
	*/

	std::string loggingTargetCentral= attr_loggingTargetCentral_write;

	//Do nothing if target is empty
	if(loggingTargetCentral==""){
		_WARN_LOG("Central logger will not be initialized as current Central logging target is not initialized or is an empty string (hint: you must set the Central target name!)");
		return;
	}

	//Retrieve appender
	//std::string log_target= std::string("device::") + loggingTargetCentralDefault;
	std::string log_target= std::string("device::") + loggingTargetCentral;
	std::transform(log_target.begin(), log_target.end(),log_target.begin(), ::tolower);
	log4tango::Appender* appender= 0;
	try{
		appender= logger->get_appender(log_target);
	}
	catch(...){
		std::stringstream ss;
		ss<<"Failed to get Element logger appender "<<log_target;
		_THROW_RECORDED_TANGO_EXCEPTION("INIT_ELEMENT_LOGGER_FAILED",ss.str());
	}

	//If appender is not present create one
	if(!appender){
		_DEBUG_LOG("Device has no central log appender with target ("<<log_target<<"), adding it...");

		appender= new Tango::TangoAppender(logger->get_name(),log_target, loggingTargetCentral );

		if (appender->is_valid() == false) {
			delete appender;
      appender = 0;
		
			std::stringstream ss;
			ss<<"Cannot connect to central log consumer " << loggingTargetCentral<<" (hint: check if proxy is offline)";
			_THROW_RECORDED_TANGO_EXCEPTION("INIT_CENTRAL_LOGGER_FAILED",ss.str());
		}	

		//Add appender to logger
		logger->add_appender(appender);

		/*
		m_centralLogAppender= new Tango::TangoAppender(logger->get_name(),log_target, loggingTargetCentral );

		if (m_centralLogAppender->is_valid() == false) {
			delete m_centralLogAppender;
      m_centralLogAppender = 0;
		
			std::stringstream ss;
			ss<<"Cannot connect to central log consumer " << loggingTargetCentral<<" (hint: check if proxy is offline)";
			_THROW_RECORDED_TANGO_EXCEPTION("INIT_CENTRAL_LOGGER_FAILED",ss.str());
		}	

		//Add appender to logger
		logger->add_appender(m_centralLogAppender);
		*/
	}//close if

	//Set Central logging level
	if(setLogLevels){	
		_INFO_LOG("Initializing Central target ("<<log_target<<") with log level "<<attr_loggingLevelCentral_write<<"...");
		if( SetAppenderLogLevel(log_target,attr_loggingLevelCentral_write)<0 ){
			std::stringstream ss;
			ss<<"Failed to set appender log level " << loggingTargetCentral<<" for central log target "<<log_target<<" (hint: check if proxy is offline?)";
			_THROW_RECORDED_TANGO_EXCEPTION("INIT_CENTRAL_LOGGER_FAILED",ss.str());			
		}	
	}

}//close InitCentralLogger()



void LMCDevice::InitElementLogger(log4tango::Logger* logger,bool setLogLevels){

	//Check given logger
	if(!logger){
		_THROW_RECORDED_TANGO_EXCEPTION("INIT_ELEMENT_LOGGER_FAILED","Null ptr to logger given in input!");
	}

	//Define logging target & level
	/*
	std::string loggingTargetElement= "";
	try{
		get_device_attr()->get_w_attr_by_name("loggingLevelElement").get_write_value(attr_loggingLevelElement_write);
		get_device_attr()->get_w_attr_by_name("loggingTargetElement").get_write_value(attr_loggingTargetElement_write);
	}
	catch(...){
		_THROW_RECORDED_TANGO_EXCEPTION("INIT_ELEMENT_LOGGER_FAILED","Failed to get writable attr loggingLevelElement value!");
	}
	loggingTargetElement= std::string(attr_loggingTargetElement_write);
	*/

	//std::string loggingTargetElement= std::string(attr_loggingTargetElement_write);
	std::string loggingTargetElement= attr_loggingTargetElement_write;
	_INFO_LOG("Initializing Element logger target "<<loggingTargetElement<<" (log level="<<attr_loggingLevelElement_write<<")...");

	//Do nothing if target is empty
	if(loggingTargetElement==""){
		_WARN_LOG("Element logger will not be initialized as current Element logging target is not initialized or is an empty string (hint: you must set the Element target name!)");
		return;
	}

	//Retrieve appender
	std::string log_target= std::string("device::") + loggingTargetElement;
	std::transform(log_target.begin(), log_target.end(),log_target.begin(), ::tolower);
	log4tango::Appender* appender= 0;
	try{
		appender= logger->get_appender(log_target);
	}
	catch(...){
		std::stringstream ss;
		ss<<"Failed to get Element logger appender "<<log_target<<"!";
		_THROW_RECORDED_TANGO_EXCEPTION("INIT_ELEMENT_LOGGER_FAILED",ss.str());
	}

	//If appender is not present create one
	if(!appender){
		_INFO_LOG("Device has no Element log appender with target ("<<log_target<<"), adding it...");
		appender= new Tango::TangoAppender(logger->get_name(),log_target, loggingTargetElement);
			
		if (appender->is_valid()==false) {
			delete appender;
      appender= 0;
			std::stringstream ss;
			ss<<"Cannot connect to Element log consumer " << loggingTargetElement<<" (hint: check if proxy is offline)";
			_THROW_RECORDED_TANGO_EXCEPTION("INIT_ELEMENT_LOGGER_FAILED",ss.str());
		}

		//Add appender to logger
		logger->add_appender(appender);
	
		/*
		m_elementLogAppender= new Tango::TangoAppender(logger->get_name(),log_target, loggingTargetElement);
		
		if (m_elementLogAppender->is_valid() == false) {
			delete m_elementLogAppender;
      m_elementLogAppender = 0;
			std::stringstream ss;
			ss<<"Cannot connect to Element log consumer " << loggingTargetElement<<" (hint: check if proxy is offline)";
			_THROW_RECORDED_TANGO_EXCEPTION("INIT_ELEMENT_LOGGER_FAILED",ss.str());
		}	

		//Add appender to logger
		logger->add_appender(m_elementLogAppender);
		*/
	}//close if

	//Set Element logging level
	if(setLogLevels){	
		_INFO_LOG("Initializing Element target ("<<log_target<<") with log level "<<attr_loggingLevelElement_write<<"...");
		if( SetAppenderLogLevel(log_target,attr_loggingLevelElement_write)<0 ){
			std::stringstream ss;
			ss<<"Failed to set appender log level " << loggingTargetElement<<" for Element log target "<<log_target<<" (hint: check if proxy is offline?)";
			_THROW_RECORDED_TANGO_EXCEPTION("INIT_ELEMENT_LOGGER_FAILED",ss.str());			
		}	
	}

}//close InitElementLogger()


void LMCDevice::InitStorageLogger(){

	//Define storage log level
	/*
	Tango::DevLong storage_log_level= 0;
	std::string loggingTargetStorage= "";
	try{
		get_device_attr()->get_w_attr_by_name("loggingLevelStorage").get_write_value(storage_log_level);
		get_device_attr()->get_w_attr_by_name("loggingTargetStorage").get_write_value(attr_loggingTargetStorage_write);
	}
	catch(...){
		std::stringstream ss;
		ss<<"Failed to get writable attr loggingLevelStorage/loggingTargetStorage value!";
		_THROW_RECORDED_TANGO_EXCEPTION("INIT_STORAGE_LOGGER_FAILED",ss.str());
	}
	loggingTargetStorage= std::string(attr_loggingTargetStorage_write);
	*/
	Tango::DevLong storage_log_level= attr_loggingLevelStorage_write;
	std::string loggingTargetStorage= attr_loggingTargetStorage_write;

	//Do nothing if target is empty
	if(loggingTargetStorage==""){
		_WARN_LOG("Storage logger will not be initialized as current storage logging target is not initialized or is an empty string (hint: you must set the storage target name!)");
		return;
	}

	std::string loggerTag= device_name;
	std::transform(loggerTag.begin(), loggerTag.end(),loggerTag.begin(), ::tolower);
	std::string slogLevel= Utils_ns::TangoUtils::GetStringMappedLogLevel(storage_log_level);

	//Create syslogger
	_INFO_LOG("Initializing syslogger target with log level "<<storage_log_level<<" (slogLevel="<<slogLevel<<", default log level="<<loggingLevelStorageDefault<<") and tag "<<loggerTag<<" (host="<<loggingTargetStorage<<", facility="<<syslogFacility<<")...");
	if(Utils_ns::LoggerManager::Instance().CreateSysLogger(slogLevel,loggerTag,syslogFacility,loggingTargetStorage)<0){	
		std::stringstream ss;
		ss<<"Failed to create sys logger (facility="<<syslogFacility<<", level="<<slogLevel<<")";
		_THROW_RECORDED_TANGO_EXCEPTION("INIT_STORAGE_LOGGER_FAILED",ss.str());
	}

	//Check if syslogger was effectively created by retrieving instance from logger manager singleton
	if(!Utils_ns::LoggerManager::Instance().GetLogger()){
		std::stringstream ss;
		ss<<"Failed to retrieve created sys logger (facility="<<syslogFacility<<", level="<<slogLevel<<"), this should not occur!!!";
		_THROW_RECORDED_TANGO_EXCEPTION("INIT_STORAGE_LOGGER_FAILED",ss.str());
	}

}//close InitStorageLogger()


void LMCDevice::RemoveZombieLogAppenders(log4tango::Logger* logger)
{
	//If logger ptr is null, retrieve it
	if(!logger){
		logger= get_logger();
		if(!logger) return;
	}

	//Removing all appenders
	log4tango::AppenderList al= logger->get_all_appenders();
	for (size_t j = 0; j < al.size(); j++) {
  	if (al[j]->is_valid() == false) {
    	logger->remove_appender(al[j]);
    }
  }//end loop appenders
	
}//close RemoveZombieLogAppenders()


int LMCDevice::SetMainLoggerLevel(log4tango::Logger* logger)
{
	//If logger ptr is null, retrieve it
	if(!logger){
		logger= get_logger();
		if(!logger) {	
			std::string errMsg("Failed to get logger instance!");
			_ERROR_LOG(errMsg);
			set_state(Tango::FAULT);		
			set_status(errMsg.c_str());
			return -1;
		}
	}

	//Get log levels per appenders
	Tango::DevLong logLevel_central= Tango::LOG_OFF;
	Tango::DevLong logLevel_element= Tango::LOG_OFF;
	Tango::DevLong logLevel_storage= Tango::LOG_OFF;
	if(attr_elementLoggerEnabled_write) logLevel_element= attr_loggingLevelElement_write;
	if(attr_centralLoggerEnabled_write) logLevel_central= attr_loggingLevelCentral_write;
	if(attr_storageLoggerEnabled_write) logLevel_storage= attr_loggingLevelStorage_write;

	//Get max log level
	Tango::DevLong minLogLevel= Tango::LOG_INFO;
	Tango::DevLong maxLogLevel= std::max({minLogLevel,logLevel_central,logLevel_element,logLevel_storage});

	//Convert to log4tango format
	log4tango::Level::Value log4_level= Tango::Logging::tango_to_log4tango_level(static_cast<Tango::LogLevel>(maxLogLevel), true);

	//Set logger level
	_DEBUG_LOG("Setting main log level to "<<maxLogLevel<<" ...");
	logger->set_level(log4_level);

	return 0;

}//close SetMainLoggerLevel()

int LMCDevice::InitLoggers(bool setLogLevels){

	//Init status
	int status= 0;

	//Get logger instance
	log4tango::Logger* logger= get_logger();
	if(!logger) {	
		std::stringstream ss;
		ss<<"Failed to get logger instance!";
		_ERROR_LOG(ss.str());

		//Set device state to FAULT
		set_state(Tango::FAULT);		
		set_status(ss.str().c_str());

		_THROW_RECORDED_TANGO_EXCEPTION("INIT_LOGGERS_FAILED",ss.str());
	}

	//## Set the logger main level
	//## NB: This should update the device property 'Current logging level' otherwise the log levels are not changed
  if(setLogLevels){
		if(SetMainLoggerLevel(logger)<0){
			std::string errMsg("Failed to set main logger level!");
			set_state(Tango::FAULT);		
			set_status(errMsg.c_str());
			_THROW_RECORDED_TANGO_EXCEPTION("INIT_LOGGERS_FAILED",errMsg);
		}
	}

	//## Initialize loggers 
	//= ELEMENT TARGET =
	if(attr_elementLoggerEnabled_write){
		bool failed= false;
		try{
			InitElementLogger(logger,setLogLevels);
		}
		catch(Tango::DevFailed& e){
			std::string reason(e.errors[0].desc.in());
			_WARN_LOG("Tango exception (reason="<<reason<<") occurred while initializing Element logger!");				
			failed= true;
		}
		catch(std::exception& e){
			_WARN_LOG("C++ exception (reason="<<e.what()<<") occurred while initializing Element logger!");				
			failed= true;
		}
		catch(...){
			_WARN_LOG("Unknown exception occurred while initializing Element logger!");				
			failed= true;
		}

		//If failed mark status to errors occurred and set attribute to FAILED
		if(failed){
			status= -1;
			*attr_elementLoggerStatus_read= elementLoggerStatusEnum::_FAILED;
		}
		else{
			*attr_elementLoggerStatus_read= elementLoggerStatusEnum::_OK;
		}
	}//close if enableElementLogTarget


	//= CENTRAL TARGET =
	if(attr_centralLoggerEnabled_write){
		bool failed= false;
		try{
			InitCentralLogger(logger,setLogLevels);
		}
		catch(Tango::DevFailed& e){
			std::string reason(e.errors[0].desc.in());
			_WARN_LOG("Tango exception (reason="<<reason<<") occurred while initializing central logger!");				
			failed= true;
		}
		catch(std::exception& e){
			_WARN_LOG("C++ exception (reason="<<e.what()<<") occurred while initializing central logger!");				
			failed= true;
		}
		catch(...){
			_WARN_LOG("Unknown exception occurred while initializing central logger!");				
			failed= true;
		}

		//If failed mark status to errors occurred and set attribute to FAILED
		if(failed){
			status= -1;
			*attr_centralLoggerStatus_read= centralLoggerStatusEnum::_FAILED;
		}
		else{
			*attr_centralLoggerStatus_read= centralLoggerStatusEnum::_OK;
		}
	}//close if enableCentralLogTarget
	
 
	
	//= STORAGE TARGET =
	if(attr_storageLoggerEnabled_write){
		bool failed= false;
		try{
			InitStorageLogger();
		}
		catch(Tango::DevFailed& e){
			std::string reason(e.errors[0].desc.in());
			_WARN_LOG("Tango exception (reason="<<reason<<") occurred while initializing storage logger!");				
			failed= true;
		}
		catch(std::exception& e){
			_WARN_LOG("C++ exception (reason="<<e.what()<<") occurred while initializing storage logger!");				
			failed= true;
		}
		catch(...){
			_WARN_LOG("Unknown exception occurred while initializing storage logger!");				
			failed= true;
		}

		//If failed mark status to errors occurred and set attribute to FAILED
		if(failed){
			status= -1;
			*attr_storageLoggerStatus_read= storageLoggerStatusEnum::_FAILED;
		}
		else{
			*attr_storageLoggerStatus_read= storageLoggerStatusEnum::_OK;
		}

	}//close if enableStorageLogTarget


	//= CONSOLE TARGET =
	//NB: Not working at present
	std::string console_log_target= std::string("console::cout");
	Tango::DevLong console_log_level;
	if(GetAppenderLogLevel(console_log_level,console_log_target)==0){
		attr_loggingLevelConsole_write= console_log_level;
		get_device_attr()->get_w_attr_by_name("loggingLevelConsole").set_write_value(attr_loggingLevelConsole_write);
	}
	else{
		_DEBUG_LOG("Failed to get log level for appender "<<console_log_target<<"!");
	}

	return status;

}//close InitLoggers()


void LMCDevice::InitLoggerPars()
{
	//##################################
	//## Init logger enabled flag
	//##################################
	//Central logger enabled
	if(Utils_ns::TangoUtils::HasMemorizedValue(this,"centralLoggerEnabled")){//set to written value
		get_device_attr()->get_w_attr_by_name("centralLoggerEnabled").get_write_value(attr_centralLoggerEnabled_write);
	}
	else{//set to default property
		attr_centralLoggerEnabled_write= centralLoggerEnabledDefault;
		get_device_attr()->get_w_attr_by_name("centralLoggerEnabled").set_write_value(attr_centralLoggerEnabled_write);
	}
	*attr_centralLoggerEnabled_read= attr_centralLoggerEnabled_write;
	
	//Element logger enabled
	if(Utils_ns::TangoUtils::HasMemorizedValue(this,"elementLoggerEnabled")){//set to written value
		get_device_attr()->get_w_attr_by_name("elementLoggerEnabled").get_write_value(attr_elementLoggerEnabled_write);
	}
	else{//set to default property
		attr_elementLoggerEnabled_write= elementLoggerEnabledDefault;
		get_device_attr()->get_w_attr_by_name("elementLoggerEnabled").set_write_value(attr_elementLoggerEnabled_write);
	}
	*attr_elementLoggerEnabled_read= attr_elementLoggerEnabled_write;
	
	//Storage logger enabled
	if(Utils_ns::TangoUtils::HasMemorizedValue(this,"storageLoggerEnabled")){//set to written value
		get_device_attr()->get_w_attr_by_name("storageLoggerEnabled").get_write_value(attr_storageLoggerEnabled_write);
	}
	else{//set to default property
		attr_storageLoggerEnabled_write= storageLoggerEnabledDefault;
		get_device_attr()->get_w_attr_by_name("storageLoggerEnabled").set_write_value(attr_storageLoggerEnabled_write);
	}
	*attr_storageLoggerEnabled_read= attr_storageLoggerEnabled_write;
	
	_INFO_LOG("central/element/storage loggers enabled? ("<<attr_centralLoggerEnabled_write<<","<<attr_elementLoggerEnabled_write<<","<<attr_storageLoggerEnabled_write<<")");
	
	//#######################################
	//## Init logger status attr
	//#######################################
	if(!attr_centralLoggerEnabled_write) *attr_centralLoggerStatus_read= centralLoggerStatusEnum::_DISABLED;
	else *attr_centralLoggerStatus_read= centralLoggerStatusEnum::_UNKNOWN;

	if(!attr_elementLoggerEnabled_write) *attr_elementLoggerStatus_read= elementLoggerStatusEnum::_DISABLED; 
	else *attr_elementLoggerStatus_read= elementLoggerStatusEnum::_UNKNOWN;
	
	if(!attr_storageLoggerEnabled_write) *attr_storageLoggerStatus_read= storageLoggerStatusEnum::_DISABLED;
	else *attr_storageLoggerStatus_read= storageLoggerStatusEnum::_UNKNOWN;

	_INFO_LOG("central/element/storage loggers status: ("<<static_cast<Tango::DevShort>(*attr_centralLoggerStatus_read)<<","<<static_cast<Tango::DevShort>(*attr_elementLoggerStatus_read)<<","<<static_cast<Tango::DevShort>(*attr_storageLoggerStatus_read)<<")");
	

	//######################################
	//## Init log targets
	//######################################
	Tango::DevString wval;

	//Central log target
	if(Utils_ns::TangoUtils::HasMemorizedValue(this,"loggingTargetCentral")){//set to written value
		//get_device_attr()->get_w_attr_by_name("loggingTargetCentral").get_write_value(attr_loggingTargetCentral_write);
		get_device_attr()->get_w_attr_by_name("loggingTargetCentral").get_write_value(wval);
		attr_loggingTargetCentral_write= std::string(wval);
	}
	else{//set to default property
		//attr_loggingTargetCentral_write= const_cast<char*>(loggingTargetCentralDefault.c_str());
		//get_device_attr()->get_w_attr_by_name("loggingTargetCentral").set_write_value(attr_loggingTargetCentral_write);
		wval= const_cast<char*>(loggingTargetCentralDefault.c_str());
		attr_loggingTargetElement_write= loggingTargetCentralDefault;
		get_device_attr()->get_w_attr_by_name("loggingTargetCentral").set_write_value(wval);
	}
	//*attr_loggingTargetCentral_read= Tango::string_dup(attr_loggingTargetCentral_write);
	*attr_loggingTargetCentral_read= Tango::string_dup(wval);

	//Element log target
	if(Utils_ns::TangoUtils::HasMemorizedValue(this,"loggingTargetElement")){//set to written value
		//get_device_attr()->get_w_attr_by_name("loggingTargetElement").get_write_value(attr_loggingTargetElement_write);
		get_device_attr()->get_w_attr_by_name("loggingTargetElement").get_write_value(wval);
		attr_loggingTargetElement_write= std::string(wval);
	}
	else{//set to default property
		//attr_loggingTargetElement_write= const_cast<char*>(loggingTargetElementDefault.c_str());
		//get_device_attr()->get_w_attr_by_name("loggingTargetElement").set_write_value(attr_loggingTargetElement_write);
		wval= const_cast<char*>(loggingTargetElementDefault.c_str());
		attr_loggingTargetElement_write= loggingTargetElementDefault;
		get_device_attr()->get_w_attr_by_name("loggingTargetElement").set_write_value(wval);
	}
	//*attr_loggingTargetElement_read= Tango::string_dup(attr_loggingTargetElement_write);
	*attr_loggingTargetElement_read= Tango::string_dup(wval);

	//Storage log target
	if(Utils_ns::TangoUtils::HasMemorizedValue(this,"loggingTargetStorage")){//set to written value
		//get_device_attr()->get_w_attr_by_name("loggingTargetStorage").get_write_value(attr_loggingTargetStorage_write);
		get_device_attr()->get_w_attr_by_name("loggingTargetStorage").get_write_value(wval);
		attr_loggingTargetStorage_write= std::string(wval);
	}
	else{//set to default property
		//attr_loggingTargetStorage_write= const_cast<char*>(loggingTargetStorageDefault.c_str());
		//get_device_attr()->get_w_attr_by_name("loggingTargetStorage").set_write_value(attr_loggingTargetStorage_write);
		wval= const_cast<char*>(loggingTargetStorageDefault.c_str());
		attr_loggingTargetStorage_write= loggingTargetStorageDefault;
		get_device_attr()->get_w_attr_by_name("loggingTargetStorage").set_write_value(wval);
	}
	//*attr_loggingTargetStorage_read= Tango::string_dup(attr_loggingTargetStorage_write);
	*attr_loggingTargetStorage_read= Tango::string_dup(wval);

	_INFO_LOG("central/element/storage logger targets: ("<<attr_loggingTargetCentral_write<<","<<attr_loggingTargetElement_write<<","<<attr_loggingTargetStorage_write<<")");
	
	//######################################
	//## Init log levels
	//######################################
	//Central log level
	if(Utils_ns::TangoUtils::HasMemorizedValue(this,"loggingLevelCentral")){//set to written value
		get_device_attr()->get_w_attr_by_name("loggingLevelCentral").get_write_value(attr_loggingLevelCentral_write);
	}
	else{//set to default property
		attr_loggingLevelCentral_write= loggingLevelCentralDefault;
		get_device_attr()->get_w_attr_by_name("loggingLevelCentral").set_write_value(attr_loggingLevelCentral_write);
	}
	*attr_loggingLevelCentral_read= attr_loggingLevelCentral_write;
	

	//Element log level
	if(Utils_ns::TangoUtils::HasMemorizedValue(this,"loggingLevelElement")){//set to written value
		get_device_attr()->get_w_attr_by_name("loggingLevelElement").get_write_value(attr_loggingLevelElement_write);
	}
	else{//set to default property
		attr_loggingLevelElement_write= loggingLevelElementDefault;
		get_device_attr()->get_w_attr_by_name("loggingLevelElement").set_write_value(attr_loggingLevelElement_write);
	}
	*attr_loggingLevelElement_read= attr_loggingLevelElement_write;
	
	
	//Storage log level
	if(Utils_ns::TangoUtils::HasMemorizedValue(this,"loggingLevelStorage")){//set to written value
		get_device_attr()->get_w_attr_by_name("loggingLevelStorage").get_write_value(attr_loggingLevelStorage_write);
	}
	else{//set to default property
		attr_loggingLevelStorage_write= loggingLevelStorageDefault;
		get_device_attr()->get_w_attr_by_name("loggingLevelStorage").set_write_value(attr_loggingLevelStorage_write);
	}
	*attr_loggingLevelStorage_read= attr_loggingLevelStorage_write;
	
	_INFO_LOG("central/element/storage logger levels: ("<<attr_loggingLevelCentral_write<<","<<attr_loggingLevelElement_write<<","<<attr_loggingLevelStorage_write<<")");
	
}//close InitLoggerPars()


void LMCDevice::EnableCentralLogger()
{
	//Get logger instance
	log4tango::Logger* logger= get_logger();
	if(!logger) {	
		std::stringstream ss;
		ss<<"Failed to get logger instance!";	
		set_state(Tango::FAULT);		
		set_status(ss.str().c_str());
		_THROW_RECORDED_TANGO_EXCEPTION("ENABLE_CENTRAL_LOGGER_FAILED",ss.str());
	}

	//Initialize central logger
	//NB: This will consider current log level & target specified in attributes
	bool setLogLevels= true;
	try {
		InitCentralLogger(logger,setLogLevels);
	}
	catch(...){
		*attr_centralLoggerStatus_read= centralLoggerStatusEnum::_FAILED;
		throw;
	}

	//If successfully enabled set logger status attr
	*attr_centralLoggerStatus_read= centralLoggerStatusEnum::_OK;

}//close EnableCentralLogger()


void LMCDevice::DisableCentralLogger()
{
	//Retrieve current central log target
	/*
	std::string loggingTargetCentral= "";
	try{
		get_device_attr()->get_w_attr_by_name("loggingTargetCentral").get_write_value(attr_loggingTargetCentral_write);
	}
	catch(...){
		throw;
	}
	loggingTargetCentral= std::string(attr_loggingTargetCentral_write);
	*/

	std::string loggingTargetCentral= attr_loggingTargetCentral_write;

	//Do nothing if no central log target is set
	if(loggingTargetCentral==""){
		return;
	}

	//Get logger instance
	log4tango::Logger* logger= get_logger();
	if(!logger) {	
		std::stringstream ss;
		ss<<"Failed to get logger instance!";	
		set_state(Tango::FAULT);		
		set_status(ss.str().c_str());
		_THROW_RECORDED_TANGO_EXCEPTION("DISABLE_CENTRAL_LOGGER_FAILED",ss.str());
	}

	//Remove all zombie appenders
	RemoveZombieLogAppenders(logger);

	//Remove appender
	std::string log_target= std::string("device::") + loggingTargetCentral;
	std::transform(log_target.begin(), log_target.end(),log_target.begin(), ::tolower);
	try{
		logger->remove_appender(log_target);
	}
	catch(...){
		std::stringstream ss;
		ss<<"Failed to remove Central logger appender "<<log_target<<" (hints: check appender name and if enabled)!";
		_THROW_RECORDED_TANGO_EXCEPTION("DISABLE_CENTRAL_LOGGER_FAILED",ss.str());
	}

	/*
	_INFO_LOG("Deleting central log appended ptr...");
	if(m_centralLogAppender){
		delete m_centralLogAppender;
		m_centralLogAppender= 0;
	}
	*/

	//If successfully disabled set logger status attr
	*attr_centralLoggerStatus_read= centralLoggerStatusEnum::_DISABLED;
	
}//close DisableCentralLogger()


void LMCDevice::EnableElementLogger()
{
	//Get logger instance
	log4tango::Logger* logger= get_logger();
	if(!logger) {	
		std::stringstream ss;
		ss<<"Failed to get logger instance!";	
		set_state(Tango::FAULT);		
		set_status(ss.str().c_str());
		_THROW_RECORDED_TANGO_EXCEPTION("ENABLE_ELEMENT_LOGGER_FAILED",ss.str());
	}

	//Initialize Element logger
	//NB: This will consider current log level & target specified in attributes
	bool setLogLevels= true;
	try {
		InitElementLogger(logger,setLogLevels);
	}
	catch(...){
		*attr_elementLoggerStatus_read= elementLoggerStatusEnum::_FAILED;
		throw;
	}

	//If successfully enabled set logger status attr
	*attr_elementLoggerStatus_read= elementLoggerStatusEnum::_OK;

}//close EnableElementLogger()

void LMCDevice::DisableElementLogger()
{
	//Retrieve current Element log target
	/*
	std::string loggingTargetElement= "";
	try{
		get_device_attr()->get_w_attr_by_name("loggingTargetElement").get_write_value(attr_loggingTargetElement_write);
	}
	catch(...){
		throw;
	}
	loggingTargetElement= std::string(attr_loggingTargetElement_write);
	*/
	std::string loggingTargetElement= std::string(attr_loggingTargetElement_write);
	_INFO_LOG("Disabling element logger target "<<attr_loggingTargetElement_write<<" (loggingTargetElement="<<loggingTargetElement<<")");
	

	//Do nothing if no Element log target is set
	if(loggingTargetElement==""){
		return;
	}

	//Get logger instance
	log4tango::Logger* logger= get_logger();
	if(!logger) {	
		std::stringstream ss;
		ss<<"Failed to get logger instance!";	
		set_state(Tango::FAULT);		
		set_status(ss.str().c_str());
		_THROW_RECORDED_TANGO_EXCEPTION("DISABLE_ELEMENT_LOGGER_FAILED",ss.str());
	}

	//Remove all zombie appenders
	RemoveZombieLogAppenders(logger);
	
	//Remove appender
	std::string log_target= std::string("device::") + loggingTargetElement;
	std::transform(log_target.begin(), log_target.end(),log_target.begin(), ::tolower);
	_INFO_LOG("Removing log appender "<<log_target<<"...");
	try{
		logger->remove_appender(log_target);
	}
	catch(...){
		std::stringstream ss;
		ss<<"Failed to remove Element logger appender "<<log_target<<" (hints: check appender name and if enabled)!";
		_THROW_RECORDED_TANGO_EXCEPTION("DISABLE_ELEMENT_LOGGER_FAILED",ss.str());
	}

	//If successfully disabled set logger status attr
	*attr_elementLoggerStatus_read= elementLoggerStatusEnum::_DISABLED;

}//close DisableElementLogger()

void LMCDevice::EnableStorageLogger()
{
	//Initialize storage logger
	//NB: This will consider current log level & target specified in attributes
	try {
		InitStorageLogger();
	}
	catch(...){
		*attr_storageLoggerStatus_read= storageLoggerStatusEnum::_FAILED;
		throw;
	}

	//If successfully enabled set logger status attr
	*attr_storageLoggerStatus_read= storageLoggerStatusEnum::_OK;

}//close EnableStorageLogger()

void LMCDevice::DisableStorageLogger()
{
	//Check if storage logger is enabled
	//Do nothing if logger is not enabled
	//if(*attr_storageLoggerStatus_read!=storageLoggerStatusEnum::_OK){
	//	return;
	//}
	
	//Remove logger	
	if(Utils_ns::LoggerManager::Instance().DestroySysLogger()<0){	
		std::stringstream ss;
		ss<<"Failed to remove sys logger!";
		_THROW_RECORDED_TANGO_EXCEPTION("DISABLE_STORAGE_LOGGER_FAILED",ss.str());
	}

	//Check if syslogger was effectively removed by trying to retrieve instance from logger manager singleton
	if(Utils_ns::LoggerManager::Instance().GetLogger()){
		std::stringstream ss;
		ss<<"Sys logger was not removed as expected (this should not occur!)";
		_THROW_RECORDED_TANGO_EXCEPTION("DISABLE_STORAGE_LOGGER_FAILED",ss.str());
	}

	//If successfully disabled set logger status attr
	*attr_storageLoggerStatus_read= storageLoggerStatusEnum::_DISABLED;

}//close DisableStorageLogger()



int LMCDevice::SetAppenderLogLevel(std::string appender_name,Tango::DevLong log_level) {
	
	
	#ifdef APPENDERS_HAVE_LEVEL_THRESHOLD
	try {
		//Convert given Tango log level in log4 code
		log4tango::Level::Value log4_level= Tango::Logging::tango_to_log4tango_level(static_cast<Tango::LogLevel>(log_level), true);

		log4tango::Logger* logger= get_logger();
		log4tango::Appender* appender= logger->get_appender(appender_name);
		if(!appender){
			_ERROR_LOG("No appender with name "<<appender_name<<" found in the appender list!");
			return -1;
		}
		appender->set_level(log4_level);

	}//close try
	catch(Tango::DevFailed& e){
		_ERROR_LOG("Failed to set appender log level!");
		return -1;
	}
	#else
		_WARN_LOG("APPENDERS_HAVE_LEVEL_THRESHOLD is disabled, cannot set log level for separate appenders");
		return -1;
	#endif

	return 0;

}//close SetAppenderLogLevel()

int LMCDevice::GetAppenderLogLevel(Tango::DevLong& log_level,std::string appender_name) {
		
	#ifdef APPENDERS_HAVE_LEVEL_THRESHOLD
	try {
		log4tango::Logger* logger= get_logger();
		log4tango::Appender* appender= logger->get_appender(appender_name);
		if(!appender){
			_WARN_LOG("No appender with name "<<appender_name<<" found in the appender list!");
			return -1;
		}

		//Get log4tango appender level
		log4tango::Level::Value log4tango_level= appender->get_level();

		//Convert log4tango log level to Tango log level
		Tango::LogLevel tango_level= Tango::Logging::log4tango_to_tango_level(log4tango_level);
		log_level= static_cast<Tango::DevLong>(tango_level);

		_DEBUG_LOG("Current console log level "<<tango_level<<" (log4tango_level="<<log4tango_level<<")");

	}//close try
	catch(Tango::DevFailed& e){
		_ERROR_LOG("Failed to set appender log level!");
		return -1;
	}
	#else
		_WARN_LOG("APPENDERS_HAVE_LEVEL_THRESHOLD is disabled, cannot set log level for separate appenders");
		return -1;
	#endif

	return 0;

}//close GetAppenderLogLevel()


void LMCDevice::InitMemorizedAttrs(){

	//Check if DB is used
	if (Tango::Util::instance()->_UseDb==false) {
		std::string errMsg("Cannot get DB instance (hint: are you running device with DB?)!");
		_WARN_LOG(errMsg);
		_THROW_RECORDED_TANGO_EXCEPTION("INIT_MEMORIZED_ATTRS_FAILED",errMsg);
	}
	
	//Loop over writable attributes
	int status= 0;
	std::vector<long> wattr_indexes= get_device_attr()->get_w_attr_list();
	for(unsigned int i=0;i<wattr_indexes.size();i++){
		long index= wattr_indexes[i];
		Tango::WAttribute& wattr= get_device_attr()->get_w_attr_by_ind(index);
		std::string wattr_name= wattr.get_name();
		bool is_memorized= wattr.is_memorized();
		if(!is_memorized) continue;
		_DEBUG_LOG("Initializing memorized w attr "<<wattr_name<<"...");

		try{
			InitMemorizedAttr(wattr_name);
		}
		catch(Tango::DevFailed& e){
			std::string reason(e.errors[0].desc.in());
			std::stringstream ss;
			ss<<"Tango exception (reason="<<reason<<") occurred while initializing writable memorized attr "<<wattr_name;
			_ERROR_LOG(ss.str());
			status= -1;
		}
		catch(std::exception& e){
			std::stringstream ss;
			ss<<"C++ exception (err="<<e.what()<<") occurred while initializing writable memorized attr "<<wattr_name;
			_ERROR_LOG(ss.str());
			status= -1;
		}
		catch(...){
			std::stringstream ss;
			ss<<"Unknown exception occurred while initializing writable memorized attr "<<wattr_name;
			_ERROR_LOG(ss.str());
			status= -1;
		}
	}//end loop memorized attrs

	if(status<0){
		std::stringstream ss;
		ss<<"Failures occurred when initializing one/more memorized attrs!";
		_THROW_RECORDED_TANGO_EXCEPTION("INIT_MEMORIZED_ATTRS_FAILED",ss.str());
	}

}//close InitMemorizedAttrs()

void LMCDevice::InitMemorizedAttr(std::string& attr_name){

	//## Init database device
	Tango::DbDevice* db_dev= get_db_device();
	if(!db_dev){
		std::string errMsg("Cannot get DbDevice instance!");
		_THROW_RECORDED_TANGO_EXCEPTION("INIT_MEMORIZED_ATTR_FAILED",errMsg);		
	}
	if(attr_name==""){
		std::string errMsg("Empty attr name given!");
		_THROW_RECORDED_TANGO_EXCEPTION("INIT_MEMORIZED_ATTR_FAILED",errMsg);		
	}

	Tango::WAttribute& wattr= get_device_attr()->get_w_attr_by_name(attr_name.c_str());
	long int data_type= wattr.get_data_type();
	Tango::AttrDataFormat attr_format= wattr.get_data_format();	

	//## Check if attr is a scalar attr
	if(attr_format!=Tango::SCALAR){
		std::string errMsg("Spectrum memorized attr are not supported in Tango!");
		_THROW_RECORDED_TANGO_EXCEPTION("INIT_MEMORIZED_ATTR_FAILED",errMsg);
	}
		
	//## Check if memorized attribute is not initialized
	//## If not initialized, set it to the default property value (if present)
	bool hasMemorizedValue= false;
	Tango::DbDatum mem_data;
	std::string attr_prop_name= "";
	try {
		Tango::DbData db_data;
		db_data.push_back(Tango::DbDatum(attr_name.c_str()));
		db_dev->get_attribute_property(db_data);
	
		long nb_prop;
		db_data[0] >> nb_prop;

   	for (int k=0;k<nb_prop;k++) {
    	std::string& prop_name = db_data[k+1].name;
			if (prop_name == "__value") {
				hasMemorizedValue= true;	
				mem_data= db_data[k+1];
			}
			if (prop_name == "default_value_prop_name") {
				db_data[k+1] >> attr_prop_name; 
			}
		}//end loop attr properties 

	}//close try
	catch(Tango::DevFailed& e){
		std::stringstream ss;
		ss<<"Failed to retrieve memorized attr "<<attr_name<<" value from DB!";
		_THROW_RECORDED_TANGO_EXCEPTION("INIT_MEMORIZED_ATTR_FAILED",ss.str());
	}

	//## If memorized value has already a value property stored in DB return!
	//if(hasMemorizedValue){
	//	_DEBUG_LOG("Attribute "<<attr_name<<" has already a memorized value, initialize to this value...");
	//	return;	
	//}

	//If no memorized value is present, set it to the associated default property value (if present & if this has a value stored)
	//NB: If a property name is given in argument use it, otherwise try to use a default prop name= attr_name+"Default"
	if(attr_prop_name==""){
		//Define property name
		std::string attr_name_capitalized= attr_name;
		attr_name_capitalized[0] = std::toupper(attr_name_capitalized[0]);
		attr_prop_name= attr_name_capitalized + std::string("Default");

		//Check if property is defined in DB
		bool hasDefaultMemProp= Utils_ns::TangoUtils::HasDevProp(this,attr_prop_name);
		if(!hasDefaultMemProp){
			std::stringstream ss;
			ss<<"Cannot find default property "<<attr_prop_name<<" to init memorized attr "<<attr_name<<" (hint: not an error if attr is created statically).";
			_WARN_LOG(ss.str());
			_THROW_RECORDED_TANGO_EXCEPTION("INIT_MEMORIZED_ATTR_FAILED",ss.str());
		}
	}//close if

	try{
		switch (data_type) {
			case Tango::DEV_FLOAT: 
				InitMemorizedAttrFromDbDatum<Tango::DevFloat>(mem_data,wattr,attr_name,hasMemorizedValue,attr_prop_name);
			break;
			case Tango::DEV_DOUBLE: 
				InitMemorizedAttrFromDbDatum<Tango::DevDouble>(mem_data,wattr,attr_name,hasMemorizedValue,attr_prop_name);
				break;
			case Tango::DEV_LONG: 
				InitMemorizedAttrFromDbDatum<Tango::DevLong>(mem_data,wattr,attr_name,hasMemorizedValue,attr_prop_name);
				break;
			case Tango::DEV_SHORT: 
				InitMemorizedAttrFromDbDatum<Tango::DevShort>(mem_data,wattr,attr_name,hasMemorizedValue,attr_prop_name);
				break;
			#if TANGO_VERSION_MAJOR >= 9
			case Tango::DEV_ENUM: 
				InitMemorizedAttrFromDbDatum<Tango::DevShort>(mem_data,wattr,attr_name,hasMemorizedValue,attr_prop_name);
				break;
			#endif
			case Tango::DEV_STRING: 
				InitMemorizedAttrFromDbDatum<std::string>(mem_data,wattr,attr_name,hasMemorizedValue,attr_prop_name);
				break;
			case Tango::DEV_BOOLEAN: 
				InitMemorizedAttrFromDbDatum<Tango::DevBoolean>(mem_data,wattr,attr_name,hasMemorizedValue,attr_prop_name);
				break;
			case Tango::DEV_STATE: 
				InitMemorizedAttrFromDbDatum<Tango::DevState>(mem_data,wattr,attr_name,hasMemorizedValue,attr_prop_name);
				break;
			default:
			{
				std::stringstream ss;
				ss<<"Unsupported data type ("<<data_type<<") for attribute "<<attr_name<<"!";
				_ERROR_LOG(ss.str());
	      _THROW_TANGO_EXCEPTION("INIT_MEMORIZED_ATTR_FAILED",ss.str());
       	break;
			}	
		}//close switch			

	}//close try
	catch(Tango::DevFailed& e){
		std::string reason(e.errors[0].desc.in());
		std::stringstream ss;
		ss<<"Tango exception (reason="<<reason<<") occurred while setting memorized value to wattr "<<attr_name<<"!";
		_THROW_TANGO_EXCEPTION("INIT_MEMORIZED_ATTR_FAILED",ss.str());
	}
	catch(std::exception& e){
		std::stringstream ss;
		ss<<"C++ exception (err="<<e.what()<<") occurred while setting memorized value to wattr "<<attr_name<<"!";
		_THROW_TANGO_EXCEPTION("INIT_MEMORIZED_ATTR_FAILED",ss.str());
	}
	catch(...){
		std::stringstream ss;
		ss<<"Unknown exception occurred while setting memorized value to wattr "<<attr_name<<"!";
		_THROW_RECORDED_TANGO_EXCEPTION("INIT_MEMORIZED_ATTR_FAILED",ss.str());
	}

}//close InitMemorizedAttr()


void LMCDevice::RandomizeDynAttrValues(){

	size_t nDynAttrs= m_device_attr.size();
	if(nDynAttrs<=0) return;

	//Loop over all dynamic attributes and randomize their values
	for(size_t i=0;i<nDynAttrs;i++){
		if(!m_device_attr[i]) continue;
		std::string attr_name= m_device_attr[i]->GetAttr()->get_name();
		bool isForwarded= m_device_attr[i]->IsForwarded(); 		
		if(isForwarded) continue;

		_DEBUG_LOG("Randomizing dyn attr "<<attr_name<<"...");
		if(RandomizeDynAttrValue(attr_name)<0){
			_WARN_LOG("Failed to randomize value of attribute "<<attr_name<<"!");
			continue;
		}
	}//end loop dyn attrs
	
}//close RandomizeDynAttrValues()


int LMCDevice::RandomizeDynAttrValue(std::string& attr_name){

	//Check if attribute exists
	long attr_data_type;
	Tango::AttrDataFormat attr_data_format;	
	long attr_data_size;
	bool isForwarded= false;
	try{
		Tango::Attribute& attr= get_device_attr()->get_attr_by_name(attr_name.c_str());
		attr_data_type= attr.get_data_type();
		attr_data_format= attr.get_data_format();
		attr_data_size= attr.get_max_dim_x();//attr.get_data_size();
		isForwarded= attr.is_fwd_att();
	}
	catch(Tango::DevFailed &e){//an exception is thrown if the attribute is not existing
		_ERROR_LOG("Attribute "<<attr_name<<" does not exist in device!");
		return -1;
	}
	catch(...){//an exception is thrown if the attribute is not existing
		_ERROR_LOG("Attribute "<<attr_name<<" does not exist in device!");
		return -1;
	}

	//Invalid op for fwd attr
	if(isForwarded){
		_ERROR_LOG("Randomization is not supported/allowed for fwd attributes!");
		return -1;
	}

	//Get access to attribute properties
	try {
		Tango::DbData db_data;
		db_data.push_back(Tango::DbDatum(attr_name.c_str()));
		get_db_device()->get_attribute_property(db_data);
	
		long nb_prop;
		db_data[0] >> nb_prop;

		//Get gen model
		bool hasGenModel= false;
		bool hasRandomize= false;
		Tango::DbDatum genModelData;
		Tango::DbDatum randomizeData;
   	for (int k=0;k<nb_prop;k++) {
    	std::string& prop_name = db_data[k+1].name;
			if (prop_name == "genModel") {
				hasGenModel= true;	
				genModelData= db_data[k+1];
			}
			if (prop_name == "randomize") {
				hasRandomize= true;	
				randomizeData= db_data[k+1];
			}
		}//end loop attr properties 

		//Check gen model & randomize property in DB
		if(!hasGenModel || !hasRandomize){
			std::stringstream ss;
			ss<<"Attribute "<<attr_name<<" has no generation model and/or randomize property set in DB!";
			_THROW_TANGO_EXCEPTION("RANDOMIZE_DYN_ATTR_FAILED",ss.str());
		}
		int genModelType= Utils_ns::AttrGenerationModel::eCONST;
		genModelData>>genModelType;

		bool isRandomizeAttr= false;
		randomizeData>>isRandomizeAttr;

		//If randomize flag is disabled no generation will be performed
		if(!isRandomizeAttr){
			_DEBUG_LOG("Attr "<<attr_name<<" is not set as randomized, nothing to be done...");
			return 0;
		}

		//Randomize attribute value according to model
		if(genModelType==Utils_ns::AttrGenerationModel::eUNIFORM){//UNIFORM
			bool hasMinValue= false;
			bool hasMaxValue= false;
			Tango::DbDatum genModelData_min;
			Tango::DbDatum genModelData_max;
   		for (int k=0;k<nb_prop;k++) {
    		std::string& prop_name = db_data[k+1].name;
				if (prop_name == "genMinValue") {
					hasMinValue= true;	
					genModelData_min= db_data[k+1];
				}
				if (prop_name == "genMaxValue") {
					hasMaxValue= true;	
					genModelData_max= db_data[k+1];
				}
			}//end loop attr properties 

			if(!hasMaxValue || !hasMinValue){
				std::stringstream ss;
				ss<<"Attribute "<<attr_name<<" has no min/max value property set in DB for uniform randomization!";
				_THROW_TANGO_EXCEPTION("RANDOMIZE_DYN_ATTR_FAILED",ss.str());
			}

			Tango::DbData genModelParData;
			genModelParData.push_back(genModelData_min);
			genModelParData.push_back(genModelData_max);

			if( RandomizeDynAttrUniform(genModelParData,attr_name,attr_data_type,attr_data_format,attr_data_size)<0 ){
				std::stringstream ss;
				ss<<"Uniform randomization for attribute "<<attr_name<<") failed!";
				_THROW_TANGO_EXCEPTION("RANDOMIZE_DYN_ATTR_FAILED",ss.str());
			}
		}//close if UNIFORM generator

		else if(genModelType==Utils_ns::AttrGenerationModel::eGAUSS){//GAUSSIAN
			bool hasMinValue= false;
			bool hasMaxValue= false;
			bool hasMeanValue= false;
			bool hasSigmaValue= false;
			Tango::DbDatum genModelData_min;
			Tango::DbDatum genModelData_max;
			Tango::DbDatum genModelData_mean;
			Tango::DbDatum genModelData_sigma;
			
   		for (int k=0;k<nb_prop;k++) {
    		std::string& prop_name = db_data[k+1].name;
				if (prop_name == "genMinValue") {
					hasMinValue= true;	
					genModelData_min= db_data[k+1];
				}
				if (prop_name == "genMaxValue") {
					hasMaxValue= true;	
					genModelData_max= db_data[k+1];
				}
				if (prop_name == "genMeanValue") {
					hasMeanValue= true;	
					genModelData_mean= db_data[k+1];
				}
				if (prop_name == "genSigmaValue") {
					hasSigmaValue= true;	
					genModelData_sigma= db_data[k+1];
				}
			}//end loop attr properties 

			if(!hasMaxValue || !hasMinValue || !hasMeanValue || !hasSigmaValue){
				std::stringstream ss;
				ss<<"Attribute "<<attr_name<<" has no min/max/mean/sigma value property set in DB for gaussian randomization!";
				_THROW_TANGO_EXCEPTION("RANDOMIZE_DYN_ATTR_FAILED",ss.str());
			}

			Tango::DbData genModelParData;
			genModelParData.push_back(genModelData_min);
			genModelParData.push_back(genModelData_max);
			genModelParData.push_back(genModelData_mean);
			genModelParData.push_back(genModelData_sigma);

			if( RandomizeDynAttrGaussian(genModelParData,attr_name,attr_data_type,attr_data_format,attr_data_size)<0 ){
				std::stringstream ss;
				ss<<"Gaussian randomization for attribute "<<attr_name<<") failed!";
				_THROW_TANGO_EXCEPTION("RANDOMIZE_DYN_ATTR_FAILED",ss.str());
			}
		}//close if gaussian model

		else if(genModelType==Utils_ns::AttrGenerationModel::eDISCRETE){
			bool hasProbWeights= false;
			Tango::DbDatum genModelData_weights;

			for (int k=0;k<nb_prop;k++) {
    		std::string& prop_name = db_data[k+1].name;
				if (prop_name == "genProbWeightValue") {
					hasProbWeights= true;	
					genModelData_weights= db_data[k+1];
				}
			}//end loop attr properties 

			if(!hasProbWeights){
				std::stringstream ss;
				ss<<"Attribute "<<attr_name<<" has no prob weights value property set in DB for gaussian randomization!";
				_THROW_TANGO_EXCEPTION("RANDOMIZE_DYN_ATTR_FAILED",ss.str());
			}

			Tango::DbData genModelParData;
			genModelParData.push_back(genModelData_weights);

			if( RandomizeDynAttrDiscrete(genModelParData,attr_name,attr_data_type,attr_data_format)<0 ){
				std::stringstream ss;
				ss<<"Discrete randomization for attribute "<<attr_name<<") failed!";
				_THROW_TANGO_EXCEPTION("RANDOMIZE_DYN_ATTR_FAILED",ss.str());
			}

		}//close else if discrete model

		else {
			std::stringstream ss;
			ss<<"Invalid gen model found (model="<<genModelType<<") in DB!";
			_THROW_TANGO_EXCEPTION("RANDOMIZE_DYN_ATTR_FAILED",ss.str());
		}

	}//close try
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Failed to update attr "<<attr_name<<" value!");
		return -1;
	}

	return 0;

}//close RandomizeDynAttrValue()


int LMCDevice::RandomizeDynAttrUniform(Tango::DbData& genModelParData,std::string& attr_name,long data_type,Tango::AttrDataFormat data_format,long data_size){

	//Check db_data
	if(genModelParData.size()!=2){
		_ERROR_LOG("Uniform randomization failed (invalid number of entries in gen model data, 2 required)!");
		return -1;
	}

	try{	
		if(data_format==Tango::SCALAR){	
			switch (data_type) {
				case Tango::DEV_FLOAT: 
					RandomizeScalarDynAttrUniform<Tango::DevFloat>(genModelParData,attr_name,data_type);
					break;
				case Tango::DEV_DOUBLE: 
					RandomizeScalarDynAttrUniform<Tango::DevDouble>(genModelParData,attr_name,data_type);
					break;
				case Tango::DEV_LONG: 
					RandomizeScalarDynAttrUniform<Tango::DevLong>(genModelParData,attr_name,data_type);
					break;
				case Tango::DEV_SHORT: 
					RandomizeScalarDynAttrUniform<Tango::DevShort>(genModelParData,attr_name,data_type);
					break;
				#if TANGO_VERSION_MAJOR >= 9
				case Tango::DEV_ENUM: 
					RandomizeScalarDynAttrUniform<Tango::DevShort>(genModelParData,attr_name,data_type);
					break;
				#endif
				case Tango::DEV_STRING: 
					RandomizeScalarDynAttrUniform<Tango::DevString>(genModelParData,attr_name,data_type);
					break;
				case Tango::DEV_BOOLEAN: 
					RandomizeScalarDynAttrUniform<Tango::DevBoolean>(genModelParData,attr_name,data_type);
					break;
				default:
				{
					std::stringstream ss;
					ss<<"Unsupported data type ("<<data_type<<") for attribute "<<attr_name<<"!";
					_ERROR_LOG(ss.str());
	      	_THROW_TANGO_EXCEPTION("ADD_DYN_ATTR_FAILED",ss.str());
       	 	break;
				}	
			}//close switch
		}//SCALAR

		else if(data_format==Tango::SPECTRUM){
			switch (data_type) {
				case Tango::DEV_FLOAT: 
					RandomizeSpectrumDynAttrUniform<Tango::DevFloat>(genModelParData,attr_name,data_type,data_size);
					break;
				case Tango::DEV_DOUBLE: 
					RandomizeSpectrumDynAttrUniform<Tango::DevDouble>(genModelParData,attr_name,data_type,data_size);
					break;
				case Tango::DEV_LONG: 
					RandomizeSpectrumDynAttrUniform<Tango::DevLong>(genModelParData,attr_name,data_type,data_size);
					break;
				case Tango::DEV_SHORT: 
					RandomizeSpectrumDynAttrUniform<Tango::DevShort>(genModelParData,attr_name,data_type,data_size);
					break;
				#if TANGO_VERSION_MAJOR >= 9
				case Tango::DEV_ENUM: 
					RandomizeSpectrumDynAttrUniform<Tango::DevShort>(genModelParData,attr_name,data_type,data_size);
					break;
				#endif
				case Tango::DEV_STRING: 
					RandomizeSpectrumDynAttrUniform<Tango::DevString>(genModelParData,attr_name,data_type,data_size);
					break;
				case Tango::DEV_BOOLEAN: 
					RandomizeSpectrumDynAttrUniform<Tango::DevBoolean>(genModelParData,attr_name,data_type,data_size);
					break;
				default:
				{
					std::stringstream ss;
					ss<<"Unsupported data type ("<<data_type<<") for attribute "<<attr_name<<"!";
					_ERROR_LOG(ss.str());
	      	_THROW_TANGO_EXCEPTION("ADD_DYN_ATTR_FAILED",ss.str());
       	 	break;
				}	
			}//close switch
		}//SPECTRUM

		else{
			std::string errMsg= "Uniform randomization unsupported for this attribute format!";	
			_THROW_TANGO_EXCEPTION("RANDOMIZE_DYN_ATTR_UNIFORM_FAILED",errMsg);	
		}

	}//close try
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Failed to randomize attribute uniform!");
		return -1;
	}
	
	return 0;

}//close RandomizeDynAttrUniform()



int LMCDevice::RandomizeDynAttrDiscrete(Tango::DbData& genModelParData,std::string& attr_name,long data_type,Tango::AttrDataFormat data_format){

	//Check db_data
	if(genModelParData.size()!=1){
		_ERROR_LOG("Discrete randomization failed (invalid number of entries in gen model data, 1 required)!");
		return -1;
	}

	//Randomize data
	try{	
		if(data_format==Tango::SCALAR){	

			if(data_type==Tango::DEV_STATE){
				//Get model par data
				std::vector<double> probWeights;
				genModelParData[0]>>probWeights;

				//Generate random number	
				std::discrete_distribution<Tango::DevShort> distribution(probWeights.begin(),probWeights.end());
				Tango::DevState attr_value= static_cast<Tango::DevState>(distribution(m_randGenerator));

				//Set attribute	value
				if(SetDynAttrValue<Tango::DevState>(attr_value,attr_name)<0){
					std::stringstream ss;
					ss<<"Failed to set attr "<<attr_name<<" value!";
					_THROW_TANGO_EXCEPTION("RANDOMIZE_DYN_ATTR_DISCRETE_FAILED",ss.str());		
				}
			}//close if STATE

			#if TANGO_VERSION_MAJOR >= 9
			else if(data_type==Tango::DEV_ENUM){
				//Get model par data
				std::vector<double> probWeights;
				genModelParData[0]>>probWeights;

				//Generate random number	
				std::discrete_distribution<Tango::DevShort> distribution(probWeights.begin(),probWeights.end());
				Tango::DevShort attr_value= distribution(m_randGenerator);

				//Set attribute	value
				if(SetDynAttrValue<Tango::DevEnum>(attr_value,attr_name)<0){
					std::stringstream ss;
					ss<<"Failed to set attr "<<attr_name<<" value!";
					_THROW_TANGO_EXCEPTION("RANDOMIZE_DYN_ATTR_DISCRETE_FAILED",ss.str());		
				}
			}//close if ENUM
			#endif

			else {
				std::stringstream ss;
				ss<<"Discrete randomization for attr type "<<data_type<<" is invalid/unsupported!";
				_THROW_TANGO_EXCEPTION("RANDOMIZE_DYN_ATTR_DISCRETE_FAILED",ss.str());
			}

		}//close SCALAR

		else if(data_format==Tango::SPECTRUM){
			std::string errMsg= "Discrete randomization unsupported for this attribute format!";
			_THROW_TANGO_EXCEPTION("RANDOMIZE_DYN_ATTR_DISCRETE_FAILED",errMsg);
		}//close SPECTRUM

		else if(data_format==Tango::IMAGE){
			std::string errMsg= "Discrete randomization unsupported for this attribute format!";
			_THROW_TANGO_EXCEPTION("RANDOMIZE_DYN_ATTR_DISCRETE_FAILED",errMsg);
		}//close IMAGE

		else{
			std::string errMsg= "Discrete randomization unsupported for this attribute format!";
			_THROW_TANGO_EXCEPTION("RANDOMIZE_DYN_ATTR_DISCRETE_FAILED",errMsg);
		}
	}//close try
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Failed to randomize attribute discrete!");
		return -1;
	}
	
	return 0;

}//close RandomizeDynAttrDiscrete()


int LMCDevice::RandomizeDynAttrGaussian(Tango::DbData& genModelParData,std::string& attr_name,long data_type,Tango::AttrDataFormat data_format,long data_size){

	//Check db_data
	if(genModelParData.size()!=4){
		_ERROR_LOG("Gaussian randomization failed (invalid number of entries in gen model data, 4 required)!");
		return -1;
	}
	
	//Randomize
	try{
		if(data_format==Tango::SCALAR){	
			switch (data_type) {
				case Tango::DEV_FLOAT: 
					RandomizeScalarDynAttrGaussian<Tango::DevFloat>(genModelParData,attr_name,data_type);
					break;
				case Tango::DEV_DOUBLE: 
					RandomizeScalarDynAttrGaussian<Tango::DevDouble>(genModelParData,attr_name,data_type);
					break;
				case Tango::DEV_LONG: 
					RandomizeScalarDynAttrGaussian<Tango::DevLong>(genModelParData,attr_name,data_type);
					break;
				case Tango::DEV_SHORT: 
					RandomizeScalarDynAttrGaussian<Tango::DevShort>(genModelParData,attr_name,data_type);
					break;
				#if TANGO_VERSION_MAJOR >= 9
				case Tango::DEV_ENUM: 
				{
					std::string errMsg= "Gaussian randomization for enum attr is invalid/unsupported!";
					_THROW_TANGO_EXCEPTION("RANDOMIZE_DYN_ATTR_GAUSSIAN_FAILED",errMsg);	
					break;
				}
				#endif
				case Tango::DEV_STRING: 
				{
					std::string errMsg= "Gaussian randomization for string attr is invalid/unsupported!";
					_THROW_TANGO_EXCEPTION("RANDOMIZE_DYN_ATTR_GAUSSIAN_FAILED",errMsg);
					break;
				}
				case Tango::DEV_BOOLEAN: 
				{
					std::string errMsg= "Gaussian randomization for bool attr is invalid/unsupported!";
					_THROW_TANGO_EXCEPTION("RANDOMIZE_DYN_ATTR_GAUSSIAN_FAILED",errMsg);
					break;
				}
				default:
				{
					std::stringstream ss;
					ss<<"Unsupported data type ("<<data_type<<") for attribute "<<attr_name<<"!";
					_ERROR_LOG(ss.str());
	      	_THROW_TANGO_EXCEPTION("RANDOMIZE_DYN_ATTR_GAUSSIAN_FAILED",ss.str());
       	 	break;
				}	
			}//close switch
		}//SCALAR

		else if(data_format==Tango::SPECTRUM){
			switch (data_type) {
				case Tango::DEV_FLOAT: 
					RandomizeSpectrumDynAttrGaussian<Tango::DevFloat>(genModelParData,attr_name,data_type,data_size);
					break;
				case Tango::DEV_DOUBLE: 
					RandomizeSpectrumDynAttrGaussian<Tango::DevDouble>(genModelParData,attr_name,data_type,data_size);
					break;
				case Tango::DEV_LONG: 
					RandomizeSpectrumDynAttrGaussian<Tango::DevLong>(genModelParData,attr_name,data_type,data_size);
					break;
				case Tango::DEV_SHORT: 
					RandomizeSpectrumDynAttrGaussian<Tango::DevShort>(genModelParData,attr_name,data_type,data_size);
					break;
				#if TANGO_VERSION_MAJOR >= 9
				case Tango::DEV_ENUM: 
				{
					std::string errMsg= "Gaussian randomization for enum attr is invalid/unsupported!";
					_THROW_TANGO_EXCEPTION("RANDOMIZE_DYN_ATTR_GAUSSIAN_FAILED",errMsg);	
					break;
				}
				#endif
				case Tango::DEV_STRING: 
				{
					std::string errMsg= "Gaussian randomization for string attr is invalid/unsupported!";
					_THROW_TANGO_EXCEPTION("RANDOMIZE_DYN_ATTR_GAUSSIAN_FAILED",errMsg);
					break;
				}
				case Tango::DEV_BOOLEAN: 
				{
					std::string errMsg= "Gaussian randomization for bool attr is invalid/unsupported!";
					_THROW_TANGO_EXCEPTION("RANDOMIZE_DYN_ATTR_GAUSSIAN_FAILED",errMsg);
					break;
				}
				default:
				{
					std::stringstream ss;
					ss<<"Unsupported data type ("<<data_type<<") for attribute "<<attr_name<<"!";
					_ERROR_LOG(ss.str());
	      	_THROW_TANGO_EXCEPTION("RANDOMIZE_DYN_ATTR_GAUSSIAN_FAILED",ss.str());
       	 	break;
				}	
			}//close switch
		}//SPECTRUM

		else{
			std::string errMsg= "Gaussian randomization unsupported for this attribute format!";	
			_THROW_TANGO_EXCEPTION("RANDOMIZE_DYN_ATTR_GAUSSIAN_FAILED",errMsg);	
		}

	}//close try
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Failed to randomize attribute gaussian!");
		return -1;
	}
	
	return 0;

}//close RandomizeDynAttrGaussian()


int LMCDevice::InitDevProxies(){

	//## Instantiate event callback if not already done
	if(!m_eventCallBack) {
		_DEBUG_LOG("Instantiate event callback class...");
		m_eventCallBack= new EventCallBack(this);
	}

	//## Check proxy manager
	if(!m_proxyManager){
		_ERROR_LOG("Proxy manager was not initialized (done at device init)!");
		return -1;
	}

	//## Init and subscribe device proxies
	if(m_proxyManager->InitAndSubscribeProxies(m_eventCallBack)<0){
		_WARN_LOG("Failed to initialize and/or subscribe proxies to their registered events!");
		return -1;
	}

	return 0;

}//close InitDevProxies()



int LMCDevice::RegisterFormula(Utils_ns::DeviceAttr* device_attr,Utils_ns::AttrDataPtr ad){

	//## Check input device attr
	if(!device_attr){
		_WARN_LOG("Null ptr to input device attr given!");
		return -1;
	}

	//## Check for input dyn attr 
	if(!ad){
		_WARN_LOG("Null ptr to input dyn attr given!");
		return -1;
	}

	//## Check if proxy manager has been created
	if(!m_proxyManager){
		_WARN_LOG("ProxyManager was not initialized yet (check your device initialization steps)!");
		return -1;
	}

	//## Get attr info and check if device attr has formula data
	Tango::Attr* attr= device_attr->GetAttr();
	std::string attr_name= attr->get_name();	
	if(!device_attr->HasFormulaData()){
		_DEBUG_LOG("No formula data present in attr "<<attr_name<<", nothing to be registered!");
		return 0;
	}

	//## Get formula data info
	Utils_ns::FormulaData* formula_data= device_attr->GetFormulaData();
	Utils_ns::FormulaSymbols formula_symbols= formula_data->GetFormulaSymbols();

	//## Register formula in manager
	if(m_formulaManager->RegisterFormula(attr_name,formula_data)<0){
		_WARN_LOG("Failed to register formula for attr "<<attr_name<<" (check for invalid syntax in formula vars)!");
		return -1;
	}

	//## Try to initialize the formula
	//## NB: If it fails it will be retried later
	if(InitializeFormula(attr_name,formula_data)<0){
		_WARN_LOG("Failed to initialize formula for attr "<<attr_name<<", will retry later...");
	}

	//## If formula registration succeeded do these steps: 
	//## 1) set flag in attr data
	//## 2) if enabled, create proxy status dynamic attribute for each of the proxy present in formula
	ad->set_has_formula(true);
	

	//Add proxy status attr
	//if(enableProxyMonitoring){
	if(enableProxyStatusAttrCreation){
		typedef std::map<std::string,Utils_ns::FormulaVarPtr>::iterator mapIter;
		for(mapIter it=formula_symbols.begin();it!=formula_symbols.end();it++){
			//Get proxy name
			std::string var_name= it->first;	
			bool is_proxy_attr= (it->second)->is_proxy_attr;
			if(!is_proxy_attr) continue;//skip if internal attr
			std::string proxy_name= (std::dynamic_pointer_cast<Utils_ns::ProxyAttrFormulaVar>(it->second))->device_name;
			
			//Parse proxy name to get domain, family and device name
			std::string proxy_facility_name= "";
			std::string proxy_domain_name= "";
			std::string proxy_family_name= "";
			std::string proxy_member_name= "";
			if(Utils_ns::TangoUtils::ParseFullProxyName(proxy_facility_name,proxy_domain_name,proxy_family_name,proxy_member_name,proxy_name)<0){
				_WARN_LOG("Failed to parse proxy name "<<proxy_name<<" (NB: will not create proxy attr!)");	
				continue;
			}
			std::string proxy_dyn_attr_name= std::string("proxyRunStatus_") + 
				proxy_domain_name + std::string("_") + 
				proxy_family_name + std::string("_") +
				proxy_member_name;

			//Create dyn attr in device
			_DEBUG_LOG("Creating proxy status dyn attr "<<proxy_dyn_attr_name<<"...");		
			if(CreateProxyMonitorDynAttr(proxy_dyn_attr_name,proxyStatusAttrPollPeriod,proxyStatusAttrPeriodicEventPeriod,proxyStatusAttrArchiveEventPeriod)<0){
				_WARN_LOG("Failed to create proxy status dyn attr name "<<proxy_dyn_attr_name<<"!");	
				continue;
			}
		}//end loop formula vars
	}//close if

	return 0;

}//close RegisterFormula()


int LMCDevice::InitializeFormula(std::string attr_name,Utils_ns::FormulaData* formula_data){
	
	//Check arg
	if(!formula_data) return -1;
	if(!m_proxyManager) return -1;

	//Check if already initialized
	if(formula_data->IsInitialized()){
		_DEBUG_LOG("Formula data for attr "<<attr_name<<" already initialized, nothing to be done...");
		return 0;
	}
	
	//Loop over formula symbols
	Utils_ns::FormulaSymbols formula_symbols= formula_data->GetFormulaSymbols();
	typedef std::map<std::string,Utils_ns::FormulaVarPtr>::iterator mapIter;

	for(mapIter it=formula_symbols.begin();it!=formula_symbols.end();it++){
		//Get proxy name
		std::string var_name= it->first;	
		bool is_proxy_attr= (it->second)->is_proxy_attr;	
		std::string proxy_attr_name= (it->second)->attr_name;
		bool is_initialized= (it->second)->IsInitialized();
		if(is_initialized) continue;//skip as already initialized

		//Initialize proxy attr in formula
		if(is_proxy_attr){
			_DEBUG_LOG("Initializing proxy attr "<<proxy_attr_name<<" in formula...");
			std::string proxy_name= std::dynamic_pointer_cast<Utils_ns::ProxyAttrFormulaVar>(it->second)->device_name;
		
			//Retrieve proxy attr info
			Tango::AttributeInfoEx attr_info;
			if(m_proxyManager->GetProxyAttributeInfo(attr_info,proxy_name,proxy_attr_name)<0){
				_WARN_LOG("Failed to retrieve attr info for formula var "<<var_name<<" (attr="<<proxy_attr_name<<"), skip to next formula var...");
				continue;
			}

			//Set attr data to formula var
			//NB: This will create attr data according to the attr info set
			if(formula_data->SetProxyAttrData(var_name,attr_info)<0){
				_WARN_LOG("Failed to set proxy attr data for formula var "<<var_name<<" (attr="<<proxy_attr_name<<")!");
				//return -1;
				continue;
			}
		}//close if is proxy attr

		else{//Internal attr
			_DEBUG_LOG("Initializing internal attr "<<proxy_attr_name<<" in formula...");
			
			//Retrieve internal dyn attr data
			Utils_ns::AttrData* ad= GetDynAttrData(proxy_attr_name);
			if(!ad){
				_WARN_LOG("Failed to retrieve internal attr data "<<proxy_attr_name<<", skip to next formula var...");
				continue;
			}

			//Set attr data to formula 
			//NB: This will create attr data according to the attr info set
			if(formula_data->SetInternalAttrData(var_name,ad)<0){
				_WARN_LOG("Failed to set internal attr data for formula var "<<var_name<<" (attr="<<proxy_attr_name<<")!");
				//return -1;
				continue;
			}
			_DEBUG_LOG("Formula var "<<var_name<<" initialized? "<<(it->second)->IsInitialized());
			
		}//close else

	}//end loop formula vars
	
	//Check if formula is initialized
	bool isFormulaInitialized= formula_data->IsInitialized();
	if(!isFormulaInitialized){
		_WARN_LOG("Formula data for attr "<<attr_name<<" not initialized, will retry later...");
		return -1;
	}
	_DEBUG_LOG("Formula for attr "<<attr_name<<" initialized? "<<isFormulaInitialized);
			
	return 0;

}//close InitializeFormula()




int LMCDevice::HandleEvent(Tango::EventData* event_data){

	//## Check event data
	if(!event_data){
		_WARN_LOG("Null ptr to event data given!");
		return -1;
	}

	//## Check proxy manager
	if(!m_proxyManager){
		_WARN_LOG("Proxy manager was not initialized (done at device init)!");
		return -1;
	}

	//## Get and parse event info	
	std::string event_attr_name= event_data->attr_name;
	std::string event_type_str= event_data->event;
	Tango::DeviceAttribute* dev_attr= event_data->attr_value;
	Tango::AttrQuality attr_quality= dev_attr->quality;
	Tango::TimeVal attr_timestamp= dev_attr->time;

	std::string domain_name= "";
	std::string proxy_name= "";
	std::string proxy_attr_name= "";
	bool hasQualityTag= false;
	if(Utils_ns::TangoUtils::ParseFullAttrName(domain_name,proxy_name,proxy_attr_name,hasQualityTag,event_attr_name)<0){
		_WARN_LOG("Failed to parse event attr name!");
		return -1;
	}
	std::string proxy_name_full= domain_name+ std::string("/") + proxy_name;
	_INFO_LOG("Handling received event (proxy="<<proxy_name_full<<", proxy_attr="<<proxy_attr_name<<", event_type="<<event_type_str<<", timestamp=("<<attr_timestamp.tv_sec<<","<<attr_timestamp.tv_usec<<"), quality="<<attr_quality<<")...");
	
	//## Find event subcription data
	_DEBUG_LOG("Findind subscription data for received event (proxy="<<proxy_name_full<<", proxy_attr="<<proxy_attr_name<<", event_type="<<event_type_str<<")...");
	Utils_ns::EvtSubscriptionDataPtr evt_sub_data_ptr= m_proxyManager->FindEvtSubscription(proxy_name_full,proxy_attr_name,event_type_str);
	if(!evt_sub_data_ptr){
		_WARN_LOG("Cannot find any registered subscription data for event "<<event_attr_name<<", no handlers and attr formulas will be called!");
		return -1;
	}

	//## Evaluate formulas linked to this event
	if(m_formulaManager->HasFormulas() && EvaluateFormulasOnEvent(evt_sub_data_ptr,event_data)<0){
		_WARN_LOG("Failed to evaluate formulas linked to received event (proxy="<<proxy_name_full<<", proxy_attr="<<proxy_attr_name<<", event_type="<<event_type_str<<")...");
	}

	//## Execute event handler commands registered for this event
	if(ExecuteEventCmdHandlers(evt_sub_data_ptr,event_data)<0){
		_WARN_LOG("One or more event handler commands failed for received event (proxy="<<proxy_name_full<<", proxy_attr="<<proxy_attr_name<<", event_type="<<event_type_str<<")...");
	}

	return 0;	

}//close HandleEvent()



int LMCDevice::EvaluateFormulasOnEvent(Utils_ns::EvtSubscriptionDataPtr evt_sub_ptr,Tango::EventData* event_data){

	if(!evt_sub_ptr || !m_formulaManager || !event_data) return -1;

	//Find all formulas linked to this event
	std::vector<std::string> attr_name_list;
	std::vector<Utils_ns::FormulaData*> formula_data_list;
	if(m_formulaManager->GetFormulasLinkedToEvent(attr_name_list,formula_data_list,evt_sub_ptr)<0){
		_WARN_LOG("Failed to retrieve formula associated to received event (proxy="<<evt_sub_ptr->device_name<<", attr="<<evt_sub_ptr->attr_name<<", event_type="<<evt_sub_ptr->event_type_str<<")...");
	}

	_DEBUG_LOG("#"<<formula_data_list.size()<<" formulas associated to received event (proxy="<<evt_sub_ptr->device_name<<", attr="<<evt_sub_ptr->attr_name<<", event_type="<<evt_sub_ptr->event_type_str<<")...");

	
	//Iterate over formula data, set event value and evaluate formula
	int status= 0;
	bool emit_event= false;

	for(unsigned int i=0;i<formula_data_list.size();i++){

		//Set event value in formula var
		if(formula_data_list[i]->SetEventValue(evt_sub_ptr,event_data)<0){
			_WARN_LOG("Failed to set value in formula no. "<<i<<", skip to next formula...");
			status= 1;
			continue;
		}	

		//Set attr value from formula evaluated
		if( SetDynAttrValueFromFormula(attr_name_list[i],formula_data_list[i],emit_event)<0 ){
			_WARN_LOG("Failed to set value of attr "<<attr_name_list[i]<<" from formula no. "<<i<<", skip to next formula...");
			status= 1;
			continue;
		}

		//If attr is an task status attr update task progress status
		if(UpdateAsynchTaskStatus(attr_name_list[i])<0){
			_WARN_LOG("Failed to update asynch task status for attr "<<attr_name_list[i]<<"!");
			//continue;
		}

		//Execute formula post-actions
		if(ExecuteFormulaPostActions(attr_name_list[i],formula_data_list[i])<0){
			_WARN_LOG("One/more failures occurred while executing post-actions for formula attr "<<attr_name_list[i]<<"!");
		}

	}//end loop formulas

	return status;

}//close EvaluateAttrFormulasOnEvent()



int LMCDevice::EvaluateFormulasOnProxyDown(std::string& proxy_name,bool changeQualityFactor,Tango::AttrQuality attr_quality){

	//Get all formulas linked to the proxy (e.g. containing proxy in their formula vars)
	std::vector<std::string> attr_name_list;
	std::vector<Utils_ns::FormulaData*> formula_data_list;
	if(m_formulaManager->GetFormulasLinkedToProxy(attr_name_list,formula_data_list,proxy_name)<0){
		_WARN_LOG("Failed to retrieve formulas associated to proxy "<<proxy_name<<" ...");
		return -1;
	}
	_DEBUG_LOG("#"<<formula_data_list.size()<<" formulas associated to proxy "<<proxy_name<<" ...");

	//Iterate over formula data and set attr value to fallback/safe value
	int status= 0;
	bool emit_event= false;
	for(size_t i=0;i<formula_data_list.size();i++){
		std::string attr_name= attr_name_list[i];
		if( SetDynAttrToSafeValue(attr_name,changeQualityFactor,attr_quality,emit_event)<0 ){
			_WARN_LOG("Failed to set attr "<<attr_name<<" to safe value from formula no. "<<i<<", skip to next formula...");
			status= 1;
			continue;
		}

		//If attr is an task status attr update task progress status
		if(UpdateAsynchTaskStatus(attr_name)<0){
			_WARN_LOG("Failed to update asynch task status for attr "<<attr_name<<"!");
			continue;
		}
		
	}//end loop formulas

	return status;

}//close EvaluateFormulasOnProxyDown()


int LMCDevice::ExecuteFormulaPostActions(std::string attr_name,Utils_ns::FormulaData* formula_data,bool check)
{
	//Check formula data given
	if(!formula_data){
		_WARN_LOG("Null ptr to input formula data given!");
		return -1;
	}

	//Get formula post-actions
	std::vector<std::string> cmd_names= formula_data->GetPostActions();
	_DEBUG_LOG("#"<<cmd_names.size()<<" post-actions for formula attr "<<attr_name<<"...");
	if(cmd_names.empty()) return 0;

	//Execute commands in sequence
	//NB: Do not break sequence if one fails
	int errCount= 0;
	for(size_t i=0;i<cmd_names.size();i++){
		std::string cmd_name= cmd_names[i];
		
		//Check command existing in device?
		if(check){
			bool hasCommand= Utils_ns::TangoUtils::HasCommand(this,cmd_name);
			if(!hasCommand){
				_WARN_LOG("Post-action command "<<cmd_name<<" for formula attr "<<attr_name<<" not found in device, skip action...");
				continue;
			}
		}
		
		//Execute command
		_DEBUG_LOG("Executing pre-action cmd "<<cmd_name<<" for formula attr "<<attr_name<<"...");
		CORBA::Any argin;
		try {
			this->get_device_class()->command_handler(this,cmd_name,argin);
		}	
		catch(Tango::DevFailed& e){
			Tango::Except::print_exception(e);
			_ERROR_LOG("Tango exception occurred while executing post action "<<cmd_name<<" for formula attr "<<attr_name<<" (hints: check cmd name, is_allowed, argin, etc...)!");
			errCount++;
		}
		catch(std::exception& e){
			_ERROR_LOG("C++ exception (err="<<e.what()<<") occurred while executing post action "<<cmd_name<<" for formula attr "<<attr_name<<" (hints: check cmd name, is_allowed, argin, etc...)!");
			errCount++;
		}
		catch(...){
			_ERROR_LOG("Unknown exception occurred while executing post action "<<cmd_name<<" for attr "<<attr_name<<" (hints: check cmd name, is_allowed, argin, etc...)!");
			errCount++;
		}

	}//end loop commands

	if(errCount>0){
		_ERROR_LOG(errCount<<"/"<<cmd_names.size()<<" post actions for formula attr "<<attr_name<<" failed!");
		return -1;
	}

	return 0;

}//close ExecuteFormulaPostActions()


int LMCDevice::UpdateAsynchTaskStatus(std::string attr_name){

	//#################################################
	//##         HARD-CODED VALUES
	//#################################################
	long min_data_size= 2;
	//#################################################

	//## Check if task manager is created
	if(!m_taskManager){
		_WARN_LOG("Task manager is not instantiated (this should not occur...)");
		return -1;
	}

	//## Check if given attr name is a progress status attr 
	//## NB: It shall be contained in the attr status attr 
	if(taskStatusAttrList.empty()){
		_DEBUG_LOG("List of status attr is empty, nothing to be done.");
		return 0;
	}
	int index= -1;
	if(!Utils_ns::CodeUtils::FindItem(taskStatusAttrList,attr_name,index)){
		_DEBUG_LOG("Attr "<<attr_name<<" is not a task status attr, nothing to be done.");
		return 0;
	}

	//## Check if attribute is a DevStringArray attr with at least 2 fields (TBD)
	long data_type;
	Tango::AttrDataFormat data_format;
	long dim_x;
	try{
		Tango::Attribute& attr= get_device_attr()->get_attr_by_name(attr_name.c_str());
		data_type= attr.get_data_type();
		data_format= attr.get_data_format();
		dim_x= attr.get_max_dim_x();
	}
	catch(...){//an exception is thrown if the attribute is not existing
		_WARN_LOG("Exception occurred while retrieving attr "<<attr_name<<" info (attr does not exist in device?)!");
		return -1;
	}
	
	if(data_type!=Tango::DEV_STRING || data_format!=Tango::SPECTRUM || dim_x<min_data_size)	{
		_WARN_LOG("Invalid status attr "<<attr_name<<" detected (it should be a DEV_STRING spectrum attr with size "<<min_data_size<<" at least!");
		return -1;
	}

	//## Get dyn attr value
	std::vector<std::string> attr_values;
	if(GetDynAttrValue(attr_values,attr_name)<0){
		_WARN_LOG("Failed to get status attr "<<attr_name<<" value!");
		return -1;
	}
	
	//std::string task_name= attr_values[0];
	//std::string task_status_str= attr_values[1];
	//std::string task_status_info= attr_values[2];
	std::string task_status_str= attr_values[0];
	std::string task_status_info= attr_values[1];
	int task_status= -1;
	if(Utils_ns::TaskManager::GetTaskStatusFromString(task_status,task_status_str)<0){
		_WARN_LOG("Invalid task status label ("<<task_status_str<<") found, cannot find corresponding task status code!");		
		return -1;
	}

	//## Update task status sequence
	_DEBUG_LOG("Updating task status (status_str="<<task_status_str<<", status="<<task_status<<", info="<<task_status_info<<") from attr "<<attr_name<<"...");
	if(m_taskManager->SetAsynchTaskStatus(attr_name,task_status,task_status_info)<0){
		_WARN_LOG("Failed to update asynch task status to (status="<<task_status<<", info="<<task_status_info<<") from attr name "<<attr_name<<"!");
		return -1;
	}

	return 0;

}//close UpdateAsynchTaskStatus()


int LMCDevice::ExecuteEventCmdHandlers(Utils_ns::EvtSubscriptionDataPtr evt_sub_ptr,Tango::EventData* event_data){

	//## Check args
	if(!evt_sub_ptr || !event_data) return -1;

	//## Get and parse event info	
	std::string event_attr_name= event_data->attr_name;
	std::string event_type_str= event_data->event;
	Tango::DeviceAttribute* da= event_data->attr_value;
	Tango::AttrDataFormat	data_format= da->data_format;
	int	data_type= da->data_type;
	
	//## Retrieve list of event handlers registered for this event	
	std::vector<Utils_ns::EventHandlerData> evt_handlers= evt_sub_ptr->event_handlers;
	if(evt_handlers.empty()){
		_DEBUG_LOG("No handlers registered for event "<<event_attr_name<<", nothing to be done.");
		return 0;
	}
	_DEBUG_LOG("#"<<evt_handlers.size()<<" cmd handlers registered for event "<<event_attr_name<<"...");

	//## Unmarshall DeviceAttribute data to generic CORBA::Any
	CORBA::Any event_value;
	if(Utils_ns::TangoUtils::DeviceAttributeToCorbaAny(event_value,da,this)<0){
		_ERROR_LOG("Failed to extract data from event "<<event_attr_name<<" to CORBA::Any, cannot execute cmd handlers!");
		return -1;
	}
	

	//============================================================
	//== Execute command handlers in sequence (TaskManager QUEUE) (TASK SEQUENCE)
	//============================================================
	int status= 0;	
	Utils_ns::TaskSequencePtr taskSequence= nullptr;
	Utils_ns::TaskPtr task= nullptr;
	bool useUTC= false;

	for(unsigned int i=0;i<evt_handlers.size();i++){
		std::string cmd_name= evt_handlers[i].name;
		int priority= evt_handlers[i].priority;
		long int execution_delay= evt_handlers[i].execution_delay;
			
		//Create a new task
		task= std::make_shared<Utils_ns::Task>(this,cmd_name,priority,useUTC);
		task->SetTaskArgin(event_value,data_type,data_format);
		if(execution_delay>0 && task->SetTimeDelayAndDuration(execution_delay,defaultTaskTimeout*1000.)<0){
			_ERROR_LOG("Failed to set activation time delay/duration for task "<<cmd_name<<", skip to next handler!");
			continue;
		}

		//Create a task sequence and add task		
		taskSequence= std::make_shared<Utils_ns::TaskSequence>(this,cmd_name,useUTC);
		if(taskSequence->AddTask(task)<0){
			status= 1;
			_ERROR_LOG("Failed to add task "<<cmd_name<<" to sequence, skip to next handler!");
			continue;
		}
		
		//Add task to queue
		if(m_taskManager->AddTaskSequence(taskSequence,true)<0){
			status= 1;
			_ERROR_LOG("Failed to add cmd handler sequence "<<cmd_name<<" (event "<<event_attr_name<<") to task queue, skip to next handler...");
			continue;
		}
		_DEBUG_LOG("Added task sequence "<<cmd_name<<" (delay(ms)="<<execution_delay<<", timeout(ms)="<<defaultTaskTimeout*1000<<", priority="<<priority<<") to queue...");

	}//end loop handlers

	/*
	//============================================================
	//== Execute command handlers in sequence (TaskManager QUEUE)
	//============================================================
	int status= 0;	
	Utils_ns::TaskPtr task= nullptr;
	bool useUTC= false;

	for(unsigned int i=0;i<evt_handlers.size();i++){
		std::string cmd_name= evt_handlers[i].name;
		int priority= evt_handlers[i].priority;
		long int execution_delay= evt_handlers[i].execution_delay;
			
		//Create a new task
		task= std::make_shared<Task>(this,cmd_name,priority,useUTC);
		task->SetTaskArgin(event_value,data_type,data_format);
		if(execution_delay>0 && task->SetTimeDelayAndDuration(execution_delay)<0){
			_ERROR_LOG("Failed to set activation time delay/duration for task "<<cmd_name<<", skip to next handler!");
			continue;
		}
		
		//Add task to queue
		if(m_taskManager->AddTask(task)<0){	
			status= 1;
			_ERROR_LOG("Failed to add cmd handler "<<cmd_name<<" (event "<<event_attr_name<<") to task queue, skip to next handler...");
			continue;
		}
		_DEBUG_LOG("Added task "<<cmd_name<<" (delay="<<execution_delay<<", priority="<<priority<<") to queue...");

	}//end loop handlers
	*/

	return status;

}//close ExecuteEventCmdHandlers()


int LMCDevice::EraseDynAttrManager(){

	
	//## Remove attributes from dam and device (if enabled)
  if(!m_dam) return 0;

	_DEBUG_LOG("Destroy dyn attr manager...");
	try{
  	delete m_dam;//this will automatically call remove_attributes on current device (e.g. derived device)
    m_dam = 0;
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Tango exception occurred while deleting DynAttrManager!");
		return -1;
	}
	catch(...){
		_ERROR_LOG("Unknown exception occurred while deleting DynAttrManager!");
		return -1;
	}

	return 0;

}//close EraseDynAttrManager()


int LMCDevice::EraseDynAttrData(){

	//## Loop over dynamic attribute created and erase data attached to manager
	if(m_dam){
		_DEBUG_LOG("Deleting data attached to dyn attr manager...");

		for(unsigned int i=0;i<m_device_attr.size();i++){	

			//Get dyn attr name
			Tango::Attr* attr= m_device_attr[i]->GetAttr();
			if(!attr) continue;
			std::string attr_name= attr->get_name();

			//Check is device has this attribute
			if(!Utils_ns::TangoUtils::HasAttribute(this,attr_name)){
				_DEBUG_LOG("Attribute "<<attr_name<<" is not present in device (for example it was not added yet), so nothing to delete...");
				continue;
			}
			
			//Retrieve dyn attr from manager
			try{
				yat4tango::DynamicAttribute & dyn_attr = m_dam->get_attribute(attr_name);
				bool is_forwarded= dyn_attr.is_forwarded();
				int data_format= dyn_attr.get_tango_data_format();
				int data_type= dyn_attr.get_tango_data_type();
				if(is_forwarded) continue;
				_DEBUG_LOG("Deleting user data for attr "<<attr_name<<"...");

				if(data_format==Tango::SCALAR){
					switch (data_type) {
						case Tango::DEV_FLOAT:
							EraseScalarDynAttrUserData<Tango::DevFloat>(dyn_attr);
							break;	
						case Tango::DEV_DOUBLE: 
							EraseScalarDynAttrUserData<Tango::DevDouble>(dyn_attr);
							break;
						case Tango::DEV_LONG: 
							EraseScalarDynAttrUserData<Tango::DevLong>(dyn_attr);
							break;
						case Tango::DEV_SHORT: 
							EraseScalarDynAttrUserData<Tango::DevShort>(dyn_attr);
							break;
						#if TANGO_VERSION_MAJOR >= 9
						case Tango::DEV_ENUM: 
							EraseScalarDynAttrUserData<Tango::DevShort>(dyn_attr);
							break;
						#endif
						case Tango::DEV_STRING: 
							EraseScalarDynAttrUserData<std::string>(dyn_attr);
							break;
						case Tango::DEV_BOOLEAN: 
							EraseScalarDynAttrUserData<Tango::DevBoolean>(dyn_attr);
							break;
						case Tango::DEV_STATE: 
							EraseScalarDynAttrUserData<Tango::DevState>(dyn_attr);
							break;
						default:
						{
							std::stringstream ss;
							ss<<"Unsupported data type ("<<data_type<<") for attribute "<<attr_name<<"!";
							_ERROR_LOG(ss.str());
	      			continue;
        			break;
						}	
					}//close switch
				}//close if SCALAR
				else if(data_format==Tango::SPECTRUM){
					switch (data_type) {
						case Tango::DEV_FLOAT:
							EraseSpectrumDynAttrUserData<Tango::DevFloat>(dyn_attr);
							break;	
						case Tango::DEV_DOUBLE: 
							EraseSpectrumDynAttrUserData<Tango::DevDouble>(dyn_attr);
							break;
						case Tango::DEV_LONG: 
							EraseSpectrumDynAttrUserData<Tango::DevLong>(dyn_attr);
							break;
						case Tango::DEV_SHORT: 
							EraseSpectrumDynAttrUserData<Tango::DevShort>(dyn_attr);
							break;
						#if TANGO_VERSION_MAJOR >= 9
						case Tango::DEV_ENUM: 
							EraseSpectrumDynAttrUserData<Tango::DevShort>(dyn_attr);
							break;
						#endif
						case Tango::DEV_STRING: 
							EraseSpectrumDynAttrUserData<std::string>(dyn_attr);
							break;
						case Tango::DEV_BOOLEAN: 
							EraseSpectrumDynAttrUserData<Tango::DevBoolean>(dyn_attr);
							break;
						case Tango::DEV_STATE: 
							EraseSpectrumDynAttrUserData<Tango::DevState>(dyn_attr);
							break;
						default:
						{
							std::stringstream ss;
							ss<<"Unsupported data type ("<<data_type<<") for attribute "<<attr_name<<"!";
							_ERROR_LOG(ss.str());
	      			continue;
        			break;
						}	
					}//close switch
				}//close else if SPECTRUM			
					
			}//close try block
			catch(Tango::DevFailed& e){
				Tango::Except::print_exception(e);
				_ERROR_LOG("Tango exception occurred while de-allocating data for dyn attr "<<attr_name<<", skip to next attr...");
				continue;
			}
			catch(...){
				_ERROR_LOG("Failed to de-allocate data for dyn attr "<<attr_name<<", skip to next attr...");
				continue;
			}
		}//end loop created dyn attrs

		
	}//close if has dyn attr manager
	else{
		_ERROR_LOG("Dyn attr manager was already destroyed before de-allocating attached data...this should not occur (memory leak!!!)");
	}

	//## Remove cfg attr list
	_DEBUG_LOG("Deleting cfg dyn attr list...");
	for(unsigned int i=0;i<m_device_attr.size();i++){
		if(m_device_attr[i]){
			delete m_device_attr[i];
			m_device_attr[i]= 0;
		}
	}
	m_device_attr.clear();

	return 0;

}//close EraseDynAttrData()


int LMCDevice::CreateProxyMonitorDynAttr(std::string attr_name,long poll_period,long periodic_event_period,long archive_event_period){

	//Check if dynamic attribute manager is instantiated
	if(!m_dam){
		_ERROR_LOG("Dynamic attribute manager was not instantiated yet!");
		return -1;
	}

	//Create a Tango attribute: format=SPECTRUM, type=STRING, rwtype=READ
	int maxDimX= 2;
	Tango::Attr* attr= new Tango::SpectrumAttr(attr_name.c_str(),Tango::DEV_STRING,Tango::READ,maxDimX,Tango::OPERATOR);
	_DEBUG_LOG("data_format="<<attr->get_format());

	//Set polling?
	if(poll_period>0) attr->set_polling_period(poll_period);

	//Create attr properties
	Tango::MultiAttrProp<Tango::DevString>* prop= new Tango::MultiAttrProp<Tango::DevString>;	
	prop->min_value= Tango::AlrmValueNotSpec;
	prop->max_value= Tango::AlrmValueNotSpec;
	prop->min_alarm= Tango::AlrmValueNotSpec;
	prop->max_alarm= Tango::AlrmValueNotSpec;
	prop->min_warning= Tango::AlrmValueNotSpec;
	prop->max_warning= Tango::AlrmValueNotSpec;
	prop->delta_t= Tango::AlrmValueNotSpec;
	prop->delta_val= Tango::AlrmValueNotSpec;
	prop->rel_change= Tango::AlrmValueNotSpec;
	prop->abs_change= Tango::AlrmValueNotSpec;
	prop->archive_rel_change= Tango::AlrmValueNotSpec;
	prop->archive_abs_change= Tango::AlrmValueNotSpec;
	
	if(periodic_event_period>0) prop->event_period= periodic_event_period;
	if(archive_event_period>0) prop->archive_period= archive_event_period;
	
	//Create a device attr
	Utils_ns::DeviceAttr* device_attr= new Utils_ns::DeviceAttrImpl<Tango::DevString>(attr,prop);
	//Utils_ns::DeviceAttr* device_attr= new Utils_ns::DeviceAttrImpl<Tango::DevString>(Tango::SPECTRUM,maxDimX,attr,prop);
	if(poll_period>0) device_attr->SetPolled(true);
	device_attr->SetGeneratorModel( new Utils_ns::AttrConstModel<std::string>(std::string()) );

	std::string initValue("");
	dynamic_cast<Utils_ns::DeviceAttrImpl<Tango::DevString>*>(device_attr)->SetInitValue(initValue);

	//Add dyn attribute in device
	try{	
		CreateAndInitDynAttr<std::string,Tango::DevString>(device_attr);
	}
	catch(Tango::DevFailed &e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Adding attr "<<attr_name<<" failed!");
		delete device_attr;
		device_attr= 0;
		return -1;
	}
	catch(std::exception& e){
		_ERROR_LOG("C++ exception occurred while adding attr "<<attr_name<<" (err="<<e.what()<<")!");
		delete device_attr;
		device_attr= 0;
		
		return -1;
	}
	catch(...){
		_ERROR_LOG("Unknown exception occurred while adding attr "<<attr_name<<"!");
		delete device_attr;
		device_attr= 0;
		return -1;
	}

	return 0;

}//close CreateProxyMonitorDynAttr()


int LMCDevice::CreateEventRateDynAttr(std::string attr_name,long poll_period,long periodic_event_period,long archive_event_period){

	//Create a Tango attribute: format=SCALAR, type=FLOAT, rwtype=READ
	Tango::Attr* attr= new Tango::Attr(attr_name.c_str(),Tango::DEV_FLOAT,Tango::READ);

	//Set polling?
	if(poll_period>0) attr->set_polling_period(poll_period);

	//Create attr properties
	Tango::MultiAttrProp<Tango::DevFloat>* prop= new Tango::MultiAttrProp<Tango::DevFloat>;	
	prop->min_value= Tango::AlrmValueNotSpec;
	prop->max_value= Tango::AlrmValueNotSpec;
	prop->min_alarm= Tango::AlrmValueNotSpec;
	prop->max_alarm= Tango::AlrmValueNotSpec;
	prop->min_warning= Tango::AlrmValueNotSpec;
	prop->max_warning= Tango::AlrmValueNotSpec;
	prop->delta_t= Tango::AlrmValueNotSpec;
	prop->delta_val= Tango::AlrmValueNotSpec;
	prop->rel_change= Tango::AlrmValueNotSpec;
	prop->abs_change= Tango::AlrmValueNotSpec;
	prop->archive_rel_change= Tango::AlrmValueNotSpec;
	prop->archive_abs_change= Tango::AlrmValueNotSpec;
	
	if(periodic_event_period>0) prop->event_period= periodic_event_period;
	if(archive_event_period>0) prop->archive_period= archive_event_period;
	
	//Create a device attr
	Utils_ns::DeviceAttr* device_attr= new Utils_ns::DeviceAttrImpl<Tango::DevFloat>(attr,prop);
	//Utils_ns::DeviceAttr* device_attr= new Utils_ns::DeviceAttrImpl<Tango::DevFloat>(Tango::SCALAR,1,attr,prop);
	if(poll_period>0) device_attr->SetPolled(true);
	device_attr->SetGeneratorModel( new Utils_ns::AttrConstModel<Tango::DevFloat>(Tango::DevFloat()) );

	std::string initValue("");
	dynamic_cast<Utils_ns::DeviceAttrImpl<Tango::DevFloat>*>(device_attr)->SetInitValue(initValue);

	//Add dyn attribute in device
	try{	
		CreateAndInitDynAttr<Tango::DevFloat,Tango::DevFloat>(device_attr);
	}
	catch(Tango::DevFailed &e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Adding attr "<<attr_name<<" failed!");
		return -1;
	}
	catch(std::exception& e){
		_ERROR_LOG("C++ exception occurred while adding attr "<<attr_name<<" (err="<<e.what()<<")!");
		return -1;
	}
	catch(...){
		_ERROR_LOG("Unknown exception occurred while adding attr "<<attr_name<<"!");
		return -1;
	}

	return 0;

}//close CreateEventRateDynAttr()


int LMCDevice::RemoveDynAttr(std::string attr_name,bool failIfNotExisting){

	//Check if attribute is present
	try{
		get_device_attr()->get_attr_by_name(attr_name.c_str());
	}
	catch(Tango::DevFailed &e){//an exception is thrown if the attribute is not existing
		if(failIfNotExisting){
			_WARN_LOG("Attribute "<<attr_name<<" not found in device!");
			return -1;
		}
		else{
			_DEBUG_LOG("Attribute "<<attr_name<<" not found in device, nothing to be removed!");
			return 0;
		}
	}//close catch

	//Remove attribute	
	try {
		m_dam->remove_attribute(attr_name);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_WARN_LOG("Failed to remove dyn attr "<<attr_name<<" from device!");
		return -1;
	}
	
	return 0;

}//close RemoveDynAttr()


Utils_ns::AttrDataPtr LMCDevice::GetDynAttrData(std::string attr_name){

	Utils_ns::AttrDataPtr ad= nullptr;
	try {
		yat4tango::DynamicAttribute& dyn_attr = m_dam->get_attribute(attr_name);
		ad= dyn_attr.get_user_data<Utils_ns::AttrData>();	
		//attr_info= dynamic_cast<Tango::AttributeInfoEx>(dyn_attr.get_attribute_info());
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_WARN_LOG("Tango exception while retrieving attr data "<<attr_name<<"!");
		ad= nullptr;
	}
	catch(std::exception& e){
		_WARN_LOG("C++ exception occurred while retrieving attr data "<<attr_name<<"!");
		ad= nullptr;
	}
	
	return ad;

}//close GetDynAttrData()

/*
int LMCDevice::InitProxyMonitoring(){

	std::string proxy_moni_cmd= "MonitorProxies";

	//Stop first proxy
	try {
		if(is_command_polled(proxy_moni_cmd)){
			stop_poll_command(proxy_moni_cmd);		
		}
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_WARN_LOG("Tango exception occurred while stopping existing polling of proxy monitoring!");
		return -1;
	}

	//Start polling with period specified in dev properties
	try {
		poll_command(proxy_moni_cmd,proxyMonitoringPeriod);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_WARN_LOG("Tango exception occurred while starting polling of proxy monitoring!");
		return -1;
	}

	return 0;

}//close InitProxyMonitoring()
*/

int LMCDevice::ConfigureCmdPolling(){

	std::string cmd_name= "";
	int status= 0;

	//## Configure State & Status command
	cmd_name= "State";
	int state_poll_period= 3000;	
	try{
		SetCmdPollInfo(cmd_name,true,state_poll_period);
	}
	catch(...){
		_ERROR_LOG("Failed to configure polling info for cmd "<<cmd_name<<"...");	
		status= -1;
	}

	cmd_name= "Status";
	int status_poll_period= 3000;	
	try{
		SetCmdPollInfo(cmd_name,true,status_poll_period);
	}
	catch(...){
		_ERROR_LOG("Failed to configure polling info for cmd "<<cmd_name<<"...");	
		status= -1;
	}

	//## Configure logging initialization cmd
	cmd_name= "InitializeLoggers";	
	try{
		SetCmdPollInfo(cmd_name,enableLoggerInitPolling,loggerInitPollPeriod);
	}
	catch(...){
		_ERROR_LOG("Failed to configure polling info for cmd "<<cmd_name<<"...");	
		status= -1;
	}

	//## Configure fwd attr initialization cmd
	cmd_name= "InitializeFwdAttrs";	
	try{
		SetCmdPollInfo(cmd_name,enableFwdAttrInitPolling,fwdAttrInitPollPeriod);
	}
	catch(...){			
		_ERROR_LOG("Failed to configure polling info for cmd "<<cmd_name<<"...");	
		status= -1;
	}

	//## Configure dev proxy initialization poll period
	cmd_name= "InitializeDevProxies";
	try{
		SetCmdPollInfo(cmd_name,enableDevProxyInitPolling,devProxyInitPollPeriod);
	}
	catch(...){
		_ERROR_LOG("Failed to configure polling info for cmd "<<cmd_name<<"...");	
		status= -1;
	}
	
	//## Configure proxy monitoring poll period
	cmd_name= "MonitorProxies";
	try{
		SetCmdPollInfo(cmd_name,enableProxyMonitoring,proxyMonitoringPeriod);
	}	
	catch(...){
		_ERROR_LOG("Failed to configure polling info for cmd "<<cmd_name<<"...");	
		status= -1;
	}

	//## Configure formula attr update cmd
	cmd_name= "UpdateFormulaAttrs";
	try{
		SetCmdPollInfo(cmd_name,enableFormulaAttrUpdatePolling,formulaAttrUpdatePollPeriod);
	}
	catch(...){
		_ERROR_LOG("Failed to configure polling info for cmd "<<cmd_name<<"...");	
		status= -1;
	}

	//## Configure status attr update cmd
	cmd_name= "UpdateStatusAttrs";
	try{
		SetCmdPollInfo(cmd_name,enableStatusAttrUpdatePolling,statusAttrUpdatePollPeriod);
	}
	catch(...){
		_ERROR_LOG("Failed to configure polling info for cmd "<<cmd_name<<"...");	
		status= -1;
	}
	

	//## Configure clear task cmd
	cmd_name= "ClearTasks";
	try{
		SetCmdPollInfo(cmd_name,enableClearTaskPolling,clearTaskPollPeriod);
	}
	catch(...){
		_ERROR_LOG("Failed to configure polling info for cmd "<<cmd_name<<"...");	
		status= -1;
	}
	
	return status;

}//close ConfigureCmdPolling()


void LMCDevice::SetCmdPollInfo(std::string cmd_name,bool enable,int poll_period){

	//Stop first polling (if enabled)
	try {
		if(is_command_polled(cmd_name)){
			stop_poll_command(cmd_name);		
		}
	}
	catch(Tango::DevFailed& e){
		std::stringstream ss;
		ss<<"Tango exception occurred while stopping existing polling of cmd "<<cmd_name<<"!";
		_WARN_LOG(ss.str());
		_THROW_RECORDED_TANGO_EXCEPTION("SET_CMD_POLL_INFO_FAILED",ss.str());
	}

	//Return if not enabled
	if(!enable) return;

	//If enable start polling with period specified in dev properties
	try {
		poll_command(cmd_name,poll_period);
	}
	catch(Tango::DevFailed& e){
		std::stringstream ss;
		ss<<"Tango exception occurred while starting cmd "<<cmd_name<<" polling!";
		_WARN_LOG(ss.str());
		_THROW_RECORDED_TANGO_EXCEPTION("SET_CMD_POLL_INFO_FAILED",ss.str());
	}

}//close SetCmdPollInfo()


int LMCDevice::InitProxyMonitorTask(){

	//## Initialize device task
	_DEBUG_LOG("Initializing device proxy monitor task ...");
	m_proxyMonitorTask = 0;

	if(!m_proxyManager){
		std::string errMsg("Proxy monitor task initialization failed (proxy manager is not initialized!)");
  	_ERROR_LOG(errMsg);
		set_state(Tango::FAULT);
    set_status(errMsg.c_str());
		return -1;
	}

	//- Define task configuration
	ProxyMonitorTask::Config cfg;
  cfg.task_activity_period_ms = proxyMonitoringPeriod;
  cfg.host_device = this;
	cfg.enable_periodic_msg= true;
	cfg.proxy_manager= m_proxyManager;
    
	//- Allocate and start the device task
	try {
		_INFO_LOG("Initializing proxy monitor task...");
    m_proxyMonitorTask = new (std::nothrow) ProxyMonitorTask(cfg);
	  if (!m_proxyMonitorTask){
    	throw std::bad_alloc();
		}
    _INFO_LOG("Starting the proxy monitor task...");
    m_proxyMonitorTask->go();
	}
  catch (const std::bad_alloc&) {
		std::string errMsg("Proxy monitor task initialization failed (allocation failed)");
  	_ERROR_LOG(errMsg);
		set_state(Tango::FAULT);
    set_status(errMsg.c_str());
		return -1;
	}
  catch (Tango::DevFailed& e) {
		Tango::Except::print_exception(e);
		std::string errMsg("Proxy monitor task initialization failed [see device log for details]");
  	_ERROR_LOG(errMsg);
		set_state(Tango::FAULT);
    set_status(errMsg.c_str());
    return -1;
  }
  catch (...) {
  	std::string errMsg("Proxy monitor task initialization failed [unknown error]");
  	_ERROR_LOG(errMsg);
		set_state(Tango::FAULT);
    set_status(errMsg.c_str());
    return -1;
  }

	return 0;

}//close InitProxyMonitorTask()

int LMCDevice::ClearProxyMonitorTask(){

	if(!m_proxyMonitorTask) return 0;

	//## First signal waiting conditions
	m_proxyMonitorTask->signal_wait();

	//## Release the task: just ask task to quit
	//## NB: Never explicitly delete a yat4tango::DeviceTask
	m_proxyMonitorTask->exit();
  m_proxyMonitorTask = 0;

	return 0;

}//close ClearProxyMonitorTask()


int LMCDevice::ProcessProxyRunStatusInfo(std::string proxy_name,int proxy_run_status){

	_DEBUG_LOG("Processing run status (status="<<proxy_run_status<<") info for proxy "<<proxy_name<<"...");

	//Update formula attr related to this proxy if proxy is in HARD DOWN state
	//NB: Switch attribute value to safe value (or maybe change attr quality?)
	int status= 0;
	
	if(proxy_run_status==Utils_ns::TangoProxyHelper::ePROXY_HARD_OFFLINE){
		if(EvaluateFormulasOnProxyDown(proxy_name,Tango::ATTR_INVALID)<0){
			_WARN_LOG("Failures occurred while setting formula linked to proxy "<<proxy_name<<" to fallback values!");
			status= 1;
		}
	}
	else if(proxy_run_status==Utils_ns::TangoProxyHelper::ePROXY_SOFT_OFFLINE){
		if(EvaluateFormulasOnProxyDown(proxy_name)<0){
			_WARN_LOG("Failures occurred while setting formula linked to proxy "<<proxy_name<<" to fallback values!");
			status= 1;
		}
	}

	//This is overridden in derived devices
	if(HandleProxyRunStatusInfo(proxy_name,proxy_run_status)<0){
		_WARN_LOG("Failed to handle proxy run status info received for proxy "<<proxy_name<<"!");
		return -1;
	}

	return status;

}//close ProcessProxyRunStatusInfo()


int LMCDevice::InitEventHandlerTask(){

	//## Initialize device task
	_DEBUG_LOG("Initializing device proxy event handler task ...");
	m_eventHandlerTask = 0;

	//- Define task configuration
	EventHandlerTask::Config cfg;
  cfg.task_activity_period_ms = 3000;//not used here
  cfg.host_device = this;
	cfg.enable_periodic_msg= false;
    
	//- Allocate and start the device task
	try {
		_INFO_LOG("Initializing event handler task...");
    m_eventHandlerTask = new (std::nothrow) EventHandlerTask(cfg);
	  if (!m_eventHandlerTask){
    	throw std::bad_alloc();
		}
    _INFO_LOG("Starting the event handler task...");
    m_eventHandlerTask->go();
	}
  catch (const std::bad_alloc&) {
		std::string errMsg("Event handler task initialization failed (allocation failed)");
  	_ERROR_LOG(errMsg);
		set_state(Tango::FAULT);
    set_status(errMsg.c_str());
		return -1;
	}
  catch (Tango::DevFailed& e) {
		Tango::Except::print_exception(e);
		std::string errMsg("Event handler task initialization failed [see device log for details]");
  	_ERROR_LOG(errMsg);
		set_state(Tango::FAULT);
    set_status(errMsg.c_str());
    return -1;
  }
  catch (...) {
  	std::string errMsg("Event handler task initialization failed [unknown error]");
  	_ERROR_LOG(errMsg);
		set_state(Tango::FAULT);
    set_status(errMsg.c_str());
    return -1;
  }

	return 0;

}//close InitEventHandlerTask()

int LMCDevice::ClearEventHandlerTask(){

	if(!m_eventHandlerTask) return 0;

	//## First signal waiting conditions
	m_eventHandlerTask->signal_wait();

	//## Release the task: just ask task to quit
	//## NB: Never explicitly delete a yat4tango::DeviceTask
	m_eventHandlerTask->exit();
  m_eventHandlerTask = 0;

	return 0;

}//close ClearEventHandlerTask()


bool LMCDevice::CheckIfCmdIsAllowed(std::string cmd_name,std::string attr_name,bool check_cmd){

	if(check_cmd){
		//Find if command exist in device
		try{
			get_device_class()->get_cmd_by_name(cmd_name);
		}
		catch(Tango::DevFailed& e){
			throw;
		}
	}//close if check_cmd

	//Get attribute info
	long data_type;
	Tango::AttrDataFormat data_format;
	try{
		Tango::Attribute& attr= get_device_attr()->get_attr_by_name(attr_name.c_str());
		data_type= attr.get_data_type();
		data_format= attr.get_data_format();	
	}
	catch(Tango::DevFailed &e){//an exception is thrown if the attribute is not existing
		throw;
	}
	catch(...){//an exception is thrown if the attribute is not existing
		throw;
	}

	//Check if attribute is not a scalar (Cmd rules supported only for scalar attr
	if(data_format!=Tango::SCALAR){
		std::stringstream ss;
		ss<<"Invalid attr data format found (cmd state machine is supported for scalar attribute only), check failed!";
		_THROW_TANGO_EXCEPTION("CHECK_IF_CMD_ALLOWED_FAILED",ss.str());
	}
		
	//Check if allowed
	bool isAllowed= true;
	try {
		switch (data_type) {
			case Tango::DEV_FLOAT: 
			{
				isAllowed= CheckIfCmdIsAllowed<Tango::DevFloat>(cmd_name,attr_name,data_type);
				break;
			}
			case Tango::DEV_DOUBLE: 
			{
				isAllowed= CheckIfCmdIsAllowed<Tango::DevDouble>(cmd_name,attr_name,data_type);
				break;
			}
			case Tango::DEV_LONG: 
			{
				isAllowed= CheckIfCmdIsAllowed<Tango::DevLong>(cmd_name,attr_name,data_type);
				break;
			}
			case Tango::DEV_SHORT: 
			{
				isAllowed= CheckIfCmdIsAllowed<Tango::DevShort>(cmd_name,attr_name,data_type);
				break;
			}
			#if TANGO_VERSION_MAJOR >= 9
			case Tango::DEV_ENUM: 
			{
				isAllowed= CheckIfCmdIsAllowed<Tango::DevEnum>(cmd_name,attr_name,data_type);
				break;
			}
			#endif
			case Tango::DEV_STRING: 
			{
				isAllowed= CheckIfCmdIsAllowed<std::string>(cmd_name,attr_name,data_type);
				break;
			}
			case Tango::DEV_BOOLEAN: 
			{
				isAllowed= CheckIfCmdIsAllowed<Tango::DevBoolean>(cmd_name,attr_name,data_type);
				break;
			}
			case Tango::DEV_STATE: 
			{
				isAllowed= CheckIfCmdIsAllowed<Tango::DevState>(cmd_name,attr_name,data_type);
				break;
			}
			default:
			{
				std::stringstream ss;
				ss<<"Unsupported data type ("<<data_type<<") for attribute "<<attr_name<<"!";
				_ERROR_LOG(ss.str());
	      _THROW_TANGO_EXCEPTION("CHECK_IF_CMD_ALLOWED_FAILED",ss.str());
       	break;
			}	
		}//close switch
	}//close try block
	catch(Tango::DevFailed& e){
		throw;
	}
	catch(...){
		throw;
	}	

	return isAllowed;

}//close CheckIfCmdAllowed()


void LMCDevice::IsCmdAllowed(std::string fcn_name,bool check_cmd){

	//Check if given cmd name is the StateMachine is allowed cmd
	std::size_t pos_prefix = fcn_name.find("is_");
	std::size_t pos_subfix = fcn_name.find("_allowed");
	std::string cmd_name= "";
	if(pos_prefix!=std::string::npos && pos_subfix!=std::string::npos) {//State machine is allowed cmd
		cmd_name= fcn_name.substr(pos_prefix+3,pos_subfix-pos_prefix-3);
	}
	else{
		cmd_name= fcn_name;
	}
	
	//Get all cmd rules 
	std::vector<std::string> attr_names;
	if(Utils_ns::TangoUtils::GetAttrsInCmdRules(attr_names,cmd_name)<0){
		_DEBUG_LOG("Cannot get list of attribute names in rules for cmd "<<cmd_name<<" (no rules present for this command or invalid cmd name), return cmd allowed");
		return;
	}

	//Iterate over attribute and check if command is allowed
	bool isAllowed= true;
	for(unsigned int i=0;i<attr_names.size();i++){		
		try{
			isAllowed= CheckIfCmdIsAllowed(cmd_name,attr_names[i],check_cmd);
		}	
		catch(Tango::DevFailed& e){
			Tango::Except::print_exception(e);
			_WARN_LOG("Tango exception occurred when checking if cmd "<<cmd_name<<" is allowed for attr "<<attr_names[i]<<", skip to next check!");
			continue;
		}
		catch(...){
			_WARN_LOG("Unknown exception occurred when checking if cmd "<<cmd_name<<" is allowed for attr "<<attr_names[i]<<", skip to next check!");
			continue;
		}
	
		if(!isAllowed) {
			std::stringstream ss;
			ss<<"Cmd "<<cmd_name<<" not allowed due to attr "<<attr_names[i]<<" violating rules!";
			_THROW_TANGO_EXCEPTION("IS_CMD_ALLOWED",ss.str());
			break;
		}
	}//end loop attr rules

}//close IsCmdAllowed()


bool LMCDevice::CheckIfAttrReadIsAllowed(std::string attr_name,std::string sm_attr_name){

	//Get sm attribute info
	long data_type;
	Tango::AttrDataFormat data_format;
	try{
		Tango::Attribute& sm_attr= get_device_attr()->get_attr_by_name(sm_attr_name.c_str());
		data_type= sm_attr.get_data_type();
		data_format= sm_attr.get_data_format();	
	}
	catch(Tango::DevFailed &e){//an exception is thrown if the sm attribute is not existing
		throw;
	}
	catch(...){//an exception is thrown if the sm attribute is not existing
		throw;
	}

	//Check if attribute is not a scalar (attr read rules supported only for scalar attr sm attr)
	if(data_format!=Tango::SCALAR){
		std::stringstream ss;
		ss<<"Invalid sm attr data format found (attr state machine is supported for scalar attribute only), check failed!";
		_THROW_TANGO_EXCEPTION("CHECK_IF_ATTR_READ_ALLOWED_FAILED",ss.str());
	}
		
	//Check if allowed
	bool isAllowed= true;
	try {
		switch (data_type) {
			case Tango::DEV_FLOAT: 
			{
				isAllowed= CheckIfAttrReadIsAllowed<Tango::DevFloat>(attr_name,sm_attr_name,data_type);
				break;
			}
			case Tango::DEV_DOUBLE: 
			{
				isAllowed= CheckIfAttrReadIsAllowed<Tango::DevDouble>(attr_name,sm_attr_name,data_type);
				break;
			}
			case Tango::DEV_LONG: 
			{
				isAllowed= CheckIfAttrReadIsAllowed<Tango::DevLong>(attr_name,sm_attr_name,data_type);
				break;
			}
			case Tango::DEV_SHORT: 
			{
				isAllowed= CheckIfAttrReadIsAllowed<Tango::DevShort>(attr_name,sm_attr_name,data_type);
				break;
			}
			#if TANGO_VERSION_MAJOR >= 9	
			case Tango::DEV_ENUM: 
			{
				isAllowed= CheckIfAttrReadIsAllowed<Tango::DevEnum>(attr_name,sm_attr_name,data_type);
				break;
			}
			#endif
			case Tango::DEV_STRING: 
			{
				isAllowed= CheckIfAttrReadIsAllowed<std::string>(attr_name,sm_attr_name,data_type);
				break;
			}
			case Tango::DEV_BOOLEAN: 
			{
				isAllowed= CheckIfAttrReadIsAllowed<Tango::DevBoolean>(attr_name,sm_attr_name,data_type);
				break;
			}
			case Tango::DEV_STATE: 
			{
				isAllowed= CheckIfAttrReadIsAllowed<Tango::DevState>(attr_name,sm_attr_name,data_type);
				break;
			}
			default:
			{
				std::stringstream ss;
				ss<<"Unsupported data type ("<<data_type<<") for sm attribute "<<sm_attr_name<<"!";
				_ERROR_LOG(ss.str());
	      _THROW_TANGO_EXCEPTION("CHECK_IF_ATTR_READ_ALLOWED_FAILED",ss.str());
       	break;
			}	
		}//close switch
	}//close try block
	catch(Tango::DevFailed& e){
		throw;
	}
	catch(...){
		throw;
	}	

	return isAllowed;

}//close CheckIfAttrReadIsAllowed()

void LMCDevice::IsAttrReadAllowed(std::string attr_name,bool check){
	
	auto tstart = std::chrono::high_resolution_clock::now();

	//Find if attr exist in device?
	if(check){
		try{
			get_device_attr()->get_attr_by_name(attr_name.c_str());
		}
		catch(Tango::DevFailed &e){//an exception is thrown if the attribute is not existing
			throw;
		}
		catch(...){//an exception is thrown if the attribute is not existing
			throw;
		}
	}//close if check

	//Get all sm attrs registered in rules 
	auto tstart_getrules = std::chrono::high_resolution_clock::now();
	std::vector<std::string> sm_attr_names;
	if(Utils_ns::TangoUtils::GetSMAttrsInAttrReadRules(sm_attr_names,attr_name)<0){
		_DEBUG_LOG("Cannot get list of state machine attribute names in rules for attr "<<attr_name<<" (no rules present for this attr or invalid attr name), return attr read allowed");
		return;
	}
	auto tstop_getrules = std::chrono::high_resolution_clock::now();
	double dt_getrules= std::chrono::duration<double, std::milli>(tstop_getrules-tstart_getrules).count();

	//Iterate over sm attribute and check if attribute read is allowed
	auto tstart_checkrules = std::chrono::high_resolution_clock::now();
	bool isAllowed= true;
	for(size_t i=0;i<sm_attr_names.size();i++){
		try{
			isAllowed= CheckIfAttrReadIsAllowed(attr_name,sm_attr_names[i]);
		}	
		catch(Tango::DevFailed& e){
			Tango::Except::print_exception(e);
			_WARN_LOG("Tango exception occurred when checking if attr "<<attr_name<<" read is allowed for sm attr "<<sm_attr_names[i]<<", skip to next check!");
			continue;
		}
		catch(...){
			_WARN_LOG("Unknown exception occurred when checking if attr "<<attr_name<<" read is allowed for sm attr "<<sm_attr_names[i]<<", skip to next check!");
			continue;
		}
	
		if(!isAllowed) {
			std::stringstream ss;
			ss<<"Attr "<<attr_name<<" read not allowed due to sm attr "<<sm_attr_names[i]<<" violating rules!";
			_THROW_TANGO_EXCEPTION("ATTR_READ_NOT_ALLOWED",ss.str());
			break;
		}
	}//end loop attr rules
	auto tstop_checkrules = std::chrono::high_resolution_clock::now();
	double dt_checkrules= std::chrono::duration<double, std::milli>(tstop_checkrules-tstart_checkrules).count();

	auto tstop = std::chrono::high_resolution_clock::now();
	double dt= std::chrono::duration<double, std::milli>(tstop-tstart).count();
	_INFO_LOG("IsAttrReadAllowed (attr="<<attr_name<<") time(ms)="<<dt<<" (getRules="<<dt_getrules/dt*100.<<"%"<<", checkRules="<<dt_checkrules/dt*100.<<"%)");
	

}//close IsAttrReadAllowed()


bool LMCDevice::CheckIfAttrWriteIsAllowed(std::string attr_name,std::string sm_attr_name){

	//Get sm attribute info
	long data_type;
	Tango::AttrDataFormat data_format;
	try{
		Tango::Attribute& sm_attr= get_device_attr()->get_attr_by_name(sm_attr_name.c_str());
		data_type= sm_attr.get_data_type();
		data_format= sm_attr.get_data_format();	
	}
	catch(Tango::DevFailed &e){//an exception is thrown if the sm attribute is not existing
		throw;
	}
	catch(...){//an exception is thrown if the sm attribute is not existing
		throw;
	}

	//Check if attribute is not a scalar (attr read rules supported only for scalar attr sm attr)
	if(data_format!=Tango::SCALAR){
		std::stringstream ss;
		ss<<"Invalid sm attr data format found (attr state machine is supported for scalar attribute only), check failed!";
		_THROW_TANGO_EXCEPTION("CHECK_IF_ATTR_WRITE_ALLOWED_FAILED",ss.str());
	}
		
	//Check if allowed
	bool isAllowed= true;
	try {
		switch (data_type) {
			case Tango::DEV_FLOAT: 
			{
				isAllowed= CheckIfAttrWriteIsAllowed<Tango::DevFloat>(attr_name,sm_attr_name,data_type);
				break;
			}
			case Tango::DEV_DOUBLE: 
			{
				isAllowed= CheckIfAttrWriteIsAllowed<Tango::DevDouble>(attr_name,sm_attr_name,data_type);
				break;
			}
			case Tango::DEV_LONG: 
			{
				isAllowed= CheckIfAttrWriteIsAllowed<Tango::DevLong>(attr_name,sm_attr_name,data_type);
				break;
			}
			case Tango::DEV_SHORT: 
			{
				isAllowed= CheckIfAttrWriteIsAllowed<Tango::DevShort>(attr_name,sm_attr_name,data_type);
				break;
			}
			#if TANGO_VERSION_MAJOR >= 9
			case Tango::DEV_ENUM: 
			{
				isAllowed= CheckIfAttrWriteIsAllowed<Tango::DevEnum>(attr_name,sm_attr_name,data_type);
				break;
			}
			#endif
			case Tango::DEV_STRING: 
			{
				isAllowed= CheckIfAttrWriteIsAllowed<std::string>(attr_name,sm_attr_name,data_type);
				break;
			}
			case Tango::DEV_BOOLEAN: 
			{
				isAllowed= CheckIfAttrWriteIsAllowed<Tango::DevBoolean>(attr_name,sm_attr_name,data_type);
				break;
			}
			case Tango::DEV_STATE: 
			{
				isAllowed= CheckIfAttrWriteIsAllowed<Tango::DevState>(attr_name,sm_attr_name,data_type);
				break;
			}
			default:
			{
				std::stringstream ss;
				ss<<"Unsupported data type ("<<data_type<<") for sm attribute "<<sm_attr_name<<"!";
				_ERROR_LOG(ss.str());
	      _THROW_TANGO_EXCEPTION("CHECK_IF_ATTR_WRITE_ALLOWED_FAILED",ss.str());
       	break;
			}	
		}//close switch
	}//close try block
	catch(Tango::DevFailed& e){
		throw;
	}
	catch(...){
		throw;
	}	

	return isAllowed;

}//close CheckIfAttrWriteIsAllowed()

void LMCDevice::IsAttrWriteAllowed(std::string attr_name,bool check){

	//Find if attr exist in device and is a writable attr?
	if(check){
		bool hasWriteAssociation= false;
		try{
			Tango::Attribute& attr= get_device_attr()->get_attr_by_name(attr_name.c_str());
			hasWriteAssociation= attr.is_writ_associated();
		}
		catch(Tango::DevFailed &e){//an exception is thrown if the attribute is not existing
			throw;
		}
		catch(...){//an exception is thrown if the attribute is not existing
			throw;
		}

		//Check if attribute is writable
		if(!hasWriteAssociation){
			_WARN_LOG("Attr "<<attr_name<<" is not a writable attribute, return attr write allowed");
			return;
		}
	}//close if check

	//Get all sm attrs registered in rules 
	std::vector<std::string> sm_attr_names;
	if(Utils_ns::TangoUtils::GetSMAttrsInAttrWriteRules(sm_attr_names,attr_name)<0){
		_DEBUG_LOG("Cannot get list of state machine attribute names in rules for attr "<<attr_name<<" (no rules present for this attr or invalid attr name), return attr write allowed");
		return;
	}

	//Iterate over sm attribute and check if attribute read is allowed
	bool isAllowed= true;
	for(unsigned int i=0;i<sm_attr_names.size();i++){		
		try{
			isAllowed= CheckIfAttrWriteIsAllowed(attr_name,sm_attr_names[i]);
		}	
		catch(Tango::DevFailed& e){
			Tango::Except::print_exception(e);
			_WARN_LOG("Tango exception occurred when checking if attr "<<attr_name<<" write is allowed for sm attr "<<sm_attr_names[i]<<", skip to next check!");
			continue;
		}
		catch(...){
			_WARN_LOG("Unknown exception occurred when checking if attr "<<attr_name<<" write is allowed for sm attr "<<sm_attr_names[i]<<", skip to next check!");
			continue;
		}
	
		if(!isAllowed) {
			std::stringstream ss;
			ss<<"Attr "<<attr_name<<" write not allowed due to sm attr "<<sm_attr_names[i]<<" violating rules!";
			_THROW_TANGO_EXCEPTION("ATTR_WRITE_NOT_ALLOWED",ss.str());
			break;
		}
	}//end loop attr rules

}//close IsAttrWriteAllowed()

void LMCDevice::ExecuteAttrWriteActions(std::string attr_name,bool preaction,bool check)
{
	//Find if attr exist in device and is a writable attr?
	if(check){
		bool hasWriteAssociation= false;
		try{
			Tango::Attribute& attr= get_device_attr()->get_attr_by_name(attr_name.c_str());
			hasWriteAssociation= attr.is_writ_associated();
		}
		catch(Tango::DevFailed &e){//an exception is thrown if the attribute is not existing
			throw;
		}
		catch(...){//an exception is thrown if the attribute is not existing
			throw;
		}

		//Check if attribute is writable
		if(!hasWriteAssociation){
			_WARN_LOG("Attr "<<attr_name<<" is not a writable attribute, return attr write allowed");
			return;
		}
	}//close if check

	//Get list of registered pre-actions	
	std::vector<std::string> cmd_names;
	if(preaction){
		if(Utils_ns::TangoUtils::GetAttrWritePreActions(cmd_names,attr_name)<0){
			_DEBUG_LOG("Cannot get list of registered pre-actions for attr "<<attr_name<<" (no actions present for this attr or invalid attr name), return.");
			return;
		}
	}
	else{
		if(Utils_ns::TangoUtils::GetAttrWritePostActions(cmd_names,attr_name)<0){
			_DEBUG_LOG("Cannot get list of registered post-actions for attr "<<attr_name<<" (no actions present for this attr or invalid attr name), return.");
			return;
		}
	}

	//Iterate over commands and execute them in sequence
	for(size_t i=0;i<cmd_names.size();i++){
		//Check command existing in device?
		if(check){
			bool hasCommand= Utils_ns::TangoUtils::HasCommand(this,cmd_names[i]);
			if(!hasCommand){
				_WARN_LOG("Write pre-action command "<<cmd_names[i]<<" for attr "<<attr_name<<" not found in device, skip action...");
				continue;
			}
		}
		
		//Execute command
		_DEBUG_LOG("Executing write pre-action cmd "<<cmd_names[i]<<" for attr "<<attr_name<<"...");
		CORBA::Any argin;
		try {
			this->get_device_class()->command_handler(this,cmd_names[i],argin);
		}	
		catch(Tango::DevFailed& e){
			Tango::Except::print_exception(e);
			_ERROR_LOG("Tango exception occurred while executing write action "<<cmd_names[i]<<" for attr "<<attr_name<<" (hints: check cmd name, is_allowed, argin, etc...)!");
			throw;
		}
		catch(std::exception& e){
			_ERROR_LOG("C++ exception (err="<<e.what()<<") occurred while executing write action "<<cmd_names[i]<<" for attr "<<attr_name<<" (hints: check cmd name, is_allowed, argin, etc...)!");
			throw;
		}
		catch(...){
			_ERROR_LOG("Unknown exception occurred while executing write action "<<cmd_names[i]<<" for attr "<<attr_name<<" (hints: check cmd name, is_allowed, argin, etc...)!");
			throw;
		}

	}//end loop commands

}//close ExecuteAttrWriteActions()


int LMCDevice::InitTaskThread(){

	//## Init task manager
	_DEBUG_LOG("Init task manager...");
	m_taskManager= 0;
	m_taskManager= new Utils_ns::TaskManager(this);
	m_taskManager->SetMaxNTasksInQueue(maxQueueableTask);
	m_taskManager->SetMaxNTasksInCollection(maxTrackableTasks);
	
	//## Start the scheduler thread
  _DEBUG_LOG("Init task thread...");
  m_stopTaskThreadFlag= false;
	m_taskThread= 0;
  m_taskThread = new TaskThread(this);
  m_taskThread->Start();

	return 0;

}//close InitTaskThread()




/*----- PROTECTED REGION END -----*/	//	LMCDevice::namespace_ending
} //	namespace
