/*----- PROTECTED REGION ID(LMCDeviceClass.cpp) ENABLED START -----*/
//=============================================================================
//
// file :        LMCDeviceClass.cpp
//
// description : C++ source for the LMCDeviceClass.
//               A singleton class derived from DeviceClass.
//               It implements the command and attribute list
//               and all properties and methods required
//               by the LMCDevice once per process.
//
// project :     LMCDevice
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
//
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <LMCDeviceClass.h>

/*----- PROTECTED REGION END -----*/	//	LMCDeviceClass.cpp

//-------------------------------------------------------------------
/**
 *	Create LMCDeviceClass singleton and
 *	return it in a C function for Python usage
 */
//-------------------------------------------------------------------
extern "C" {
#ifdef _TG_WINDOWS_

__declspec(dllexport)

#endif

	Tango::DeviceClass *_create_LMCDevice_class(const char *name) {
		return LMCDevice_ns::LMCDeviceClass::init(name);
	}
}

namespace LMCDevice_ns
{
//===================================================================
//	Initialize pointer for singleton pattern
//===================================================================
LMCDeviceClass *LMCDeviceClass::_instance = NULL;

//--------------------------------------------------------
/**
 * method : 		LMCDeviceClass::LMCDeviceClass(string &s)
 * description : 	constructor for the LMCDeviceClass
 *
 * @param s	The class name
 */
//--------------------------------------------------------
LMCDeviceClass::LMCDeviceClass(string &s):Tango::DeviceClass(s)
{
	cout2 << "Entering LMCDeviceClass constructor" << endl;
	set_default_property();
	write_class_property();

	/*----- PROTECTED REGION ID(LMCDeviceClass::constructor) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	LMCDeviceClass::constructor

	cout2 << "Leaving LMCDeviceClass constructor" << endl;
}

//--------------------------------------------------------
/**
 * method : 		LMCDeviceClass::~LMCDeviceClass()
 * description : 	destructor for the LMCDeviceClass
 */
//--------------------------------------------------------
LMCDeviceClass::~LMCDeviceClass()
{
	/*----- PROTECTED REGION ID(LMCDeviceClass::destructor) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	LMCDeviceClass::destructor

	_instance = NULL;
}


//--------------------------------------------------------
/**
 * method : 		LMCDeviceClass::init
 * description : 	Create the object if not already done.
 *                  Otherwise, just return a pointer to the object
 *
 * @param	name	The class name
 */
//--------------------------------------------------------
LMCDeviceClass *LMCDeviceClass::init(const char *name)
{
	if (_instance == NULL)
	{
		try
		{
			string s(name);
			_instance = new LMCDeviceClass(s);
		}
		catch (bad_alloc &)
		{
			throw;
		}
	}
	return _instance;
}

//--------------------------------------------------------
/**
 * method : 		LMCDeviceClass::instance
 * description : 	Check if object already created,
 *                  and return a pointer to the object
 */
//--------------------------------------------------------
LMCDeviceClass *LMCDeviceClass::instance()
{
	if (_instance == NULL)
	{
		cerr << "Class is not initialised !!" << endl;
		exit(-1);
	}
	return _instance;
}



//===================================================================
//	Command execution method calls
//===================================================================
//--------------------------------------------------------
/**
 * method : 		InitializeLoggersClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *InitializeLoggersClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "InitializeLoggersClass::execute(): arrived" << endl;
	((static_cast<LMCDevice *>(device))->initialize_loggers());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		InitializeFwdAttrsClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *InitializeFwdAttrsClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "InitializeFwdAttrsClass::execute(): arrived" << endl;
	((static_cast<LMCDevice *>(device))->initialize_fwd_attrs());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		RandomizeDynAttrsClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *RandomizeDynAttrsClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "RandomizeDynAttrsClass::execute(): arrived" << endl;
	((static_cast<LMCDevice *>(device))->randomize_dyn_attrs());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		InitializeDevProxiesClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *InitializeDevProxiesClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "InitializeDevProxiesClass::execute(): arrived" << endl;
	((static_cast<LMCDevice *>(device))->initialize_dev_proxies());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		GetRegisteredProxiesClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *GetRegisteredProxiesClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "GetRegisteredProxiesClass::execute(): arrived" << endl;
	return insert((static_cast<LMCDevice *>(device))->get_registered_proxies());
}

//--------------------------------------------------------
/**
 * method : 		GetRegisteredEventsClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *GetRegisteredEventsClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "GetRegisteredEventsClass::execute(): arrived" << endl;
	return insert((static_cast<LMCDevice *>(device))->get_registered_events());
}

//--------------------------------------------------------
/**
 * method : 		GetRegisteredFormulasClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *GetRegisteredFormulasClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "GetRegisteredFormulasClass::execute(): arrived" << endl;
	return insert((static_cast<LMCDevice *>(device))->get_registered_formulas());
}

//--------------------------------------------------------
/**
 * method : 		GetInitializedFormulasClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *GetInitializedFormulasClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "GetInitializedFormulasClass::execute(): arrived" << endl;
	return insert((static_cast<LMCDevice *>(device))->get_initialized_formulas());
}

//--------------------------------------------------------
/**
 * method : 		GetNRunningTasksClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *GetNRunningTasksClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "GetNRunningTasksClass::execute(): arrived" << endl;
	return insert((static_cast<LMCDevice *>(device))->get_nrunning_tasks());
}

//--------------------------------------------------------
/**
 * method : 		GetNQueuedTasksClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *GetNQueuedTasksClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "GetNQueuedTasksClass::execute(): arrived" << endl;
	return insert((static_cast<LMCDevice *>(device))->get_nqueued_tasks());
}

//--------------------------------------------------------
/**
 * method : 		GetNIdleTasksClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *GetNIdleTasksClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "GetNIdleTasksClass::execute(): arrived" << endl;
	return insert((static_cast<LMCDevice *>(device))->get_nidle_tasks());
}

//--------------------------------------------------------
/**
 * method : 		GetNTasksClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *GetNTasksClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "GetNTasksClass::execute(): arrived" << endl;
	return insert((static_cast<LMCDevice *>(device))->get_ntasks());
}

//--------------------------------------------------------
/**
 * method : 		GetNFailedTasksClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *GetNFailedTasksClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "GetNFailedTasksClass::execute(): arrived" << endl;
	return insert((static_cast<LMCDevice *>(device))->get_nfailed_tasks());
}

//--------------------------------------------------------
/**
 * method : 		GetNTotFailedTasksClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *GetNTotFailedTasksClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "GetNTotFailedTasksClass::execute(): arrived" << endl;
	return insert((static_cast<LMCDevice *>(device))->get_ntot_failed_tasks());
}

//--------------------------------------------------------
/**
 * method : 		IsTaskQuotaReachedClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *IsTaskQuotaReachedClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "IsTaskQuotaReachedClass::execute(): arrived" << endl;
	return insert((static_cast<LMCDevice *>(device))->is_task_quota_reached());
}

//--------------------------------------------------------
/**
 * method : 		FlushTaskQueueClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *FlushTaskQueueClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "FlushTaskQueueClass::execute(): arrived" << endl;
	((static_cast<LMCDevice *>(device))->flush_task_queue());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		GetQueuedTaskInfoClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *GetQueuedTaskInfoClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "GetQueuedTaskInfoClass::execute(): arrived" << endl;
	return insert((static_cast<LMCDevice *>(device))->get_queued_task_info());
}

//--------------------------------------------------------
/**
 * method : 		GetTaskInfoClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *GetTaskInfoClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "GetTaskInfoClass::execute(): arrived" << endl;
	return insert((static_cast<LMCDevice *>(device))->get_task_info());
}

//--------------------------------------------------------
/**
 * method : 		ClearTasksClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *ClearTasksClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "ClearTasksClass::execute(): arrived" << endl;
	((static_cast<LMCDevice *>(device))->clear_tasks());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		UpdateFormulaAttrsClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *UpdateFormulaAttrsClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "UpdateFormulaAttrsClass::execute(): arrived" << endl;
	((static_cast<LMCDevice *>(device))->update_formula_attrs());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		UpdateStatusAttrsClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *UpdateStatusAttrsClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "UpdateStatusAttrsClass::execute(): arrived" << endl;
	((static_cast<LMCDevice *>(device))->update_status_attrs());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		MonitorProxiesClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *MonitorProxiesClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "MonitorProxiesClass::execute(): arrived" << endl;
	((static_cast<LMCDevice *>(device))->monitor_proxies());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		RevokeTaskClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *RevokeTaskClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "RevokeTaskClass::execute(): arrived" << endl;
	Tango::DevString argin;
	extract(in_any, argin);
	((static_cast<LMCDevice *>(device))->revoke_task(argin));
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		RevokeTaskSequenceClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *RevokeTaskSequenceClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "RevokeTaskSequenceClass::execute(): arrived" << endl;
	Tango::DevString argin;
	extract(in_any, argin);
	((static_cast<LMCDevice *>(device))->revoke_task_sequence(argin));
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		GetFormulaDataClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *GetFormulaDataClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "GetFormulaDataClass::execute(): arrived" << endl;
	Tango::DevString argin;
	extract(in_any, argin);
	return insert((static_cast<LMCDevice *>(device))->get_formula_data(argin));
}

//--------------------------------------------------------
/**
 * method : 		SendTestLogMsgClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *SendTestLogMsgClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "SendTestLogMsgClass::execute(): arrived" << endl;
	const Tango::DevVarLongStringArray *argin;
	extract(in_any, argin);
	((static_cast<LMCDevice *>(device))->send_test_log_msg(argin));
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		ClearTaskHistoryClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *ClearTaskHistoryClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "ClearTaskHistoryClass::execute(): arrived" << endl;
	((static_cast<LMCDevice *>(device))->clear_task_history());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		GetLogAppenderInfoClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *GetLogAppenderInfoClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "GetLogAppenderInfoClass::execute(): arrived" << endl;
	return insert((static_cast<LMCDevice *>(device))->get_log_appender_info());
}

//--------------------------------------------------------
/**
 * method : 		dummyDynCmdClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *dummyDynCmdClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "dummyDynCmdClass::execute(): arrived" << endl;
	((static_cast<LMCDevice *>(device))->dummy_dyn_cmd(*this));
	return new CORBA::Any();
}


//===================================================================
//	Properties management
//===================================================================
//--------------------------------------------------------
/**
 *	Method      : LMCDeviceClass::get_class_property()
 *	Description : Get the class property for specified name.
 */
//--------------------------------------------------------
Tango::DbDatum LMCDeviceClass::get_class_property(string &prop_name)
{
	for (unsigned int i=0 ; i<cl_prop.size() ; i++)
		if (cl_prop[i].name == prop_name)
			return cl_prop[i];
	//	if not found, returns  an empty DbDatum
	return Tango::DbDatum(prop_name);
}

//--------------------------------------------------------
/**
 *	Method      : LMCDeviceClass::get_default_device_property()
 *	Description : Return the default value for device property.
 */
//--------------------------------------------------------
Tango::DbDatum LMCDeviceClass::get_default_device_property(string &prop_name)
{
	for (unsigned int i=0 ; i<dev_def_prop.size() ; i++)
		if (dev_def_prop[i].name == prop_name)
			return dev_def_prop[i];
	//	if not found, return  an empty DbDatum
	return Tango::DbDatum(prop_name);
}

//--------------------------------------------------------
/**
 *	Method      : LMCDeviceClass::get_default_class_property()
 *	Description : Return the default value for class property.
 */
//--------------------------------------------------------
Tango::DbDatum LMCDeviceClass::get_default_class_property(string &prop_name)
{
	for (unsigned int i=0 ; i<cl_def_prop.size() ; i++)
		if (cl_def_prop[i].name == prop_name)
			return cl_def_prop[i];
	//	if not found, return  an empty DbDatum
	return Tango::DbDatum(prop_name);
}


//--------------------------------------------------------
/**
 *	Method      : LMCDeviceClass::set_default_property()
 *	Description : Set default property (class and device) for wizard.
 *                For each property, add to wizard property name and description.
 *                If default value has been set, add it to wizard property and
 *                store it in a DbDatum.
 */
//--------------------------------------------------------
void LMCDeviceClass::set_default_property()
{
	string	prop_name;
	string	prop_desc;
	string	prop_def;
	vector<string>	vect_data;

	//	Set Default Class Properties

	//	Set Default device Properties
	prop_name = "CentralLoggerEnabledDefault";
	prop_desc = "Enable central logging target";
	prop_def  = "true";
	vect_data.clear();
	vect_data.push_back("true");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "ElementLoggerEnabledDefault";
	prop_desc = "Enable element logging target";
	prop_def  = "true";
	vect_data.clear();
	vect_data.push_back("true");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "StorageLoggerEnabledDefault";
	prop_desc = "Enable log storage (e.g. logging to syslog)";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "LoggingTargetCentralDefault";
	prop_desc = "Pre-configured logging target CentralLogger DS";
	prop_def  = "DSHLMC/LogConsumer/id1";
	vect_data.clear();
	vect_data.push_back("DSHLMC/LogConsumer/id1");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "LoggingTargetElementDefault";
	prop_desc = "Pre-configured logging target ElementLogger DS";
	prop_def  = "DSHLMC/LogConsumer/id2";
	vect_data.clear();
	vect_data.push_back("DSHLMC/LogConsumer/id2");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "LoggingTargetStorageDefault";
	prop_desc = "Pre-configured logging target for syslog";
	prop_def  = "localhost";
	vect_data.clear();
	vect_data.push_back("localhost");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "SkaLevel";
	prop_desc = "Indication of importance of the device in the SKA hierarchy \nto support drill-down navigation: 1..6, with 1 highest";
	prop_def  = "6";
	vect_data.clear();
	vect_data.push_back("6");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "SyslogFacility";
	prop_desc = "LOG_USER: A miscellaneous user process\nLOG_MAIL: Mail\nLOG_DAEMON: A miscellaneous system daemon\nLOG_AUTH:  Security (authorization)\nLOG_SYSLOG: Syslog\nLOG_LPR: Central printer\nLOG_NEWS: Network news (e.g. Usenet)\nLOG_UUCP: UUCP\nLOG_CRON: Cron and At\nLOG_AUTHPRIV: Private security (authorization)\nLOG_FTP: Ftp server\nLOG_LOCAL0,1,2,3,4,5,6,7: Locally defined\n\n``auth``: LOG_AUTH\n``authpriv``: LOG_AUTHPRIV\n``cron``: LOG_CRON \n``daemon``: LOG_DAEMON\n``ftp``: LOG_FTP\n``kern``: LOG_KERN\n``lpr``: LOG_LPR\n``mail``: LOG_MAIL\n``mark``: INTERNAL_MARK\n``news``: LOG_NEWS\n``security``: LOG_AUTH,\n``syslog``: LOG_SYSLOG\n``user``: LOG_USER\n``uucp``: LOG_UUCP\n``local0``: LOG_LOCAL0\n``local1``: LOG_LOCAL1 \n``local2``: LOG_LOCAL2 \n``local3``: LOG_LOCAL3 \n``local4``: LOG_LOCAL4 \n``local5``: LOG_LOCAL5 \n``local6``: LOG_LOCAL6 \n``local7``: LOG_LOCAL7";
	prop_def  = "local6";
	vect_data.clear();
	vect_data.push_back("local6");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "SyslogHost";
	prop_desc = "Hostname of syslog server used for log storage";
	prop_def  = "localhost";
	vect_data.clear();
	vect_data.push_back("localhost");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "LoggingLevelCentralDefault";
	prop_desc = "Default logging level to Central logging target\n(0=OFF, 1=FATAL, 2=ERROR, 3=WARNING, 4=INFO, 5=DEBUG)\n\nDefault: 3";
	prop_def  = "";
	vect_data.clear();
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "LoggingLevelElementDefault";
	prop_desc = "Default logging level to Element logging target\n(0=OFF, 1=FATAL, 2=ERROR, 3=WARNING, 4=INFO, 5=DEBUG)\n\nDefault: 4";
	prop_def  = "";
	vect_data.clear();
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "LoggingLevelStorageDefault";
	prop_desc = "Default logging level to Syslog logging target\n(0=OFF, 1=FATAL, 2=ERROR, 3=WARNING, 4=INFO, 5=DEBUG)\n\nDefault: 4";
	prop_def  = "";
	vect_data.clear();
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "ConfigFile";
	prop_desc = "String with full path to a XML file with device configuration\n(attributes & their properties)";
	prop_def  = "";
	vect_data.clear();
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "EnableConfigFromFile";
	prop_desc = "Configure device attribute from file";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "EnableDynAttrCleanup";
	prop_desc = "Enable/disable automatic cleanup of dynamical attributes created, \ne.g. at device destroy all dynamical attributes created from\nconfig file are removed from the device.";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "EnableDynAttrRandomize";
	prop_desc = "Enable/disable randomization of dynamical attributes according\nto configured random model & parameters";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "DynAttrRandomizePeriod";
	prop_desc = "Period t (in ms) to be used for randomization of dynamical\nattributes (if enabled), e.g. attributes are randomized (and therefore)\nupdated each t.";
	prop_def  = "3000";
	vect_data.clear();
	vect_data.push_back("3000");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "ProxyDevices";
	prop_desc = "Proxy device list";
	prop_def  = "";
	vect_data.clear();
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "FormulaVarMaxTimeInterval";
	prop_desc = "Max time interval (in seconds) for an attribute value present in \nattr formula after which \nthe formula is declared as `old` and relative formula \nresult attribute quality switched to INVALID";
	prop_def  = "10";
	vect_data.clear();
	vect_data.push_back("10");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "EnableProxyMonitoring";
	prop_desc = "Enable periodic monitoring of registered proxies in device\n\nIf enabled, a monitoring thread will be started and\nwhenever a proxy is registered a corresponding \ndyn attr is created in device with notation:\n\nproxyRunStatus_[domain_name]_[family_name]_[member_name]\n\nholding the monitoring status.";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "ProxyMonitoringPeriod";
	prop_desc = "Period (in ms) used to monitor registered proxies.";
	prop_def  = "10000";
	vect_data.clear();
	vect_data.push_back("10000");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "ProxyStatusAttrPollPeriod";
	prop_desc = "Polling period for proxy status attributes in ms";
	prop_def  = "10000";
	vect_data.clear();
	vect_data.push_back("10000");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "ProxyStatusAttrPeriodicEventPeriod";
	prop_desc = "Periodic event period for proxy status attributes in ms";
	prop_def  = "10000";
	vect_data.clear();
	vect_data.push_back("10000");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "ProxyStatusAttrArchiveEventPeriod";
	prop_desc = "Archive event period for proxy status attributes in ms";
	prop_def  = "20000";
	vect_data.clear();
	vect_data.push_back("20000");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "ProxyTimeout";
	prop_desc = "Timeout (in s) after which a non responding proxy device is marked\nas down (in hard state)";
	prop_def  = "20";
	vect_data.clear();
	vect_data.push_back("20");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "EventSubscriptions";
	prop_desc = "List of event subscriptions to be performed for this device in\nthe following format:\n\n[0]= full attr name 1\n[1]= event type 1\n...\n[N]= full attr name N\n[N+1]= event type N";
	prop_def  = "";
	vect_data.clear();
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "EventHandlers";
	prop_desc = "List of event handlers to be registered in device given in the following\nformat:\n\n[0]: full attr name\n[1]: event type string\n[2]: name of event handler command\n[3]: execution delay (0=now)\n[4]: priority (0=LOW,1=MEDIUM,2=HIGH)\n...\n[N]: ...\n[N+1]: ...\n[N+2]: ...\n[N+3]: ...\n[N+4]: ...\n\nCommand handler name must exist in device otherwise registration\nfails.";
	prop_def  = "";
	vect_data.clear();
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "MaxQueueableTask";
	prop_desc = "Maximum number of tasks that can be inserted in the task queue";
	prop_def  = "20";
	vect_data.clear();
	vect_data.push_back("20");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "MaxTrackableTasks";
	prop_desc = "Maximum number of tasks that can be stored in cache list \n(historical info).";
	prop_def  = "100";
	vect_data.clear();
	vect_data.push_back("100");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "TaskHistoryTimeDepth";
	prop_desc = "Max time interval (in seconds) used to maintain tasks in the task \nlist.";
	prop_def  = "600";
	vect_data.clear();
	vect_data.push_back("600");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "DefaultTaskTimeout";
	prop_desc = "Default task timeout (in seconds) to be used in task manager";
	prop_def  = "120";
	vect_data.clear();
	vect_data.push_back("120");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "TaskSequenceStatusAttrList";
	prop_desc = "List of sequence task status progress attribute names.";
	prop_def  = "";
	vect_data.clear();
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "TaskStatusAttrList";
	prop_desc = "List of asynch task status attr.\n\nNB: These are the attributes containing each task status progress\ninfo. Task sequence status is contained in attribute \nnames listed in the TaskSequenceAttrList property.";
	prop_def  = "";
	vect_data.clear();
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "EnableEventRateMonitoring";
	prop_desc = "Enable event rate monitoring";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "EnableLoggerInitPolling";
	prop_desc = "Enable/disable periodic logging system initialization. \nThis is to allow adding log target devices if they are not present \n(e.g. because down) at device initialization.";
	prop_def  = "true";
	vect_data.clear();
	vect_data.push_back("true");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "LoggerInitPollPeriod";
	prop_desc = "Logging initialization polling period in ms.";
	prop_def  = "10000";
	vect_data.clear();
	vect_data.push_back("10000");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "EnableDevProxyInitPolling";
	prop_desc = "Enable/disable polling of proxy initialization & registration. \nThis is to handle down proxy at startup. In this case if the \ninitialization is not re-attempted that proxies will never be \nregistered in device.";
	prop_def  = "true";
	vect_data.clear();
	vect_data.push_back("true");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "DevProxyInitPollPeriod";
	prop_desc = "";
	prop_def  = "10000";
	vect_data.clear();
	vect_data.push_back("10000");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "EnableFwdAttrInitPolling";
	prop_desc = "";
	prop_def  = "true";
	vect_data.clear();
	vect_data.push_back("true");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "FwdAttrInitPollPeriod";
	prop_desc = "";
	prop_def  = "5000";
	vect_data.clear();
	vect_data.push_back("5000");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "EnableFormulaAttrUpdatePolling";
	prop_desc = "Enable/disable update of formula attrs present in device.\nThe update is needed to initialize the formula in case one/more \nproxies  contained in the device were down at the startup.\nIf initialization is succesful, the formula attr is evaluated to \nupdate the quality status. If not done, otherwise, the formula attr is\nonly computed when proxy events are received.\n\nYou can turn off this flag if you don`t have formula attrs in your\ndevice.";
	prop_def  = "true";
	vect_data.clear();
	vect_data.push_back("true");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "FormulaAttrUpdatePollPeriod";
	prop_desc = "";
	prop_def  = "5000";
	vect_data.clear();
	vect_data.push_back("5000");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "EnableStatusAttrUpdatePolling";
	prop_desc = "";
	prop_def  = "true";
	vect_data.clear();
	vect_data.push_back("true");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "StatusAttrUpdatePollPeriod";
	prop_desc = "";
	prop_def  = "3000";
	vect_data.clear();
	vect_data.push_back("3000");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "EnableClearTaskPolling";
	prop_desc = "";
	prop_def  = "true";
	vect_data.clear();
	vect_data.push_back("true");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "ClearTaskPollPeriod";
	prop_desc = "";
	prop_def  = "10000";
	vect_data.clear();
	vect_data.push_back("10000");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "EnableProxyStatusAttrCreation";
	prop_desc = "Enable proxy status attr creation";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "EnableAutoAdminProxyRegistration";
	prop_desc = "Enable/disable automatic registration of admin device whenever\na proxy registration is needed.";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "ProcessEventsInQueueThread";
	prop_desc = "If enabled the events received in the callback are moved to \nthe EventHandlerTask queue thread.";
	prop_def  = "true";
	vect_data.clear();
	vect_data.push_back("true");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
}

//--------------------------------------------------------
/**
 *	Method      : LMCDeviceClass::write_class_property()
 *	Description : Set class description fields as property in database
 */
//--------------------------------------------------------
void LMCDeviceClass::write_class_property()
{
	//	First time, check if database used
	if (Tango::Util::_UseDb == false)
		return;

	Tango::DbData	data;
	string	classname = get_name();
	string	header;
	string::size_type	start, end;

	//	Put title
	Tango::DbDatum	title("ProjectTitle");
	string	str_title("LMCDevice");
	title << str_title;
	data.push_back(title);

	//	Put Description
	Tango::DbDatum	description("Description");
	vector<string>	str_desc;
	str_desc.push_back("This class represents the base device class for SKA Dish LMC. ");
	str_desc.push_back("All LMC Tango devices inherit from this basic functionalities, ");
	str_desc.push_back("among them:");
	str_desc.push_back("");
	str_desc.push_back("- logging configuration (level/target)");
	str_desc.push_back("- proxy registration and monitoring utilities");
	str_desc.push_back("- event handler registration utilities");
	str_desc.push_back("- dynamic attribute creation from XML configuration file");
	str_desc.push_back("- formula attributes");
	str_desc.push_back("- task command queue management");
	str_desc.push_back("");
	str_desc.push_back("More details are reported in the Dish LMC repository wiki page.");
	description << str_desc;
	data.push_back(description);

	//  Put inheritance
	Tango::DbDatum	inher_datum("InheritedFrom");
	vector<string> inheritance;
	inheritance.push_back("TANGO_BASE_CLASS");
	inher_datum << inheritance;
	data.push_back(inher_datum);

	//	Call database and and values
	get_db_class()->put_property(data);
}

//===================================================================
//	Factory methods
//===================================================================

//--------------------------------------------------------
/**
 *	Method      : LMCDeviceClass::device_factory()
 *	Description : Create the device object(s)
 *                and store them in the device list
 */
//--------------------------------------------------------
void LMCDeviceClass::device_factory(const Tango::DevVarStringArray *devlist_ptr)
{
	/*----- PROTECTED REGION ID(LMCDeviceClass::device_factory_before) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	LMCDeviceClass::device_factory_before

	//	Create devices and add it into the device list
	for (unsigned long i=0 ; i<devlist_ptr->length() ; i++)
	{
		cout4 << "Device name : " << (*devlist_ptr)[i].in() << endl;
		device_list.push_back(new LMCDevice(this, (*devlist_ptr)[i]));
	}

	//	Manage dynamic attributes if any
	erase_dynamic_attributes(devlist_ptr, get_class_attr()->get_attr_list());

	//	Export devices to the outside world
	for (unsigned long i=1 ; i<=devlist_ptr->length() ; i++)
	{
		//	Add dynamic attributes if any
		LMCDevice *dev = static_cast<LMCDevice *>(device_list[device_list.size()-i]);
		dev->add_dynamic_attributes();
		dev->add_dynamic_commands();

		//	Check before if database used.
		if ((Tango::Util::_UseDb == true) && (Tango::Util::_FileDb == false))
			export_device(dev);
		else
			export_device(dev, dev->get_name().c_str());
	}

	/*----- PROTECTED REGION ID(LMCDeviceClass::device_factory_after) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	LMCDeviceClass::device_factory_after
}
//--------------------------------------------------------
/**
 *	Method      : LMCDeviceClass::attribute_factory()
 *	Description : Create the attribute object(s)
 *                and store them in the attribute list
 */
//--------------------------------------------------------
void LMCDeviceClass::attribute_factory(vector<Tango::Attr *> &att_list)
{
	/*----- PROTECTED REGION ID(LMCDeviceClass::attribute_factory_before) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	LMCDeviceClass::attribute_factory_before
	//	Attribute : loggingLevelCentral
	loggingLevelCentralAttrib	*logginglevelcentral = new loggingLevelCentralAttrib();
	Tango::UserDefaultAttrProp	logginglevelcentral_prop;
	logginglevelcentral_prop.set_description("Current  logging level to Central logging target for this device");
	//	label	not set for loggingLevelCentral
	//	unit	not set for loggingLevelCentral
	//	standard_unit	not set for loggingLevelCentral
	//	display_unit	not set for loggingLevelCentral
	//	format	not set for loggingLevelCentral
	//	max_value	not set for loggingLevelCentral
	//	min_value	not set for loggingLevelCentral
	//	max_alarm	not set for loggingLevelCentral
	//	min_alarm	not set for loggingLevelCentral
	//	max_warning	not set for loggingLevelCentral
	//	min_warning	not set for loggingLevelCentral
	//	delta_t	not set for loggingLevelCentral
	//	delta_val	not set for loggingLevelCentral
	logginglevelcentral_prop.set_event_period("10000");
	logginglevelcentral_prop.set_event_abs_change("1");
	
	logginglevelcentral->set_default_properties(logginglevelcentral_prop);
	logginglevelcentral->set_polling_period(10000);
	logginglevelcentral->set_disp_level(Tango::OPERATOR);
	logginglevelcentral->set_memorized();
	logginglevelcentral->set_memorized_init(false);
	logginglevelcentral->set_change_event(true, false);
	att_list.push_back(logginglevelcentral);

	//	Attribute : loggingLevelElement
	loggingLevelElementAttrib	*logginglevelelement = new loggingLevelElementAttrib();
	Tango::UserDefaultAttrProp	logginglevelelement_prop;
	logginglevelelement_prop.set_description("Current  logging level to Element logging target for this device");
	//	label	not set for loggingLevelElement
	//	unit	not set for loggingLevelElement
	//	standard_unit	not set for loggingLevelElement
	//	display_unit	not set for loggingLevelElement
	//	format	not set for loggingLevelElement
	//	max_value	not set for loggingLevelElement
	//	min_value	not set for loggingLevelElement
	//	max_alarm	not set for loggingLevelElement
	//	min_alarm	not set for loggingLevelElement
	//	max_warning	not set for loggingLevelElement
	//	min_warning	not set for loggingLevelElement
	//	delta_t	not set for loggingLevelElement
	//	delta_val	not set for loggingLevelElement
	logginglevelelement_prop.set_event_period("10000");
	logginglevelelement_prop.set_event_abs_change("1");
	
	logginglevelelement->set_default_properties(logginglevelelement_prop);
	logginglevelelement->set_polling_period(10000);
	logginglevelelement->set_disp_level(Tango::OPERATOR);
	logginglevelelement->set_memorized();
	logginglevelelement->set_memorized_init(false);
	att_list.push_back(logginglevelelement);

	//	Attribute : loggingLevelStorage
	loggingLevelStorageAttrib	*logginglevelstorage = new loggingLevelStorageAttrib();
	Tango::UserDefaultAttrProp	logginglevelstorage_prop;
	logginglevelstorage_prop.set_description("Current  logging level to Syslog for this device");
	//	label	not set for loggingLevelStorage
	//	unit	not set for loggingLevelStorage
	//	standard_unit	not set for loggingLevelStorage
	//	display_unit	not set for loggingLevelStorage
	//	format	not set for loggingLevelStorage
	//	max_value	not set for loggingLevelStorage
	//	min_value	not set for loggingLevelStorage
	//	max_alarm	not set for loggingLevelStorage
	//	min_alarm	not set for loggingLevelStorage
	//	max_warning	not set for loggingLevelStorage
	//	min_warning	not set for loggingLevelStorage
	//	delta_t	not set for loggingLevelStorage
	//	delta_val	not set for loggingLevelStorage
	logginglevelstorage_prop.set_event_period("10000");
	logginglevelstorage_prop.set_event_abs_change("1");
	
	logginglevelstorage->set_default_properties(logginglevelstorage_prop);
	logginglevelstorage->set_polling_period(10000);
	logginglevelstorage->set_disp_level(Tango::OPERATOR);
	logginglevelstorage->set_memorized();
	logginglevelstorage->set_memorized_init(false);
	logginglevelstorage->set_change_event(true, false);
	att_list.push_back(logginglevelstorage);

	//	Attribute : loggingLevelConsole
	loggingLevelConsoleAttrib	*logginglevelconsole = new loggingLevelConsoleAttrib();
	Tango::UserDefaultAttrProp	logginglevelconsole_prop;
	//	description	not set for loggingLevelConsole
	//	label	not set for loggingLevelConsole
	//	unit	not set for loggingLevelConsole
	//	standard_unit	not set for loggingLevelConsole
	//	display_unit	not set for loggingLevelConsole
	//	format	not set for loggingLevelConsole
	//	max_value	not set for loggingLevelConsole
	//	min_value	not set for loggingLevelConsole
	//	max_alarm	not set for loggingLevelConsole
	//	min_alarm	not set for loggingLevelConsole
	//	max_warning	not set for loggingLevelConsole
	//	min_warning	not set for loggingLevelConsole
	//	delta_t	not set for loggingLevelConsole
	//	delta_val	not set for loggingLevelConsole
	
	logginglevelconsole->set_default_properties(logginglevelconsole_prop);
	//	Not Polled
	logginglevelconsole->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(logginglevelconsole);

	//	Attribute : buildState
	buildStateAttrib	*buildstate = new buildStateAttrib();
	Tango::UserDefaultAttrProp	buildstate_prop;
	buildstate_prop.set_description("Build state of this device");
	//	label	not set for buildState
	//	unit	not set for buildState
	//	standard_unit	not set for buildState
	//	display_unit	not set for buildState
	//	format	not set for buildState
	//	max_value	not set for buildState
	//	min_value	not set for buildState
	//	max_alarm	not set for buildState
	//	min_alarm	not set for buildState
	//	max_warning	not set for buildState
	//	min_warning	not set for buildState
	//	delta_t	not set for buildState
	//	delta_val	not set for buildState
	
	buildstate->set_default_properties(buildstate_prop);
	buildstate->set_polling_period(60000);
	buildstate->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(buildstate);

	//	Attribute : centralLoggerStatus
	centralLoggerStatusAttrib	*centralloggerstatus = new centralLoggerStatusAttrib();
	Tango::UserDefaultAttrProp	centralloggerstatus_prop;
	centralloggerstatus_prop.set_description("Central logging target status. Possible values are:\n\nUNKNOWN: Typically set at device startup\nDISABLED: When central logging target is disabled (see device properties)\nOK: When central logging target is initialized with success\nFAILED: When central logging target initialization fails, e.g. logger is offline or proxy name invalid ");
	//	label	not set for centralLoggerStatus
	//	unit	not set for centralLoggerStatus
	//	standard_unit	not set for centralLoggerStatus
	//	display_unit	not set for centralLoggerStatus
	//	format	not set for centralLoggerStatus
	//	max_value	not set for centralLoggerStatus
	//	min_value	not set for centralLoggerStatus
	//	max_alarm	not set for centralLoggerStatus
	//	min_alarm	not set for centralLoggerStatus
	//	max_warning	not set for centralLoggerStatus
	//	min_warning	not set for centralLoggerStatus
	//	delta_t	not set for centralLoggerStatus
	//	delta_val	not set for centralLoggerStatus
	centralloggerstatus_prop.set_event_period("3000");
	
	{
		vector<string> labels;
		labels.push_back("UNKNOWN");
		labels.push_back("DISABLED");
		labels.push_back("OK");
		labels.push_back("FAILED");
		centralloggerstatus_prop.set_enum_labels(labels);
	}
	centralloggerstatus->set_default_properties(centralloggerstatus_prop);
	centralloggerstatus->set_polling_period(3000);
	centralloggerstatus->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	centralloggerstatus->set_change_event(true, false);
	att_list.push_back(centralloggerstatus);

	//	Attribute : elementLoggerStatus
	elementLoggerStatusAttrib	*elementloggerstatus = new elementLoggerStatusAttrib();
	Tango::UserDefaultAttrProp	elementloggerstatus_prop;
	elementloggerstatus_prop.set_description("Element logging target status. Possible values are:\n\nUNKNOWN: Typically set at device startup\nDISABLED: When element logging target is disabled (see device properties)\nOK: When element logging target is initialized with success\nFAILED: When element logging target initialization fails, e.g. logger is offline or proxy name invalid ");
	//	label	not set for elementLoggerStatus
	//	unit	not set for elementLoggerStatus
	//	standard_unit	not set for elementLoggerStatus
	//	display_unit	not set for elementLoggerStatus
	//	format	not set for elementLoggerStatus
	//	max_value	not set for elementLoggerStatus
	//	min_value	not set for elementLoggerStatus
	//	max_alarm	not set for elementLoggerStatus
	//	min_alarm	not set for elementLoggerStatus
	//	max_warning	not set for elementLoggerStatus
	//	min_warning	not set for elementLoggerStatus
	//	delta_t	not set for elementLoggerStatus
	//	delta_val	not set for elementLoggerStatus
	elementloggerstatus_prop.set_event_period("3000");
	
	{
		vector<string> labels;
		labels.push_back("UNKNOWN");
		labels.push_back("DISABLED");
		labels.push_back("OK");
		labels.push_back("FAILED");
		elementloggerstatus_prop.set_enum_labels(labels);
	}
	elementloggerstatus->set_default_properties(elementloggerstatus_prop);
	elementloggerstatus->set_polling_period(3000);
	elementloggerstatus->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	elementloggerstatus->set_change_event(true, false);
	att_list.push_back(elementloggerstatus);

	//	Attribute : storageLoggerStatus
	storageLoggerStatusAttrib	*storageloggerstatus = new storageLoggerStatusAttrib();
	Tango::UserDefaultAttrProp	storageloggerstatus_prop;
	storageloggerstatus_prop.set_description("Storage logging target status. Possible values are:\n\nUNKNOWN: Typically set at device startup\nDISABLED: When storage logging target is disabled (see device properties)\nOK: When storage logging target is initialized with success\nFAILED: When storage logging target initialization fails, e.g. logger is offline or proxy name invalid ");
	//	label	not set for storageLoggerStatus
	//	unit	not set for storageLoggerStatus
	//	standard_unit	not set for storageLoggerStatus
	//	display_unit	not set for storageLoggerStatus
	//	format	not set for storageLoggerStatus
	//	max_value	not set for storageLoggerStatus
	//	min_value	not set for storageLoggerStatus
	//	max_alarm	not set for storageLoggerStatus
	//	min_alarm	not set for storageLoggerStatus
	//	max_warning	not set for storageLoggerStatus
	//	min_warning	not set for storageLoggerStatus
	//	delta_t	not set for storageLoggerStatus
	//	delta_val	not set for storageLoggerStatus
	storageloggerstatus_prop.set_event_period("3000");
	
	{
		vector<string> labels;
		labels.push_back("UNKNOWN");
		labels.push_back("DISABLED");
		labels.push_back("OK");
		labels.push_back("FAILED");
		storageloggerstatus_prop.set_enum_labels(labels);
	}
	storageloggerstatus->set_default_properties(storageloggerstatus_prop);
	storageloggerstatus->set_polling_period(3000);
	storageloggerstatus->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	storageloggerstatus->set_change_event(true, false);
	att_list.push_back(storageloggerstatus);

	//	Attribute : eventRate
	eventRateAttrib	*eventrate = new eventRateAttrib();
	Tango::UserDefaultAttrProp	eventrate_prop;
	eventrate_prop.set_description("Rate in Hz of events received from the device.");
	eventrate_prop.set_label("eventRate");
	eventrate_prop.set_unit("Hz");
	eventrate_prop.set_standard_unit("Hz");
	eventrate_prop.set_display_unit("Hz");
	//	format	not set for eventRate
	//	max_value	not set for eventRate
	//	min_value	not set for eventRate
	//	max_alarm	not set for eventRate
	//	min_alarm	not set for eventRate
	//	max_warning	not set for eventRate
	//	min_warning	not set for eventRate
	//	delta_t	not set for eventRate
	//	delta_val	not set for eventRate
	eventrate_prop.set_event_period("10000");
	
	eventrate->set_default_properties(eventrate_prop);
	eventrate->set_polling_period(10000);
	eventrate->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	eventrate->set_change_event(true, false);
	att_list.push_back(eventrate);

	//	Attribute : exceptionRate
	exceptionRateAttrib	*exceptionrate = new exceptionRateAttrib();
	Tango::UserDefaultAttrProp	exceptionrate_prop;
	exceptionrate_prop.set_description("Rate of internal exceptions thrown in the device");
	exceptionrate_prop.set_label("exceptionRate");
	exceptionrate_prop.set_unit("Hz");
	exceptionrate_prop.set_standard_unit("Hz");
	exceptionrate_prop.set_display_unit("Hz");
	//	format	not set for exceptionRate
	//	max_value	not set for exceptionRate
	//	min_value	not set for exceptionRate
	//	max_alarm	not set for exceptionRate
	//	min_alarm	not set for exceptionRate
	//	max_warning	not set for exceptionRate
	//	min_warning	not set for exceptionRate
	//	delta_t	not set for exceptionRate
	//	delta_val	not set for exceptionRate
	exceptionrate_prop.set_event_period("10000");
	
	exceptionrate->set_default_properties(exceptionrate_prop);
	exceptionrate->set_polling_period(10000);
	exceptionrate->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	exceptionrate->set_change_event(true, false);
	att_list.push_back(exceptionrate);

	//	Attribute : fwdAttrInitStatus
	fwdAttrInitStatusAttrib	*fwdattrinitstatus = new fwdAttrInitStatusAttrib();
	Tango::UserDefaultAttrProp	fwdattrinitstatus_prop;
	fwdattrinitstatus_prop.set_description("Initialization status of fwd attributes in device. \n\nUNKNOWN: typically at startup\nOK: All fwd attributes initialized or no fwd attributes present in device\nFAILED: One/more fwd attributes not initialized yet (e.g. root device down)");
	//	label	not set for fwdAttrInitStatus
	//	unit	not set for fwdAttrInitStatus
	//	standard_unit	not set for fwdAttrInitStatus
	//	display_unit	not set for fwdAttrInitStatus
	//	format	not set for fwdAttrInitStatus
	//	max_value	not set for fwdAttrInitStatus
	//	min_value	not set for fwdAttrInitStatus
	//	max_alarm	not set for fwdAttrInitStatus
	//	min_alarm	not set for fwdAttrInitStatus
	//	max_warning	not set for fwdAttrInitStatus
	//	min_warning	not set for fwdAttrInitStatus
	//	delta_t	not set for fwdAttrInitStatus
	//	delta_val	not set for fwdAttrInitStatus
	fwdattrinitstatus_prop.set_event_period("10000");
	
	{
		vector<string> labels;
		labels.push_back("UNKNOWN");
		labels.push_back("OK");
		labels.push_back("FAILED");
		fwdattrinitstatus_prop.set_enum_labels(labels);
	}
	fwdattrinitstatus->set_default_properties(fwdattrinitstatus_prop);
	fwdattrinitstatus->set_polling_period(10000);
	fwdattrinitstatus->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	fwdattrinitstatus->set_change_event(true, false);
	att_list.push_back(fwdattrinitstatus);

	//	Attribute : centralLoggerEnabled
	centralLoggerEnabledAttrib	*centralloggerenabled = new centralLoggerEnabledAttrib();
	Tango::UserDefaultAttrProp	centralloggerenabled_prop;
	centralloggerenabled_prop.set_description("Enable/disable the central logger in device.\nNB: Attribute is not persisted after device restart.");
	//	label	not set for centralLoggerEnabled
	//	unit	not set for centralLoggerEnabled
	//	standard_unit	not set for centralLoggerEnabled
	//	display_unit	not set for centralLoggerEnabled
	//	format	not set for centralLoggerEnabled
	//	max_value	not set for centralLoggerEnabled
	//	min_value	not set for centralLoggerEnabled
	//	max_alarm	not set for centralLoggerEnabled
	//	min_alarm	not set for centralLoggerEnabled
	//	max_warning	not set for centralLoggerEnabled
	//	min_warning	not set for centralLoggerEnabled
	//	delta_t	not set for centralLoggerEnabled
	//	delta_val	not set for centralLoggerEnabled
	centralloggerenabled_prop.set_event_period("10000");
	
	centralloggerenabled->set_default_properties(centralloggerenabled_prop);
	centralloggerenabled->set_polling_period(10000);
	centralloggerenabled->set_disp_level(Tango::OPERATOR);
	centralloggerenabled->set_memorized();
	centralloggerenabled->set_memorized_init(false);
	centralloggerenabled->set_change_event(true, false);
	att_list.push_back(centralloggerenabled);

	//	Attribute : elementLoggerEnabled
	elementLoggerEnabledAttrib	*elementloggerenabled = new elementLoggerEnabledAttrib();
	Tango::UserDefaultAttrProp	elementloggerenabled_prop;
	elementloggerenabled_prop.set_description("Enable/disable the central logger in device.\nNB: Attribute is not persisted after device restart.");
	//	label	not set for elementLoggerEnabled
	//	unit	not set for elementLoggerEnabled
	//	standard_unit	not set for elementLoggerEnabled
	//	display_unit	not set for elementLoggerEnabled
	//	format	not set for elementLoggerEnabled
	//	max_value	not set for elementLoggerEnabled
	//	min_value	not set for elementLoggerEnabled
	//	max_alarm	not set for elementLoggerEnabled
	//	min_alarm	not set for elementLoggerEnabled
	//	max_warning	not set for elementLoggerEnabled
	//	min_warning	not set for elementLoggerEnabled
	//	delta_t	not set for elementLoggerEnabled
	//	delta_val	not set for elementLoggerEnabled
	elementloggerenabled_prop.set_event_period("10000");
	
	elementloggerenabled->set_default_properties(elementloggerenabled_prop);
	elementloggerenabled->set_polling_period(10000);
	elementloggerenabled->set_disp_level(Tango::OPERATOR);
	elementloggerenabled->set_memorized();
	elementloggerenabled->set_memorized_init(false);
	elementloggerenabled->set_change_event(true, false);
	att_list.push_back(elementloggerenabled);

	//	Attribute : storageLoggerEnabled
	storageLoggerEnabledAttrib	*storageloggerenabled = new storageLoggerEnabledAttrib();
	Tango::UserDefaultAttrProp	storageloggerenabled_prop;
	storageloggerenabled_prop.set_description("Enable/disable the storage logger in device.\nNB: Attribute is not persisted after device restart.");
	//	label	not set for storageLoggerEnabled
	//	unit	not set for storageLoggerEnabled
	//	standard_unit	not set for storageLoggerEnabled
	//	display_unit	not set for storageLoggerEnabled
	//	format	not set for storageLoggerEnabled
	//	max_value	not set for storageLoggerEnabled
	//	min_value	not set for storageLoggerEnabled
	//	max_alarm	not set for storageLoggerEnabled
	//	min_alarm	not set for storageLoggerEnabled
	//	max_warning	not set for storageLoggerEnabled
	//	min_warning	not set for storageLoggerEnabled
	//	delta_t	not set for storageLoggerEnabled
	//	delta_val	not set for storageLoggerEnabled
	storageloggerenabled_prop.set_event_period("10000");
	
	storageloggerenabled->set_default_properties(storageloggerenabled_prop);
	storageloggerenabled->set_polling_period(10000);
	storageloggerenabled->set_disp_level(Tango::OPERATOR);
	storageloggerenabled->set_memorized();
	storageloggerenabled->set_memorized_init(false);
	storageloggerenabled->set_change_event(true, false);
	att_list.push_back(storageloggerenabled);

	//	Attribute : loggingTargetCentral
	loggingTargetCentralAttrib	*loggingtargetcentral = new loggingTargetCentralAttrib();
	Tango::UserDefaultAttrProp	loggingtargetcentral_prop;
	loggingtargetcentral_prop.set_description("Current Central logging target");
	//	label	not set for loggingTargetCentral
	//	unit	not set for loggingTargetCentral
	//	standard_unit	not set for loggingTargetCentral
	//	display_unit	not set for loggingTargetCentral
	//	format	not set for loggingTargetCentral
	//	max_value	not set for loggingTargetCentral
	//	min_value	not set for loggingTargetCentral
	//	max_alarm	not set for loggingTargetCentral
	//	min_alarm	not set for loggingTargetCentral
	//	max_warning	not set for loggingTargetCentral
	//	min_warning	not set for loggingTargetCentral
	//	delta_t	not set for loggingTargetCentral
	//	delta_val	not set for loggingTargetCentral
	
	loggingtargetcentral->set_default_properties(loggingtargetcentral_prop);
	//	Not Polled
	loggingtargetcentral->set_disp_level(Tango::OPERATOR);
	loggingtargetcentral->set_memorized();
	loggingtargetcentral->set_memorized_init(false);
	att_list.push_back(loggingtargetcentral);

	//	Attribute : loggingTargetElement
	loggingTargetElementAttrib	*loggingtargetelement = new loggingTargetElementAttrib();
	Tango::UserDefaultAttrProp	loggingtargetelement_prop;
	loggingtargetelement_prop.set_description("Current Element logging target");
	//	label	not set for loggingTargetElement
	//	unit	not set for loggingTargetElement
	//	standard_unit	not set for loggingTargetElement
	//	display_unit	not set for loggingTargetElement
	//	format	not set for loggingTargetElement
	//	max_value	not set for loggingTargetElement
	//	min_value	not set for loggingTargetElement
	//	max_alarm	not set for loggingTargetElement
	//	min_alarm	not set for loggingTargetElement
	//	max_warning	not set for loggingTargetElement
	//	min_warning	not set for loggingTargetElement
	//	delta_t	not set for loggingTargetElement
	//	delta_val	not set for loggingTargetElement
	
	loggingtargetelement->set_default_properties(loggingtargetelement_prop);
	//	Not Polled
	loggingtargetelement->set_disp_level(Tango::OPERATOR);
	loggingtargetelement->set_memorized();
	loggingtargetelement->set_memorized_init(false);
	att_list.push_back(loggingtargetelement);

	//	Attribute : loggingTargetStorage
	loggingTargetStorageAttrib	*loggingtargetstorage = new loggingTargetStorageAttrib();
	Tango::UserDefaultAttrProp	loggingtargetstorage_prop;
	loggingtargetstorage_prop.set_description("Current storage logging target");
	//	label	not set for loggingTargetStorage
	//	unit	not set for loggingTargetStorage
	//	standard_unit	not set for loggingTargetStorage
	//	display_unit	not set for loggingTargetStorage
	//	format	not set for loggingTargetStorage
	//	max_value	not set for loggingTargetStorage
	//	min_value	not set for loggingTargetStorage
	//	max_alarm	not set for loggingTargetStorage
	//	min_alarm	not set for loggingTargetStorage
	//	max_warning	not set for loggingTargetStorage
	//	min_warning	not set for loggingTargetStorage
	//	delta_t	not set for loggingTargetStorage
	//	delta_val	not set for loggingTargetStorage
	
	loggingtargetstorage->set_default_properties(loggingtargetstorage_prop);
	//	Not Polled
	loggingtargetstorage->set_disp_level(Tango::OPERATOR);
	loggingtargetstorage->set_memorized();
	loggingtargetstorage->set_memorized_init(false);
	att_list.push_back(loggingtargetstorage);

	//	Attribute : attrRandomizationEnabled
	attrRandomizationEnabledAttrib	*attrrandomizationenabled = new attrRandomizationEnabledAttrib();
	Tango::UserDefaultAttrProp	attrrandomizationenabled_prop;
	//	description	not set for attrRandomizationEnabled
	//	label	not set for attrRandomizationEnabled
	//	unit	not set for attrRandomizationEnabled
	//	standard_unit	not set for attrRandomizationEnabled
	//	display_unit	not set for attrRandomizationEnabled
	//	format	not set for attrRandomizationEnabled
	//	max_value	not set for attrRandomizationEnabled
	//	min_value	not set for attrRandomizationEnabled
	//	max_alarm	not set for attrRandomizationEnabled
	//	min_alarm	not set for attrRandomizationEnabled
	//	max_warning	not set for attrRandomizationEnabled
	//	min_warning	not set for attrRandomizationEnabled
	//	delta_t	not set for attrRandomizationEnabled
	//	delta_val	not set for attrRandomizationEnabled
	
	attrrandomizationenabled->set_default_properties(attrrandomizationenabled_prop);
	//	Not Polled
	attrrandomizationenabled->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(attrrandomizationenabled);

	//	Attribute : attrRandomizationPeriod
	attrRandomizationPeriodAttrib	*attrrandomizationperiod = new attrRandomizationPeriodAttrib();
	Tango::UserDefaultAttrProp	attrrandomizationperiod_prop;
	//	description	not set for attrRandomizationPeriod
	//	label	not set for attrRandomizationPeriod
	//	unit	not set for attrRandomizationPeriod
	//	standard_unit	not set for attrRandomizationPeriod
	//	display_unit	not set for attrRandomizationPeriod
	//	format	not set for attrRandomizationPeriod
	//	max_value	not set for attrRandomizationPeriod
	//	min_value	not set for attrRandomizationPeriod
	//	max_alarm	not set for attrRandomizationPeriod
	//	min_alarm	not set for attrRandomizationPeriod
	//	max_warning	not set for attrRandomizationPeriod
	//	min_warning	not set for attrRandomizationPeriod
	//	delta_t	not set for attrRandomizationPeriod
	//	delta_val	not set for attrRandomizationPeriod
	
	attrrandomizationperiod->set_default_properties(attrrandomizationperiod_prop);
	//	Not Polled
	attrrandomizationperiod->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(attrrandomizationperiod);


	//	Create a list of static attributes
	create_static_attribute_list(get_class_attr()->get_attr_list());
	/*----- PROTECTED REGION ID(LMCDeviceClass::attribute_factory_after) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	LMCDeviceClass::attribute_factory_after
}
//--------------------------------------------------------
/**
 *	Method      : LMCDeviceClass::pipe_factory()
 *	Description : Create the pipe object(s)
 *                and store them in the pipe list
 */
//--------------------------------------------------------
void LMCDeviceClass::pipe_factory()
{
	/*----- PROTECTED REGION ID(LMCDeviceClass::pipe_factory_before) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	LMCDeviceClass::pipe_factory_before
	/*----- PROTECTED REGION ID(LMCDeviceClass::pipe_factory_after) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	LMCDeviceClass::pipe_factory_after
}
//--------------------------------------------------------
/**
 *	Method      : LMCDeviceClass::command_factory()
 *	Description : Create the command object(s)
 *                and store them in the command list
 */
//--------------------------------------------------------
void LMCDeviceClass::command_factory()
{
	/*----- PROTECTED REGION ID(LMCDeviceClass::command_factory_before) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	LMCDeviceClass::command_factory_before


	//	Command InitializeLoggers
	InitializeLoggersClass	*pInitializeLoggersCmd =
		new InitializeLoggersClass("InitializeLoggers",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::EXPERT);
	pInitializeLoggersCmd->set_polling_period(10000);
	command_list.push_back(pInitializeLoggersCmd);

	//	Command InitializeFwdAttrs
	InitializeFwdAttrsClass	*pInitializeFwdAttrsCmd =
		new InitializeFwdAttrsClass("InitializeFwdAttrs",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::EXPERT);
	pInitializeFwdAttrsCmd->set_polling_period(5000);
	command_list.push_back(pInitializeFwdAttrsCmd);

	//	Command RandomizeDynAttrs
	RandomizeDynAttrsClass	*pRandomizeDynAttrsCmd =
		new RandomizeDynAttrsClass("RandomizeDynAttrs",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::EXPERT);
	command_list.push_back(pRandomizeDynAttrsCmd);

	//	Command InitializeDevProxies
	InitializeDevProxiesClass	*pInitializeDevProxiesCmd =
		new InitializeDevProxiesClass("InitializeDevProxies",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::EXPERT);
	pInitializeDevProxiesCmd->set_polling_period(10000);
	command_list.push_back(pInitializeDevProxiesCmd);

	//	Command GetRegisteredProxies
	GetRegisteredProxiesClass	*pGetRegisteredProxiesCmd =
		new GetRegisteredProxiesClass("GetRegisteredProxies",
			Tango::DEV_VOID, Tango::DEVVAR_STRINGARRAY,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pGetRegisteredProxiesCmd);

	//	Command GetRegisteredEvents
	GetRegisteredEventsClass	*pGetRegisteredEventsCmd =
		new GetRegisteredEventsClass("GetRegisteredEvents",
			Tango::DEV_VOID, Tango::DEVVAR_STRINGARRAY,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pGetRegisteredEventsCmd);

	//	Command GetRegisteredFormulas
	GetRegisteredFormulasClass	*pGetRegisteredFormulasCmd =
		new GetRegisteredFormulasClass("GetRegisteredFormulas",
			Tango::DEV_VOID, Tango::DEVVAR_STRINGARRAY,
			"",
			"The list of attr formulas currently registered in device \nand expressed in json format.",
			Tango::OPERATOR);
	command_list.push_back(pGetRegisteredFormulasCmd);

	//	Command GetInitializedFormulas
	GetInitializedFormulasClass	*pGetInitializedFormulasCmd =
		new GetInitializedFormulasClass("GetInitializedFormulas",
			Tango::DEV_VOID, Tango::DEVVAR_STRINGARRAY,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pGetInitializedFormulasCmd);

	//	Command GetNRunningTasks
	GetNRunningTasksClass	*pGetNRunningTasksCmd =
		new GetNRunningTasksClass("GetNRunningTasks",
			Tango::DEV_VOID, Tango::DEV_LONG,
			"",
			"The number of running tasks",
			Tango::OPERATOR);
	command_list.push_back(pGetNRunningTasksCmd);

	//	Command GetNQueuedTasks
	GetNQueuedTasksClass	*pGetNQueuedTasksCmd =
		new GetNQueuedTasksClass("GetNQueuedTasks",
			Tango::DEV_VOID, Tango::DEV_LONG,
			"",
			"The number of queued tasks",
			Tango::OPERATOR);
	command_list.push_back(pGetNQueuedTasksCmd);

	//	Command GetNIdleTasks
	GetNIdleTasksClass	*pGetNIdleTasksCmd =
		new GetNIdleTasksClass("GetNIdleTasks",
			Tango::DEV_VOID, Tango::DEV_LONG,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pGetNIdleTasksCmd);

	//	Command GetNTasks
	GetNTasksClass	*pGetNTasksCmd =
		new GetNTasksClass("GetNTasks",
			Tango::DEV_VOID, Tango::DEV_LONG,
			"",
			"Number of tasks",
			Tango::OPERATOR);
	command_list.push_back(pGetNTasksCmd);

	//	Command GetNFailedTasks
	GetNFailedTasksClass	*pGetNFailedTasksCmd =
		new GetNFailedTasksClass("GetNFailedTasks",
			Tango::DEV_VOID, Tango::DEV_LONG,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pGetNFailedTasksCmd);

	//	Command GetNTotFailedTasks
	GetNTotFailedTasksClass	*pGetNTotFailedTasksCmd =
		new GetNTotFailedTasksClass("GetNTotFailedTasks",
			Tango::DEV_VOID, Tango::DEV_LONG,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pGetNTotFailedTasksCmd);

	//	Command IsTaskQuotaReached
	IsTaskQuotaReachedClass	*pIsTaskQuotaReachedCmd =
		new IsTaskQuotaReachedClass("IsTaskQuotaReached",
			Tango::DEV_VOID, Tango::DEV_BOOLEAN,
			"",
			"The task quota flag",
			Tango::OPERATOR);
	command_list.push_back(pIsTaskQuotaReachedCmd);

	//	Command FlushTaskQueue
	FlushTaskQueueClass	*pFlushTaskQueueCmd =
		new FlushTaskQueueClass("FlushTaskQueue",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pFlushTaskQueueCmd);

	//	Command GetQueuedTaskInfo
	GetQueuedTaskInfoClass	*pGetQueuedTaskInfoCmd =
		new GetQueuedTaskInfoClass("GetQueuedTaskInfo",
			Tango::DEV_VOID, Tango::DEVVAR_STRINGARRAY,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pGetQueuedTaskInfoCmd);

	//	Command GetTaskInfo
	GetTaskInfoClass	*pGetTaskInfoCmd =
		new GetTaskInfoClass("GetTaskInfo",
			Tango::DEV_VOID, Tango::DEVVAR_STRINGARRAY,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pGetTaskInfoCmd);

	//	Command ClearTasks
	ClearTasksClass	*pClearTasksCmd =
		new ClearTasksClass("ClearTasks",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	pClearTasksCmd->set_polling_period(10000);
	command_list.push_back(pClearTasksCmd);

	//	Command UpdateFormulaAttrs
	UpdateFormulaAttrsClass	*pUpdateFormulaAttrsCmd =
		new UpdateFormulaAttrsClass("UpdateFormulaAttrs",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::EXPERT);
	pUpdateFormulaAttrsCmd->set_polling_period(5000);
	command_list.push_back(pUpdateFormulaAttrsCmd);

	//	Command UpdateStatusAttrs
	UpdateStatusAttrsClass	*pUpdateStatusAttrsCmd =
		new UpdateStatusAttrsClass("UpdateStatusAttrs",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::EXPERT);
	pUpdateStatusAttrsCmd->set_polling_period(3000);
	command_list.push_back(pUpdateStatusAttrsCmd);

	//	Command MonitorProxies
	MonitorProxiesClass	*pMonitorProxiesCmd =
		new MonitorProxiesClass("MonitorProxies",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pMonitorProxiesCmd);

	//	Command RevokeTask
	RevokeTaskClass	*pRevokeTaskCmd =
		new RevokeTaskClass("RevokeTask",
			Tango::DEV_STRING, Tango::DEV_VOID,
			"Name of task to be canceled",
			"",
			Tango::EXPERT);
	command_list.push_back(pRevokeTaskCmd);

	//	Command RevokeTaskSequence
	RevokeTaskSequenceClass	*pRevokeTaskSequenceCmd =
		new RevokeTaskSequenceClass("RevokeTaskSequence",
			Tango::DEV_STRING, Tango::DEV_VOID,
			"Name of task sequence to be revoked.",
			"",
			Tango::EXPERT);
	command_list.push_back(pRevokeTaskSequenceCmd);

	//	Command GetFormulaData
	GetFormulaDataClass	*pGetFormulaDataCmd =
		new GetFormulaDataClass("GetFormulaData",
			Tango::DEV_STRING, Tango::DEV_STRING,
			"Formula attr name",
			"Formula data encoded in json string",
			Tango::OPERATOR);
	command_list.push_back(pGetFormulaDataCmd);

	//	Command SendTestLogMsg
	SendTestLogMsgClass	*pSendTestLogMsgCmd =
		new SendTestLogMsgClass("SendTestLogMsg",
			Tango::DEVVAR_LONGSTRINGARRAY, Tango::DEV_VOID,
			"Long arg\n[0]: Level of log message\n(0=OFF, 1=FATAL, 2=ERROR, 3=WARNING, 4=INFO, 5=DEBUG)\n\nString arg\n[0]: log message",
			"",
			Tango::EXPERT);
	command_list.push_back(pSendTestLogMsgCmd);

	//	Command ClearTaskHistory
	ClearTaskHistoryClass	*pClearTaskHistoryCmd =
		new ClearTaskHistoryClass("ClearTaskHistory",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pClearTaskHistoryCmd);

	//	Command GetLogAppenderInfo
	GetLogAppenderInfoClass	*pGetLogAppenderInfoCmd =
		new GetLogAppenderInfoClass("GetLogAppenderInfo",
			Tango::DEV_VOID, Tango::DEVVAR_LONGSTRINGARRAY,
			"",
			"",
			Tango::EXPERT);
	command_list.push_back(pGetLogAppenderInfoCmd);

	/*----- PROTECTED REGION ID(LMCDeviceClass::command_factory_after) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	LMCDeviceClass::command_factory_after
}

//===================================================================
//	Dynamic attributes related methods
//===================================================================

//--------------------------------------------------------
/**
 * method : 		LMCDeviceClass::create_static_attribute_list
 * description : 	Create the a list of static attributes
 *
 * @param	att_list	the ceated attribute list
 */
//--------------------------------------------------------
void LMCDeviceClass::create_static_attribute_list(vector<Tango::Attr *> &att_list)
{
	for (unsigned long i=0 ; i<att_list.size() ; i++)
	{
		string att_name(att_list[i]->get_name());
		transform(att_name.begin(), att_name.end(), att_name.begin(), ::tolower);
		defaultAttList.push_back(att_name);
	}

	cout2 << defaultAttList.size() << " attributes in default list" << endl;

	/*----- PROTECTED REGION ID(LMCDeviceClass::create_static_att_list) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	LMCDeviceClass::create_static_att_list
}


//--------------------------------------------------------
/**
 * method : 		LMCDeviceClass::erase_dynamic_attributes
 * description : 	delete the dynamic attributes if any.
 *
 * @param	devlist_ptr	the device list pointer
 * @param	list of all attributes
 */
//--------------------------------------------------------
void LMCDeviceClass::erase_dynamic_attributes(const Tango::DevVarStringArray *devlist_ptr, vector<Tango::Attr *> &att_list)
{
	Tango::Util *tg = Tango::Util::instance();

	for (unsigned long i=0 ; i<devlist_ptr->length() ; i++)
	{
		Tango::DeviceImpl *dev_impl = tg->get_device_by_name(((string)(*devlist_ptr)[i]).c_str());
		LMCDevice *dev = static_cast<LMCDevice *> (dev_impl);

		vector<Tango::Attribute *> &dev_att_list = dev->get_device_attr()->get_attribute_list();
		vector<Tango::Attribute *>::iterator ite_att;
		for (ite_att=dev_att_list.begin() ; ite_att != dev_att_list.end() ; ++ite_att)
		{
			string att_name((*ite_att)->get_name_lower());
			if ((att_name == "state") || (att_name == "status"))
				continue;
			vector<string>::iterator ite_str = find(defaultAttList.begin(), defaultAttList.end(), att_name);
			if (ite_str == defaultAttList.end())
			{
				cout2 << att_name << " is a UNWANTED dynamic attribute for device " << (*devlist_ptr)[i] << endl;
				Tango::Attribute &att = dev->get_device_attr()->get_attr_by_name(att_name.c_str());
				dev->remove_attribute(att_list[att.get_attr_idx()], true, false);
				--ite_att;
			}
		}
	}
	/*----- PROTECTED REGION ID(LMCDeviceClass::erase_dynamic_attributes) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	LMCDeviceClass::erase_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Method      : LMCDeviceClass::get_attr_by_name()
 *	Description : returns Tango::Attr * object found by name
 */
//--------------------------------------------------------
Tango::Attr *LMCDeviceClass::get_attr_object_by_name(vector<Tango::Attr *> &att_list, string attname)
{
	vector<Tango::Attr *>::iterator it;
	for (it=att_list.begin() ; it<att_list.end() ; ++it)
		if ((*it)->get_name()==attname)
			return (*it);
	//	Attr does not exist
	return NULL;
}


/*----- PROTECTED REGION ID(LMCDeviceClass::Additional Methods) ENABLED START -----*/

/*----- PROTECTED REGION END -----*/	//	LMCDeviceClass::Additional Methods
} //	namespace
