/*----- PROTECTED REGION ID(DSEmulator.cpp) ENABLED START -----*/
//=============================================================================
//
// file :        DSEmulator.cpp
//
// description : C++ source for the DSEmulator class and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               DSEmulator are implemented in this file.
//
// project :     DSEmulator
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
//
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <DSEmulator.h>
#include <DSEmulatorClass.h>

#include "PointingSchedule.h"
#include "TrackingThread.h"

/*----- PROTECTED REGION END -----*/	//	DSEmulator.cpp

/**
 *  DSEmulator class description:
 *    Emulator of DSManager Tango Device Server
 */

//================================================================
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name            |  Method name
//================================================================
//  State                   |  Inherited (no method)
//  Status                  |  Inherited (no method)
//  InitializeLoggers       |  Inherited (no method)
//  InitializeFwdAttrs      |  Inherited (no method)
//  RandomizeDynAttrs       |  Inherited (no method)
//  InitializeDevProxies    |  Inherited (no method)
//  GetRegisteredProxies    |  Inherited (no method)
//  GetRegisteredEvents     |  Inherited (no method)
//  GetRegisteredFormulas   |  Inherited (no method)
//  GetInitializedFormulas  |  Inherited (no method)
//  GetNRunningTasks        |  Inherited (no method)
//  GetNQueuedTasks         |  Inherited (no method)
//  GetNIdleTasks           |  Inherited (no method)
//  GetNTasks               |  Inherited (no method)
//  GetNFailedTasks         |  Inherited (no method)
//  GetNTotFailedTasks      |  Inherited (no method)
//  IsTaskQuotaReached      |  Inherited (no method)
//  FlushTaskQueue          |  Inherited (no method)
//  GetQueuedTaskInfo       |  Inherited (no method)
//  GetTaskInfo             |  Inherited (no method)
//  ClearTasks              |  Inherited (no method)
//  UpdateFormulaAttrs      |  Inherited (no method)
//  UpdateStatusAttrs       |  Inherited (no method)
//  MonitorProxies          |  Inherited (no method)
//  RevokeTask              |  Inherited (no method)
//  GetFormulaData          |  Inherited (no method)
//  SendTestLogMsg          |  Inherited (no method)
//  SetStandbyLPMode        |  set_standby_lpmode
//  SetStandbyFPMode        |  set_standby_fpmode
//  SetPointMode            |  set_point_mode
//  Stow                    |  stow
//  SetMaintenanceMode      |  set_maintenance_mode
//  SetIndexPosition        |  set_index_position
//  SimulatePowerCut        |  simulate_power_cut
//  SimulatePowerRestore    |  simulate_power_restore
//  SimulateESTOP           |  simulate_estop
//  GetTrackProgram         |  get_track_program
//  FlushTrackProgram       |  flush_track_program
//  PauseTracking           |  pause_tracking
//  ResumeTracking          |  resume_tracking
//  ResetProgressAttrs      |  reset_progress_attrs
//  RevokeTaskSequence      |  Inherited (no method)
//  ResetPowerCutAttrs      |  reset_power_cut_attrs
//================================================================

//================================================================
//  Attributes managed are:
//================================================================
//  loggingLevelCentral       |  Tango::DevLong	Scalar
//  loggingLevelElement       |  Tango::DevLong	Scalar
//  loggingLevelStorage       |  Tango::DevLong	Scalar
//  loggingLevelConsole       |  Tango::DevLong	Scalar
//  buildState                |  Tango::DevString	Scalar
//  centralLoggerStatus       |  Tango::DevEnum	Scalar
//  elementLoggerStatus       |  Tango::DevEnum	Scalar
//  storageLoggerStatus       |  Tango::DevEnum	Scalar
//  eventRate                 |  Tango::DevFloat	Scalar
//  exceptionRate             |  Tango::DevFloat	Scalar
//  fwdAttrInitStatus         |  Tango::DevEnum	Scalar
//  centralLoggerEnabled      |  Tango::DevBoolean	Scalar
//  elementLoggerEnabled      |  Tango::DevBoolean	Scalar
//  storageLoggerEnabled      |  Tango::DevBoolean	Scalar
//  loggingTargetCentral      |  Tango::DevString	Scalar
//  loggingTargetElement      |  Tango::DevString	Scalar
//  loggingTargetStorage      |  Tango::DevString	Scalar
//  powerCut                  |  Tango::DevBoolean	Scalar
//  powerRestored             |  Tango::DevBoolean	Scalar
//  attrRandomizationEnabled  |  Tango::DevBoolean	Scalar
//  attrRandomizationPeriod   |  Tango::DevULong	Scalar
//  stowProgress              |  Tango::DevString	Spectrum  ( max = 2)
//  indexingProgress          |  Tango::DevString	Spectrum  ( max = 2)
//  achievedPointing          |  Tango::DevDouble	Spectrum  ( max = 3)
//  desiredPointing           |  Tango::DevDouble	Spectrum  ( max = 7)
//  setStandbyLPModeProgress  |  Tango::DevString	Spectrum  ( max = 2)
//  setStandbyFPModeProgress  |  Tango::DevString	Spectrum  ( max = 2)
//  setPointModeProgress      |  Tango::DevString	Spectrum  ( max = 2)
//================================================================

namespace DSEmulator_ns
{
/*----- PROTECTED REGION ID(DSEmulator::namespace_starting) ENABLED START -----*/

//	static initializations

/*----- PROTECTED REGION END -----*/	//	DSEmulator::namespace_starting

//--------------------------------------------------------
/**
 *	Method      : DSEmulator::DSEmulator()
 *	Description : Constructors for a Tango device
 *                implementing the classDSEmulator
 */
//--------------------------------------------------------
DSEmulator::DSEmulator(Tango::DeviceClass *cl, string &s)
 : LMCDevice(cl, s.c_str())
{
	/*----- PROTECTED REGION ID(DSEmulator::constructor_1) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	DSEmulator::constructor_1
}
//--------------------------------------------------------
DSEmulator::DSEmulator(Tango::DeviceClass *cl, const char *s)
 : LMCDevice(cl, s)
{
	/*----- PROTECTED REGION ID(DSEmulator::constructor_2) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	DSEmulator::constructor_2
}
//--------------------------------------------------------
DSEmulator::DSEmulator(Tango::DeviceClass *cl, const char *s, const char *d)
 : LMCDevice(cl, s, d)
{
	/*----- PROTECTED REGION ID(DSEmulator::constructor_3) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	DSEmulator::constructor_3
}

//--------------------------------------------------------
/**
 *	Method      : DSEmulator::delete_device()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void DSEmulator::delete_device()
{
	DEBUG_STREAM << "DSEmulator::delete_device() " << device_name << endl;
	/*----- PROTECTED REGION ID(DSEmulator::delete_device) ENABLED START -----*/
	
	//	Delete device allocated objects
	//## Delete allocated memory
	for(int i=0;i<2;i++){
		CORBA::string_free(*(attr_stowProgress_read+i));
		CORBA::string_free(*(attr_indexingProgress_read+i));
		CORBA::string_free(*(attr_setStandbyLPModeProgress_read+i));
		CORBA::string_free(*(attr_setStandbyFPModeProgress_read+i));	
		CORBA::string_free(*(attr_setPointModeProgress_read+i));
	}

	//## Clear tracking thread
	if(m_trackingThread){
		_DEBUG_LOG("Shutting down tracking thread...");	
		m_trackingThread->Stop();
		_DEBUG_LOG("Deleting tracking thread...");	
		delete m_trackingThread;
		m_trackingThread = 0;
		_DEBUG_LOG("Tracking thread cleared!");	
	}

	//## Delete pnt schedule
	if(m_pntSchedule){
		_DEBUG_LOG("Deleting pnt schedule...");
		delete m_pntSchedule;
		m_pntSchedule= 0;
	}

	//## Clear task: notify wait cond & exit
	if(ClearTask()<0){
		_ERROR_LOG("Failed to clearup task thread");
	}


	/*----- PROTECTED REGION END -----*/	//	DSEmulator::delete_device
	delete[] attr_powerCut_read;
	delete[] attr_powerRestored_read;
	delete[] attr_stowProgress_read;
	delete[] attr_indexingProgress_read;
	delete[] attr_achievedPointing_read;
	delete[] attr_desiredPointing_read;
	delete[] attr_setStandbyLPModeProgress_read;
	delete[] attr_setStandbyFPModeProgress_read;
	delete[] attr_setPointModeProgress_read;

	if (Tango::Util::instance()->is_svr_shutting_down()==false  &&
		Tango::Util::instance()->is_device_restarting(device_name)==false &&
		Tango::Util::instance()->is_svr_starting()==false)
	{
		//	If not shutting down call delete device for inherited object
		LMCDevice_ns::LMCDevice::delete_device();
	}
}

//--------------------------------------------------------
/**
 *	Method      : DSEmulator::init_device()
 *	Description : will be called at device initialization.
 */
//--------------------------------------------------------
void DSEmulator::init_device()
{
	DEBUG_STREAM << "DSEmulator::init_device() create device " << device_name << endl;
	/*----- PROTECTED REGION ID(DSEmulator::init_device_before) ENABLED START -----*/
	
	//	Initialization before get_device_property() call
	
	/*----- PROTECTED REGION END -----*/	//	DSEmulator::init_device_before
	
	if (Tango::Util::instance()->is_svr_starting() == false  &&
		Tango::Util::instance()->is_device_restarting(device_name)==false)
	{
		//	If not starting up call init device for inherited object
		LMCDevice_ns::LMCDevice::init_device();
	}

	//	Get the device properties from database
	get_device_property();
	
	attr_powerCut_read = new Tango::DevBoolean[1];
	attr_powerRestored_read = new Tango::DevBoolean[1];
	attr_stowProgress_read = new Tango::DevString[2];
	attr_indexingProgress_read = new Tango::DevString[2];
	attr_achievedPointing_read = new Tango::DevDouble[3];
	attr_desiredPointing_read = new Tango::DevDouble[7];
	attr_setStandbyLPModeProgress_read = new Tango::DevString[2];
	attr_setStandbyFPModeProgress_read = new Tango::DevString[2];
	attr_setPointModeProgress_read = new Tango::DevString[2];
	//	No longer if mandatory property not set. 
	if (mandatoryNotDefined)
		return;

	/*----- PROTECTED REGION ID(DSEmulator::init_device) ENABLED START -----*/
	
	//	Initialize device
	//## Set init device state
	set_state(Tango::INIT);
	set_status("Device " + device_name + " is initializing");
	
	//## Initialize attributes
	SetStowStatus("INIT","No stowing task information present",false);
	SetIndexingStatus("INIT","No indexing task information present",false);
	SetStandbyLPStatus("INIT","No SetSTandbyLPMode task information present",false);
	SetStandbyFPStatus("INIT","No SetStandbyFPMode task information present",false);
	SetPointStatus("INIT","No SetPointMode task information present",false);
	*attr_powerCut_read= false;
	*attr_powerRestored_read= false;
	for(int i=0;i<3;i++) attr_achievedPointing_read[i]= 0;
	for(int i=0;i<7;i++) attr_desiredPointing_read[i]= 0;

	//## Initialize and start device task thread
	if(InitTask()<0){
		_ERROR_LOG("Failed to initialize and start device task!");
	}

	// Initialize and start tracking thread
	_INFO_LOG("Initializing pnt schedule and starting tracking thread...");
	if(InitTrackingThread()<0){
		_ERROR_LOG("Failed to initialize pnt schedule and/or tracking thread!");
	}

	/*----- PROTECTED REGION END -----*/	//	DSEmulator::init_device
}

//--------------------------------------------------------
/**
 *	Method      : DSEmulator::get_device_property()
 *	Description : Read database to initialize property data members.
 */
//--------------------------------------------------------
void DSEmulator::get_device_property()
{
	/*----- PROTECTED REGION ID(DSEmulator::get_device_property_before) ENABLED START -----*/
	
	//	Initialize property data members
	
	/*----- PROTECTED REGION END -----*/	//	DSEmulator::get_device_property_before

	mandatoryNotDefined = false;

	//	Read device properties from database.
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("CentralLoggerEnabledDefault"));
	dev_prop.push_back(Tango::DbDatum("ElementLoggerEnabledDefault"));
	dev_prop.push_back(Tango::DbDatum("StorageLoggerEnabledDefault"));
	dev_prop.push_back(Tango::DbDatum("LoggingTargetCentralDefault"));
	dev_prop.push_back(Tango::DbDatum("LoggingTargetElementDefault"));
	dev_prop.push_back(Tango::DbDatum("LoggingTargetStorageDefault"));
	dev_prop.push_back(Tango::DbDatum("SkaLevel"));
	dev_prop.push_back(Tango::DbDatum("SyslogFacility"));
	dev_prop.push_back(Tango::DbDatum("SyslogHost"));
	dev_prop.push_back(Tango::DbDatum("LoggingLevelCentralDefault"));
	dev_prop.push_back(Tango::DbDatum("LoggingLevelElementDefault"));
	dev_prop.push_back(Tango::DbDatum("LoggingLevelStorageDefault"));
	dev_prop.push_back(Tango::DbDatum("ConfigFile"));
	dev_prop.push_back(Tango::DbDatum("EnableConfigFromFile"));
	dev_prop.push_back(Tango::DbDatum("EnableDynAttrCleanup"));
	dev_prop.push_back(Tango::DbDatum("EnableDynAttrRandomize"));
	dev_prop.push_back(Tango::DbDatum("DynAttrRandomizePeriod"));
	dev_prop.push_back(Tango::DbDatum("ProxyDevices"));
	dev_prop.push_back(Tango::DbDatum("FormulaVarMaxTimeInterval"));
	dev_prop.push_back(Tango::DbDatum("EnableProxyMonitoring"));
	dev_prop.push_back(Tango::DbDatum("ProxyMonitoringPeriod"));
	dev_prop.push_back(Tango::DbDatum("ProxyStatusAttrPollPeriod"));
	dev_prop.push_back(Tango::DbDatum("ProxyStatusAttrPeriodicEventPeriod"));
	dev_prop.push_back(Tango::DbDatum("ProxyStatusAttrArchiveEventPeriod"));
	dev_prop.push_back(Tango::DbDatum("ProxyTimeout"));
	dev_prop.push_back(Tango::DbDatum("EventSubscriptions"));
	dev_prop.push_back(Tango::DbDatum("EventHandlers"));
	dev_prop.push_back(Tango::DbDatum("MaxQueueableTask"));
	dev_prop.push_back(Tango::DbDatum("MaxTrackableTasks"));
	dev_prop.push_back(Tango::DbDatum("TaskHistoryTimeDepth"));
	dev_prop.push_back(Tango::DbDatum("DefaultTaskTimeout"));
	dev_prop.push_back(Tango::DbDatum("TaskSequenceStatusAttrList"));
	dev_prop.push_back(Tango::DbDatum("TaskStatusAttrList"));
	dev_prop.push_back(Tango::DbDatum("EnableEventRateMonitoring"));
	dev_prop.push_back(Tango::DbDatum("EnableLoggerInitPolling"));
	dev_prop.push_back(Tango::DbDatum("LoggerInitPollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableDevProxyInitPolling"));
	dev_prop.push_back(Tango::DbDatum("DevProxyInitPollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableFwdAttrInitPolling"));
	dev_prop.push_back(Tango::DbDatum("FwdAttrInitPollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableFormulaAttrUpdatePolling"));
	dev_prop.push_back(Tango::DbDatum("FormulaAttrUpdatePollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableStatusAttrUpdatePolling"));
	dev_prop.push_back(Tango::DbDatum("StatusAttrUpdatePollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableClearTaskPolling"));
	dev_prop.push_back(Tango::DbDatum("ClearTaskPollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableProxyStatusAttrCreation"));
	dev_prop.push_back(Tango::DbDatum("EnableAutoAdminProxyRegistration"));
	dev_prop.push_back(Tango::DbDatum("ProcessEventsInQueueThread"));
	dev_prop.push_back(Tango::DbDatum("StartupTime"));
	dev_prop.push_back(Tango::DbDatum("EnableStartupFailure"));
	dev_prop.push_back(Tango::DbDatum("StartupFailureProbability"));
	dev_prop.push_back(Tango::DbDatum("StowTime"));
	dev_prop.push_back(Tango::DbDatum("EnableStowFailure"));
	dev_prop.push_back(Tango::DbDatum("StowFailureProbability"));
	dev_prop.push_back(Tango::DbDatum("IndexingTime"));
	dev_prop.push_back(Tango::DbDatum("EnableIndexingFailure"));
	dev_prop.push_back(Tango::DbDatum("IndexingFailureProbability"));
	dev_prop.push_back(Tango::DbDatum("PointingModelParamsDefault"));
	dev_prop.push_back(Tango::DbDatum("IndexerPositionDefault"));
	dev_prop.push_back(Tango::DbDatum("SmearPointingCoords"));
	dev_prop.push_back(Tango::DbDatum("PointingResolution"));
	dev_prop.push_back(Tango::DbDatum("MaxPointingQueueSize"));
	dev_prop.push_back(Tango::DbDatum("UseUTCTime"));
	dev_prop.push_back(Tango::DbDatum("TrackProgramMaxSize"));
	dev_prop.push_back(Tango::DbDatum("TrackProgramTimeStep"));
	dev_prop.push_back(Tango::DbDatum("MinAzimuth"));
	dev_prop.push_back(Tango::DbDatum("MaxAzimuth"));
	dev_prop.push_back(Tango::DbDatum("MinElevation"));
	dev_prop.push_back(Tango::DbDatum("MaxElevation"));
	dev_prop.push_back(Tango::DbDatum("SlewRate"));
	dev_prop.push_back(Tango::DbDatum("SlewTimeStep"));
	dev_prop.push_back(Tango::DbDatum("StowAzimuthPos"));
	dev_prop.push_back(Tango::DbDatum("StowElevationPos"));
	dev_prop.push_back(Tango::DbDatum("SetModeTime"));
	dev_prop.push_back(Tango::DbDatum("EnableSetModeFailure"));
	dev_prop.push_back(Tango::DbDatum("SetModeFailureProbability"));
	dev_prop.push_back(Tango::DbDatum("ShutdownTime"));

	//	is there at least one property to be read ?
	if (dev_prop.size()>0)
	{
		//	Call database and extract values
		if (Tango::Util::instance()->_UseDb==true)
			get_db_device()->get_property(dev_prop);
	
		//	get instance on DSEmulatorClass to get class property
		Tango::DbDatum	def_prop, cl_prop;
		DSEmulatorClass	*ds_class =
			(static_cast<DSEmulatorClass *>(get_device_class()));
		int	i = -1;

		//	Try to initialize CentralLoggerEnabledDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  centralLoggerEnabledDefault;
		else {
			//	Try to initialize CentralLoggerEnabledDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  centralLoggerEnabledDefault;
		}
		//	And try to extract CentralLoggerEnabledDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  centralLoggerEnabledDefault;

		//	Try to initialize ElementLoggerEnabledDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  elementLoggerEnabledDefault;
		else {
			//	Try to initialize ElementLoggerEnabledDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  elementLoggerEnabledDefault;
		}
		//	And try to extract ElementLoggerEnabledDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  elementLoggerEnabledDefault;

		//	Try to initialize StorageLoggerEnabledDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  storageLoggerEnabledDefault;
		else {
			//	Try to initialize StorageLoggerEnabledDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  storageLoggerEnabledDefault;
		}
		//	And try to extract StorageLoggerEnabledDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  storageLoggerEnabledDefault;

		//	Try to initialize LoggingTargetCentralDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingTargetCentralDefault;
		else {
			//	Try to initialize LoggingTargetCentralDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingTargetCentralDefault;
		}
		//	And try to extract LoggingTargetCentralDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingTargetCentralDefault;

		//	Try to initialize LoggingTargetElementDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingTargetElementDefault;
		else {
			//	Try to initialize LoggingTargetElementDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingTargetElementDefault;
		}
		//	And try to extract LoggingTargetElementDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingTargetElementDefault;

		//	Try to initialize LoggingTargetStorageDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingTargetStorageDefault;
		else {
			//	Try to initialize LoggingTargetStorageDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingTargetStorageDefault;
		}
		//	And try to extract LoggingTargetStorageDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingTargetStorageDefault;

		//	Try to initialize SkaLevel from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  skaLevel;
		else {
			//	Try to initialize SkaLevel from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  skaLevel;
		}
		//	And try to extract SkaLevel value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  skaLevel;

		//	Try to initialize SyslogFacility from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  syslogFacility;
		else {
			//	Try to initialize SyslogFacility from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  syslogFacility;
		}
		//	And try to extract SyslogFacility value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  syslogFacility;

		//	Try to initialize SyslogHost from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  syslogHost;
		else {
			//	Try to initialize SyslogHost from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  syslogHost;
		}
		//	And try to extract SyslogHost value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  syslogHost;

		//	Try to initialize LoggingLevelCentralDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingLevelCentralDefault;
		else {
			//	Try to initialize LoggingLevelCentralDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingLevelCentralDefault;
		}
		//	And try to extract LoggingLevelCentralDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingLevelCentralDefault;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize LoggingLevelElementDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingLevelElementDefault;
		else {
			//	Try to initialize LoggingLevelElementDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingLevelElementDefault;
		}
		//	And try to extract LoggingLevelElementDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingLevelElementDefault;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize LoggingLevelStorageDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingLevelStorageDefault;
		else {
			//	Try to initialize LoggingLevelStorageDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingLevelStorageDefault;
		}
		//	And try to extract LoggingLevelStorageDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingLevelStorageDefault;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize ConfigFile from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  configFile;
		else {
			//	Try to initialize ConfigFile from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  configFile;
		}
		//	And try to extract ConfigFile value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  configFile;

		//	Try to initialize EnableConfigFromFile from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableConfigFromFile;
		else {
			//	Try to initialize EnableConfigFromFile from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableConfigFromFile;
		}
		//	And try to extract EnableConfigFromFile value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableConfigFromFile;

		//	Try to initialize EnableDynAttrCleanup from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableDynAttrCleanup;
		else {
			//	Try to initialize EnableDynAttrCleanup from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableDynAttrCleanup;
		}
		//	And try to extract EnableDynAttrCleanup value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableDynAttrCleanup;

		//	Try to initialize EnableDynAttrRandomize from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableDynAttrRandomize;
		else {
			//	Try to initialize EnableDynAttrRandomize from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableDynAttrRandomize;
		}
		//	And try to extract EnableDynAttrRandomize value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableDynAttrRandomize;

		//	Try to initialize DynAttrRandomizePeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  dynAttrRandomizePeriod;
		else {
			//	Try to initialize DynAttrRandomizePeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  dynAttrRandomizePeriod;
		}
		//	And try to extract DynAttrRandomizePeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  dynAttrRandomizePeriod;

		//	Try to initialize ProxyDevices from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyDevices;
		else {
			//	Try to initialize ProxyDevices from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyDevices;
		}
		//	And try to extract ProxyDevices value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyDevices;

		//	Try to initialize FormulaVarMaxTimeInterval from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  formulaVarMaxTimeInterval;
		else {
			//	Try to initialize FormulaVarMaxTimeInterval from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  formulaVarMaxTimeInterval;
		}
		//	And try to extract FormulaVarMaxTimeInterval value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  formulaVarMaxTimeInterval;

		//	Try to initialize EnableProxyMonitoring from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableProxyMonitoring;
		else {
			//	Try to initialize EnableProxyMonitoring from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableProxyMonitoring;
		}
		//	And try to extract EnableProxyMonitoring value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableProxyMonitoring;

		//	Try to initialize ProxyMonitoringPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyMonitoringPeriod;
		else {
			//	Try to initialize ProxyMonitoringPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyMonitoringPeriod;
		}
		//	And try to extract ProxyMonitoringPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyMonitoringPeriod;

		//	Try to initialize ProxyStatusAttrPollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyStatusAttrPollPeriod;
		else {
			//	Try to initialize ProxyStatusAttrPollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyStatusAttrPollPeriod;
		}
		//	And try to extract ProxyStatusAttrPollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyStatusAttrPollPeriod;

		//	Try to initialize ProxyStatusAttrPeriodicEventPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyStatusAttrPeriodicEventPeriod;
		else {
			//	Try to initialize ProxyStatusAttrPeriodicEventPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyStatusAttrPeriodicEventPeriod;
		}
		//	And try to extract ProxyStatusAttrPeriodicEventPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyStatusAttrPeriodicEventPeriod;

		//	Try to initialize ProxyStatusAttrArchiveEventPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyStatusAttrArchiveEventPeriod;
		else {
			//	Try to initialize ProxyStatusAttrArchiveEventPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyStatusAttrArchiveEventPeriod;
		}
		//	And try to extract ProxyStatusAttrArchiveEventPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyStatusAttrArchiveEventPeriod;

		//	Try to initialize ProxyTimeout from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyTimeout;
		else {
			//	Try to initialize ProxyTimeout from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyTimeout;
		}
		//	And try to extract ProxyTimeout value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyTimeout;

		//	Try to initialize EventSubscriptions from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  eventSubscriptions;
		else {
			//	Try to initialize EventSubscriptions from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  eventSubscriptions;
		}
		//	And try to extract EventSubscriptions value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  eventSubscriptions;

		//	Try to initialize EventHandlers from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  eventHandlers;
		else {
			//	Try to initialize EventHandlers from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  eventHandlers;
		}
		//	And try to extract EventHandlers value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  eventHandlers;

		//	Try to initialize MaxQueueableTask from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  maxQueueableTask;
		else {
			//	Try to initialize MaxQueueableTask from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  maxQueueableTask;
		}
		//	And try to extract MaxQueueableTask value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  maxQueueableTask;

		//	Try to initialize MaxTrackableTasks from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  maxTrackableTasks;
		else {
			//	Try to initialize MaxTrackableTasks from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  maxTrackableTasks;
		}
		//	And try to extract MaxTrackableTasks value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  maxTrackableTasks;

		//	Try to initialize TaskHistoryTimeDepth from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  taskHistoryTimeDepth;
		else {
			//	Try to initialize TaskHistoryTimeDepth from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  taskHistoryTimeDepth;
		}
		//	And try to extract TaskHistoryTimeDepth value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  taskHistoryTimeDepth;

		//	Try to initialize DefaultTaskTimeout from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  defaultTaskTimeout;
		else {
			//	Try to initialize DefaultTaskTimeout from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  defaultTaskTimeout;
		}
		//	And try to extract DefaultTaskTimeout value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  defaultTaskTimeout;

		//	Try to initialize TaskSequenceStatusAttrList from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  taskSequenceStatusAttrList;
		else {
			//	Try to initialize TaskSequenceStatusAttrList from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  taskSequenceStatusAttrList;
		}
		//	And try to extract TaskSequenceStatusAttrList value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  taskSequenceStatusAttrList;

		//	Try to initialize TaskStatusAttrList from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  taskStatusAttrList;
		else {
			//	Try to initialize TaskStatusAttrList from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  taskStatusAttrList;
		}
		//	And try to extract TaskStatusAttrList value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  taskStatusAttrList;

		//	Try to initialize EnableEventRateMonitoring from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableEventRateMonitoring;
		else {
			//	Try to initialize EnableEventRateMonitoring from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableEventRateMonitoring;
		}
		//	And try to extract EnableEventRateMonitoring value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableEventRateMonitoring;

		//	Try to initialize EnableLoggerInitPolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableLoggerInitPolling;
		else {
			//	Try to initialize EnableLoggerInitPolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableLoggerInitPolling;
		}
		//	And try to extract EnableLoggerInitPolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableLoggerInitPolling;

		//	Try to initialize LoggerInitPollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggerInitPollPeriod;
		else {
			//	Try to initialize LoggerInitPollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggerInitPollPeriod;
		}
		//	And try to extract LoggerInitPollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggerInitPollPeriod;

		//	Try to initialize EnableDevProxyInitPolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableDevProxyInitPolling;
		else {
			//	Try to initialize EnableDevProxyInitPolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableDevProxyInitPolling;
		}
		//	And try to extract EnableDevProxyInitPolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableDevProxyInitPolling;

		//	Try to initialize DevProxyInitPollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  devProxyInitPollPeriod;
		else {
			//	Try to initialize DevProxyInitPollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  devProxyInitPollPeriod;
		}
		//	And try to extract DevProxyInitPollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  devProxyInitPollPeriod;

		//	Try to initialize EnableFwdAttrInitPolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableFwdAttrInitPolling;
		else {
			//	Try to initialize EnableFwdAttrInitPolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableFwdAttrInitPolling;
		}
		//	And try to extract EnableFwdAttrInitPolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableFwdAttrInitPolling;

		//	Try to initialize FwdAttrInitPollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  fwdAttrInitPollPeriod;
		else {
			//	Try to initialize FwdAttrInitPollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  fwdAttrInitPollPeriod;
		}
		//	And try to extract FwdAttrInitPollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  fwdAttrInitPollPeriod;

		//	Try to initialize EnableFormulaAttrUpdatePolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableFormulaAttrUpdatePolling;
		else {
			//	Try to initialize EnableFormulaAttrUpdatePolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableFormulaAttrUpdatePolling;
		}
		//	And try to extract EnableFormulaAttrUpdatePolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableFormulaAttrUpdatePolling;

		//	Try to initialize FormulaAttrUpdatePollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  formulaAttrUpdatePollPeriod;
		else {
			//	Try to initialize FormulaAttrUpdatePollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  formulaAttrUpdatePollPeriod;
		}
		//	And try to extract FormulaAttrUpdatePollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  formulaAttrUpdatePollPeriod;

		//	Try to initialize EnableStatusAttrUpdatePolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableStatusAttrUpdatePolling;
		else {
			//	Try to initialize EnableStatusAttrUpdatePolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableStatusAttrUpdatePolling;
		}
		//	And try to extract EnableStatusAttrUpdatePolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableStatusAttrUpdatePolling;

		//	Try to initialize StatusAttrUpdatePollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  statusAttrUpdatePollPeriod;
		else {
			//	Try to initialize StatusAttrUpdatePollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  statusAttrUpdatePollPeriod;
		}
		//	And try to extract StatusAttrUpdatePollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  statusAttrUpdatePollPeriod;

		//	Try to initialize EnableClearTaskPolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableClearTaskPolling;
		else {
			//	Try to initialize EnableClearTaskPolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableClearTaskPolling;
		}
		//	And try to extract EnableClearTaskPolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableClearTaskPolling;

		//	Try to initialize ClearTaskPollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  clearTaskPollPeriod;
		else {
			//	Try to initialize ClearTaskPollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  clearTaskPollPeriod;
		}
		//	And try to extract ClearTaskPollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  clearTaskPollPeriod;

		//	Try to initialize EnableProxyStatusAttrCreation from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableProxyStatusAttrCreation;
		else {
			//	Try to initialize EnableProxyStatusAttrCreation from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableProxyStatusAttrCreation;
		}
		//	And try to extract EnableProxyStatusAttrCreation value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableProxyStatusAttrCreation;

		//	Try to initialize EnableAutoAdminProxyRegistration from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableAutoAdminProxyRegistration;
		else {
			//	Try to initialize EnableAutoAdminProxyRegistration from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableAutoAdminProxyRegistration;
		}
		//	And try to extract EnableAutoAdminProxyRegistration value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableAutoAdminProxyRegistration;

		//	Try to initialize ProcessEventsInQueueThread from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  processEventsInQueueThread;
		else {
			//	Try to initialize ProcessEventsInQueueThread from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  processEventsInQueueThread;
		}
		//	And try to extract ProcessEventsInQueueThread value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  processEventsInQueueThread;

		//	Try to initialize StartupTime from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  startupTime;
		else {
			//	Try to initialize StartupTime from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  startupTime;
		}
		//	And try to extract StartupTime value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  startupTime;

		//	Try to initialize EnableStartupFailure from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableStartupFailure;
		else {
			//	Try to initialize EnableStartupFailure from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableStartupFailure;
		}
		//	And try to extract EnableStartupFailure value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableStartupFailure;

		//	Try to initialize StartupFailureProbability from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  startupFailureProbability;
		else {
			//	Try to initialize StartupFailureProbability from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  startupFailureProbability;
		}
		//	And try to extract StartupFailureProbability value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  startupFailureProbability;

		//	Try to initialize StowTime from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  stowTime;
		else {
			//	Try to initialize StowTime from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  stowTime;
		}
		//	And try to extract StowTime value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  stowTime;

		//	Try to initialize EnableStowFailure from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableStowFailure;
		else {
			//	Try to initialize EnableStowFailure from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableStowFailure;
		}
		//	And try to extract EnableStowFailure value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableStowFailure;

		//	Try to initialize StowFailureProbability from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  stowFailureProbability;
		else {
			//	Try to initialize StowFailureProbability from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  stowFailureProbability;
		}
		//	And try to extract StowFailureProbability value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  stowFailureProbability;

		//	Try to initialize IndexingTime from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  indexingTime;
		else {
			//	Try to initialize IndexingTime from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  indexingTime;
		}
		//	And try to extract IndexingTime value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  indexingTime;

		//	Try to initialize EnableIndexingFailure from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableIndexingFailure;
		else {
			//	Try to initialize EnableIndexingFailure from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableIndexingFailure;
		}
		//	And try to extract EnableIndexingFailure value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableIndexingFailure;

		//	Try to initialize IndexingFailureProbability from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  indexingFailureProbability;
		else {
			//	Try to initialize IndexingFailureProbability from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  indexingFailureProbability;
		}
		//	And try to extract IndexingFailureProbability value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  indexingFailureProbability;

		//	Try to initialize PointingModelParamsDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  pointingModelParamsDefault;
		else {
			//	Try to initialize PointingModelParamsDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  pointingModelParamsDefault;
		}
		//	And try to extract PointingModelParamsDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  pointingModelParamsDefault;

		//	Try to initialize IndexerPositionDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  indexerPositionDefault;
		else {
			//	Try to initialize IndexerPositionDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  indexerPositionDefault;
		}
		//	And try to extract IndexerPositionDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  indexerPositionDefault;

		//	Try to initialize SmearPointingCoords from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  smearPointingCoords;
		else {
			//	Try to initialize SmearPointingCoords from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  smearPointingCoords;
		}
		//	And try to extract SmearPointingCoords value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  smearPointingCoords;

		//	Try to initialize PointingResolution from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  pointingResolution;
		else {
			//	Try to initialize PointingResolution from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  pointingResolution;
		}
		//	And try to extract PointingResolution value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  pointingResolution;

		//	Try to initialize MaxPointingQueueSize from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  maxPointingQueueSize;
		else {
			//	Try to initialize MaxPointingQueueSize from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  maxPointingQueueSize;
		}
		//	And try to extract MaxPointingQueueSize value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  maxPointingQueueSize;

		//	Try to initialize UseUTCTime from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  useUTCTime;
		else {
			//	Try to initialize UseUTCTime from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  useUTCTime;
		}
		//	And try to extract UseUTCTime value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  useUTCTime;

		//	Try to initialize TrackProgramMaxSize from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  trackProgramMaxSize;
		else {
			//	Try to initialize TrackProgramMaxSize from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  trackProgramMaxSize;
		}
		//	And try to extract TrackProgramMaxSize value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  trackProgramMaxSize;

		//	Try to initialize TrackProgramTimeStep from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  trackProgramTimeStep;
		else {
			//	Try to initialize TrackProgramTimeStep from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  trackProgramTimeStep;
		}
		//	And try to extract TrackProgramTimeStep value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  trackProgramTimeStep;

		//	Try to initialize MinAzimuth from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  minAzimuth;
		else {
			//	Try to initialize MinAzimuth from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  minAzimuth;
		}
		//	And try to extract MinAzimuth value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  minAzimuth;

		//	Try to initialize MaxAzimuth from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  maxAzimuth;
		else {
			//	Try to initialize MaxAzimuth from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  maxAzimuth;
		}
		//	And try to extract MaxAzimuth value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  maxAzimuth;

		//	Try to initialize MinElevation from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  minElevation;
		else {
			//	Try to initialize MinElevation from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  minElevation;
		}
		//	And try to extract MinElevation value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  minElevation;

		//	Try to initialize MaxElevation from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  maxElevation;
		else {
			//	Try to initialize MaxElevation from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  maxElevation;
		}
		//	And try to extract MaxElevation value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  maxElevation;

		//	Try to initialize SlewRate from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  slewRate;
		else {
			//	Try to initialize SlewRate from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  slewRate;
		}
		//	And try to extract SlewRate value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  slewRate;

		//	Try to initialize SlewTimeStep from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  slewTimeStep;
		else {
			//	Try to initialize SlewTimeStep from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  slewTimeStep;
		}
		//	And try to extract SlewTimeStep value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  slewTimeStep;

		//	Try to initialize StowAzimuthPos from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  stowAzimuthPos;
		else {
			//	Try to initialize StowAzimuthPos from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  stowAzimuthPos;
		}
		//	And try to extract StowAzimuthPos value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  stowAzimuthPos;

		//	Try to initialize StowElevationPos from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  stowElevationPos;
		else {
			//	Try to initialize StowElevationPos from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  stowElevationPos;
		}
		//	And try to extract StowElevationPos value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  stowElevationPos;

		//	Try to initialize SetModeTime from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  setModeTime;
		else {
			//	Try to initialize SetModeTime from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  setModeTime;
		}
		//	And try to extract SetModeTime value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  setModeTime;

		//	Try to initialize EnableSetModeFailure from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableSetModeFailure;
		else {
			//	Try to initialize EnableSetModeFailure from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableSetModeFailure;
		}
		//	And try to extract EnableSetModeFailure value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableSetModeFailure;

		//	Try to initialize SetModeFailureProbability from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  setModeFailureProbability;
		else {
			//	Try to initialize SetModeFailureProbability from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  setModeFailureProbability;
		}
		//	And try to extract SetModeFailureProbability value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  setModeFailureProbability;

		//	Try to initialize ShutdownTime from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  shutdownTime;
		else {
			//	Try to initialize ShutdownTime from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  shutdownTime;
		}
		//	And try to extract ShutdownTime value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  shutdownTime;

	}

	/*----- PROTECTED REGION ID(DSEmulator::get_device_property_after) ENABLED START -----*/
	
	//	Check device property data members init
	
	/*----- PROTECTED REGION END -----*/	//	DSEmulator::get_device_property_after
}
//--------------------------------------------------------
/**
 *	Method      : DSEmulator::check_mandatory_property()
 *	Description : For mandatory properties check if defined in database.
 */
//--------------------------------------------------------
void DSEmulator::check_mandatory_property(Tango::DbDatum &class_prop, Tango::DbDatum &dev_prop)
{
	//	Check if all properties are empty
	if (class_prop.is_empty() && dev_prop.is_empty())
	{
		TangoSys_OMemStream	tms;
		tms << endl <<"Property \'" << dev_prop.name;
		if (Tango::Util::instance()->_UseDb==true)
			tms << "\' is mandatory but not defined in database";
		else
			tms << "\' is mandatory but cannot be defined without database";
		string	status(get_status());
		status += tms.str();
		set_status(status);
		mandatoryNotDefined = true;
		/*----- PROTECTED REGION ID(DSEmulator::check_mandatory_property) ENABLED START -----*/
		cerr << tms.str() << " for " << device_name << endl;
		
		/*----- PROTECTED REGION END -----*/	//	DSEmulator::check_mandatory_property
	}
}


//--------------------------------------------------------
/**
 *	Method      : DSEmulator::always_executed_hook()
 *	Description : method always executed before any command is executed
 */
//--------------------------------------------------------
void DSEmulator::always_executed_hook()
{
	DEBUG_STREAM << "DSEmulator::always_executed_hook()  " << device_name << endl;
	if (mandatoryNotDefined)
	{
		string	status(get_status());
		Tango::Except::throw_exception(
					(const char *)"PROPERTY_NOT_SET",
					status.c_str(),
					(const char *)"DSEmulator::always_executed_hook()");
	}
	/*----- PROTECTED REGION ID(DSEmulator::always_executed_hook) ENABLED START -----*/
	
	//	code always executed before all requests
	
	/*----- PROTECTED REGION END -----*/	//	DSEmulator::always_executed_hook
}

//--------------------------------------------------------
/**
 *	Method      : DSEmulator::read_attr_hardware()
 *	Description : Hardware acquisition for attributes
 */
//--------------------------------------------------------
void DSEmulator::read_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "DSEmulator::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(DSEmulator::read_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	DSEmulator::read_attr_hardware
}
//--------------------------------------------------------
/**
 *	Method      : DSEmulator::write_attr_hardware()
 *	Description : Hardware writing for attributes
 */
//--------------------------------------------------------
void DSEmulator::write_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "DSEmulator::write_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(DSEmulator::write_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	DSEmulator::write_attr_hardware
}

//--------------------------------------------------------
/**
 *	Read attribute powerCut related method
 *	Description: 
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void DSEmulator::read_powerCut(Tango::Attribute &attr)
{
	DEBUG_STREAM << "DSEmulator::read_powerCut(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(DSEmulator::read_powerCut) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_powerCut_read);
	
	/*----- PROTECTED REGION END -----*/	//	DSEmulator::read_powerCut
}
//--------------------------------------------------------
/**
 *	Read attribute powerRestored related method
 *	Description: 
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void DSEmulator::read_powerRestored(Tango::Attribute &attr)
{
	DEBUG_STREAM << "DSEmulator::read_powerRestored(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(DSEmulator::read_powerRestored) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_powerRestored_read);
	
	/*----- PROTECTED REGION END -----*/	//	DSEmulator::read_powerRestored
}
//--------------------------------------------------------
/**
 *	Read attribute stowProgress related method
 *	Description: 
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 2
 */
//--------------------------------------------------------
void DSEmulator::read_stowProgress(Tango::Attribute &attr)
{
	DEBUG_STREAM << "DSEmulator::read_stowProgress(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(DSEmulator::read_stowProgress) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_stowProgress_read, 2);
	
	/*----- PROTECTED REGION END -----*/	//	DSEmulator::read_stowProgress
}
//--------------------------------------------------------
/**
 *	Read attribute indexingProgress related method
 *	Description: 
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 2
 */
//--------------------------------------------------------
void DSEmulator::read_indexingProgress(Tango::Attribute &attr)
{
	DEBUG_STREAM << "DSEmulator::read_indexingProgress(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(DSEmulator::read_indexingProgress) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_indexingProgress_read, 2);
	
	/*----- PROTECTED REGION END -----*/	//	DSEmulator::read_indexingProgress
}
//--------------------------------------------------------
/**
 *	Read attribute achievedPointing related method
 *	Description: Actual pointing coordinates
 *               [0]: Timestamp (milliseconds since UNIX epoch, UTC)
 *               [1]: Azimuth
 *               [2]: Elevation
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Spectrum max = 3
 */
//--------------------------------------------------------
void DSEmulator::read_achievedPointing(Tango::Attribute &attr)
{
	DEBUG_STREAM << "DSEmulator::read_achievedPointing(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(DSEmulator::read_achievedPointing) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_achievedPointing_read, 3);
	
	/*----- PROTECTED REGION END -----*/	//	DSEmulator::read_achievedPointing
}
//--------------------------------------------------------
/**
 *	Read attribute desiredPointing related method
 *	Description: Desired pointing coordinates
 *               [0]: Timestamp (Milliseconds since UNIX epoch, UTC Time at which Dish should start
 *               applying the polynomial)
 *               [1]: Az (0th order pol coeff)
 *               [2]: El (0th order pol coeff)
 *               [3]: Az (1st order pol coeff)
 *               [4]: El (1st order pol coeff)
 *               [5]: Az (2nd order pol coeff)
 *               [6]: El (2nd order pol coeff)
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Spectrum max = 7
 */
//--------------------------------------------------------
void DSEmulator::read_desiredPointing(Tango::Attribute &attr)
{
	DEBUG_STREAM << "DSEmulator::read_desiredPointing(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(DSEmulator::read_desiredPointing) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_desiredPointing_read, 7);
	
	/*----- PROTECTED REGION END -----*/	//	DSEmulator::read_desiredPointing
}
//--------------------------------------------------------
/**
 *	Write attribute desiredPointing related method
 *	Description: Desired pointing coordinates
 *               [0]: Timestamp (Milliseconds since UNIX epoch, UTC Time at which Dish should start
 *               applying the polynomial)
 *               [1]: Az (0th order pol coeff)
 *               [2]: El (0th order pol coeff)
 *               [3]: Az (1st order pol coeff)
 *               [4]: El (1st order pol coeff)
 *               [5]: Az (2nd order pol coeff)
 *               [6]: El (2nd order pol coeff)
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Spectrum max = 7
 */
//--------------------------------------------------------
void DSEmulator::write_desiredPointing(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "DSEmulator::write_desiredPointing(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve number of write values
	int	w_length = attr.get_write_value_length();

	//	Retrieve pointer on write values (Do not delete !)
	const Tango::DevDouble	*w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(DSEmulator::write_desiredPointing) ENABLED START -----*/
	
	//###########################################################################
	//##    HARD-CODED PARAMETERS 
	//##    (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string operatingMode_attr_name= "operatingMode";
	std::string operatingModeStr_point= "POINT";
	//=====================================================

	//==============================================
	//==     CHECK OPERATING MODE
	//===============================================
	//Retrieve mode corresponding to POINT
	Tango::DevShort operatingMode;
	if( GetDynAttrValue(operatingMode,operatingMode_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<operatingMode_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("WRITE_DESIRED_POINTING_FAILED",ss.str());
	}

	//Reject if not in POINT MODE
	Tango::DevShort operatingMode_point;
	Utils_ns::TangoUtils::GetEnumAttrValue(operatingMode_point,this,operatingMode_attr_name,operatingModeStr_point);
	if(operatingMode!=operatingMode_point){
		std::stringstream ss;
		ss<<"Setting pointing coordinates in mode "<<operatingMode<<" is forbidden (hint: set DS point mode)!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("WRITE_DESIRED_POINTING_FAILED",ss.str());
	}

	//==============================================
	//==     CHECK ARGS
	//===============================================
	//## Check number of entries
	_INFO_LOG("Pointing coordinates given (n="<<w_length<<")");
	if(w_length<3){
		std::stringstream ss;
		ss<<"Invalid number of entries given (n="<<w_length<<"), at least 3 required!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("WRITE_DESIRED_POINTING_FAILED",ss.str());
	}
	if(w_length-1%2==1){
		std::stringstream ss;
		ss<<"Invalid number of entries given (n="<<w_length<<"), an odd number of entries is required!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("WRITE_DESIRED_POINTING_FAILED",ss.str());
	}

	double t0= w_val[0];
	double Az= w_val[1];
	double El= w_val[2];

	//## Check timestamp
	//## NB: A negative timestamp means point now!
	double dt= 0;
	yat::Time t_now;
	t_now.set_current(useUTCTime);
	if(t0>0){
		yat::Time t_point;
		t_point.set_double_unix(t0/1000);//should be given in seconds
		dt= t0-t_now.double_unix()*1000.;
		if(t0<0 || t_point<=t_now){
			std::stringstream ss;
			ss<<"Given timestamp (t(ms)="<<t0<<") is invalid or has passed (now(ms)="<<t_now.double_unix()*1000.<<", dt(ms)="<<dt<<")";
			_ERROR_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("WRITE_DESIRED_POINTING_FAILED",ss.str());
		}
	}//close if t0
	
	_INFO_LOG("Desired pointing coords to be applied at t0(ms)="<<t0<<" (now(ms)="<<t_now.double_unix()*1000.<<", dt(ms)="<<dt<<")");

	//==============================================
	//==     PUSH COORDINATES TO QUEUE
	//===============================================
	//## Push pointing coords to queue
	//## 3 different modes: single coords, pol1, pol2
	PointingDataPtr pData= nullptr;	
	std::vector<PointingDataPtr> pDataList;	

	if(w_length==3){//single coord mode
		double Az_t= Az;
		double El_t= El;
		double t= t0;
		pData= std::make_shared<PointingData>(Az_t,El_t,t,PointingData::eTRACK_PROGRAM);
		pDataList.push_back(pData);

		//Correct coordinates
		if(CorrectPointingDataList(pDataList)<0){
			std::string errMsg("Failed to correct pointing coordinates (check correction pars)!");
			_ERROR_LOG(errMsg);
			_THROW_TANGO_EXCEPTION("WRITE_DESIRED_POINTING_FAILED",errMsg);
		}

		//Add to tracking queue	
		if(m_pntSchedule->Push(pData)<0){//failed to add data to queue
			std::string errMsg("Failed to add single pointing data to queue (hint: check if queue is full)");
			_ERROR_LOG(errMsg);
			_THROW_TANGO_EXCEPTION("WRITE_DESIRED_POINTING_FAILED",errMsg);
		}
				
		//Set pnt coords 
		attr_desiredPointing_read[0]= t;	
		attr_desiredPointing_read[1]= Az_t;
		attr_desiredPointing_read[2]= El_t;


	}//close if single coords
	else if(w_length==5){//pol1 coord mode
		//Get pol coeff
		double p_Az= w_val[3];
		double p_El= w_val[4];

		//Expand polynomial in a coord list
		double t= t0;
		for(int i=0;i<trackProgramMaxSize;i++){
			double Az_t= Az + p_Az*(t-t0);
			double El_t= El + p_El*(t-t0);
			pData= std::make_shared<PointingData>(Az_t,El_t,t,PointingData::eTRACK_PROGRAM);
			pDataList.push_back(pData);
			t+= trackProgramTimeStep;
		}//end coord list

		//Correct coordinates
		if(CorrectPointingDataList(pDataList)<0){
			std::string errMsg("Failed to correct pointing coordinates (check correction pars)!");
			_ERROR_LOG(errMsg);
			_THROW_TANGO_EXCEPTION("WRITE_DESIRED_POINTING_FAILED",errMsg);
		}
	
		//Add track program to queue
		if(m_pntSchedule->Push(pDataList)<0){//failed to add data to queue
			std::string errMsg("Failed to add pointing data to queue expanded from pol1 pnt polynomial (hint: check if queue is full)");
			_ERROR_LOG(errMsg);
			_THROW_TANGO_EXCEPTION("WRITE_DESIRED_POINTING_FAILED",errMsg);
		}

		//Set pnt coords 
		attr_desiredPointing_read[0]= t;	
		attr_desiredPointing_read[1]= Az;
		attr_desiredPointing_read[2]= El;
		attr_desiredPointing_read[3]= p_Az;
		attr_desiredPointing_read[4]= p_El;

	}//close if pol1 coords
	else if(w_length==7){//pol2 coord mode
		//Get pol coeff
		double p_Az= w_val[3];
		double p_El= w_val[4];
		double p2_Az= w_val[5];
		double p2_El= w_val[6];

		//Expand polynomial in a coord list
		double t= t0;
		for(int i=0;i<trackProgramMaxSize;i++){
			double Az_t= Az + p_Az*(t-t0) + p2_Az*(t-t0)*(t-t0);
			double El_t= El + p_El*(t-t0) + p2_El*(t-t0)*(t-t0);
			pData= std::make_shared<PointingData>(Az_t,El_t,t,PointingData::eTRACK_PROGRAM);
			pDataList.push_back(pData);
			t+= trackProgramTimeStep;
		}//end coord list

		//Correct coordinates
		if(CorrectPointingDataList(pDataList)<0){
			std::string errMsg("Failed to correct pointing coordinates (check correction pars)!");
			_ERROR_LOG(errMsg);
			_THROW_TANGO_EXCEPTION("WRITE_DESIRED_POINTING_FAILED",errMsg);
		}

		//Add track program to queue
		if(m_pntSchedule->Push(pDataList)<0){//failed to add data to queue
			std::string errMsg("Failed to add pointing data to queue expanded from pol2 pnt polynomial (hint: check if queue is full)");
			_ERROR_LOG(errMsg);
			_THROW_TANGO_EXCEPTION("WRITE_DESIRED_POINTING_FAILED",errMsg);
		}

		//Set pnt coords 
		attr_desiredPointing_read[0]= t;	
		attr_desiredPointing_read[1]= Az;
		attr_desiredPointing_read[2]= El;
		attr_desiredPointing_read[3]= p_Az;
		attr_desiredPointing_read[4]= p_El;
		attr_desiredPointing_read[5]= p2_Az;
		attr_desiredPointing_read[6]= p2_El;

	}//close if pol2 pointing model
	else{
		std::stringstream ss;
		ss<<"Invalid number of arguments given (this should not occur)!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("WRITE_DESIRED_POINTING_FAILED",ss.str());
	}

	//## Notify data available to tracking thread
	m_trackingThread->NotifyDataAvailable();

	/*----- PROTECTED REGION END -----*/	//	DSEmulator::write_desiredPointing
}
//--------------------------------------------------------
/**
 *	Read attribute setStandbyLPModeProgress related method
 *	Description: 
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 2
 */
//--------------------------------------------------------
void DSEmulator::read_setStandbyLPModeProgress(Tango::Attribute &attr)
{
	DEBUG_STREAM << "DSEmulator::read_setStandbyLPModeProgress(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(DSEmulator::read_setStandbyLPModeProgress) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_setStandbyLPModeProgress_read, 2);
	
	/*----- PROTECTED REGION END -----*/	//	DSEmulator::read_setStandbyLPModeProgress
}
//--------------------------------------------------------
/**
 *	Read attribute setStandbyFPModeProgress related method
 *	Description: 
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 2
 */
//--------------------------------------------------------
void DSEmulator::read_setStandbyFPModeProgress(Tango::Attribute &attr)
{
	DEBUG_STREAM << "DSEmulator::read_setStandbyFPModeProgress(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(DSEmulator::read_setStandbyFPModeProgress) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_setStandbyFPModeProgress_read, 2);
	
	/*----- PROTECTED REGION END -----*/	//	DSEmulator::read_setStandbyFPModeProgress
}
//--------------------------------------------------------
/**
 *	Read attribute setPointModeProgress related method
 *	Description: 
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 2
 */
//--------------------------------------------------------
void DSEmulator::read_setPointModeProgress(Tango::Attribute &attr)
{
	DEBUG_STREAM << "DSEmulator::read_setPointModeProgress(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(DSEmulator::read_setPointModeProgress) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_setPointModeProgress_read, 2);
	
	/*----- PROTECTED REGION END -----*/	//	DSEmulator::read_setPointModeProgress
}

//--------------------------------------------------------
/**
 *	Method      : DSEmulator::add_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *                for specified device.
 */
//--------------------------------------------------------
void DSEmulator::add_dynamic_attributes()
{
	/*----- PROTECTED REGION ID(DSEmulator::add_dynamic_attributes) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic attributes if any
	LMCDevice::add_dynamic_attributes();

	/*
	//Add dynamic attributes from config file
	if(AddDynAttrs()<0){
		std::string errMsg("Failed to create dyn attributes!");
		_ERROR_LOG(errMsg);
		set_status(errMsg.c_str());
		set_state(Tango::FAULT);
		return;
	}
	
	//Configure state machine for cmd & attrs
	if(InitCmdAttrStateMachine()<0){
		std::string errMsg("Failed to create cmd & attr state machines for dyn attributes!");
		_ERROR_LOG(errMsg);
		set_status(errMsg.c_str());
		set_state(Tango::FAULT);
		return;
	}
	*/
	/*----- PROTECTED REGION END -----*/	//	DSEmulator::add_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Command SetStandbyLPMode related method
 *	Description: Set STANDBY-LP mode in DS
 *
 *	@returns 
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *DSEmulator::set_standby_lpmode()
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "DSEmulator::SetStandbyLPMode()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DSEmulator::set_standby_lpmode) ENABLED START -----*/
	
	//	Add your own code
	// == COMMAND BEHAVIOR ==
	// 1) Check if cmd mode-allowed (ALL MODES ALLOWED) (DONE IN STATE MACHINE)
	// 2) Apply brakes, drives disabled
	// 3) If power=LOW-POWER disable drives (REQ. R.DS.SM.30) UNCLEAR!!!!
	// 4) Set mode=STANDBY
	// 4) Set pointState=NONE

	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string mode_attr_name= "operatingMode";
	std::string powerState_attr_name= "powerState";
	std::string pointState_attr_name= "pointingState";
	std::string mode_str= "STANDBY-LP";
	std::string powerState_str= "LOW-POWER"; 
	std::string pointState_str= "NONE"; 
	//===========================================================================

	_INFO_LOG("Setting DS to STANDBY_LP mode...");

	//Init output attribute
	argout= new Tango::DevVarLongStringArray;
	argout->svalue.length(1);
	argout->lvalue.length(1);

	//=====================================================
	//==         CHECK IF CMD ALLOWED
	//=====================================================
	_DEBUG_LOG("Check if cmd "<<__FUNCTION__<<" is allowed...");
	bool check_cmd= true;
	try {
		IsCmdAllowed(__FUNCTION__,check_cmd);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		throw;
	}

	//=====================================================
	//==         CHECK IF TASK IS ALREADY RUNNING
	//=====================================================
	_DEBUG_LOG("Check if a previous SetStandbyLPMode task is already running...");
	if( strcmp(attr_setStandbyLPModeProgress_read[0],"RUNNING")==0  || strcmp(attr_setStandbyLPModeProgress_read[0],"IDLE")==0 ){
		std::stringstream ss;
		ss<<"Another SetStandbyLPMode task is running or waiting for execution in device!";
		_INFO_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STANDBY_LP_MODE_FAILED",ss.str());
	}

	//=====================================================
	//==      CHECK CURRENT MODE & POWER
	//=====================================================
	//Retrieve mode/power value corresponding to label
	Tango::DevShort mode;
	Utils_ns::TangoUtils::GetEnumAttrValue(mode,this,mode_attr_name,mode_str);

	Tango::DevShort powerState;
	Utils_ns::TangoUtils::GetEnumAttrValue(powerState,this,powerState_attr_name,powerState_str);

	//Get current mode
	Tango::DevShort mode_current;	
	if(GetDynAttrValue(mode_current,mode_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<mode_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STANDBY_LP_MODE_FAILED",ss.str());	
	}	

	//Get current mode
	Tango::DevShort powerState_current;	
	if(GetDynAttrValue(powerState_current,powerState_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<powerState_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STANDBY_LP_MODE_FAILED",ss.str());	
	}	

	//Check if mode is already active	
	//if(mode==mode_current && powerState==powerState_current){//include also power to dsitinguish from STANDBY-FP mode?
	if(mode==mode_current){
		std::stringstream ss;	
		ss<<"Mode "<<mode_str<<" already active, nothing to be done";
		_INFO_LOG(ss.str());
		SetStandbyLPStatus("COMPLETED",ss.str(),true);

		argout->svalue[0] = CORBA::string_dup(ss.str().c_str());	
		argout->lvalue[0] = 0;
		return argout;
	}
	
	
	//=====================================================
	//==    SET STANDBY-LP TASK (PERFORMED IN TASK THREAD)
	//=====================================================

	_INFO_LOG("Scheduling SetStandbyLPMode task...");

	//Prepare message data
	StandbyLPMsg msg_data;
	msg_data.task_duration= setModeTime;
	msg_data.enable_failure= enableSetModeFailure;
	msg_data.failure_probability= setModeFailureProbability;	
	msg_data.checkPreConditions= false;
	
	//Init status attr
	SetStandbyLPStatus("IDLE","Set StandbyLPMode command being scheduled...",true);
	
	//Post configure message to queue
	bool isSynchronous= false;
	try {	
		m_task->execute_set_standby_lp(msg_data, isSynchronous);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		std::string errMsg("Tango exception occurred while executing indexing task!");
		_ERROR_LOG(errMsg);
		SetStandbyLPStatus("ABORTED","StandbyLPMode command failed to be scheduled!",true);
		throw;
	}	
	catch(...){
		std::string errMsg("Unknown C++ exception occurred while executing indexing task!");
		_ERROR_LOG(errMsg);	
		SetStandbyLPStatus("ABORTED","StandbyLPMode command failed to be scheduled!",true);
		throw;
	}

	//Set reply 
	argout->svalue[0] = CORBA::string_dup("StandbyLPMode command scheduled");	
	argout->lvalue[0] = 1;

	
	/*----- PROTECTED REGION END -----*/	//	DSEmulator::set_standby_lpmode
	return argout;
}
//--------------------------------------------------------
/**
 *	Command SetStandbyFPMode related method
 *	Description: Activate full power mode in DS
 *               Corresponds to mode=STANDBY and power=FULL 
 *               (drives enabled)
 *
 *	@returns 
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *DSEmulator::set_standby_fpmode()
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "DSEmulator::SetStandbyFPMode()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DSEmulator::set_standby_fpmode) ENABLED START -----*/
	
	//	Add your own code
	// == COMMAND BEHAVIOR ==
	// 1) Check if cmd mode-allowed (ALL MODES ALLOWED) (DONE IN STATE MACHINE)
	// 2) Apply brakes, drives disabled
	// 3) If power=LOW-POWER disable drives (REQ. R.DS.SM.30) UNCLEAR!!!!
	// 4) Set mode=STANDBY
	// 4) Set pointState=NONE

	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string mode_attr_name= "operatingMode";
	std::string powerState_attr_name= "powerState";
	std::string pointState_attr_name= "pointingState";
	std::string mode_str= "STANDBY-FP";
	std::string powerState_str= "FULL-POWER"; 
	std::string pointState_str= "NONE"; 
	//===========================================================================

	_INFO_LOG("Setting DS to STANDBY_FP mode...");

	//Init output attribute
	argout= new Tango::DevVarLongStringArray;
	argout->svalue.length(1);
	argout->lvalue.length(1);

	//=====================================================
	//==         CHECK IF CMD ALLOWED
	//=====================================================
	_DEBUG_LOG("Check if cmd "<<__FUNCTION__<<" is allowed...");
	bool check_cmd= true;
	try {
		IsCmdAllowed(__FUNCTION__,check_cmd);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		throw;
	}

	//=====================================================
	//==         CHECK IF TASK IS ALREADY RUNNING
	//=====================================================
	_DEBUG_LOG("Check if a previous SetStandbyFPMode task is already running...");
	if( strcmp(attr_setStandbyFPModeProgress_read[0],"RUNNING")==0  || strcmp(attr_setStandbyFPModeProgress_read[0],"IDLE")==0 ){
		std::stringstream ss;
		ss<<"Another SetStandbyFPMode task is running or waiting for execution in device!";
		_INFO_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STANDBY_FP_MODE_FAILED",ss.str());
	}

	//=====================================================
	//==      CHECK CURRENT MODE & POWER
	//=====================================================
	//Retrieve mode/power value corresponding to label
	Tango::DevShort mode;
	Utils_ns::TangoUtils::GetEnumAttrValue(mode,this,mode_attr_name,mode_str);

	Tango::DevShort powerState;
	Utils_ns::TangoUtils::GetEnumAttrValue(powerState,this,powerState_attr_name,powerState_str);

	//Get current mode
	Tango::DevShort mode_current;	
	if(GetDynAttrValue(mode_current,mode_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<mode_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STANDBY_FP_MODE_FAILED",ss.str());	
	}	

	//Get current power
	Tango::DevShort powerState_current;	
	if(GetDynAttrValue(powerState_current,powerState_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<powerState_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STANDBY_FP_MODE_FAILED",ss.str());	
	}	

	//Check if mode is already active	(include also power to distinguish from STANDBY-LP)
	if(mode==mode_current && powerState==powerState_current){
		std::stringstream ss;	
		ss<<"Mode "<<mode_str<<" already active, nothing to be done";
		_INFO_LOG(ss.str());
		SetStandbyFPStatus("COMPLETED",ss.str(),true);

		argout->svalue[0] = CORBA::string_dup(ss.str().c_str());	
		argout->lvalue[0] = 0;
		return argout;
	}


	//=====================================================
	//==    SET STANDBY-FP TASK (PERFORMED IN TASK THREAD)
	//=====================================================

	_INFO_LOG("Scheduling SetStandbyFPMode task...");

	//Prepare message data
	StandbyFPMsg msg_data;
	msg_data.task_duration= setModeTime;
	msg_data.enable_failure= enableSetModeFailure;
	msg_data.failure_probability= setModeFailureProbability;
	
	//Init status attr
	SetStandbyFPStatus("IDLE","Set StandbyFPMode command being scheduled...",true);
	
	//Post configure message to queue
	bool isSynchronous= false;
	try {	
		m_task->execute_set_standby_fp(msg_data, isSynchronous);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		std::string errMsg("Tango exception occurred while executing SetStandbyFPMode task!");
		_ERROR_LOG(errMsg);
		SetStandbyLPStatus("ABORTED","StandbyFPMode command failed to be scheduled!",true);
		throw;
	}	
	catch(...){
		std::string errMsg("Unknown C++ exception occurred while executing indexing task!");
		_ERROR_LOG(errMsg);	
		SetStandbyLPStatus("ABORTED","StandbyFPMode command failed to be scheduled!",true);
		throw;
	}

	//Set reply 
	argout->svalue[0] = CORBA::string_dup("StandbyFPMode command scheduled");	
	argout->lvalue[0] = 1;
	

	/*----- PROTECTED REGION END -----*/	//	DSEmulator::set_standby_fpmode
	return argout;
}
//--------------------------------------------------------
/**
 *	Command SetPointMode related method
 *	Description: Activate POINT mode in antenna.
 *               
 *               - Brakes are off
 *               - Able to index & to point
 *
 *	@returns 
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *DSEmulator::set_point_mode()
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "DSEmulator::SetPointMode()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DSEmulator::set_point_mode) ENABLED START -----*/
	
	//	Add your own code
	// == COMMAND BEHAVIOR ==
	// 1) Check if cmd mode-allowed {"STANDBY","POINT","STOW"} (DONE IN STATE MACHINE)
	// 2) Remove brakes, enable drives and set powerState=FULL-POWER
	// 3) Set mode to POINT
	// 4) Set pointState=READY

	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string mode_attr_name= "operatingMode";
	std::string powerState_attr_name= "powerState";
	std::string pointState_attr_name= "pointingState";
	std::string mode_str= "POINT"; 
	std::string powerState_str= "FULL-POWER"; 
	std::string pointState_str= "READY"; 
	//===========================================================================

	_INFO_LOG("Setting DS to POINT mode...");
	
	//Init output attribute
	argout= new Tango::DevVarLongStringArray;
	argout->svalue.length(1);
	argout->lvalue.length(1);

	//=====================================================
	//==         CHECK IF CMD ALLOWED
	//=====================================================
	_DEBUG_LOG("Check if cmd "<<__FUNCTION__<<" is allowed...");
	bool check_cmd= true;
	try {
		IsCmdAllowed(__FUNCTION__,check_cmd);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		throw;
	}

	//=====================================================
	//==         CHECK IF TASK IS ALREADY RUNNING
	//=====================================================
	_DEBUG_LOG("Check if a previous indexing task is already running...");
	if( strcmp(attr_setPointModeProgress_read[0],"RUNNING")==0  || strcmp(attr_setPointModeProgress_read[0],"IDLE")==0 ){
		std::stringstream ss;
		ss<<"Another Indexing task is running or waiting for execution in device!";
		_INFO_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_POINT_MODE_FAILED",ss.str());
	}


	//=====================================================
	//==      CHECK CURRENT MODE 
	//=====================================================
	//Retrieve mode value corresponding to label
	Tango::DevShort mode;
	Utils_ns::TangoUtils::GetEnumAttrValue(mode,this,mode_attr_name,mode_str);

	//Get current mode
	Tango::DevShort mode_current;	
	if(GetDynAttrValue(mode_current,mode_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<mode_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_POINT_MODE_FAILED",ss.str());	
	}	

	//Check if maintenance mode is already active	
	if(mode==mode_current){
		std::stringstream ss;	
		ss<<"Mode "<<mode_str<<" already active, nothing to be done";
		_INFO_LOG(ss.str());
		SetPointStatus("COMPLETED",ss.str(),true);

		argout->svalue[0] = CORBA::string_dup(ss.str().c_str());	
		argout->lvalue[0] = 0;
		return argout;
	}
	

	//=====================================================
	//==    SET POINT MODE TASK (PERFORMED IN TASK THREAD)
	//=====================================================

	_INFO_LOG("Scheduling SetPointMode task...");

	//Prepare message data
	PointMsg msg_data;
	msg_data.task_duration= setModeTime;
	msg_data.enable_failure= enableSetModeFailure;
	msg_data.failure_probability= setModeFailureProbability;
	
	//Init status attr
	SetPointStatus("IDLE","SetPointMode command being scheduled...",true);
	
	//Post configure message to queue
	bool isSynchronous= false;
	try {	
		m_task->execute_set_point(msg_data, isSynchronous);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		std::string errMsg("Tango exception occurred while executing indexing task!");
		_ERROR_LOG(errMsg);
		SetPointStatus("ABORTED","SetPointMode command failed to be scheduled!",true);
		throw;
	}	
	catch(...){
		std::string errMsg("Unknown C++ exception occurred while executing indexing task!");
		_ERROR_LOG(errMsg);	
		SetPointStatus("ABORTED","SetPointMode command failed to be scheduled!",true);
		throw;
	}

	//Set reply 
	argout->svalue[0] = CORBA::string_dup("SetPointMode command scheduled");	
	argout->lvalue[0] = 1;

	/*----- PROTECTED REGION END -----*/	//	DSEmulator::set_point_mode
	return argout;
}
//--------------------------------------------------------
/**
 *	Command Stow related method
 *	Description: Stow the antenna and apply brakes
 *
 *	@returns == Long field ==
 *           [0]: ack code (0=OK, 1=QUEUED, 2=FAILED)
 *           
 *           == String field ==
 *           [0]: Informative message or error/fault description
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *DSEmulator::stow()
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "DSEmulator::Stow()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DSEmulator::stow) ENABLED START -----*/
	
	//	Add your own code
	// == COMMAND BEHAVIOR ==
	// 1) Check if cmd mode-allowed {"STOW","STANDBY","POINT","MAINTENANCE","ESTOP"} (DONE IN STATE MACHINE)
	// 2) If powerState=LOW remove brakes and turn drives on
	// 3) Set mode to STOW
	// 4) Disable drives, apply brakes and set powerState=LOW (if powerState was FULL)

	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string mode_attr_name= "operatingMode";
	std::string mode_str= "STOW";
	//###########################################################################

	_INFO_LOG("Stow command requested...");

	//Init output attribute
	argout= new Tango::DevVarLongStringArray;
	argout->svalue.length(1);
	argout->lvalue.length(1);

	//=====================================================
	//==         CHECK IF CMD ALLOWED
	//=====================================================
	_DEBUG_LOG("Check if cmd "<<__FUNCTION__<<" is allowed...");
	bool check_cmd= true;
	try {
		IsCmdAllowed(__FUNCTION__,check_cmd);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		throw;
	}

	//=====================================================
	//==         CHECK IF TASK IS ALREADY RUNNING
	//=====================================================
	_DEBUG_LOG("Check if a previous Stow task is already running...");
	if( strcmp(attr_stowProgress_read[0],"RUNNING")==0  || strcmp(attr_stowProgress_read[0],"IDLE")==0 ){
		std::stringstream ss;
		ss<<"Another Stow task is running or waiting for execution in device!";
		_INFO_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("STOW_FAILED",ss.str());
	}

	//=====================================================
	//==         CHECK MODE & POWER
	//=====================================================
	//Retrieve current mode attr value
	Tango::DevShort current_mode;
	if(GetDynAttrValue(current_mode,mode_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<mode_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("STOW_FAILED",ss.str());	
	}

	//Get string label
	std::string current_mode_str= "";
	Utils_ns::TangoUtils::GetEnumAttrLabelValue(current_mode_str,this,mode_attr_name,current_mode);


	//Check if same mode is given
	if(mode_str==current_mode_str){
		_INFO_LOG("Mode "<<mode_str<<" is already selected, nothing to be done");
		SetStowStatus("COMPLETED","Stow mode already active",true);

		argout->svalue[0] = CORBA::string_dup("Stow mode already active");	
		argout->lvalue[0] = 0;
		return argout;
	}	


	//=====================================================
	//==    STOW TASK (PERFORMED IN TRACKING THREAD)
	//=====================================================
	_INFO_LOG("Stow task being scheduled...");

	//Disable tracking
	_INFO_LOG("Disabling tracking to stop existing tracking/slewing tasks...");
	m_trackingThread->DisableTracking();

	//Clear tracking queue
	_INFO_LOG("Clearing tracking queue ...");
	m_pntSchedule->FlushQueue();

	//Add stow pointing coord to tracking queue
	_INFO_LOG("Adding stow coordinates in tracking queue ...");
	PointingDataPtr pData= std::make_shared<PointingData>(stowAzimuthPos,stowElevationPos,-1,PointingData::eSTOW);
	if(m_pntSchedule->Push(pData)<0){//failed to add data to queue
		std::string errMsg("Failed to add stow pointing coords to queue!");
		_ERROR_LOG(errMsg);
		SetStowStatus("ABORTED","Stow command failed to be scheduled!",true);
		_THROW_TANGO_EXCEPTION("STOW_FAILED",errMsg);
	}
			
	//Enable tracking
	_INFO_LOG("Enable tracking to start stow slewing ...");
	m_trackingThread->EnableTracking();
	

	/*
	//=====================================================
	//==    STOW TASK (PERFORMED IN TASK THREAD)
	//=====================================================
	_INFO_LOG("Stow task being scheduled...");

	//Prepare message data
	StowMsg msg_data;
	msg_data.task_duration= stowTime;
	msg_data.enable_failure= enableStowFailure;
	msg_data.failure_probability= stowFailureProbability;

	//Init status attr
	SetStowStatus("IDLE","Stow command requested",true);
	
	//Post configure message to queue
	bool isSynchronous= false;
	try {	
		m_task->execute_stow(msg_data, isSynchronous);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		std::string errMsg("Tango exception occurred while executing stow task!");
		_ERROR_LOG(errMsg);
		SetStowStatus("ABORTED","Stow command failed to be scheduled!",true);
		throw;
	}	
	catch(...){
		std::string errMsg("Unknown C++ exception occurred while executing stow task!");
		_ERROR_LOG(errMsg);	
		SetStowStatus("ABORTED","Stow command failed to be scheduled!",true);
		throw;
	}
	*/

	//Set reply 
	argout->svalue[0] = CORBA::string_dup("Stow command scheduled");	
	argout->lvalue[0] = 1;

	/*----- PROTECTED REGION END -----*/	//	DSEmulator::stow
	return argout;
}
//--------------------------------------------------------
/**
 *	Command SetMaintenanceMode related method
 *	Description: Activate maintenance mode
 *
 */
//--------------------------------------------------------
void DSEmulator::set_maintenance_mode()
{
	DEBUG_STREAM << "DSEmulator::SetMaintenanceMode()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DSEmulator::set_maintenance_mode) ENABLED START -----*/
	
	//	Add your own code
	// == COMMAND BEHAVIOR ==
	// 1) Check if cmd mode-allowed {"STANDBY-LP","MAINTENANCE","STANDBY-FP","STOW"} (DONE IN STATE MACHINE)
	// 2) Check if mode transition allowed {"STANDBY-LP","MAINTENANCE","STANDBY-FP","STOW"}-->"MAINTENANCE" (DONE IN STATE MACHINE)
	// 3) Leave power state unchanged
	// 4) Set mode to MAINTENANCE

	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string mode_attr_name= "operatingMode";
	std::string powerState_attr_name= "powerState";
	std::string mode_str= "MAINTENANCE"; 
	//===========================================================================

	_INFO_LOG("Setting DS to MAINTENANCE mode...");

	//=====================================================
	//==      CHECK CURRENT MODE
	//=====================================================
	//Retrieve mode value corresponding to label
	Tango::DevShort mode;
	Utils_ns::TangoUtils::GetEnumAttrValue(mode,this,mode_attr_name,mode_str);

	//Get current mode
	Tango::DevShort mode_current;	
	if(GetDynAttrValue(mode_current,mode_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<mode_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_MAINTENANCE_MODE_FAILED",ss.str());	
	}	

	//Check if maintenance mode is already active	
	if(mode==mode_current){
		_INFO_LOG("Mode "<<mode_str<<" already active, nothing to be done");
		return;
	}
	
	//=====================================================
	//==        SET MODE
	//=====================================================
	//Set mode to MAINTENANCE
	if(SetSMDynAttrValue(mode,mode_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<mode_attr_name<<" to "<<mode_str<<"!";
		_ERROR_LOG(ss.str());	
		_THROW_TANGO_EXCEPTION("SET_MAINTENANCE_MODE_FAILED",ss.str());	
	}
	
	/*----- PROTECTED REGION END -----*/	//	DSEmulator::set_maintenance_mode
}
//--------------------------------------------------------
/**
 *	Command SetIndexPosition related method
 *	Description: Set indexer to given position. 
 *               
 *               Command may take at maximum 30 seconds to transition 
 *               from the two most extreme positions (see requirements)
 *               
 *               Only allowed in modes {STOW, STANDBY, POINT} (see requirements)
 *
 *	@param argin Indexer position [1-5]
 *	@returns == Long field ==
 *           [0]: ack code (0=OK, 1=QUEUED, 2=FAILED)
 *           
 *           == String field ==
 *           [0]: Informative message or error/fault description
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *DSEmulator::set_index_position(Tango::DevShort argin)
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "DSEmulator::SetIndexPosition()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DSEmulator::set_index_position) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string indexerPosition_attr_name= "indexerPosition";
	std::vector<std::string> indexerPosition_values {"B1","B2","B3","B4","B5","MOVING"};
	//===========================================================================

	_INFO_LOG("Requested to set indexer position to "<<argin<<"...");

	//Init output attribute
	argout= new Tango::DevVarLongStringArray;
	argout->svalue.length(1);
	argout->lvalue.length(1);

	//=====================================================
	//==         CHECK IF CMD ALLOWED
	//=====================================================
	_DEBUG_LOG("Check if cmd "<<__FUNCTION__<<" is allowed...");
	bool check_cmd= true;
	try {
		IsCmdAllowed(__FUNCTION__,check_cmd);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		throw;
	}

	//=====================================================
	//==         CHECK IF TASK IS ALREADY RUNNING
	//=====================================================
	_DEBUG_LOG("Check if a previous indexing task is already running...");
	if( strcmp(attr_indexingProgress_read[0],"RUNNING")==0  || strcmp(attr_indexingProgress_read[0],"IDLE")==0 ){
		std::stringstream ss;
		ss<<"Another Indexing task is running or waiting for execution in device!";
		_INFO_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_INDEX_POSITION_FAILED",ss.str());
	}


	//=====================================================
	//==      CHECK CURRENT INDEXER POSITION 
	//=====================================================
	
	//Get current indexer position
	Tango::DevShort indexerPosition_current;	
	if(GetDynAttrValue(indexerPosition_current,indexerPosition_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<indexerPosition_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_INDEX_POSITION_FAILED",ss.str());	
	}	
	
	//Check if same position is given
	//if(argin==indexerPosition_current+1){	
	if(argin==indexerPosition_current){
		std::stringstream ss;	
		ss<<"Indexer position "<<argin<<" is already selected";
		_INFO_LOG(ss.str());
		SetIndexingStatus("COMPLETED",ss.str(),true);

		argout->svalue[0] = CORBA::string_dup(ss.str().c_str());	
		argout->lvalue[0] = 0;
		return argout;
	}	


	//=====================================================
	//==    MOVE INDEXER TASK (PERFORMED IN TASK THREAD)
	//=====================================================

	_INFO_LOG("Scheduling indexing task...");

	//Prepare message data
	MoveIndexerMsg msg_data;
	msg_data.task_duration= indexingTime;
	msg_data.enable_failure= enableIndexingFailure;
	msg_data.failure_probability= indexingFailureProbability;
	msg_data.indexer_position= argin;//argin-1;

	//Init status attr
	SetIndexingStatus("IDLE","Indexing command being scheduled...",true);
	
	//Post configure message to queue
	bool isSynchronous= false;
	try {	
		m_task->execute_move_indexer(msg_data, isSynchronous);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		std::string errMsg("Tango exception occurred while executing indexing task!");
		_ERROR_LOG(errMsg);
		SetIndexingStatus("ABORTED","Indexing command failed to be scheduled!",true);
		throw;
	}	
	catch(...){
		std::string errMsg("Unknown C++ exception occurred while executing indexing task!");
		_ERROR_LOG(errMsg);	
		SetIndexingStatus("ABORTED","Indexing command failed to be scheduled!",true);
		throw;
	}

	//Set reply 
	argout->svalue[0] = CORBA::string_dup("Indexing command scheduled");	
	argout->lvalue[0] = 1;

	/*----- PROTECTED REGION END -----*/	//	DSEmulator::set_index_position
	return argout;
}
//--------------------------------------------------------
/**
 *	Command SimulatePowerCut related method
 *	Description: Simulate power cut in Dish
 *
 */
//--------------------------------------------------------
void DSEmulator::simulate_power_cut()
{
	DEBUG_STREAM << "DSEmulator::SimulatePowerCut()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DSEmulator::simulate_power_cut) ENABLED START -----*/
	
	//	Add your own code
	//##### EXPECTED BEHAVIOR ########
	//1) Set powerState=UPS
	//2) Set ds to STANDBY-LP mode
	//3) Set powerCut=1 and notify LMC
	//4) Stow dish
	//################################	

	//================================================
	//==           HARD CODED VALUES
	//================================================
	std::string attr_name= "powerCut";
	std::string powerState_attr_name= "powerState";
	std::string powerState_str= "UPS";
	//================================================

	//=====================================================
	//==         CHECK IF CMD ALLOWED
	//=====================================================
	_DEBUG_LOG("Check if cmd "<<__FUNCTION__<<" is allowed...");
	bool check_cmd= true;
	try {
		IsCmdAllowed(__FUNCTION__,check_cmd);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		throw;
	}

	//=====================================================
	//==    SHUTDOWN TASK (PERFORMED IN TASK THREAD)
	//=====================================================

	_INFO_LOG("Scheduling Shutdown task...");

	//Prepare message data
	ShutdownMsg msg_data;
	msg_data.task_duration= setModeTime;
	msg_data.shutdown_time= shutdownTime;
	msg_data.enable_failure= enableSetModeFailure;
	msg_data.failure_probability= setModeFailureProbability;	
	
	
	//Post configure message to queue
	bool isSynchronous= false;
	try {	
		m_task->execute_shutdown(msg_data, isSynchronous);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		std::string errMsg("Tango exception occurred while executing shutdown task!");
		_ERROR_LOG(errMsg);
		throw;
	}	
	catch(...){
		std::string errMsg("Unknown C++ exception occurred while executing shutdown task!");
		_ERROR_LOG(errMsg);	
		throw;
	}


	/*
	//================================================
	//==           CHECK CURRENT POWER CUT
	//================================================
	//## Check is power cut is already active
	if(*attr_powerCut_read==true){
		_WARN_LOG("Power cut is already active, nothing to be done!");
		return;
	}
	_INFO_LOG("Dish power cut, starting safe actions!!!");

	//================================================
	//==           SET POWER STATE TO UPS
	//================================================
	//## Set powerState to UPS
	//Retrieve mode value corresponding to label
	Tango::DevShort powerState;
	Utils_ns::TangoUtils::GetEnumAttrValue(powerState,this,powerState_attr_name,powerState_str);

	//Set dyn attr value
	if(SetDynAttrValue(powerState,powerState_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<powerState_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SIMULATE_POWER_CUT_FAILED",ss.str());	
	}	
	
	//================================================
	//==           SET DS MODE TO STANDBY-LP
	//================================================
	//## Switch ds mode to STANDBY-LP
	_INFO_LOG("Setting ds to STANDBY-LP mode...");
	try{	
		set_standby_lpmode();
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		throw;
	}

	//================================================
	//==           SET POWER CUT
	//================================================
	//## Set powerCut=1 and push event
	*attr_powerRestored_read= false;	
	*attr_powerCut_read= true;

	//================================================
	//==           STOW DISH
	//================================================
	//## Stow the dish
	try{
		stow();
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Tango exception occurred while stowing the dish!");
		throw;
	}
	*/
	/*----- PROTECTED REGION END -----*/	//	DSEmulator::simulate_power_cut
}
//--------------------------------------------------------
/**
 *	Command SimulatePowerRestore related method
 *	Description: Simulate power restoring in Dish
 *
 */
//--------------------------------------------------------
void DSEmulator::simulate_power_restore()
{
	DEBUG_STREAM << "DSEmulator::SimulatePowerRestore()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DSEmulator::simulate_power_restore) ENABLED START -----*/
	
	//	Add your own code
	//##### EXPECTED BEHAVIOR ########
	//1) Set powerState=LOW-POWER
	//2) Set powerCut=0
	//3) Set powerRestored=1 and notify LMC
	//################################	

	//================================================
	//==           HARD CODED VALUES
	//================================================
	std::string attr_name= "powerRestored";		
	std::string powerState_attr_name= "powerState";
	std::string powerState_str= "LOW-POWER";
	//================================================

	//================================================
	//==           CHECK CURRENT POWER CUT
	//================================================
	//## Check is power restored is already active
	if(*attr_powerRestored_read==true){
		_WARN_LOG("Power restored is already active, nothing to be done!");
		return;
	}
	_INFO_LOG("Dish power was restored, notify LMC...");
	
	//================================================
	//==           SET POWER STATE TO LOW-POWER
	//================================================
	//## Set powerState to LOW-POWER
	//Retrieve mode value corresponding to label
	Tango::DevShort powerState;
	Utils_ns::TangoUtils::GetEnumAttrValue(powerState,this,powerState_attr_name,powerState_str);

	//Set dyn attr value
	if(SetDynAttrValue(powerState,powerState_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<powerState_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SIMULATE_POWER_RESTORE_FAILED",ss.str());	
	}	

	//================================================
	//==           SET POWER RESTORE
	//================================================
	//## Set powerCut=0 
	*attr_powerCut_read= false;

	//## Set powerRestored=1 and push event
	*attr_powerRestored_read= true;

	/*
	std::vector<std::string> filt_names;
	std::vector<double> filt_vals;
	bool release = false;
	
	try{
		push_event(attr_name,filt_names,filt_vals,attr_powerRestored_read,1,0,release);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);	
		_ERROR_LOG("Tango exception occurred while pushing "<<attr_name<<" event!");
		throw;
	}
	*/
	
	/*----- PROTECTED REGION END -----*/	//	DSEmulator::simulate_power_restore
}
//--------------------------------------------------------
/**
 *	Command SimulateESTOP related method
 *	Description: Simulate emergency stop scenario in antenna
 *
 */
//--------------------------------------------------------
void DSEmulator::simulate_estop()
{
	DEBUG_STREAM << "DSEmulator::SimulateESTOP()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DSEmulator::simulate_estop) ENABLED START -----*/
	
	//	Add your own code
	//##### EXPECTED BEHAVIOR ########
	//1) Stop/disable tracking
	//2) Set mode=ESTOP
	//3) Set ESTOP flag
	//################################	

	//================================================
	//==           HARD CODED VALUES
	//================================================
	std::string mode_attr_name= "operatingMode";
	std::string mode_str= "ESTOP";
	//================================================


	//================================================
	//==           CHECK CURRENT MODE
	//================================================
	//Get current mode
	Tango::DevShort mode_current;
	if(GetDynAttrValue(mode_current,mode_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<mode_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SIMULATE_ESTOP_FAILED",ss.str());	
	}	

	//Retrieve mode string corresponding to value
	std::string modeStr_current;
	Utils_ns::TangoUtils::GetEnumAttrLabelValue(modeStr_current,this,mode_attr_name,mode_current);

	//Check is ESTOP is already active
	if(modeStr_current==mode_str){
		_INFO_LOG("ESTOP is already active, nothing to be done!");
		return;
	}
	_INFO_LOG("ESTOP was pressed, notify LMC...");

	//================================================
	//==           DISABLE TRACKING
	//================================================
	//Disable tracking
	_INFO_LOG("Disabling tracking to stop existing tracking/slewing tasks...");
	m_trackingThread->DisableTracking();

	//Clear tracking queue (TBD)
	_INFO_LOG("Clearing tracking queue ...");
	m_pntSchedule->FlushQueue();

	//================================================
	//==           SET ESTOP MODE
	//================================================
	//## Set mode to ESTOP
	//Retrieve mode value corresponding to label
	Tango::DevShort mode;
	Utils_ns::TangoUtils::GetEnumAttrValue(mode,this,mode_attr_name,mode_str);

	//Set dyn attr value
	if(SetDynAttrValue(mode,mode_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<mode_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SIMULATE_ESTOP_FAILED",ss.str());	
	}	


	/*
	//================================================
	//==           SET ESTOP FLAG
	//================================================
	//## Set estop=1
	*attr_estop_read= true;

		
	//## Push estop event?
	std::vector<std::string> filt_names;
	std::vector<double> filt_vals;
	bool release = false;

	try{
		push_event(attr_name,filt_names,filt_vals,attr_estop_read,1,0,release);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);	
		_ERROR_LOG("Tango exception occurred while pushing "<<attr_name<<" event!");
		throw;
	}
	*/

	/*----- PROTECTED REGION END -----*/	//	DSEmulator::simulate_estop
}
//--------------------------------------------------------
/**
 *	Command GetTrackProgram related method
 *	Description: Returns a list of string with track program info
 *
 *	@returns List of track program items
 */
//--------------------------------------------------------
Tango::DevVarStringArray *DSEmulator::get_track_program()
{
	Tango::DevVarStringArray *argout;
	DEBUG_STREAM << "DSEmulator::GetTrackProgram()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DSEmulator::get_track_program) ENABLED START -----*/
	
	//	Add your own code
	//Check if pnt schedule is instantiated, otherwise throw exception
	if(!m_pntSchedule){
		std::string errMsg("Pointing schedule was not initialized!");
		_WARN_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("GET_TRACK_PROGRAM_INFO_FAILED",errMsg);	
	}

	//Get task info from manager
	std::vector<std::string> info;
	m_pntSchedule->GetQueueInfo(info);
	
	//Fill argout
	argout= new Tango::DevVarStringArray;
	argout->length(info.size());
	for(unsigned int i=0;i<info.size();i++){
		(*argout)[i] = CORBA::string_dup(info[i].c_str());
	}
	/*----- PROTECTED REGION END -----*/	//	DSEmulator::get_track_program
	return argout;
}
//--------------------------------------------------------
/**
 *	Command FlushTrackProgram related method
 *	Description: Flush track program queue
 *
 */
//--------------------------------------------------------
void DSEmulator::flush_track_program()
{
	DEBUG_STREAM << "DSEmulator::FlushTrackProgram()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DSEmulator::flush_track_program) ENABLED START -----*/
	
	//	Add your own code
	//Check if pnt schedule is instantiated, otherwise throw exception
	if(!m_pntSchedule){
		std::string errMsg("Pointing schedule was not initialized!");
		_WARN_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("FLUSH_TRACK_PROGRAM_INFO_FAILED",errMsg);	
	}

	//Remove all entries present in pointing queue
	m_pntSchedule->FlushQueue();

	/*----- PROTECTED REGION END -----*/	//	DSEmulator::flush_track_program
}
//--------------------------------------------------------
/**
 *	Command PauseTracking related method
 *	Description: Disable tracking without removing pointing entries in queue
 *
 */
//--------------------------------------------------------
void DSEmulator::pause_tracking()
{
	DEBUG_STREAM << "DSEmulator::PauseTracking()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DSEmulator::pause_tracking) ENABLED START -----*/
	
	//	Add your own code
	try{
		DisableTracking();
	}
	catch(...){
		throw;
	}
	
	/*----- PROTECTED REGION END -----*/	//	DSEmulator::pause_tracking
}
//--------------------------------------------------------
/**
 *	Command ResumeTracking related method
 *	Description: Resume/enable tracking using current pointings available in queue
 *
 */
//--------------------------------------------------------
void DSEmulator::resume_tracking()
{
	DEBUG_STREAM << "DSEmulator::ResumeTracking()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DSEmulator::resume_tracking) ENABLED START -----*/
	
	//	Add your own code
	try{
		EnableTracking();
	}
	catch(...){
		throw;
	}

	/*----- PROTECTED REGION END -----*/	//	DSEmulator::resume_tracking
}
//--------------------------------------------------------
/**
 *	Command ResetProgressAttrs related method
 *	Description: Reset all progress attributes to INIT state.
 *               
 *               NB: This command serves to solve spurious deadlocks 
 *               found in task management. In this situation the progress 
 *               attribute remains stuck to RUNNING state and no other 
 *               tasks can be scheduled if not reset. Need to fix this bug!
 *
 */
//--------------------------------------------------------
void DSEmulator::reset_progress_attrs()
{
	DEBUG_STREAM << "DSEmulator::ResetProgressAttrs()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DSEmulator::reset_progress_attrs) ENABLED START -----*/
	
	//	Add your own code
	SetStowStatus("INIT","Stowing task progress info was reset",false);
	SetIndexingStatus("INIT","Indexing task progress info was reset",false);
	SetStandbyLPStatus("INIT","SetStandbyLPMode task info was reset",false);
	SetStandbyFPStatus("INIT","SetStandbyFPMode task info was reset",false);
	SetPointStatus("INIT","SetPointMode task info was reset",false);

	/*----- PROTECTED REGION END -----*/	//	DSEmulator::reset_progress_attrs
}
//--------------------------------------------------------
/**
 *	Command ResetPowerCutAttrs related method
 *	Description: Reset power cut attributes to false
 *
 */
//--------------------------------------------------------
void DSEmulator::reset_power_cut_attrs()
{
	DEBUG_STREAM << "DSEmulator::ResetPowerCutAttrs()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DSEmulator::reset_power_cut_attrs) ENABLED START -----*/
	
	//	Add your own code
	_INFO_LOG("Resetting power cut attributes ...");
	*attr_powerCut_read= false;
	*attr_powerRestored_read= false;
	
	/*----- PROTECTED REGION END -----*/	//	DSEmulator::reset_power_cut_attrs
}
//--------------------------------------------------------
/**
 *	Command dummyDynCmd related method
 *	Description: 
 *
 */
//--------------------------------------------------------
void DSEmulator::dummy_dyn_cmd(Tango::Command &command)
{
	DEBUG_STREAM << "DSEmulator::" << command.get_name() << "  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DSEmulator::dummy_dyn_cmd) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	DSEmulator::dummy_dyn_cmd
}
//--------------------------------------------------------
/**
 *	Method      : DSEmulator::add_dynamic_commands()
 *	Description : Create the dynamic commands if any
 *                for specified device.
 */
//--------------------------------------------------------
void DSEmulator::add_dynamic_commands()
{
	//	Example to add dynamic command:
	//	Copy inside the folowing protected area to instanciate at startup.
	//	add_dummyDynCmd_dynamic_command("MydummyDynCmdCommand", true);
	
	/*----- PROTECTED REGION ID(DSEmulator::add_dynamic_commands) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic commands if any
	LMCDevice::add_dynamic_commands();
	/*----- PROTECTED REGION END -----*/	//	DSEmulator::add_dynamic_commands
}

/*----- PROTECTED REGION ID(DSEmulator::namespace_ending) ENABLED START -----*/

//	Additional Methods
int DSEmulator::InitCmdAttrStateMachine(){
	
	//========================================
	//==   CMD RULES
	//========================================
	//- SetMaintenanceMode()
	_REGISTER_CMD_RULE(std::string,"SetMaintenanceMode","operatingMode",("STANDBY-LP","STANDBY-FP","POINT","MAINTENANCE","STOW"));
	
	//- Stow()
	_REGISTER_CMD_RULE(std::string,"Stow","operatingMode",("STOW","STANDBY-LP","STANDBY-FP","POINT","MAINTENANCE","ESTOP"));
	
	//- SetPointMode()
	_REGISTER_CMD_RULE(std::string,"SetPointMode","operatingMode",("STANDBY-FP","POINT","STOW"));
	
	//- SetStandbyLPMode() (ALL MODES ALLOWED)
	_REGISTER_CMD_RULE(std::string,"SetStandbyLPMode","operatingMode",("STANDBY-LP","STANDBY-FP","POINT","STOW","ESTOP","MAINTENANCE","STARTUP"));
	
	//- SetStandbyFPMode() 
	_REGISTER_CMD_RULE(std::string,"SetStandbyFPMode","operatingMode",("STANDBY-FP","STANDBY-LP","POINT","STOW","MAINTENANCE"));
	
	//- SetIndexPosition()
	//_REGISTER_CMD_RULE(std::string,"SetIndexPosition","operatingMode",("STANDBY-LP","STANDBY-FP","POINT","STOW"));
	_REGISTER_CMD_RULE(std::string,"SetIndexPosition","operatingMode",("STANDBY-FP","POINT","STOW"));
	

	//- SimulateESTOP()
	_REGISTER_CMD_RULE(bool,"SimulateESTOP","testMode",(true));
	
	//- SimulatePowerCut()
	_REGISTER_CMD_RULE(bool,"SimulatePowerCut","testMode",(true));
	
	//- SimulatePowerRestore()
	_REGISTER_CMD_RULE(bool,"SimulatePowerRestore","testMode",(true));
	

	//========================================
	//==   ATTR TRANSITION RULES
	//========================================
	//- operatingMode	
	_REGISTER_ATTR_RULE(std::string,"operatingMode","STARTUP",("STARTUP","STANDBY-LP","ESTOP"));
	_REGISTER_ATTR_RULE(std::string,"operatingMode","STANDBY-LP",("STANDBY-LP","STANDBY-FP","STOW","POINT","MAINTENANCE","ESTOP"));
	_REGISTER_ATTR_RULE(std::string,"operatingMode","POINT",("POINT","STANDBY-LP","STANDBY-FP","MAINTENANCE","STOW","ESTOP"));//Added STANDBY-LP (20 Apr 2018)
	_REGISTER_ATTR_RULE(std::string,"operatingMode","MAINTENANCE",("MAINTENANCE","STANDBY-LP","STANDBY-FP","STOW","ESTOP"));

	//========================================
	//==   ATTR WRITE RULES
	//========================================
	_REGISTER_ATTR_WRITE_RULE(bool,"azimuthOverWrap","testMode",(true));	
	_REGISTER_ATTR_WRITE_RULE(bool,"targetLock","testMode",(true));	
	_REGISTER_ATTR_WRITE_RULE(bool,"antennaAzPosition","testMode",(true));	
	_REGISTER_ATTR_WRITE_RULE(bool,"antennaElPosition","testMode",(true));	
	_REGISTER_ATTR_WRITE_RULE(bool,"pointingState","testMode",(true));	
	_REGISTER_ATTR_WRITE_RULE(bool,"healthState","testMode",(true));	
	_REGISTER_ATTR_WRITE_RULE(bool,"interfaceType","testMode",(true));	
	_REGISTER_ATTR_WRITE_RULE(bool,"indexerPosition","testMode",(true));	
	_REGISTER_ATTR_WRITE_RULE(bool,"powerState","testMode",(true));	
	_REGISTER_ATTR_WRITE_RULE(bool,"operatingMode","testMode",(true));	
	


	return 0;

}//close InitCmdAttrStateMachine()

int DSEmulator::RegisterProxies(){

	//## Register device proxies
	_DEBUG_LOG("Registering device proxies for device "<<device_name<<"...");
	
	
	return 0;

}//close RegisterProxies()

int DSEmulator::RegisterEventSubscriptions(){

	//## Register proxy events 
	_DEBUG_LOG("Registering event subscription for device "<<device_name<<"...");
	
	// Tango::CHANGE_EVENT
	// Tango::PERIODIC_EVENT
	// Tango::ARCHIVE_EVENT
	// Tango::ATTR_CONF_EVENT
	// Tango::DATA_READY_EVENT
	// Tango::USER_EVENT
	// Tango::INTERFACE_CHANGE_EVENT,		///< Device interface change event
	// Tango::PIPE_EVENT,					///< Device pipe event
	

	return 0;

}//close RegisterEventSubscriptions()

int DSEmulator::RegisterEventHandlers(){

	//## Register event handlers

	return 0;

}//close RegisterEventHandlers()


int DSEmulator::InitTask(){

	//## Initialize device task
	_DEBUG_LOG("Initializing device task config...");
	m_task = 0;

	//- Define task configuration
	DSEmulatorTask::Config cfg;
  cfg.task_activity_period_ms = 3000;
  cfg.host_device = this;
	cfg.enable_periodic_msg= false;
    
	//- Allocate and start the device task
	try {
		_INFO_LOG("Initializing device task...");
    m_task = new (std::nothrow) DSEmulatorTask(cfg);
	  if (!m_task){
    	throw std::bad_alloc();
		}

    _INFO_LOG("Starting the task...");
    m_task->go();
	}
  catch (const std::bad_alloc&) {
		std::string errMsg("Device task initialization failed (allocation failed)");
  	_ERROR_LOG(errMsg);
		set_state(Tango::FAULT);
    set_status(errMsg.c_str());
		return -1;
	}
  catch (Tango::DevFailed& e) {
		Tango::Except::print_exception(e);
		std::string errMsg("Device task initialization failed [see device log for details]");
  	_ERROR_LOG(errMsg);
		set_state(Tango::FAULT);
    set_status(errMsg.c_str());
    return -1;
  }
  catch (...) {
  	std::string errMsg("Device task initialization failed [unknown error]");
  	_ERROR_LOG(errMsg);
		set_state(Tango::FAULT);
    set_status(errMsg.c_str());
    return -1;
  }

	return 0;

}//close InitTask()

int DSEmulator::ClearTask(){

	if(!m_task) return 0;

	//## First signal waiting conditions
	m_task->signal_wait();

	//## Release the task: just ask task to quit
	//## NB: Never explicitly delete a yat4tango::DeviceTask
	m_task->exit();
  m_task = 0;

	return 0;

}//close ClearTask

int DSEmulator::Startup(){

	//## Prepare message data
	StartupMsg msg_data;
	msg_data.task_duration= startupTime;
	msg_data.enable_failure= enableStartupFailure;
	msg_data.failure_probability= startupFailureProbability;

	//## Execute DS startup task
	bool isSynchronous= false;
	try {
		_INFO_LOG("Executing DS startup...");
		m_task->execute_startup(msg_data, isSynchronous);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		std::string errMsg("Tango exception occurred while executing DS startup!");
		_ERROR_LOG(errMsg);
		set_state(Tango::FAULT);
    set_status(errMsg.c_str());
    return -1;
	}	
	catch(...){
		std::string errMsg("Unknown C++ exception occurred while adding device to group!");
		_ERROR_LOG(errMsg);	
		set_state(Tango::FAULT);
    set_status(errMsg.c_str());
    return -1;
	}
	
	return 0;

}//close Startup()

void DSEmulator::SetStowStatus(std::string status,std::string info,bool clear){

	//Clear previously allocated string
	//NB: According to Tango doc it is safe to call free even if string is not allocated
	if(clear){
		for(int i=0;i<2;i++){
			CORBA::string_free( *(attr_stowProgress_read+i) );
		}
	}
		
	attr_stowProgress_read[0]= Tango::string_dup(status.c_str());
	attr_stowProgress_read[1]= Tango::string_dup(info.c_str());

}//close SetStowStatus()

void DSEmulator::SetIndexingStatus(std::string status,std::string info,bool clear){

	//Clear previously allocated string
	//NB: According to Tango doc it is safe to call free even if string is not allocated
	if(clear){
		for(int i=0;i<2;i++){
			CORBA::string_free( *(attr_indexingProgress_read+i) );
		}
	}
		
	attr_indexingProgress_read[0]= Tango::string_dup(status.c_str());
	attr_indexingProgress_read[1]= Tango::string_dup(info.c_str());

}//close SetIndexingStatus()


void DSEmulator::SetStandbyLPStatus(std::string status,std::string info,bool clear){

	//Clear previously allocated string
	//NB: According to Tango doc it is safe to call free even if string is not allocated
	if(clear){
		for(int i=0;i<2;i++){
			CORBA::string_free( *(attr_setStandbyLPModeProgress_read+i) );
		}
	}
		
	attr_setStandbyLPModeProgress_read[0]= Tango::string_dup(status.c_str());
	attr_setStandbyLPModeProgress_read[1]= Tango::string_dup(info.c_str());

}//close SetStandbyLPStatus()

void DSEmulator::SetStandbyFPStatus(std::string status,std::string info,bool clear){

	//Clear previously allocated string
	//NB: According to Tango doc it is safe to call free even if string is not allocated
	if(clear){
		for(int i=0;i<2;i++){
			CORBA::string_free( *(attr_setStandbyFPModeProgress_read+i) );
		}
	}
		
	attr_setStandbyFPModeProgress_read[0]= Tango::string_dup(status.c_str());
	attr_setStandbyFPModeProgress_read[1]= Tango::string_dup(info.c_str());

}//close SetStandbyFPStatus()

void DSEmulator::SetPointStatus(std::string status,std::string info,bool clear){

	//Clear previously allocated string
	//NB: According to Tango doc it is safe to call free even if string is not allocated
	if(clear){
		for(int i=0;i<2;i++){
			CORBA::string_free( *(attr_setPointModeProgress_read+i) );
		}
	}
		
	attr_setPointModeProgress_read[0]= Tango::string_dup(status.c_str());
	attr_setPointModeProgress_read[1]= Tango::string_dup(info.c_str());

}//close SetPointStatus()

int DSEmulator::InitTrackingThread(){

	//## Init poitning schedule
	_DEBUG_LOG("Init pointing schedule...");
	m_pntSchedule= 0;
	m_pntSchedule= new PointingSchedule(this);
	m_pntSchedule->SetMaxQueueSize(maxPointingQueueSize);
	m_pntSchedule->UseUTC(useUTCTime);
	
	//## Start the tracking thread
  _DEBUG_LOG("Init tracking thread...");
  m_stopTrackingThreadFlag= false;
	m_trackingThread= 0;
  m_trackingThread = new TrackingThread(this,m_pntSchedule);
  m_trackingThread->Start();

	return 0;

}//close InitTaskThread()


void DSEmulator::DisableTracking(){

	//Check if tracking thread is instantiated, otherwise throw exception
	if(!m_trackingThread){
		std::string errMsg("Tracking thread was not initialized!");
		_WARN_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("DISABLE_TRACKING_FAILED",errMsg);	
	}

	//Disable tracking
	_INFO_LOG("Disabling tracking without canceling existing pointing entries...");
	m_trackingThread->DisableTracking();

}//close DisableTracking()

void DSEmulator::EnableTracking(){

	//Check if tracking thread is instantiated, otherwise throw exception
	if(!m_trackingThread){
		std::string errMsg("Tracking thread was not initialized!");
		_WARN_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("ENABLE_TRACKING_FAILED",errMsg);	
	}

	//Enable tracking
	_INFO_LOG("Enabling tracking ...");
	m_trackingThread->EnableTracking();

}//close EnableTracking()


int DSEmulator::CorrectPointingDataList(std::vector<PointingDataPtr>& pDataList){

	//==========================================
	//         HARD_CODED VALUES
	//==========================================
	std::string corrPars_attr_name= "pointingModelParams";
	int nPars= 9;
	//==========================================

	//## Check list
	if(pDataList.empty()){
		_WARN_LOG("Given pointing data list is empty, nothing to be done...");
		return 0;
	}

	//## Read correction pars
	std::vector<float> corrPars;
	if(GetDynAttrValue(corrPars,corrPars_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<corrPars_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		return -1;
	}
	
	if(corrPars.size()<nPars){
		_ERROR_LOG("Invalid number of correction pars read (shall be equal to "<<nPars<<", no correction will be applied!");
		return -1;
	}
	
	//## Loop data and correct
	for(size_t i=0;i<pDataList.size();i++) CorrectPointingData(pDataList[i],corrPars);

	return 0;

}//close CorrectPointingDataList()


void DSEmulator::CorrectPointingData(PointingDataPtr pData,const std::vector<float>& p){

	//===================================================
	// Correction formulas taken from: 
	//    Deconstructing a pointing model for the 40M OAN radiotelescope
	//    P. de Vicente, A. Barcia
	//    Informe Técnico IT-OAN 2007-26
	//====================================================
	double Az= pData->az;
	double El= pData->el;
	double Az_r= deg2rad(Az);
	double El_r= deg2rad(El);
	
	double dAz= p[0] + p[1]/cos(El_r) + p[2]*tan(El_r) + p[3]*tan(El_r)*cos(Az_r) + p[4]*tan(El_r)*sin(Az_r) + p[5]*sin(Az_r); 
	double dEl= p[6] - p[3]*sin(Az_r) + p[4]*cos(Az_r) + p[7]*cos(El_r) + p[8]*sin(El_r) + p[5]*cos(Az_r)*sin(El_r);

	//## CHECK IN ICD IF CORRECTION PARS ARE GIVEN IN DEGREES	
	double Az_corr= Az + dAz;
	double El_corr= El + dEl;

	pData->az= Az_corr;	
	pData->el= El_corr;

}//close CorrectPointingData()




// //--------------------------------------------------------
// /**
//  *	Command PushPowerCutEvent related method
//  *	Description: Push power cut event periodicalyl (only if power cut is 
//  *               active)
//  *
//  */
// //--------------------------------------------------------
// void DSEmulator::push_power_cut_event()
// {
// 	DEBUG_STREAM << "DSEmulator::PushPowerCutEvent()  - " << device_name << endl;
// 	
// 	//	Add your own code
// 	//If power cut is active push event manually
// 	std::string attr_name= "powerCut";
// 	if(*attr_powerCut_read==false) return;
// 	_INFO_LOG("Pushing "<<attr_name<<" event!");
// 	std::vector<std::string> filt_names;
// 	std::vector<double> filt_vals;
// 	bool release = false;
// 		
// 	try{
// 		push_event(attr_name,filt_names,filt_vals,attr_powerCut_read,1,0,release);
// 	}
// 	catch(Tango::DevFailed& e){
// 		Tango::Except::print_exception(e);	
// 		_ERROR_LOG("Tango exception occurred while pushing "<<attr_name<<" event!");
// 	}
// }

// //--------------------------------------------------------
// /**
//  *	Command PushPowerRestoredEvent related method
//  *	Description: Push power restored event (only if active)
//  *
//  */
// //--------------------------------------------------------
// void DSEmulator::push_power_restored_event()
// {
// 	DEBUG_STREAM << "DSEmulator::PushPowerRestoredEvent()  - " << device_name << endl;
// 	
// 	//	Add your own code
// 	//If power restore is active push event manually
// 	std::string attr_name= "powerRestored";
// 	if(*attr_powerRestored_read==false) return;
// 	_INFO_LOG("Pushing "<<attr_name<<" event!");
// 	std::vector<std::string> filt_names;
// 	std::vector<double> filt_vals;
// 	bool release = false;
// 		
// 	try{
// 		push_event(attr_name,filt_names,filt_vals,attr_powerRestored_read,1,0,release);
// 	}
// 	catch(Tango::DevFailed& e){
// 		Tango::Except::print_exception(e);	
// 		_ERROR_LOG("Tango exception occurred while pushing "<<attr_name<<" event!");
// 	}
// }

// //--------------------------------------------------------
// /**
//  *	Command PushESTOPEvent related method
//  *	Description: Push ESTOP event (only if active)
//  *
//  */
// //--------------------------------------------------------
// void DSEmulator::push_estopevent()
// {
// 	DEBUG_STREAM << "DSEmulator::PushESTOPEvent()  - " << device_name << endl;
// 	
// 	//	Add your own code
// 	//If ESTOP is active push event manually
// 	std::string attr_name= "estop";
// 	if(*attr_estop_read==false) return;
// 	_INFO_LOG("Pushing "<<attr_name<<" event!");
// 	std::vector<std::string> filt_names;
// 	std::vector<double> filt_vals;
// 	bool release = false;
// 		
// 	try{
// 		push_event(attr_name,filt_names,filt_vals,attr_estop_read,1,0,release);
// 	}
// 	catch(Tango::DevFailed& e){
// 		Tango::Except::print_exception(e);	
// 		_ERROR_LOG("Tango exception occurred while pushing "<<attr_name<<" event!");
// 	}	
// }

// //--------------------------------------------------------
// /**
//  *	Read attribute estop related method
//  *	Description: 
//  *
//  *	Data type:	Tango::DevBoolean
//  *	Attr type:	Scalar
//  */
// //--------------------------------------------------------
// void DSEmulator::read_estop(Tango::Attribute &attr)
// {
// 	DEBUG_STREAM << "DSEmulator::read_estop(Tango::Attribute &attr) entering... " << endl;
// 	//	Set the attribute value
// 	attr.set_value(attr_estop_read);
// 	
// }

// //--------------------------------------------------------
// /**
//  *	Command ResetAfterESTOP related method
//  *	Description: Reset DS after an ESTOP conditions. This command is to 
//  *               emulate what an operator would do after ESTOP and to
//  *               reset DS to a usable condition (e.g. for testing).
//  *               The command will:
//  *               
//  *               - Set DS to STANDBY-LP mode
//  *
//  */
// //--------------------------------------------------------
// void DSEmulator::reset_after_estop()
// {
// 	DEBUG_STREAM << "DSEmulator::ResetAfterESTOP()  - " << device_name << endl;
// 	
// 	//	Add your own code
// 	
// 	
// }


/*----- PROTECTED REGION END -----*/	//	DSEmulator::namespace_ending
} //	namespace
