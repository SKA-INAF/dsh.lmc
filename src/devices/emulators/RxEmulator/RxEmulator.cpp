/*----- PROTECTED REGION ID(RxEmulator.cpp) ENABLED START -----*/
static const char *RcsId = "$Id:  $";
//=============================================================================
//
// file :        RxEmulator.cpp
//
// description : C++ source for the RxEmulator class and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               RxEmulator are implemented in this file.
//
// project :     RxEmulator
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
// $Author:  $
//
// $Revision:  $
// $Date:  $
//
// $HeadURL:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <RxEmulator.h>
#include <RxEmulatorClass.h>
#include <RxEmulatorTask.h>

#include <TangoUtils.h>

#include <map>
#include <utility>

/*----- PROTECTED REGION END -----*/	//	RxEmulator.cpp

/**
 *  RxEmulator class description:
 *    RxEmulator
 */

//================================================================
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name            |  Method name
//================================================================
//  State                   |  Inherited (no method)
//  Status                  |  Inherited (no method)
//  InitializeLoggers       |  Inherited (no method)
//  Synchronise             |  synchronise
//  ConfigureBand           |  configure_band
//  ConfigureBand1          |  configure_band1
//  ConfigureBand2          |  configure_band2
//  ConfigureBand3          |  configure_band3
//  ConfigureBand4          |  configure_band4
//  ConfigureBand5a         |  configure_band5a
//  ConfigureBand5b         |  configure_band5b
//  ConfigureBandAsync      |  configure_band_async
//  CaptureData             |  capture_data
//  SetSubElementMode       |  set_sub_element_mode
//  InitializeFwdAttrs      |  Inherited (no method)
//  RandomizeDynAttrs       |  Inherited (no method)
//  SetSubElementModeStr    |  set_sub_element_mode_str
//  SetStandbyLPMode        |  set_standby_lpmode
//  SetStandbyFPMode        |  set_standby_fpmode
//  SetMaintenanceMode      |  set_maintenance_mode
//  InitializeDevProxies    |  Inherited (no method)
//  GetRegisteredProxies    |  Inherited (no method)
//  GetRegisteredEvents     |  Inherited (no method)
//  InitializeAttrFormulas  |  Inherited (no method)
//  GetRegisteredFormulas   |  Inherited (no method)
//  GetInitializedFormulas  |  Inherited (no method)
//  GetNRunningTasks        |  Inherited (no method)
//  GetNQueuedTasks         |  Inherited (no method)
//  GetNIdleTasks           |  Inherited (no method)
//  GetNTasks               |  Inherited (no method)
//  GetNFailedTasks         |  Inherited (no method)
//  GetNTotFailedTasks      |  Inherited (no method)
//  IsTaskQuotaReached      |  Inherited (no method)
//  FlushTaskQueue          |  Inherited (no method)
//  GetQueuedTaskInfo       |  Inherited (no method)
//  GetTaskInfo             |  Inherited (no method)
//  ClearTasks              |  Inherited (no method)
//  InitializeFormulas      |  Inherited (no method)
//  UpdateStatusAttrs       |  Inherited (no method)
//  MonitorProxies          |  Inherited (no method)
//  UpdateFormulaAttrs      |  Inherited (no method)
//  RevokeTask              |  Inherited (no method)
//  GetFormulaData          |  Inherited (no method)
//  EnableEngineeringMode   |  enable_engineering_mode
//  UpdateFirmware          |  update_firmware
//  SetHighPowerState       |  set_high_power_state
//  AdjustPolHAttenuation   |  adjust_pol_hattenuation
//  AdjustPolVAttenuation   |  adjust_pol_vattenuation
//  SendTestLogMsg          |  Inherited (no method)
//  Shutdown                |  shutdown
//  RevokeTaskSequence      |  Inherited (no method)
//================================================================

//================================================================
//  Attributes managed are:
//================================================================
//  loggingLevelCentral       |  Tango::DevLong	Scalar
//  loggingLevelElement       |  Tango::DevLong	Scalar
//  loggingLevelStorage       |  Tango::DevLong	Scalar
//  loggingLevelConsole       |  Tango::DevLong	Scalar
//  buildState                |  Tango::DevString	Scalar
//  centralLoggerStatus       |  Tango::DevEnum	Scalar
//  elementLoggerStatus       |  Tango::DevEnum	Scalar
//  storageLoggerStatus       |  Tango::DevEnum	Scalar
//  eventRate                 |  Tango::DevFloat	Scalar
//  exceptionRate             |  Tango::DevFloat	Scalar
//  fwdAttrInitStatus         |  Tango::DevEnum	Scalar
//  centralLoggerEnabled      |  Tango::DevBoolean	Scalar
//  elementLoggerEnabled      |  Tango::DevBoolean	Scalar
//  storageLoggerEnabled      |  Tango::DevBoolean	Scalar
//  loggingTargetCentral      |  Tango::DevString	Scalar
//  loggingTargetElement      |  Tango::DevString	Scalar
//  loggingTargetStorage      |  Tango::DevString	Scalar
//  attrRandomizationEnabled  |  Tango::DevBoolean	Scalar
//  attrRandomizationPeriod   |  Tango::DevULong	Scalar
//  configureBandProgress     |  Tango::DevString	Spectrum  ( max = 3)
//  firmware0UpdateProgress   |  Tango::DevString	Spectrum  ( max = 4)
//  firmware1UpdateProgress   |  Tango::DevString	Spectrum  ( max = 4)
//  firmware2UpdateProgress   |  Tango::DevString	Spectrum  ( max = 4)
//  firmware3UpdateProgress   |  Tango::DevString	Spectrum  ( max = 4)
//================================================================

namespace RxEmulator_ns
{
/*----- PROTECTED REGION ID(RxEmulator::namespace_starting) ENABLED START -----*/

//	static initializations

/*----- PROTECTED REGION END -----*/	//	RxEmulator::namespace_starting

//--------------------------------------------------------
/**
 *	Method      : RxEmulator::RxEmulator()
 *	Description : Constructors for a Tango device
 *                implementing the classRxEmulator
 */
//--------------------------------------------------------
RxEmulator::RxEmulator(Tango::DeviceClass *cl, string &s)
 : LMCDevice(cl, s.c_str())
{
	/*----- PROTECTED REGION ID(RxEmulator::constructor_1) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	RxEmulator::constructor_1
}
//--------------------------------------------------------
RxEmulator::RxEmulator(Tango::DeviceClass *cl, const char *s)
 : LMCDevice(cl, s)
{
	/*----- PROTECTED REGION ID(RxEmulator::constructor_2) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	RxEmulator::constructor_2
}
//--------------------------------------------------------
RxEmulator::RxEmulator(Tango::DeviceClass *cl, const char *s, const char *d)
 : LMCDevice(cl, s, d)
{
	/*----- PROTECTED REGION ID(RxEmulator::constructor_3) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	RxEmulator::constructor_3
}

//--------------------------------------------------------
/**
 *	Method      : RxEmulator::delete_device()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void RxEmulator::delete_device()
{
	DEBUG_STREAM << "RxEmulator::delete_device() " << device_name << endl;
	/*----- PROTECTED REGION ID(RxEmulator::delete_device) ENABLED START -----*/
	
	//	Delete device allocated objects

	//## Clear task: notify wait cond & exit
	if(ClearTask()<0){
		_ERROR_LOG("Failed to clearup task thread");
	}

	//## Delete allocated memory
	for(int i=0;i<3;i++){
		CORBA::string_free(*(attr_configureBandProgress_read+i));
	}
	for(int i=0;i<4;i++){
		CORBA::string_free(*(attr_firmware0UpdateProgress_read+i));
		CORBA::string_free(*(attr_firmware1UpdateProgress_read+i));
		CORBA::string_free(*(attr_firmware2UpdateProgress_read+i));
		CORBA::string_free(*(attr_firmware3UpdateProgress_read+i));
	}

	/*----- PROTECTED REGION END -----*/	//	RxEmulator::delete_device
	delete[] attr_configureBandProgress_read;
	delete[] attr_firmware0UpdateProgress_read;
	delete[] attr_firmware1UpdateProgress_read;
	delete[] attr_firmware2UpdateProgress_read;
	delete[] attr_firmware3UpdateProgress_read;

	if (Tango::Util::instance()->is_svr_shutting_down()==false  &&
		Tango::Util::instance()->is_device_restarting(device_name)==false &&
		Tango::Util::instance()->is_svr_starting()==false)
	{
		//	If not shutting down call delete device for inherited object
		LMCDevice_ns::LMCDevice::delete_device();
	}
}

//--------------------------------------------------------
/**
 *	Method      : RxEmulator::init_device()
 *	Description : will be called at device initialization.
 */
//--------------------------------------------------------
void RxEmulator::init_device()
{
	DEBUG_STREAM << "RxEmulator::init_device() create device " << device_name << endl;
	/*----- PROTECTED REGION ID(RxEmulator::init_device_before) ENABLED START -----*/
	
	//	Initialization before get_device_property() call
	
	/*----- PROTECTED REGION END -----*/	//	RxEmulator::init_device_before
	
	if (Tango::Util::instance()->is_svr_starting() == false  &&
		Tango::Util::instance()->is_device_restarting(device_name)==false)
	{
		//	If not starting up call init device for inherited object
		LMCDevice_ns::LMCDevice::init_device();
	}

	//	Get the device properties from database
	get_device_property();
	
	attr_configureBandProgress_read = new Tango::DevString[3];
	attr_firmware0UpdateProgress_read = new Tango::DevString[4];
	attr_firmware1UpdateProgress_read = new Tango::DevString[4];
	attr_firmware2UpdateProgress_read = new Tango::DevString[4];
	attr_firmware3UpdateProgress_read = new Tango::DevString[4];
	//	No longer if mandatory property not set. 
	if (mandatoryNotDefined)
		return;

	/*----- PROTECTED REGION ID(RxEmulator::init_device) ENABLED START -----*/
	
	//	Initialize device

	//## Set init device state
	set_state(Tango::INIT);
	set_status("Device " + device_name + " is initializing");

	//## Init attributes
	SetConfigureStatus("INIT","No configure band task information present",false);
	for(int i=0;i<4;i++) SetUpdateFirmwareStatus("INIT","No update firmware task information present",i,"",false);

	//## Initialize and start device task thread
	if(InitTask()<0){
		_ERROR_LOG("Failed to initialize and start device task!");
	}

	/*----- PROTECTED REGION END -----*/	//	RxEmulator::init_device
}

//--------------------------------------------------------
/**
 *	Method      : RxEmulator::get_device_property()
 *	Description : Read database to initialize property data members.
 */
//--------------------------------------------------------
void RxEmulator::get_device_property()
{
	/*----- PROTECTED REGION ID(RxEmulator::get_device_property_before) ENABLED START -----*/
	
	//	Initialize property data members
	
	/*----- PROTECTED REGION END -----*/	//	RxEmulator::get_device_property_before

	mandatoryNotDefined = false;

	//	Read device properties from database.
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("StorageLoggerEnabledDefault"));
	dev_prop.push_back(Tango::DbDatum("SyslogFacility"));
	dev_prop.push_back(Tango::DbDatum("SkaLevel"));
	dev_prop.push_back(Tango::DbDatum("LoggingLevelCentralDefault"));
	dev_prop.push_back(Tango::DbDatum("LoggingLevelElementDefault"));
	dev_prop.push_back(Tango::DbDatum("LoggingLevelStorageDefault"));
	dev_prop.push_back(Tango::DbDatum("LoggingTargetCentralDefault"));
	dev_prop.push_back(Tango::DbDatum("LoggingTargetElementDefault"));
	dev_prop.push_back(Tango::DbDatum("LoggingTargetStorageDefault"));
	dev_prop.push_back(Tango::DbDatum("ElementLoggerEnabledDefault"));
	dev_prop.push_back(Tango::DbDatum("CentralLoggerEnabledDefault"));
	dev_prop.push_back(Tango::DbDatum("SyslogHost"));
	dev_prop.push_back(Tango::DbDatum("StartupTime"));
	dev_prop.push_back(Tango::DbDatum("ConfigureTime"));
	dev_prop.push_back(Tango::DbDatum("ConfigFile"));
	dev_prop.push_back(Tango::DbDatum("EnableConfigFromFile"));
	dev_prop.push_back(Tango::DbDatum("EnableDynAttrCleanup"));
	dev_prop.push_back(Tango::DbDatum("EnableDynAttrRandomize"));
	dev_prop.push_back(Tango::DbDatum("DynAttrRandomizePeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableStartupFailure"));
	dev_prop.push_back(Tango::DbDatum("StartupFailureProbability"));
	dev_prop.push_back(Tango::DbDatum("EnableConfigureFailure"));
	dev_prop.push_back(Tango::DbDatum("ConfigureFailureProbability"));
	dev_prop.push_back(Tango::DbDatum("ProxyDevices"));
	dev_prop.push_back(Tango::DbDatum("FormulaVarMaxTimeInterval"));
	dev_prop.push_back(Tango::DbDatum("EnableProxyMonitoring"));
	dev_prop.push_back(Tango::DbDatum("ProxyMonitoringPeriod"));
	dev_prop.push_back(Tango::DbDatum("ProxyStatusAttrPollPeriod"));
	dev_prop.push_back(Tango::DbDatum("ProxyStatusAttrPeriodicEventPeriod"));
	dev_prop.push_back(Tango::DbDatum("ProxyStatusAttrArchiveEventPeriod"));
	dev_prop.push_back(Tango::DbDatum("ProxyTimeout"));
	dev_prop.push_back(Tango::DbDatum("EventSubscriptions"));
	dev_prop.push_back(Tango::DbDatum("EventHandlers"));
	dev_prop.push_back(Tango::DbDatum("MaxQueueableTask"));
	dev_prop.push_back(Tango::DbDatum("MaxTrackableTasks"));
	dev_prop.push_back(Tango::DbDatum("TaskHistoryTimeDepth"));
	dev_prop.push_back(Tango::DbDatum("DefaultTaskTimeout"));
	dev_prop.push_back(Tango::DbDatum("TaskSequenceStatusAttrList"));
	dev_prop.push_back(Tango::DbDatum("TaskStatusAttrList"));
	dev_prop.push_back(Tango::DbDatum("EnableEventRateMonitoring"));
	dev_prop.push_back(Tango::DbDatum("EnableLoggerInitPolling"));
	dev_prop.push_back(Tango::DbDatum("LoggerInitPollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableDevProxyInitPolling"));
	dev_prop.push_back(Tango::DbDatum("DevProxyInitPollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableFwdAttrInitPolling"));
	dev_prop.push_back(Tango::DbDatum("FwdAttrInitPollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableFormulaAttrUpdatePolling"));
	dev_prop.push_back(Tango::DbDatum("FormulaAttrUpdatePollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableStatusAttrUpdatePolling"));
	dev_prop.push_back(Tango::DbDatum("StatusAttrUpdatePollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableClearTaskPolling"));
	dev_prop.push_back(Tango::DbDatum("ClearTaskPollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableProxyStatusAttrCreation"));
	dev_prop.push_back(Tango::DbDatum("EnableAutoAdminProxyRegistration"));
	dev_prop.push_back(Tango::DbDatum("ProcessEventsInQueueThread"));
	dev_prop.push_back(Tango::DbDatum("B1NominalGain"));
	dev_prop.push_back(Tango::DbDatum("B2NominalGain"));
	dev_prop.push_back(Tango::DbDatum("B3NominalGain"));
	dev_prop.push_back(Tango::DbDatum("B4NominalGain"));
	dev_prop.push_back(Tango::DbDatum("B5aNominalGain"));
	dev_prop.push_back(Tango::DbDatum("B5bNominalGain"));
	dev_prop.push_back(Tango::DbDatum("B1MaxGain"));
	dev_prop.push_back(Tango::DbDatum("B2MaxGain"));
	dev_prop.push_back(Tango::DbDatum("B3MaxGain"));
	dev_prop.push_back(Tango::DbDatum("B4MaxGain"));
	dev_prop.push_back(Tango::DbDatum("B5aMaxGain"));
	dev_prop.push_back(Tango::DbDatum("B5bMaxGain"));
	dev_prop.push_back(Tango::DbDatum("B1PolHNominalAttenuation"));
	dev_prop.push_back(Tango::DbDatum("B2PolHNominalAttenuation"));
	dev_prop.push_back(Tango::DbDatum("B3PolHNominalAttenuation"));
	dev_prop.push_back(Tango::DbDatum("B4PolHNominalAttenuation"));
	dev_prop.push_back(Tango::DbDatum("B5aPolHNominalAttenuation"));
	dev_prop.push_back(Tango::DbDatum("B5bPolHNominalAttenuation"));
	dev_prop.push_back(Tango::DbDatum("B1PolVNominalAttenuation"));
	dev_prop.push_back(Tango::DbDatum("B2PolVNominalAttenuation"));
	dev_prop.push_back(Tango::DbDatum("B3PolVNominalAttenuation"));
	dev_prop.push_back(Tango::DbDatum("B4PolVNominalAttenuation"));
	dev_prop.push_back(Tango::DbDatum("B5aPolVNominalAttenuation"));
	dev_prop.push_back(Tango::DbDatum("B5bPolVNominalAttenuation"));
	dev_prop.push_back(Tango::DbDatum("NoiseDiodeStateDefault"));
	dev_prop.push_back(Tango::DbDatum("PeriodicNoiseDiodeParsDefault"));
	dev_prop.push_back(Tango::DbDatum("PseudoRandomNoiseDiodeParsDefault"));
	dev_prop.push_back(Tango::DbDatum("B1NominalSamplingClockFrequency"));
	dev_prop.push_back(Tango::DbDatum("B2NominalSamplingClockFrequency"));
	dev_prop.push_back(Tango::DbDatum("B3NominalSamplingClockFrequency"));
	dev_prop.push_back(Tango::DbDatum("B4NominalSamplingClockFrequency"));
	dev_prop.push_back(Tango::DbDatum("B5aNominalSamplingClockFrequency"));
	dev_prop.push_back(Tango::DbDatum("B5bNominalSamplingClockFrequency"));
	dev_prop.push_back(Tango::DbDatum("ConfiguredBandDefault"));
	dev_prop.push_back(Tango::DbDatum("ExpectedOnlineDefault"));

	//	is there at least one property to be read ?
	if (dev_prop.size()>0)
	{
		//	Call database and extract values
		if (Tango::Util::instance()->_UseDb==true)
			get_db_device()->get_property(dev_prop);
	
		//	get instance on RxEmulatorClass to get class property
		Tango::DbDatum	def_prop, cl_prop;
		RxEmulatorClass	*ds_class =
			(static_cast<RxEmulatorClass *>(get_device_class()));
		int	i = -1;

		//	Try to initialize StorageLoggerEnabledDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  storageLoggerEnabledDefault;
		else {
			//	Try to initialize StorageLoggerEnabledDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  storageLoggerEnabledDefault;
		}
		//	And try to extract StorageLoggerEnabledDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  storageLoggerEnabledDefault;

		//	Try to initialize SyslogFacility from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  syslogFacility;
		else {
			//	Try to initialize SyslogFacility from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  syslogFacility;
		}
		//	And try to extract SyslogFacility value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  syslogFacility;

		//	Try to initialize SkaLevel from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  skaLevel;
		else {
			//	Try to initialize SkaLevel from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  skaLevel;
		}
		//	And try to extract SkaLevel value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  skaLevel;

		//	Try to initialize LoggingLevelCentralDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingLevelCentralDefault;
		else {
			//	Try to initialize LoggingLevelCentralDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingLevelCentralDefault;
		}
		//	And try to extract LoggingLevelCentralDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingLevelCentralDefault;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize LoggingLevelElementDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingLevelElementDefault;
		else {
			//	Try to initialize LoggingLevelElementDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingLevelElementDefault;
		}
		//	And try to extract LoggingLevelElementDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingLevelElementDefault;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize LoggingLevelStorageDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingLevelStorageDefault;
		else {
			//	Try to initialize LoggingLevelStorageDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingLevelStorageDefault;
		}
		//	And try to extract LoggingLevelStorageDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingLevelStorageDefault;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize LoggingTargetCentralDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingTargetCentralDefault;
		else {
			//	Try to initialize LoggingTargetCentralDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingTargetCentralDefault;
		}
		//	And try to extract LoggingTargetCentralDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingTargetCentralDefault;

		//	Try to initialize LoggingTargetElementDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingTargetElementDefault;
		else {
			//	Try to initialize LoggingTargetElementDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingTargetElementDefault;
		}
		//	And try to extract LoggingTargetElementDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingTargetElementDefault;

		//	Try to initialize LoggingTargetStorageDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingTargetStorageDefault;
		else {
			//	Try to initialize LoggingTargetStorageDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingTargetStorageDefault;
		}
		//	And try to extract LoggingTargetStorageDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingTargetStorageDefault;

		//	Try to initialize ElementLoggerEnabledDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  elementLoggerEnabledDefault;
		else {
			//	Try to initialize ElementLoggerEnabledDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  elementLoggerEnabledDefault;
		}
		//	And try to extract ElementLoggerEnabledDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  elementLoggerEnabledDefault;

		//	Try to initialize CentralLoggerEnabledDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  centralLoggerEnabledDefault;
		else {
			//	Try to initialize CentralLoggerEnabledDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  centralLoggerEnabledDefault;
		}
		//	And try to extract CentralLoggerEnabledDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  centralLoggerEnabledDefault;

		//	Try to initialize SyslogHost from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  syslogHost;
		else {
			//	Try to initialize SyslogHost from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  syslogHost;
		}
		//	And try to extract SyslogHost value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  syslogHost;

		//	Try to initialize StartupTime from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  startupTime;
		else {
			//	Try to initialize StartupTime from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  startupTime;
		}
		//	And try to extract StartupTime value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  startupTime;

		//	Try to initialize ConfigureTime from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  configureTime;
		else {
			//	Try to initialize ConfigureTime from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  configureTime;
		}
		//	And try to extract ConfigureTime value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  configureTime;

		//	Try to initialize ConfigFile from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  configFile;
		else {
			//	Try to initialize ConfigFile from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  configFile;
		}
		//	And try to extract ConfigFile value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  configFile;

		//	Try to initialize EnableConfigFromFile from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableConfigFromFile;
		else {
			//	Try to initialize EnableConfigFromFile from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableConfigFromFile;
		}
		//	And try to extract EnableConfigFromFile value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableConfigFromFile;

		//	Try to initialize EnableDynAttrCleanup from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableDynAttrCleanup;
		else {
			//	Try to initialize EnableDynAttrCleanup from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableDynAttrCleanup;
		}
		//	And try to extract EnableDynAttrCleanup value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableDynAttrCleanup;

		//	Try to initialize EnableDynAttrRandomize from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableDynAttrRandomize;
		else {
			//	Try to initialize EnableDynAttrRandomize from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableDynAttrRandomize;
		}
		//	And try to extract EnableDynAttrRandomize value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableDynAttrRandomize;

		//	Try to initialize DynAttrRandomizePeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  dynAttrRandomizePeriod;
		else {
			//	Try to initialize DynAttrRandomizePeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  dynAttrRandomizePeriod;
		}
		//	And try to extract DynAttrRandomizePeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  dynAttrRandomizePeriod;

		//	Try to initialize EnableStartupFailure from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableStartupFailure;
		else {
			//	Try to initialize EnableStartupFailure from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableStartupFailure;
		}
		//	And try to extract EnableStartupFailure value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableStartupFailure;

		//	Try to initialize StartupFailureProbability from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  startupFailureProbability;
		else {
			//	Try to initialize StartupFailureProbability from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  startupFailureProbability;
		}
		//	And try to extract StartupFailureProbability value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  startupFailureProbability;

		//	Try to initialize EnableConfigureFailure from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableConfigureFailure;
		else {
			//	Try to initialize EnableConfigureFailure from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableConfigureFailure;
		}
		//	And try to extract EnableConfigureFailure value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableConfigureFailure;

		//	Try to initialize ConfigureFailureProbability from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  configureFailureProbability;
		else {
			//	Try to initialize ConfigureFailureProbability from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  configureFailureProbability;
		}
		//	And try to extract ConfigureFailureProbability value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  configureFailureProbability;

		//	Try to initialize ProxyDevices from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyDevices;
		else {
			//	Try to initialize ProxyDevices from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyDevices;
		}
		//	And try to extract ProxyDevices value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyDevices;

		//	Try to initialize FormulaVarMaxTimeInterval from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  formulaVarMaxTimeInterval;
		else {
			//	Try to initialize FormulaVarMaxTimeInterval from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  formulaVarMaxTimeInterval;
		}
		//	And try to extract FormulaVarMaxTimeInterval value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  formulaVarMaxTimeInterval;

		//	Try to initialize EnableProxyMonitoring from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableProxyMonitoring;
		else {
			//	Try to initialize EnableProxyMonitoring from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableProxyMonitoring;
		}
		//	And try to extract EnableProxyMonitoring value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableProxyMonitoring;

		//	Try to initialize ProxyMonitoringPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyMonitoringPeriod;
		else {
			//	Try to initialize ProxyMonitoringPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyMonitoringPeriod;
		}
		//	And try to extract ProxyMonitoringPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyMonitoringPeriod;

		//	Try to initialize ProxyStatusAttrPollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyStatusAttrPollPeriod;
		else {
			//	Try to initialize ProxyStatusAttrPollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyStatusAttrPollPeriod;
		}
		//	And try to extract ProxyStatusAttrPollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyStatusAttrPollPeriod;

		//	Try to initialize ProxyStatusAttrPeriodicEventPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyStatusAttrPeriodicEventPeriod;
		else {
			//	Try to initialize ProxyStatusAttrPeriodicEventPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyStatusAttrPeriodicEventPeriod;
		}
		//	And try to extract ProxyStatusAttrPeriodicEventPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyStatusAttrPeriodicEventPeriod;

		//	Try to initialize ProxyStatusAttrArchiveEventPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyStatusAttrArchiveEventPeriod;
		else {
			//	Try to initialize ProxyStatusAttrArchiveEventPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyStatusAttrArchiveEventPeriod;
		}
		//	And try to extract ProxyStatusAttrArchiveEventPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyStatusAttrArchiveEventPeriod;

		//	Try to initialize ProxyTimeout from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyTimeout;
		else {
			//	Try to initialize ProxyTimeout from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyTimeout;
		}
		//	And try to extract ProxyTimeout value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyTimeout;

		//	Try to initialize EventSubscriptions from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  eventSubscriptions;
		else {
			//	Try to initialize EventSubscriptions from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  eventSubscriptions;
		}
		//	And try to extract EventSubscriptions value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  eventSubscriptions;

		//	Try to initialize EventHandlers from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  eventHandlers;
		else {
			//	Try to initialize EventHandlers from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  eventHandlers;
		}
		//	And try to extract EventHandlers value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  eventHandlers;

		//	Try to initialize MaxQueueableTask from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  maxQueueableTask;
		else {
			//	Try to initialize MaxQueueableTask from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  maxQueueableTask;
		}
		//	And try to extract MaxQueueableTask value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  maxQueueableTask;

		//	Try to initialize MaxTrackableTasks from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  maxTrackableTasks;
		else {
			//	Try to initialize MaxTrackableTasks from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  maxTrackableTasks;
		}
		//	And try to extract MaxTrackableTasks value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  maxTrackableTasks;

		//	Try to initialize TaskHistoryTimeDepth from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  taskHistoryTimeDepth;
		else {
			//	Try to initialize TaskHistoryTimeDepth from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  taskHistoryTimeDepth;
		}
		//	And try to extract TaskHistoryTimeDepth value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  taskHistoryTimeDepth;

		//	Try to initialize DefaultTaskTimeout from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  defaultTaskTimeout;
		else {
			//	Try to initialize DefaultTaskTimeout from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  defaultTaskTimeout;
		}
		//	And try to extract DefaultTaskTimeout value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  defaultTaskTimeout;

		//	Try to initialize TaskSequenceStatusAttrList from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  taskSequenceStatusAttrList;
		else {
			//	Try to initialize TaskSequenceStatusAttrList from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  taskSequenceStatusAttrList;
		}
		//	And try to extract TaskSequenceStatusAttrList value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  taskSequenceStatusAttrList;

		//	Try to initialize TaskStatusAttrList from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  taskStatusAttrList;
		else {
			//	Try to initialize TaskStatusAttrList from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  taskStatusAttrList;
		}
		//	And try to extract TaskStatusAttrList value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  taskStatusAttrList;

		//	Try to initialize EnableEventRateMonitoring from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableEventRateMonitoring;
		else {
			//	Try to initialize EnableEventRateMonitoring from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableEventRateMonitoring;
		}
		//	And try to extract EnableEventRateMonitoring value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableEventRateMonitoring;

		//	Try to initialize EnableLoggerInitPolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableLoggerInitPolling;
		else {
			//	Try to initialize EnableLoggerInitPolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableLoggerInitPolling;
		}
		//	And try to extract EnableLoggerInitPolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableLoggerInitPolling;

		//	Try to initialize LoggerInitPollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggerInitPollPeriod;
		else {
			//	Try to initialize LoggerInitPollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggerInitPollPeriod;
		}
		//	And try to extract LoggerInitPollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggerInitPollPeriod;

		//	Try to initialize EnableDevProxyInitPolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableDevProxyInitPolling;
		else {
			//	Try to initialize EnableDevProxyInitPolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableDevProxyInitPolling;
		}
		//	And try to extract EnableDevProxyInitPolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableDevProxyInitPolling;

		//	Try to initialize DevProxyInitPollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  devProxyInitPollPeriod;
		else {
			//	Try to initialize DevProxyInitPollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  devProxyInitPollPeriod;
		}
		//	And try to extract DevProxyInitPollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  devProxyInitPollPeriod;

		//	Try to initialize EnableFwdAttrInitPolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableFwdAttrInitPolling;
		else {
			//	Try to initialize EnableFwdAttrInitPolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableFwdAttrInitPolling;
		}
		//	And try to extract EnableFwdAttrInitPolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableFwdAttrInitPolling;

		//	Try to initialize FwdAttrInitPollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  fwdAttrInitPollPeriod;
		else {
			//	Try to initialize FwdAttrInitPollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  fwdAttrInitPollPeriod;
		}
		//	And try to extract FwdAttrInitPollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  fwdAttrInitPollPeriod;

		//	Try to initialize EnableFormulaAttrUpdatePolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableFormulaAttrUpdatePolling;
		else {
			//	Try to initialize EnableFormulaAttrUpdatePolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableFormulaAttrUpdatePolling;
		}
		//	And try to extract EnableFormulaAttrUpdatePolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableFormulaAttrUpdatePolling;

		//	Try to initialize FormulaAttrUpdatePollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  formulaAttrUpdatePollPeriod;
		else {
			//	Try to initialize FormulaAttrUpdatePollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  formulaAttrUpdatePollPeriod;
		}
		//	And try to extract FormulaAttrUpdatePollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  formulaAttrUpdatePollPeriod;

		//	Try to initialize EnableStatusAttrUpdatePolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableStatusAttrUpdatePolling;
		else {
			//	Try to initialize EnableStatusAttrUpdatePolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableStatusAttrUpdatePolling;
		}
		//	And try to extract EnableStatusAttrUpdatePolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableStatusAttrUpdatePolling;

		//	Try to initialize StatusAttrUpdatePollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  statusAttrUpdatePollPeriod;
		else {
			//	Try to initialize StatusAttrUpdatePollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  statusAttrUpdatePollPeriod;
		}
		//	And try to extract StatusAttrUpdatePollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  statusAttrUpdatePollPeriod;

		//	Try to initialize EnableClearTaskPolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableClearTaskPolling;
		else {
			//	Try to initialize EnableClearTaskPolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableClearTaskPolling;
		}
		//	And try to extract EnableClearTaskPolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableClearTaskPolling;

		//	Try to initialize ClearTaskPollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  clearTaskPollPeriod;
		else {
			//	Try to initialize ClearTaskPollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  clearTaskPollPeriod;
		}
		//	And try to extract ClearTaskPollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  clearTaskPollPeriod;

		//	Try to initialize EnableProxyStatusAttrCreation from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableProxyStatusAttrCreation;
		else {
			//	Try to initialize EnableProxyStatusAttrCreation from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableProxyStatusAttrCreation;
		}
		//	And try to extract EnableProxyStatusAttrCreation value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableProxyStatusAttrCreation;

		//	Try to initialize EnableAutoAdminProxyRegistration from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableAutoAdminProxyRegistration;
		else {
			//	Try to initialize EnableAutoAdminProxyRegistration from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableAutoAdminProxyRegistration;
		}
		//	And try to extract EnableAutoAdminProxyRegistration value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableAutoAdminProxyRegistration;

		//	Try to initialize ProcessEventsInQueueThread from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  processEventsInQueueThread;
		else {
			//	Try to initialize ProcessEventsInQueueThread from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  processEventsInQueueThread;
		}
		//	And try to extract ProcessEventsInQueueThread value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  processEventsInQueueThread;

		//	Try to initialize B1NominalGain from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  b1NominalGain;
		else {
			//	Try to initialize B1NominalGain from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  b1NominalGain;
		}
		//	And try to extract B1NominalGain value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  b1NominalGain;

		//	Try to initialize B2NominalGain from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  b2NominalGain;
		else {
			//	Try to initialize B2NominalGain from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  b2NominalGain;
		}
		//	And try to extract B2NominalGain value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  b2NominalGain;

		//	Try to initialize B3NominalGain from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  b3NominalGain;
		else {
			//	Try to initialize B3NominalGain from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  b3NominalGain;
		}
		//	And try to extract B3NominalGain value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  b3NominalGain;

		//	Try to initialize B4NominalGain from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  b4NominalGain;
		else {
			//	Try to initialize B4NominalGain from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  b4NominalGain;
		}
		//	And try to extract B4NominalGain value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  b4NominalGain;

		//	Try to initialize B5aNominalGain from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  b5aNominalGain;
		else {
			//	Try to initialize B5aNominalGain from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  b5aNominalGain;
		}
		//	And try to extract B5aNominalGain value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  b5aNominalGain;

		//	Try to initialize B5bNominalGain from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  b5bNominalGain;
		else {
			//	Try to initialize B5bNominalGain from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  b5bNominalGain;
		}
		//	And try to extract B5bNominalGain value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  b5bNominalGain;

		//	Try to initialize B1MaxGain from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  b1MaxGain;
		else {
			//	Try to initialize B1MaxGain from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  b1MaxGain;
		}
		//	And try to extract B1MaxGain value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  b1MaxGain;

		//	Try to initialize B2MaxGain from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  b2MaxGain;
		else {
			//	Try to initialize B2MaxGain from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  b2MaxGain;
		}
		//	And try to extract B2MaxGain value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  b2MaxGain;

		//	Try to initialize B3MaxGain from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  b3MaxGain;
		else {
			//	Try to initialize B3MaxGain from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  b3MaxGain;
		}
		//	And try to extract B3MaxGain value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  b3MaxGain;

		//	Try to initialize B4MaxGain from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  b4MaxGain;
		else {
			//	Try to initialize B4MaxGain from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  b4MaxGain;
		}
		//	And try to extract B4MaxGain value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  b4MaxGain;

		//	Try to initialize B5aMaxGain from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  b5aMaxGain;
		else {
			//	Try to initialize B5aMaxGain from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  b5aMaxGain;
		}
		//	And try to extract B5aMaxGain value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  b5aMaxGain;

		//	Try to initialize B5bMaxGain from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  b5bMaxGain;
		else {
			//	Try to initialize B5bMaxGain from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  b5bMaxGain;
		}
		//	And try to extract B5bMaxGain value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  b5bMaxGain;

		//	Try to initialize B1PolHNominalAttenuation from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  b1PolHNominalAttenuation;
		else {
			//	Try to initialize B1PolHNominalAttenuation from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  b1PolHNominalAttenuation;
		}
		//	And try to extract B1PolHNominalAttenuation value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  b1PolHNominalAttenuation;

		//	Try to initialize B2PolHNominalAttenuation from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  b2PolHNominalAttenuation;
		else {
			//	Try to initialize B2PolHNominalAttenuation from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  b2PolHNominalAttenuation;
		}
		//	And try to extract B2PolHNominalAttenuation value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  b2PolHNominalAttenuation;

		//	Try to initialize B3PolHNominalAttenuation from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  b3PolHNominalAttenuation;
		else {
			//	Try to initialize B3PolHNominalAttenuation from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  b3PolHNominalAttenuation;
		}
		//	And try to extract B3PolHNominalAttenuation value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  b3PolHNominalAttenuation;

		//	Try to initialize B4PolHNominalAttenuation from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  b4PolHNominalAttenuation;
		else {
			//	Try to initialize B4PolHNominalAttenuation from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  b4PolHNominalAttenuation;
		}
		//	And try to extract B4PolHNominalAttenuation value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  b4PolHNominalAttenuation;

		//	Try to initialize B5aPolHNominalAttenuation from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  b5aPolHNominalAttenuation;
		else {
			//	Try to initialize B5aPolHNominalAttenuation from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  b5aPolHNominalAttenuation;
		}
		//	And try to extract B5aPolHNominalAttenuation value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  b5aPolHNominalAttenuation;

		//	Try to initialize B5bPolHNominalAttenuation from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  b5bPolHNominalAttenuation;
		else {
			//	Try to initialize B5bPolHNominalAttenuation from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  b5bPolHNominalAttenuation;
		}
		//	And try to extract B5bPolHNominalAttenuation value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  b5bPolHNominalAttenuation;

		//	Try to initialize B1PolVNominalAttenuation from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  b1PolVNominalAttenuation;
		else {
			//	Try to initialize B1PolVNominalAttenuation from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  b1PolVNominalAttenuation;
		}
		//	And try to extract B1PolVNominalAttenuation value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  b1PolVNominalAttenuation;

		//	Try to initialize B2PolVNominalAttenuation from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  b2PolVNominalAttenuation;
		else {
			//	Try to initialize B2PolVNominalAttenuation from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  b2PolVNominalAttenuation;
		}
		//	And try to extract B2PolVNominalAttenuation value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  b2PolVNominalAttenuation;

		//	Try to initialize B3PolVNominalAttenuation from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  b3PolVNominalAttenuation;
		else {
			//	Try to initialize B3PolVNominalAttenuation from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  b3PolVNominalAttenuation;
		}
		//	And try to extract B3PolVNominalAttenuation value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  b3PolVNominalAttenuation;

		//	Try to initialize B4PolVNominalAttenuation from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  b4PolVNominalAttenuation;
		else {
			//	Try to initialize B4PolVNominalAttenuation from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  b4PolVNominalAttenuation;
		}
		//	And try to extract B4PolVNominalAttenuation value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  b4PolVNominalAttenuation;

		//	Try to initialize B5aPolVNominalAttenuation from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  b5aPolVNominalAttenuation;
		else {
			//	Try to initialize B5aPolVNominalAttenuation from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  b5aPolVNominalAttenuation;
		}
		//	And try to extract B5aPolVNominalAttenuation value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  b5aPolVNominalAttenuation;

		//	Try to initialize B5bPolVNominalAttenuation from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  b5bPolVNominalAttenuation;
		else {
			//	Try to initialize B5bPolVNominalAttenuation from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  b5bPolVNominalAttenuation;
		}
		//	And try to extract B5bPolVNominalAttenuation value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  b5bPolVNominalAttenuation;

		//	Try to initialize NoiseDiodeStateDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  noiseDiodeStateDefault;
		else {
			//	Try to initialize NoiseDiodeStateDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  noiseDiodeStateDefault;
		}
		//	And try to extract NoiseDiodeStateDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  noiseDiodeStateDefault;

		//	Try to initialize PeriodicNoiseDiodeParsDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  periodicNoiseDiodeParsDefault;
		else {
			//	Try to initialize PeriodicNoiseDiodeParsDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  periodicNoiseDiodeParsDefault;
		}
		//	And try to extract PeriodicNoiseDiodeParsDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  periodicNoiseDiodeParsDefault;

		//	Try to initialize PseudoRandomNoiseDiodeParsDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  pseudoRandomNoiseDiodeParsDefault;
		else {
			//	Try to initialize PseudoRandomNoiseDiodeParsDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  pseudoRandomNoiseDiodeParsDefault;
		}
		//	And try to extract PseudoRandomNoiseDiodeParsDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  pseudoRandomNoiseDiodeParsDefault;

		//	Try to initialize B1NominalSamplingClockFrequency from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  b1NominalSamplingClockFrequency;
		else {
			//	Try to initialize B1NominalSamplingClockFrequency from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  b1NominalSamplingClockFrequency;
		}
		//	And try to extract B1NominalSamplingClockFrequency value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  b1NominalSamplingClockFrequency;

		//	Try to initialize B2NominalSamplingClockFrequency from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  b2NominalSamplingClockFrequency;
		else {
			//	Try to initialize B2NominalSamplingClockFrequency from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  b2NominalSamplingClockFrequency;
		}
		//	And try to extract B2NominalSamplingClockFrequency value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  b2NominalSamplingClockFrequency;

		//	Try to initialize B3NominalSamplingClockFrequency from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  b3NominalSamplingClockFrequency;
		else {
			//	Try to initialize B3NominalSamplingClockFrequency from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  b3NominalSamplingClockFrequency;
		}
		//	And try to extract B3NominalSamplingClockFrequency value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  b3NominalSamplingClockFrequency;

		//	Try to initialize B4NominalSamplingClockFrequency from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  b4NominalSamplingClockFrequency;
		else {
			//	Try to initialize B4NominalSamplingClockFrequency from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  b4NominalSamplingClockFrequency;
		}
		//	And try to extract B4NominalSamplingClockFrequency value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  b4NominalSamplingClockFrequency;

		//	Try to initialize B5aNominalSamplingClockFrequency from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  b5aNominalSamplingClockFrequency;
		else {
			//	Try to initialize B5aNominalSamplingClockFrequency from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  b5aNominalSamplingClockFrequency;
		}
		//	And try to extract B5aNominalSamplingClockFrequency value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  b5aNominalSamplingClockFrequency;

		//	Try to initialize B5bNominalSamplingClockFrequency from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  b5bNominalSamplingClockFrequency;
		else {
			//	Try to initialize B5bNominalSamplingClockFrequency from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  b5bNominalSamplingClockFrequency;
		}
		//	And try to extract B5bNominalSamplingClockFrequency value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  b5bNominalSamplingClockFrequency;

		//	Try to initialize ConfiguredBandDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  configuredBandDefault;
		else {
			//	Try to initialize ConfiguredBandDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  configuredBandDefault;
		}
		//	And try to extract ConfiguredBandDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  configuredBandDefault;

		//	Try to initialize ExpectedOnlineDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  expectedOnlineDefault;
		else {
			//	Try to initialize ExpectedOnlineDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  expectedOnlineDefault;
		}
		//	And try to extract ExpectedOnlineDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  expectedOnlineDefault;

	}

	/*----- PROTECTED REGION ID(RxEmulator::get_device_property_after) ENABLED START -----*/
	
	//	Check device property data members init
	
	/*----- PROTECTED REGION END -----*/	//	RxEmulator::get_device_property_after
}
//--------------------------------------------------------
/**
 *	Method      : RxEmulator::check_mandatory_property()
 *	Description : For mandatory properties check if defined in database.
 */
//--------------------------------------------------------
void RxEmulator::check_mandatory_property(Tango::DbDatum &class_prop, Tango::DbDatum &dev_prop)
{
	//	Check if all properties are empty
	if (class_prop.is_empty() && dev_prop.is_empty())
	{
		TangoSys_OMemStream	tms;
		tms << endl <<"Property \'" << dev_prop.name;
		if (Tango::Util::instance()->_UseDb==true)
			tms << "\' is mandatory but not defined in database";
		else
			tms << "\' is mandatory but cannot be defined without database";
		string	status(get_status());
		status += tms.str();
		set_status(status);
		mandatoryNotDefined = true;
		/*----- PROTECTED REGION ID(RxEmulator::check_mandatory_property) ENABLED START -----*/
		cerr << tms.str() << " for " << device_name << endl;
		
		/*----- PROTECTED REGION END -----*/	//	RxEmulator::check_mandatory_property
	}
}


//--------------------------------------------------------
/**
 *	Method      : RxEmulator::always_executed_hook()
 *	Description : method always executed before any command is executed
 */
//--------------------------------------------------------
void RxEmulator::always_executed_hook()
{
	DEBUG_STREAM << "RxEmulator::always_executed_hook()  " << device_name << endl;
	if (mandatoryNotDefined)
	{
		string	status(get_status());
		Tango::Except::throw_exception(
					(const char *)"PROPERTY_NOT_SET",
					status.c_str(),
					(const char *)"RxEmulator::always_executed_hook()");
	}
	/*----- PROTECTED REGION ID(RxEmulator::always_executed_hook) ENABLED START -----*/
	
	//	code always executed before all requests
	
	/*----- PROTECTED REGION END -----*/	//	RxEmulator::always_executed_hook
}

//--------------------------------------------------------
/**
 *	Method      : RxEmulator::read_attr_hardware()
 *	Description : Hardware acquisition for attributes
 */
//--------------------------------------------------------
void RxEmulator::read_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "RxEmulator::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(RxEmulator::read_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	RxEmulator::read_attr_hardware
}
//--------------------------------------------------------
/**
 *	Method      : RxEmulator::write_attr_hardware()
 *	Description : Hardware writing for attributes
 */
//--------------------------------------------------------
void RxEmulator::write_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "RxEmulator::write_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(RxEmulator::write_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	RxEmulator::write_attr_hardware
}

//--------------------------------------------------------
/**
 *	Read attribute configureBandProgress related method
 *	Description: 
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 3
 */
//--------------------------------------------------------
void RxEmulator::read_configureBandProgress(Tango::Attribute &attr)
{
	DEBUG_STREAM << "RxEmulator::read_configureBandProgress(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(RxEmulator::read_configureBandProgress) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_configureBandProgress_read, 3);
	
	/*----- PROTECTED REGION END -----*/	//	RxEmulator::read_configureBandProgress
}
//--------------------------------------------------------
/**
 *	Read attribute firmware0UpdateProgress related method
 *	Description: Firmware update command status progress.  Will indicate the progress of a firmware update to update the FPGA firmware code at the designated location.
 *               
 *               [0]: status label {?COMPLETED?,?RUNNING?,?FAILED?,...}
 *               [1] : Firmware location { ?0?, ?1?, ?2?, ?3? }
 *               [2]: Firmware version information
 *               [3]: Informational information regarding status.
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 4
 */
//--------------------------------------------------------
void RxEmulator::read_firmware0UpdateProgress(Tango::Attribute &attr)
{
	DEBUG_STREAM << "RxEmulator::read_firmware0UpdateProgress(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(RxEmulator::read_firmware0UpdateProgress) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_firmware0UpdateProgress_read, 4);
	
	/*----- PROTECTED REGION END -----*/	//	RxEmulator::read_firmware0UpdateProgress
}
//--------------------------------------------------------
/**
 *	Read attribute firmware1UpdateProgress related method
 *	Description: .Firmware update command status progress.  Will indicate the progress of a firmware update to update the FPGA firmware code at the designated location.
 *               
 *               [0]: status label {?COMPLETED?,?RUNNING?,?FAILED?,...}
 *               [1] : Firmware location { ?0?, ?1?, ?2?, ?3? }
 *               [2]: Firmware version information
 *               [3]: Informational information regarding status.
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 4
 */
//--------------------------------------------------------
void RxEmulator::read_firmware1UpdateProgress(Tango::Attribute &attr)
{
	DEBUG_STREAM << "RxEmulator::read_firmware1UpdateProgress(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(RxEmulator::read_firmware1UpdateProgress) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_firmware1UpdateProgress_read, 4);
	
	/*----- PROTECTED REGION END -----*/	//	RxEmulator::read_firmware1UpdateProgress
}
//--------------------------------------------------------
/**
 *	Read attribute firmware2UpdateProgress related method
 *	Description: Firmware update command status progress.  Will indicate the progress of a firmware update to update the FPGA firmware code at the designated location.
 *               
 *               [0]: status label {?COMPLETED?,?RUNNING?,?FAILED?,...}
 *               [1] : Firmware location { ?0?, ?1?, ?2?, ?3? }
 *               [2]: Firmware version information
 *               [3]: Informational information regarding status.
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 4
 */
//--------------------------------------------------------
void RxEmulator::read_firmware2UpdateProgress(Tango::Attribute &attr)
{
	DEBUG_STREAM << "RxEmulator::read_firmware2UpdateProgress(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(RxEmulator::read_firmware2UpdateProgress) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_firmware2UpdateProgress_read, 4);
	
	/*----- PROTECTED REGION END -----*/	//	RxEmulator::read_firmware2UpdateProgress
}
//--------------------------------------------------------
/**
 *	Read attribute firmware3UpdateProgress related method
 *	Description: Firmware update command status progress.  Will indicate the progress of a firmware update to update the FPGA firmware code at the designated location.
 *               
 *               [0]: status label {?COMPLETED?,?RUNNING?,?FAILED?,...}
 *               [1] : Firmware location { ?0?, ?1?, ?2?, ?3? }
 *               [2]: Firmware version information
 *               [3]: Informational information regarding status.
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 4
 */
//--------------------------------------------------------
void RxEmulator::read_firmware3UpdateProgress(Tango::Attribute &attr)
{
	DEBUG_STREAM << "RxEmulator::read_firmware3UpdateProgress(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(RxEmulator::read_firmware3UpdateProgress) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_firmware3UpdateProgress_read, 4);
	
	/*----- PROTECTED REGION END -----*/	//	RxEmulator::read_firmware3UpdateProgress
}

//--------------------------------------------------------
/**
 *	Method      : RxEmulator::add_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *                for specified device.
 */
//--------------------------------------------------------
void RxEmulator::add_dynamic_attributes()
{
	/*----- PROTECTED REGION ID(RxEmulator::add_dynamic_attributes) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic attributes if any
	LMCDevice::add_dynamic_attributes();
	
	/*
	//Add dynamic attributes from config file
	if(AddDynAttrs()<0){
		std::string errMsg("Failed to create dyn attributes!");
		_ERROR_LOG(errMsg);
		set_status(errMsg.c_str());
		set_state(Tango::FAULT);
		return;
	}
	
	//Configure state machine for cmd & attrs
	if(InitCmdAttrStateMachine()<0){
		std::string errMsg("Failed to create cmd & attr state machines for dyn attributes!");
		_ERROR_LOG(errMsg);
		set_status(errMsg.c_str());
		set_state(Tango::FAULT);
		return;
	}
	*/
	
	/*----- PROTECTED REGION END -----*/	//	RxEmulator::add_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Command Synchronise related method
 *	Description: Reset configured band sample counters.
 *               Command only valid in DATA-CAPTURE mode.
 *               
 *               NB: Run over the selected band only
 *
 */
//--------------------------------------------------------
void RxEmulator::synchronise()
{
	DEBUG_STREAM << "RxEmulator::Synchronise()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(RxEmulator::synchronise) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string attr_name= "samplingClockSynchronised";
	//###########################################################################
	
	_INFO_LOG("Synchronise command executed with success");

	//=====================================================
	//==         CHECK STATE MACHINE
	//=====================================================
	_DEBUG_LOG("Check if cmd "<<__FUNCTION__<<" is allowed...");
	bool check_cmd= true;
	try {
		IsCmdAllowed(__FUNCTION__,check_cmd);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		throw;
	}

	//=====================================================
	//==         SET SYNCHRONISE ATTR
	//=====================================================	
	Tango::DevBoolean attr_value= true;
	if(SetDynAttrValue<Tango::DevBoolean>(attr_value,attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<attr_name<<"!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SYNCHRONISE_FAILED",ss.str());
	}	

	/*----- PROTECTED REGION END -----*/	//	RxEmulator::synchronise
}
//--------------------------------------------------------
/**
 *	Command ConfigureBand related method
 *	Description: Set designated band and load the necessary configuration 
 *               into the FPGA. This will prepare the FPGA so that on 
 *               completion of this command, the FPGA 
 *               and sub-element will begin capturing data.
 *               The command automatically transition to 
 *               DATA-CAPTURE in case of success, otherwise revert back
 *               to STANDBY-FP (MAINTENANCE?).
 *               
 *               Allowed only in Rx modes:{STANDBY-FP,DATA-CAPTURE,MAINTENANCE}
 *
 *	@param argin 
 */
//--------------------------------------------------------
void RxEmulator::configure_band(Tango::DevShort argin)
{
	DEBUG_STREAM << "RxEmulator::ConfigureBand()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(RxEmulator::configure_band) ENABLED START -----*/
	
	//	Add your own code
	// == COMMAND BEHAVIOR ==
	// 1) Check if mode-allowed (DONE IN STATE MACHINE FILE)
	// 2) Check given band argument
	// 3) Check if required band is already configured. If so, reconfigure (parameters could have changed before this command is invoked)
	//    NB: It would be better to check if the config pars have changed (define an attribute?). If not, reply quickly with "Band already configured"
	// 4) Stop data capture on active band and check mode (TBD)
	// 5) Set mode to CONFIGURE 
	// 6) Switch given band capability to CONFIGURE [transition may take up to 30 s]
	// 7) If successful, automatically start data capture and switch rx_mode to DATA-CAPTURE
	// 8) If successful, switch capability of selected band to OPERATE
	// 9) Update configuredBand attr
	//10) Set attenuationPolH/attenuationPolV to default values relative to chosen band 

	
	_INFO_LOG("Configuring receiver band "<<argin<<"...");
	try{
		ConfigureBand(argin);
	}
	catch(...){
		throw;
	}

	/*
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string attr_name= "operatingMode";
	std::vector<std::string> cap_attr_names= {
		"b1CapabilityState",
		"b2CapabilityState",
		"b3CapabilityState",
		"b4CapabilityState",
		"b5aCapabilityState",
		"b5bCapabilityState",
	};
	std::string activeBand_attr_name= "configuredBand";	
	std::vector<std::string> attenuation_h_attr_names= {
		"b1PolHAttenuationDefault",
		"b2PolHAttenuationDefault",
		"b3PolHAttenuationDefault",
		"b4PolHAttenuationDefault",
		"b5aPolHAttenuationDefault",
		"b5bPolHAttenuationDefault",
	};
	std::vector<std::string> attenuation_v_attr_names= {
		"b1PolVAttenuationDefault",
		"b2PolVAttenuationDefault",
		"b3PolVAttenuationDefault",
		"b4PolVAttenuationDefault",
		"b5aPolVAttenuationDefault",
		"b5bPolVAttenuationDefault",
	};
	std::string mode_str= "CONFIGURE";
	std::string mode_safe_str= "STANDBY-FP";
	std::string mode_final_str= "DATA-CAPTURE";
	std::string capability_str= "CONFIGURE";
	std::string capability_final_str= "OPERATE";
	std::string capability_safe_str= "STANDBY";
	std::string synchronise_attr_name= "synchronised";
	Tango::DevShort bandNotConfigured= 0;
	int nBands= 6;
	//============================================================================

	//=====================================================
	//==         INIT ARGUMENTS
	//=====================================================
	//## Get bandId arg 
	Tango::DevShort bandId= argin;	
	if(bandId<=0 || bandId>nBands){
		std::stringstream ss;
		ss<<"Invalid argument given (bandId="<<bandId<<"), valid values are in range ["<<1<<","<<nBands<<"]!";
		_ERROR_LOG(ss.str());
	
		//Set fault status	
		SetConfigureStatus("FAILED",ss.str(),true);

		_THROW_TANGO_EXCEPTION("CONFIGURE_FAILED",ss.str());
	}

	
	//=====================================================
	//==        CHECK CONFIGURED BAND ID
	//=====================================================
	//## Get band currently active (can be the same of given argument or different)
	Tango::DevShort activeBandId= 0;
	if(GetDynAttrValue(activeBandId,activeBand_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<activeBand_attr_name<<" value!";
		_ERROR_LOG(ss.str());

		//Set fault status	
		SetConfigureStatus("FAILED",ss.str(),true);
	
		_THROW_TANGO_EXCEPTION("CONFIGURE_BAND_FAILED",ss.str());
	}	

	bool hasActiveBand= (activeBandId != bandNotConfigured);
	bool isSameBandRequested= (bandId == activeBandId);
	if(isSameBandRequested && hasActiveBand){
		_INFO_LOG("Requested band (bandId="<<bandId<<") is already active, re-configuring...");
	}	
	

	//=====================================================
	//==         GET SET VALUES
	//=====================================================
	//Retrieve mode value corresponding to label
	Tango::DevShort mode;
	Tango::DevShort mode_safe;	
	Utils_ns::TangoUtils::GetEnumAttrValue(mode,this,attr_name,mode_str);
	Utils_ns::TangoUtils::GetEnumAttrValue(mode_safe,this,attr_name,mode_safe_str);
	
	//Retrieve capability corresponding to label
	std::string cap_attr_name= cap_attr_names[bandId-1];
	Tango::DevShort capability;
	Tango::DevShort capability_safe;
	Utils_ns::TangoUtils::GetEnumAttrValue(capability,this,cap_attr_name,capability_str);
	Utils_ns::TangoUtils::GetEnumAttrValue(capability_safe,this,cap_attr_name,capability_safe_str);

	//Retrieve default attenuations
	Tango::DevFloat attenuation_h;
	Tango::DevFloat attenuation_v;
	if(GetDynAttrValue(attenuation_h,attenuation_h_attr_names[bandId-1])<0){
		std::stringstream ss;
		ss<<"Failed to get dyn attr "<<attenuation_h_attr_names[bandId-1]<<" value!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("CONFIGURE_BAND_FAILED",ss.str());	
	}
	if(GetDynAttrValue(attenuation_v,attenuation_v_attr_names[bandId-1])<0){
		std::stringstream ss;
		ss<<"Failed to get dyn attr "<<attenuation_v_attr_names[bandId-1]<<" value!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("CONFIGURE_BAND_FAILED",ss.str());	
	}

	//=====================================================
	//==      STOP CAPTURE ON ACTIVE BAND (IF ANY)
	//=====================================================
	//Stop capture on active band
	if(hasActiveBand){
		try {
			capture_data(false);
		}
		catch(Tango::DevFailed& e){
			std::stringstream ss;
			ss<<"Failed to stop data capture on active band "<<activeBandId<<"!";
			_ERROR_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("CONFIGURE_BAND_FAILED",ss.str());
		}//close catch
	}//close if hasActiveBand

	//=====================================================
	//==      SET SYNCHRONISE TO FALSE
	//=====================================================
	_INFO_LOG("Setting synchronise flag to FALSE ...");
	Tango::DevBoolean synchronised= false;
	if(SetDynAttrValue<Tango::DevBoolean>(synchronised,synchronise_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<synchronise_attr_name<<" to "<<synchronised<<"!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("CONFIGURE_BAND_FAILED",ss.str());
	}

	//=====================================================
	//==         SET MODE TO CONFIGURE
	//=====================================================
	_INFO_LOG("Setting mode to "<<mode<<" ("<<mode_str<<")...");
	if(SetSMDynAttrValue<Tango::DevShort>(mode,attr_name,&mode_safe)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<attr_name<<" to "<<mode<<"!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("CONFIGURE_BAND_FAILED",ss.str());
	}

	//=====================================================
	//==         SET CAPABILITY TO CONFIGURE
	//=====================================================
	//Set capability to CONFIGURE (check if allowed and if it fails revert it to STANDBY)
	_INFO_LOG("Setting capability to "<<capability<<" ("<<capability_str<<")...");
	if(SetSMDynAttrValue<Tango::DevShort>(capability,cap_attr_name,&capability_safe)<0){
		std::stringstream ss;
		ss<<"Failed to set capability "<<cap_attr_name<<" to "<<capability<<"!";
		_ERROR_LOG(ss.str());

		//Revert mode to STANDBY-FP	
		SetDynAttrValue<Tango::DevShort>(mode_safe,attr_name);
	
		//Throw exception
		_THROW_TANGO_EXCEPTION("CONFIGURE_BAND_FAILED",ss.str());
	}

	//=====================================================
	//==         SET ATTENUATION
	//=====================================================
	//Set attenuations for configured band
	_INFO_LOG("Setting current attenuation for H/V channels to default value of band "<<bandId<<" ...");
	if(SetDynAttrValue<Tango::DevFloat>(attenuation_h,attenuation_h_attr_names[bandId-1])<0){
		std::stringstream ss;
		ss<<"Failed to set h-channel attenuation attr "<<attenuation_h_attr_names[bandId-1]<<" to "<<attenuation_h<<"!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("CONFIGURE_BAND_FAILED",ss.str());
	}
	if(SetDynAttrValue<Tango::DevFloat>(attenuation_v,attenuation_v_attr_names[bandId-1])<0){
		std::stringstream ss;
		ss<<"Failed to set v-channel attenuation attr "<<attenuation_v_attr_names[bandId-1]<<" to "<<attenuation_v<<"!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("CONFIGURE_BAND_FAILED",ss.str());
	}

	//=====================================================
	//==        UPDATE SELECTED BAND (DO BEFORE START CAPTURE)
	//=====================================================
	//Set current band attr to the selected (MISSING IN ICD!!!)
	if(SetDynAttrValue<Tango::DevShort>(bandId,activeBand_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<activeBand_attr_name<<" to "<<bandId<<"!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("CONFIGURE_BAND_FAILED",ss.str());
	}

	//=====================================================
	//==      START CAPTURE ON SELECTED BAND
	//=====================================================
	//Start data capture: if successful mode=DATA-CAPTURE, cap=OPERATE
	try {
		capture_data(true);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		std::stringstream ss;
		ss<<"Failed to stop data capture on selected band!";
		_ERROR_LOG(ss.str());

		//Revert mode to STANDBY-FP	(already done in capture)
		SetDynAttrValue<Tango::DevShort>(mode_safe,attr_name);
	
		//Revert capability to STANDBY (already done in capture)
		SetDynAttrValue<Tango::DevShort>(capability_safe,cap_attr_name);
	
		//Throw exception
		_THROW_TANGO_EXCEPTION("CONFIGURE_BAND_FAILED",ss.str());
	}//close catch
	*/
	
	/*----- PROTECTED REGION END -----*/	//	RxEmulator::configure_band
}
//--------------------------------------------------------
/**
 *	Command ConfigureBand1 related method
 *	Description: Set designated band and load the necessary configuration 
 *               into the FPGA. This will prepare the FPGA so that on 
 *               completion of this command, the FPGA 
 *               and sub-element will begin capturing data.
 *               The command automatically transition to 
 *               DATA-CAPTURE in case of success, otherwise revert back
 *               to STANDBY-FP (MAINTENANCE?).
 *               
 *               Allowed only in SPFRx modes:{STANDBY-FP,DATA-CAPTURE,MAINTENANCE}
 *
 */
//--------------------------------------------------------
void RxEmulator::configure_band1()
{
	DEBUG_STREAM << "RxEmulator::ConfigureBand1()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(RxEmulator::configure_band1) ENABLED START -----*/
	
	//	Add your own code
	_INFO_LOG("Configuring receiver band 1...");
	Tango::DevShort bandId= 1;
	try{
		ConfigureBand(bandId);
	}
	catch(...){
		throw;
	}
	/*----- PROTECTED REGION END -----*/	//	RxEmulator::configure_band1
}
//--------------------------------------------------------
/**
 *	Command ConfigureBand2 related method
 *	Description: Set designated band and load the necessary configuration 
 *               into the FPGA. This will prepare the FPGA so that on 
 *               completion of this command, the FPGA 
 *               and sub-element will begin capturing data.
 *               The command automatically transition to 
 *               DATA-CAPTURE in case of success, otherwise revert back
 *               to STANDBY-FP (MAINTENANCE?).
 *               
 *               Allowed only in SPFRx modes:{STANDBY-FP,DATA-CAPTURE,MAINTENANCE}
 *
 */
//--------------------------------------------------------
void RxEmulator::configure_band2()
{
	DEBUG_STREAM << "RxEmulator::ConfigureBand2()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(RxEmulator::configure_band2) ENABLED START -----*/
	
	//	Add your own code
	_INFO_LOG("Configuring receiver band 2...");
	Tango::DevShort bandId= 2;
	try{
		ConfigureBand(bandId);
	}
	catch(...){
		throw;
	}
	/*----- PROTECTED REGION END -----*/	//	RxEmulator::configure_band2
}
//--------------------------------------------------------
/**
 *	Command ConfigureBand3 related method
 *	Description: Set designated band and load the necessary configuration 
 *               into the FPGA. This will prepare the FPGA so that on 
 *               completion of this command, the FPGA 
 *               and sub-element will begin capturing data.
 *               The command automatically transition to 
 *               DATA-CAPTURE in case of success, otherwise revert back
 *               to STANDBY-FP (MAINTENANCE?).
 *               
 *               Allowed only in SPFRx modes:{STANDBY-FP,DATA-CAPTURE,MAINTENANCE}
 *
 */
//--------------------------------------------------------
void RxEmulator::configure_band3()
{
	DEBUG_STREAM << "RxEmulator::ConfigureBand3()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(RxEmulator::configure_band3) ENABLED START -----*/
	
	//	Add your own code
	_INFO_LOG("Configuring receiver band 3...");
	Tango::DevShort bandId= 3;
	try{
		ConfigureBand(bandId);
	}
	catch(...){
		throw;
	}
	/*----- PROTECTED REGION END -----*/	//	RxEmulator::configure_band3
}
//--------------------------------------------------------
/**
 *	Command ConfigureBand4 related method
 *	Description: Set designated band and load the necessary configuration 
 *               into the FPGA. This will prepare the FPGA so that on 
 *               completion of this command, the FPGA 
 *               and sub-element will begin capturing data.
 *               The command automatically transition to 
 *               DATA-CAPTURE in case of success, otherwise revert back
 *               to STANDBY-FP (MAINTENANCE?).
 *               
 *               Allowed only in SPFRx modes:{STANDBY-FP,DATA-CAPTURE,MAINTENANCE}
 *
 */
//--------------------------------------------------------
void RxEmulator::configure_band4()
{
	DEBUG_STREAM << "RxEmulator::ConfigureBand4()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(RxEmulator::configure_band4) ENABLED START -----*/
	
	//	Add your own code
	_INFO_LOG("Configuring receiver band 4...");
	Tango::DevShort bandId= 4;
	try{
		ConfigureBand(bandId);
	}
	catch(...){
		throw;
	}
	/*----- PROTECTED REGION END -----*/	//	RxEmulator::configure_band4
}
//--------------------------------------------------------
/**
 *	Command ConfigureBand5a related method
 *	Description: Set designated band and load the necessary configuration 
 *               into the FPGA. This will prepare the FPGA so that on 
 *               completion of this command, the FPGA 
 *               and sub-element will begin capturing data.
 *               The command automatically transition to 
 *               DATA-CAPTURE in case of success, otherwise revert back
 *               to STANDBY-FP (MAINTENANCE?).
 *               
 *               Allowed only in SPFRx modes:{STANDBY-FP,DATA-CAPTURE,MAINTENANCE}
 *
 */
//--------------------------------------------------------
void RxEmulator::configure_band5a()
{
	DEBUG_STREAM << "RxEmulator::ConfigureBand5a()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(RxEmulator::configure_band5a) ENABLED START -----*/
	
	//	Add your own code
	_INFO_LOG("Configuring receiver band 5a...");
	Tango::DevShort bandId= 5;
	try{
		ConfigureBand(bandId);
	}
	catch(...){
		throw;
	}
	/*----- PROTECTED REGION END -----*/	//	RxEmulator::configure_band5a
}
//--------------------------------------------------------
/**
 *	Command ConfigureBand5b related method
 *	Description: Set designated band and load the necessary configuration 
 *               into the FPGA. This will prepare the FPGA so that on 
 *               completion of this command, the FPGA 
 *               and sub-element will begin capturing data.
 *               The command automatically transition to 
 *               DATA-CAPTURE in case of success, otherwise revert back
 *               to STANDBY-FP (MAINTENANCE?).
 *               
 *               Allowed only in SPFRx modes:{STANDBY-FP,DATA-CAPTURE,MAINTENANCE}
 *
 */
//--------------------------------------------------------
void RxEmulator::configure_band5b()
{
	DEBUG_STREAM << "RxEmulator::ConfigureBand5b()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(RxEmulator::configure_band5b) ENABLED START -----*/
	
	//	Add your own code
	_INFO_LOG("Configuring receiver band 5b...");
	Tango::DevShort bandId= 6;
	try{
		ConfigureBand(bandId);
	}
	catch(...){
		throw;
	}
	
	/*----- PROTECTED REGION END -----*/	//	RxEmulator::configure_band5b
}
//--------------------------------------------------------
/**
 *	Command ConfigureBandAsync related method
 *	Description: Configure receiver band. 
 *               This command Instructs the receiver to select the 
 *               Set designated band and load the necessary configuration 
 *               into the FPGA. This will prepare the FPGA so that on 
 *               completion of this command, the FPGA 
 *               and sub-element will begin capturing data.
 *               The command automatically transition to 
 *               DATA-CAPTURE in case of success, otherwise revert back
 *               to STANDBY-FP (MAINTENANCE?).
 *               
 *               Allowed only in Rx modes:{STANDBY-FP,DATA-CAPTURE,MAINTENANCE}
 *
 *	@param argin Band id
 *	@returns 
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *RxEmulator::configure_band_async(Tango::DevShort argin)
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "RxEmulator::ConfigureBandAsync()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(RxEmulator::configure_band_async) ENABLED START -----*/
	
	//	Add your own code
	// == COMMAND BEHAVIOR ==
	// 1) Check if mode-allowed (DONE IN STATE MACHINE FILE)
	// 2) Check given band argument
	// 3) Check if required band is already configured. If so, reconfigure (parameters could have changed before this command is invoked)
	//    NB: It would be better to check if the config pars have changed (define an attribute?). If not, reply quickly with "Band already configured"
	// 4) Stop data capture on active band and check mode (TBD)
	// 5) Set mode to CONFIGURE 
	// 6) Switch given band capability to CONFIGURE [transition may take up to 30 s]
	// 7) If successful, automatically start data capture and switch rx_mode to DATA-CAPTURE
	// 8) If successful, switch capability of selected band to OPERATE
	// 9) Update configuredBand attr 

	//Init output argument
	argout= new Tango::DevVarLongStringArray;
	argout->svalue.length(1);
	argout->lvalue.length(1);	

	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string attr_name= "operatingMode";
	std::vector<std::string> cap_attr_names= {
		"b1CapabilityState",
		"b2CapabilityState",
		"b3CapabilityState",
		"b4CapabilityState",
		"b5aCapabilityState",
		"b5bCapabilityState",
	};
	std::string activeBand_attr_name= "configuredBand";
	std::string mode_str= "CONFIGURE";
	std::string mode_safe_str= "STANDBY-FP";
	std::string mode_final_str= "DATA-CAPTURE";
	std::string capability_str= "CONFIGURE";
	std::string capability_final_str= "OPERATE";
	std::string capability_safe_str= "STANDBY";
	Tango::DevShort bandNotConfigured= 0;
	int nBands= 6;
	//============================================================================

	//=====================================================
	//==         INIT ARGUMENTS
	//=====================================================
	//## Get bandId arg 
	Tango::DevShort bandId= argin;	
	if(bandId<=0 || bandId>nBands){
		std::stringstream ss;
		ss<<"Invalid argument given (bandId="<<bandId<<"), valid values are in range ["<<1<<","<<nBands<<"]!";
		_ERROR_LOG(ss.str());
	
		//Set fault status	
		SetConfigureStatus("FAILED",ss.str(),true);

		_THROW_TANGO_EXCEPTION("CONFIGURE_FAILED",ss.str());
	}
	
	//=====================================================
	//==        CHECK CONFIGURED BAND ID
	//=====================================================
	//## Get band currently active (can be the same of given argument or different)
	Tango::DevShort activeBandId= 0;
	if(GetDynAttrValue(activeBandId,activeBand_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<activeBand_attr_name<<" value!";
		_ERROR_LOG(ss.str());

		//Set fault status	
		SetConfigureStatus("FAILED",ss.str(),true);
	
		_THROW_TANGO_EXCEPTION("CONFIGURE_BAND_FAILED",ss.str());
	}	

	bool hasActiveBand= (activeBandId != bandNotConfigured);
	bool isSameBandRequested= (bandId == activeBandId);
	if(isSameBandRequested && hasActiveBand){
		_INFO_LOG("Requested band (bandId="<<bandId<<") is already active, re-configuring...");
	}	
	
	
	//=====================================================
	//==    CONFIGURE TASK (PERFORMED IN TASK THREAD)
	//=====================================================
	//Prepare message data
	ConfigMsg msg_data;
	msg_data.bandId= bandId;
	msg_data.task_duration= configureTime;
	msg_data.enable_failure= enableConfigureFailure;
	msg_data.failure_probability= configureFailureProbability;

	//Init status attr
	SetConfigureStatus("IDLE","Configure band command requested",true);

	//Post configure message to queue
	bool isSynchronous= false;
	try {	
		m_task->execute_configure(msg_data, isSynchronous);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		std::string errMsg("Tango exception occurred while executing configuration task!");
		_ERROR_LOG(errMsg);

		SetConfigureStatus("ABORTED","Configure band command failed to be scheduled!",true);

		throw;
	}	
	catch(...){
		std::string errMsg("Unknown C++ exception occurred while adding device to group!");
		_ERROR_LOG(errMsg);	

		SetConfigureStatus("ABORTED","Configure band command failed to be scheduled!",true);

		throw;
	}

	//Set reply 
	argout->svalue[0] = CORBA::string_dup("Configure band scheduled");	
	argout->lvalue[0] = 1;

	/*----- PROTECTED REGION END -----*/	//	RxEmulator::configure_band_async
	return argout;
}
//--------------------------------------------------------
/**
 *	Command CaptureData related method
 *	Description: Start/stop capture on the configured band.
 *               Command only valid in {DATA-CAPTURE, STANDBY-FP} modes
 *
 *	@param argin Flag value start/stop (0/1)
 */
//--------------------------------------------------------
void RxEmulator::capture_data(Tango::DevBoolean argin)
{
	DEBUG_STREAM << "RxEmulator::CaptureData()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(RxEmulator::capture_data) ENABLED START -----*/
	
	
	//	Add your own code
	// == COMMAND BEHAVIOR ==
	// 1) Check if mode-allowed {"STANDBY-FP","DATA-CAPTURE","MAINTENANCE"} (DONE IN STATE MACHINE FILE)
	// 2) Check if power-allowed {"FULL-POWER"} (DONE IN STATE MACHINE FILE)
	// 3) Check if there is a band active, if not throw exception (inform clients to configure first)! (DONE IN STATE MACHINE FILE)
	// 4) Check if capability-allowed {"OPERATE","STANDBY"} (DONE IN STATE MACHINE FILE)
	// 5) Set mode 
	//      CASE (current_mode==DATA-CAPTURE)
	// 				** CASE enable: Already in capture, nothing to be done!
	//				** CASE disable: Go to STANDBY-FP mode, set capability of active band to STANDBY  
	// 			CASE (current_mode== STANDBY-FP || MAINTENANCE)
	// 				** CASE enable: Go to DATA-CAPTURE mode, set capability of selected band to OPERATE
	// 				** CASE disable: Already disabled, nothing to be done
	

	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string attr_name= "operatingMode";
	std::string powerState_attr_name= "powerState";
	std::vector<std::string> cap_attr_names= {
		"b1CapabilityState",
		"b2CapabilityState",
		"b3CapabilityState",
		"b4CapabilityState",
		"b5aCapabilityState",
		"b5bCapabilityState",
	};
	std::string activeBand_attr_name= "configuredBand";
	std::string capturing_attr_name= "capturingData";
	std::string inactiveBand_str= "NONE";
	std::string mode_captureOn_str= "DATA-CAPTURE";
	std::string mode_captureOff_str= "STANDBY-FP";
	std::string mode_str= "";
	std::string mode_safe_str= "STANDBY-FP";
	std::string powerState_str= "FULL-POWER";
	std::string capability_captureOn_str= "OPERATE";	
	std::string capability_captureOff_str= "STANDBY";
	std::string capability_str= "";
	std::string capability_safe_str= "STANDBY";
	std::string capability_faulty_str= "UNAVAILABLE"; 
	//============================================================================

	//=====================================================
	//==         INIT ARGUMENTS
	//=====================================================
	// Get capture enable flag arg 
	bool captureEnabled= argin;
	if(captureEnabled==true){
		_INFO_LOG("Requested to start data capture... ");
		mode_str= mode_captureOn_str;
		capability_str= capability_captureOn_str;
	}
	else{
		_INFO_LOG("Requested to stop data capture... ");
		mode_str= mode_captureOff_str;
		capability_str= capability_captureOff_str;
	}

	//=====================================================
	//==         GET ACTIVE BAND
	//=====================================================
	//Retrieve current configured band
	Tango::DevShort activeBand;
	if(GetDynAttrValue(activeBand,activeBand_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<activeBand_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("CAPTURE_DATA_FAILED",ss.str());
	}
	std::string activeBand_str;	
	Utils_ns::TangoUtils::GetEnumAttrLabelValue(activeBand_str,this,activeBand_attr_name,activeBand);

	//If start capture check if configured band is NONE
	bool hasActiveBand= (activeBand_str != inactiveBand_str);
	if(captureEnabled && !hasActiveBand){
		std::stringstream ss;
		ss<<"Failed to start capture because no band was configured!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("CAPTURE_DATA_FAILED",ss.str());
	}

	
	//=====================================================
	//==         SET MODE 
	//=====================================================
	//Retrieve mode value corresponding to label
	Tango::DevShort mode;
	Utils_ns::TangoUtils::GetEnumAttrValue(mode,this,attr_name,mode_str);

	//Retrieve current mode attr value
	Tango::DevShort current_mode;
	if(GetDynAttrValue(current_mode,attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("CAPTURE_DATA_FAILED",ss.str());
	}

	//If mode is already set return
	if(current_mode==mode){
		std::stringstream ss;
		if(captureEnabled) ss<<"Receiver already capturing data (mode="<<mode_str<<" already active), nothing to be done!";
		else ss<<"Data capture is already off (mode="<<mode_str<<" already active), nothing to be done!";
		_INFO_LOG(ss.str());
		return;
	}	
	//Set mode
	if(SetSMDynAttrValue<Tango::DevShort>(mode,attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<attr_name<<" to "<<mode<<")!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("CAPTURE_DATA_FAILED",ss.str());
	}

	//=============================================================
	//==         SET CAPABILITY (ONLY IF THERE IS AN ACTIVE BAND
	//=============================================================
	//Set capability
	if(hasActiveBand){
		//Retrieve capability corresponding to label
		std::string cap_attr_name= cap_attr_names[activeBand-1];
		Tango::DevShort capability;
		Utils_ns::TangoUtils::GetEnumAttrValue(capability,this,cap_attr_name,capability_str);

		//Retrieve current capability attr value
		Tango::DevShort current_capability;
		if(GetDynAttrValue(current_capability,cap_attr_name)<0){
			std::stringstream ss;
			ss<<"Failed to get attr "<<cap_attr_name<<" value!";
			_ERROR_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("CAPTURE_DATA_FAILED",ss.str());
		}
		std::string current_capability_str;	
		Utils_ns::TangoUtils::GetEnumAttrLabelValue(current_capability_str,this,cap_attr_name,current_capability);

		//Set capability value
		if(current_capability_str!=capability_faulty_str && SetSMDynAttrValue(capability,cap_attr_name)<0){
			std::stringstream ss;
			ss<<"Failed to set attr "<<cap_attr_name<<" to "<<capability<<")!";
			_ERROR_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("CAPTURE_DATA_FAILED",ss.str());
		}
	}//close if hasActiveBand


	//=============================================================
	//==         SET CAPTURING DATA FLAG
	//=============================================================
	Tango::DevBoolean capturing= false;
	if(captureEnabled==true) capturing= true;
	
	if(SetDynAttrValue<Tango::DevBoolean>(capturing,capturing_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<capturing_attr_name<<" to "<<capturing<<")!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("CAPTURE_DATA_FAILED",ss.str());
	}


	/*----- PROTECTED REGION END -----*/	//	RxEmulator::capture_data
}
//--------------------------------------------------------
/**
 *	Command SetSubElementMode related method
 *	Description: Set the sub-element mode.
 *               Allowed set modes are: 
 *               
 *               Data_Capture
 *               Standby_FP 
 *               Standby_LP 
 *               Maintenance
 *
 *	@param argin Operational mode 
 *               {Data_Capture | Standby_FP | Standby_LP | Maintenance}
 */
//--------------------------------------------------------
void RxEmulator::set_sub_element_mode(Tango::DevShort argin)
{
	DEBUG_STREAM << "RxEmulator::SetSubElementMode()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(RxEmulator::set_sub_element_mode) ENABLED START -----*/
	
	//	Add your own code
	
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string attr_name= "operatingMode";
	std::vector<std::string> cap_attr_names= {
		"b1CapabilityState",
		"b2CapabilityState",
		"b3CapabilityState",
		"b4CapabilityState",
		"b5aCapabilityState",	
		"b5bCapabilityState",
	};
	std::string activeBand_attr_name= "configuredBand";
	std::string powerState_attr_name= "powerState";
	//============================================================================


	//=====================================================
	//==         CHECK ARGS
	//=====================================================
	//Get args 
	Tango::DevShort mode= argin;
	
	//Get string label (check if it is a valid enum)
	std::string mode_str= "";
	if(Utils_ns::TangoUtils::GetEnumAttrLabelValue(mode_str,this,attr_name,mode)<0){
		std::stringstream ss;
		ss<<"Invalid mode enumeration given in argument (check mode enum values)!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_SUB_ELEMENT_MODE_FAILED",ss.str());
	}

	//=====================================================
	//==         CHECK MODE
	//=====================================================
	//Retrieve current mode attr value
	Tango::DevShort current_mode;
	if(GetDynAttrValue(current_mode,attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_SUB_ELEMENT_MODE_FAILED",ss.str());
	}

	//Check if same mode is given
	if(mode==current_mode){
		_INFO_LOG("Mode "<<mode_str<<" is already selected, nothing to be done");
		return;
	}	
	
	//=====================================================
	//==         SET MODE
	//=====================================================
	if(mode_str=="STANDBY-LP"){
		return set_standby_lpmode();
	}
	else if(mode_str=="STANDBY-FP"){
		return set_standby_fpmode();
	}
	else if(mode_str=="DATA-CAPTURE"){
		return capture_data(true);
	}
	else if(mode_str=="MAINTENANCE"){
		return set_maintenance_mode();
	}
	else{//should not get here
		std::stringstream ss;
		ss<<"Invalid mode requested ("<<mode_str<<")!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_SUB_ELEMENT_MODE_FAILED",ss.str());
	}

	/*----- PROTECTED REGION END -----*/	//	RxEmulator::set_sub_element_mode
}
//--------------------------------------------------------
/**
 *	Command SetSubElementModeStr related method
 *	Description: Set Rx mode
 *
 *	@param argin Requested mode. Allowed values are:
 *               
 *               {``STANDBY-LP``,``STANDBY-FP``,``DATA-CAPTURE``,``MAINTENANCE``}
 */
//--------------------------------------------------------
void RxEmulator::set_sub_element_mode_str(Tango::DevString argin)
{
	DEBUG_STREAM << "RxEmulator::SetSubElementModeStr()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(RxEmulator::set_sub_element_mode_str) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string attr_name= "operatingMode";
	//============================================================================

	//=====================================================
	//==         CHECK ARGS
	//=====================================================
	//Get args (INTEGRITY CHECK PERFORMED IN STATE MACHINE CLASS)
	std::string mode_str= std::string(argin);

	//Check this is a valid mode enumeration
	Tango::DevShort mode;
	if(Utils_ns::TangoUtils::GetEnumAttrValue(mode,this,attr_name,mode_str)<0){
		std::stringstream ss;
		ss<<"Invalid mode enumeration ("<<mode_str<<") given in argument (check mode enum values)!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_SUB_ELEMENT_MODE_STR_FAILED",ss.str());
	}

	//=====================================================
	//==         SET MODE
	//=====================================================
	//Return SetSubElementMode cmd
	return set_sub_element_mode(mode);
	

	/*----- PROTECTED REGION END -----*/	//	RxEmulator::set_sub_element_mode_str
}
//--------------------------------------------------------
/**
 *	Command SetStandbyLPMode related method
 *	Description: Activate STANDBY-LP mode
 *               
 *               Allowed only in mode: {STANDBY-LP, STANDBY-FP, MAINTENANCE}
 *
 */
//--------------------------------------------------------
void RxEmulator::set_standby_lpmode()
{
	DEBUG_STREAM << "RxEmulator::SetStandbyLPMode()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(RxEmulator::set_standby_lpmode) ENABLED START -----*/
	
	//	Add your own code
	// == COMMAND BEHAVIOR ==
	// 1) Check if cmd mode-allowed {"STANDBY-FP","MAINTENANCE","DATA-CAPTURE"} (DONE IN STATE MACHINE)
	// 2) Check if mode transition allowed {"STANDBY-FP","MAINTENANCE"}-->"STANDBY-LP" (DONE IN STATE MACHINE)
	// 3) Check if powerState transition allowed {"LOW-POWER","FULL-POWER"}-->"LOW-POWER" (DONE IN STATE MACHINE)
	// 4) Stop data capture (if active)
	// 5) Set power state to LOW-POWER
	// 6) Set capabilities to STANDBY 
	// 7) Set mode to STANDBY-LP

	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string mode_attr_name= "operatingMode";
	std::string powerState_attr_name= "powerState";
	std::vector<std::string> cap_attr_names= {
		"b1CapabilityState",
		"b2CapabilityState",
		"b3CapabilityState",
		"b4CapabilityState",
		"b5aCapabilityState",
		"b5bCapabilityState",
	};
	std::string activeBand_attr_name= "configuredBand";
	std::string mode_str= "STANDBY-LP"; 
	std::string powerState_str= "LOW-POWER";
	std::string capability_str= "STANDBY"; 
	std::string capability_faulty_str= "UNAVAILABLE"; 
	Tango::DevShort bandNotConfigured= 0;
	//===========================================================================

	_INFO_LOG("Setting SPFRx mode to STANDBY-LP...");

	//=====================================================
	//==         CHECK STATE MACHINE
	//=====================================================
	_DEBUG_LOG("Check if cmd "<<__FUNCTION__<<" is allowed...");
	bool check_cmd= true;
	try {
		IsCmdAllowed(__FUNCTION__,check_cmd);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		throw;
	}

	//=====================================================
	//==         GET ATTRS INIT VALUES
	//=====================================================

	//Retrieve mode value corresponding to label
	Tango::DevShort mode;
	Utils_ns::TangoUtils::GetEnumAttrValue(mode,this,mode_attr_name,mode_str);

	//Retrieve powerState value corresponding to label
	Tango::DevShort powerState;
	Utils_ns::TangoUtils::GetEnumAttrValue(powerState,this,powerState_attr_name,powerState_str);

	std::vector<Tango::DevShort> capabilities;
	for(unsigned int i=0;i<cap_attr_names.size();i++){
		Tango::DevShort capability= -1;
		Utils_ns::TangoUtils::GetEnumAttrValue(capability,this,cap_attr_names[i],capability_str);
		capabilities.push_back(capability);
	}

	//=====================================================
	//==      CHECK CURRENT MODE/POWER/CAPABILITIES
	//=====================================================
	//Get current mode
	Tango::DevShort mode_current;	
	if(GetDynAttrValue(mode_current,mode_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<mode_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STANDBY_LP_MODE_FAILED",ss.str());
	}	

	//Get current powerState
	Tango::DevShort powerState_current= -1;	
	if(GetDynAttrValue(powerState_current,powerState_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<powerState_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STANDBY_LP_MODE_FAILED",ss.str());
	}	

	//Get capability values
	std::vector<Tango::DevShort> capabilities_current;
	std::vector<std::string> capabilities_current_str;	
	for(unsigned int i=0;i<cap_attr_names.size();i++){
		Tango::DevShort cap;	
		if(GetDynAttrValue(cap,cap_attr_names[i])<0){
			std::stringstream ss;
			ss<<"Failed to get attr "<<cap_attr_names[i]<<" value!";
			_ERROR_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("SET_STANDBY_LP_MODE_FAILED",ss.str());
		}		
		capabilities_current.push_back(cap);

		std::string cap_str= "";
		Utils_ns::TangoUtils::GetEnumAttrLabelValue(cap_str,this,cap_attr_names[i],cap);
		capabilities_current_str.push_back(cap_str);
	}//end loop capabilities


	//Check if requested attr values are already activated
	bool alreadyActive= ( 
		(mode==mode_current) && 
		(powerState==powerState_current) 
	);
	if(alreadyActive){
		_INFO_LOG("Requested mode "<<mode_str<<" is already active, nothing to be done!");
		return;
	}
	
	//=====================================================
	//==      STOP CAPTURE ON ACTIVE BAND (IF ANY)
	//=====================================================
	//Get band currently active (can be the same of given argument or different)
	Tango::DevShort activeBandId= 0;
	if(GetDynAttrValue(activeBandId,activeBand_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<activeBand_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STANDBY_LP_MODE_FAILED",ss.str());
	}	

	bool hasActiveBand= (activeBandId != bandNotConfigured);

	//Stop capture on active band
	if(hasActiveBand){
		_INFO_LOG("Stopping data capture on active band (if any)...");
		try {
			capture_data(false);
		}
		catch(Tango::DevFailed& e){
			std::stringstream ss;
			ss<<"Failed to stop data capture on active band "<<activeBandId<<"!";
			_ERROR_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("SET_STANDBY_LP_MODE_FAILED",ss.str());
		}//close catch
	}//close if hasActiveBand

	//=====================================================
	//==        SET POWER STATE
	//=====================================================
	//Set power state to LOW-POWER
	if(SetSMDynAttrValue(powerState,powerState_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<powerState_attr_name<<" to "<<powerState<<"!";
		_ERROR_LOG(ss.str());	
		_THROW_TANGO_EXCEPTION("SET_STANDBY_LP_MODE_FAILED",ss.str());
	}

	//=====================================================
	//==        SET CAPABILITY
	//=====================================================
	//Set capability to STANDBY
	for(unsigned int i=0;i<cap_attr_names.size();i++){
		if(capabilities_current_str[i]!=capability_faulty_str && SetSMDynAttrValue(capabilities[i],cap_attr_names[i])<0){
			std::stringstream ss;
			ss<<"Failed to set attr "<<cap_attr_names[i]<<" to "<<capabilities[i]<<"!";
			_ERROR_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("SET_STANDBY_LP_MODE_FAILED",ss.str());
		}
	}//end loop capabilities

	//=====================================================
	//==        SET MODE
	//=====================================================
	//Set mode to STANDBY-LP
	if(SetSMDynAttrValue(mode,mode_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<mode_attr_name<<" to "<<mode<<"!";
		_ERROR_LOG(ss.str());	
		_THROW_TANGO_EXCEPTION("SET_STANDBY_LP_MODE_FAILED",ss.str());
	}

	/*----- PROTECTED REGION END -----*/	//	RxEmulator::set_standby_lpmode
}
//--------------------------------------------------------
/**
 *	Command SetStandbyFPMode related method
 *	Description: Activate STANDBY-FP mode
 *               
 *               Allowed only in mode: {STANDBY-LP,STANDBY-FP,MAINTENANCE,CONFIGURE,DATA-CAPTURE}
 *
 */
//--------------------------------------------------------
void RxEmulator::set_standby_fpmode()
{
	DEBUG_STREAM << "RxEmulator::SetStandbyFPMode()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(RxEmulator::set_standby_fpmode) ENABLED START -----*/
	
	//	Add your own code
	// == COMMAND BEHAVIOR ==
	// 1) Check if cmd mode-allowed {"STANDBY-LP","MAINTENANCE","CONFIGURE","DATA-CAPTURE"} (DONE IN STATE MACHINE)
	// 2) Check if mode transition allowed {"STANDBY-LP","MAINTENANCE","CONFIGURE","DATA-CAPTURE"}-->"STANDBY-FP" (DONE IN STATE MACHINE)
	// 3) Check if powerState transition allowed {"LOW-POWER","FULL-POWER"}-->"FULL-POWER" (DONE IN STATE MACHINE)
	// 4) Set power state to FULL-POWER
	// 5) Set capability of selected band to STANDBY 
	// 6) Set mode to STANDBY-FP

	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string mode_attr_name= "operatingMode";
	std::string powerState_attr_name= "powerState";
	std::vector<std::string> cap_attr_names= {
		"b1CapabilityState",
		"b2CapabilityState",
		"b3CapabilityState",
		"b4CapabilityState",
		"b5aCapabilityState",
		"b5bCapabilityState",
	};
	std::string activeBand_attr_name= "configuredBand";
	std::string mode_str= "STANDBY-FP"; 
	std::string powerState_str= "FULL-POWER";
	std::string capability_str= "STANDBY"; 
	std::string capability_faulty_str= "UNAVAILABLE"; 
	//===========================================================================

	_INFO_LOG("Setting SPFRx to STANDBY-FP mode...");

	//=====================================================
	//==         CHECK STATE MACHINE
	//=====================================================
	_DEBUG_LOG("Check if cmd "<<__FUNCTION__<<" is allowed...");
	bool check_cmd= true;
	try {
		IsCmdAllowed(__FUNCTION__,check_cmd);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		throw;
	}

	//=====================================================
	//==         GET ATTRS INIT VALUES
	//=====================================================

	//Retrieve mode value corresponding to label
	Tango::DevShort mode;
	Utils_ns::TangoUtils::GetEnumAttrValue(mode,this,mode_attr_name,mode_str);

	//Retrieve powerState value corresponding to label
	Tango::DevShort powerState;
	Utils_ns::TangoUtils::GetEnumAttrValue(powerState,this,powerState_attr_name,powerState_str);

	std::vector<Tango::DevShort> capabilities;
	for(unsigned int i=0;i<cap_attr_names.size();i++){
		Tango::DevShort capability= -1;
		Utils_ns::TangoUtils::GetEnumAttrValue(capability,this,cap_attr_names[i],capability_str);
		capabilities.push_back(capability);
	}

	//=====================================================
	//==      CHECK CURRENT MODE/POWER/CAPABILITIES
	//=====================================================
	//Get current mode
	Tango::DevShort mode_current;	
	if(GetDynAttrValue(mode_current,mode_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<mode_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STANDBY_FP_MODE_FAILED",ss.str());
	}	

	//Get current powerState
	Tango::DevShort powerState_current;	
	if(GetDynAttrValue(powerState_current,powerState_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<powerState_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STANDBY_FP_MODE_FAILED",ss.str());
	}	

	//Get capability values
	std::vector<Tango::DevShort> capabilities_current;
	std::vector<std::string> capabilities_current_str;	
	for(unsigned int i=0;i<cap_attr_names.size();i++){
		Tango::DevShort cap;	
		if(GetDynAttrValue(cap,cap_attr_names[i])<0){
			std::stringstream ss;
			ss<<"Failed to get attr "<<cap_attr_names[i]<<" value!";
			_ERROR_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("SET_STANDBY_FP_MODE_FAILED",ss.str());
		}		
		capabilities_current.push_back(cap);

		std::string cap_str= "";
		Utils_ns::TangoUtils::GetEnumAttrLabelValue(cap_str,this,cap_attr_names[i],cap);
		capabilities_current_str.push_back(cap_str);
	}//end loop capabilities

	//Check if requested attr values are already activated
	bool alreadyActive= ( 
		(mode==mode_current) && 
		(powerState==powerState_current)
	);
	if(alreadyActive){
		_INFO_LOG("Requested mode is already active, nothing to be done!");
		return;
	}

	//=====================================================
	//==        SET POWER STATE
	//=====================================================
	//Set power state to FULL-POWER
	if(SetSMDynAttrValue(powerState,powerState_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<powerState_attr_name<<" to "<<powerState<<"!";
		_ERROR_LOG(ss.str());	
		_THROW_TANGO_EXCEPTION("SET_STANDBY_FP_MODE_FAILED",ss.str());
	}

	//=====================================================
	//==        SET CAPABILITY
	//=====================================================
	//Set capability to STANDBY
	for(unsigned int i=0;i<cap_attr_names.size();i++){
		if(capabilities_current_str[i]!=capability_faulty_str && SetSMDynAttrValue(capabilities[i],cap_attr_names[i])<0){
			std::stringstream ss;
			ss<<"Failed to set attr "<<cap_attr_names[i]<<" to "<<capabilities[i]<<"!";
			_ERROR_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("SET_STANDBY_FP_MODE_FAILED",ss.str());
		}
	}//end loop capabilities

	//=====================================================
	//==        SET MODE
	//=====================================================
	//Set mode to STANDBY-FP
	if(SetSMDynAttrValue(mode,mode_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<mode_attr_name<<" to "<<mode<<"!";
		_ERROR_LOG(ss.str());	
		_THROW_TANGO_EXCEPTION("SET_STANDBY_FP_MODE_FAILED",ss.str());
	}

	/*----- PROTECTED REGION END -----*/	//	RxEmulator::set_standby_fpmode
}
//--------------------------------------------------------
/**
 *	Command SetMaintenanceMode related method
 *	Description: Activate MAINTENANCE mode. 
 *               Allowed only in mode: {STANDBY-LP, STANDBY-FP, MAINTENANCE, DATA-CAPTURE?}
 *
 */
//--------------------------------------------------------
void RxEmulator::set_maintenance_mode()
{
	DEBUG_STREAM << "RxEmulator::SetMaintenanceMode()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(RxEmulator::set_maintenance_mode) ENABLED START -----*/
	
	//	Add your own code

	// == COMMAND BEHAVIOR ==
	// 1) Check if cmd mode-allowed {"STANDBY-LP","MAINTENANCE","STANDBY-FP","DATA-CAPTURE"} (DONE IN STATE MACHINE)
	// 2) Check if mode transition allowed {"STANDBY-LP","MAINTENANCE","STANDBY-FP"}-->"MAINTENANCE" (DONE IN STATE MACHINE)
	// 3) Leave power state unchanged
	// 4) Leave capabilities unchanged
	// 5) Set mode to MAINTENANCE

	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string mode_attr_name= "operatingMode";
	std::string powerState_attr_name= "powerState";
	std::vector<std::string> cap_attr_names= {
		"b1CapabilityState",
		"b2CapabilityState",
		"b3CapabilityState",
		"b4CapabilityState",
		"b5aCapabilityState",
		"b5bCapabilityState",
	};
	std::string activeBand_attr_name= "configuredBand";
	std::string mode_str= "MAINTENANCE"; 
	std::string powerState_str= "FULL-POWER";
	std::string capability_str= "STANDBY"; 
	std::string capability_faulty_str= "UNAVAILABLE"; 
	//===========================================================================

	_INFO_LOG("Setting SPFRx mode to MAINTENANCE...");
	
	//=====================================================
	//==      CHECK CURRENT MODE
	//=====================================================
	//Retrieve mode value corresponding to label
	Tango::DevShort mode;
	Utils_ns::TangoUtils::GetEnumAttrValue(mode,this,mode_attr_name,mode_str);

	//Get current mode
	Tango::DevShort mode_current;	
	if(GetDynAttrValue(mode_current,mode_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<mode_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_MAINTENANCE_MODE_FAILED",ss.str());
	}	

	//Check if maintenance mode is already active	
	if(mode==mode_current){
		_INFO_LOG("Mode "<<mode_str<<" already active, nothing to be done");
		return;
	}
	
	//=====================================================
	//==        SET MODE
	//=====================================================
	//Set mode to MAINTENANCE
	if(SetSMDynAttrValue(mode,mode_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<mode_attr_name<<" to "<<mode_str<<"!";
		_ERROR_LOG(ss.str());	
		_THROW_TANGO_EXCEPTION("SET_MAINTENANCE_MODE_FAILED",ss.str());
	}
	

	/*----- PROTECTED REGION END -----*/	//	RxEmulator::set_maintenance_mode
}
//--------------------------------------------------------
/**
 *	Command EnableEngineeringMode related method
 *	Description: Allows the caller to enable engineering mode.  
 *               When in engineering mode, many of the features become 
 *               available that may be resticted when running in 
 *               regular operational mode.  This is considered an expert 
 *               mode and should only be enabled by expert users.
 *
 *	@param argin Ture to enable engineering mode.  False to return to regular operations mode.
 */
//--------------------------------------------------------
void RxEmulator::enable_engineering_mode(Tango::DevBoolean argin)
{
	DEBUG_STREAM << "RxEmulator::EnableEngineeringMode()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(RxEmulator::enable_engineering_mode) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string attr_name= "engineeringModeEnabled";
	//===========================================================================

	_INFO_LOG("Setting SPFRx engineering mode to "<<argin<<"...");
	
	//=====================================================
	//==        SET ATTR
	//=====================================================
	if(SetDynAttrValue(argin,attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<attr_name<<" to "<<argin<<"!";
		_ERROR_LOG(ss.str());	
		_THROW_TANGO_EXCEPTION("ENABLE_ENGINEERING_MODE_FAILED",ss.str());
	}

	/*----- PROTECTED REGION END -----*/	//	RxEmulator::enable_engineering_mode
}
//--------------------------------------------------------
/**
 *	Command UpdateFirmware related method
 *	Description: his command instructs the SPFRx to update the firmware to the latest loaded on the controller.  Firmware file must be pre-loaded into the correct location on the SPFRxSW hardware.
 *
 *	@param argin Firmware Position to Update
 */
//--------------------------------------------------------
void RxEmulator::update_firmware(Tango::DevShort argin)
{
	DEBUG_STREAM << "RxEmulator::UpdateFirmware()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(RxEmulator::update_firmware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	RxEmulator::update_firmware
}
//--------------------------------------------------------
/**
 *	Command SetHighPowerState related method
 *	Description: True for enabling High Power Mode.  
 *               False for Low Power Mode
 *
 *	@param argin 
 */
//--------------------------------------------------------
void RxEmulator::set_high_power_state(Tango::DevBoolean argin)
{
	DEBUG_STREAM << "RxEmulator::SetHighPowerState()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(RxEmulator::set_high_power_state) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	RxEmulator::set_high_power_state
}
//--------------------------------------------------------
/**
 *	Command AdjustPolHAttenuation related method
 *	Description: Allows the adjustment of the currently set attenuation.  
 *               This adjusts the attenuation a + or - value from the 
 *               current offset (TBD: this may be from nominal).  
 *               TBD: Can only be run when in engineering mode.
 *               
 *               Adjustments to the attenuation and not preserved 
 *               across power-up or changing bands.
 *               
 *               Command allowed only in modes 
 *               {STANDBY-LP, STANDBY-FP,MAINTENANCE,DATA-CAPTURE}
 *
 *	@param argin attenuationOffset
 */
//--------------------------------------------------------
void RxEmulator::adjust_pol_hattenuation(Tango::DevFloat argin)
{
	DEBUG_STREAM << "RxEmulator::AdjustPolHAttenuation()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(RxEmulator::adjust_pol_hattenuation) ENABLED START -----*/
	
	//	Add your own code
	// == COMMAND BEHAVIOR ==
	// 1) Check if cmd mode-allowed {"STANDBY-LP","STANDBY-FP","MAINTENANCE","DATA-CAPTURE"} (DONE IN STATE MACHINE)
	// 2) Check if min/max offset are is exceeded. If so, throw exception.
	// 3) Change attenuationPolH attr by given offset
	
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string attr_name= "attenuationPolH";
	//===========================================================================

	//=====================================================
	//==        CHECK ARGIN
	//=====================================================
	Tango::DevFloat attenuation_offset= argin;
	_INFO_LOG("Adjusting current h pol attenuation by "<<attenuation_offset<<" ...");
	
	//Check min/max att offset that can be given
	//...

	
	//=====================================================
	//==        CHANGE ATTENUATION
	//=====================================================
	//Get current attenuation
	Tango::DevFloat attenuation_current;
	if(GetDynAttrValue(attenuation_current,attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("ADJUST_POL_H_ATTENUATION_FAILED",ss.str());
	}	

	//Set new attenuation
	Tango::DevFloat attenuation= attenuation_current + attenuation_offset;	
	if(SetDynAttrValue(attenuation,attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<attr_name<<" to "<<attenuation<<"!";
		_ERROR_LOG(ss.str());	
		_THROW_TANGO_EXCEPTION("ADJUST_POL_H_ATTENUATION_FAILED",ss.str());
	}

	/*----- PROTECTED REGION END -----*/	//	RxEmulator::adjust_pol_hattenuation
}
//--------------------------------------------------------
/**
 *	Command AdjustPolVAttenuation related method
 *	Description: This adjusts the attenuation a + or - value from the 
 *               current offset (TBD: this may be from nominal).  
 *               TBD: Can only be run when in engineering mode.
 *               
 *               Adjustments to the attenuation and not preserved 
 *               across power-up or changing bands.
 *               
 *               Command allowed only in modes 
 *               {STANDBY-LP, STANDBY-FP,MAINTENANCE,DATA-CAPTURE}
 *
 *	@param argin attenuationOffset
 */
//--------------------------------------------------------
void RxEmulator::adjust_pol_vattenuation(Tango::DevFloat argin)
{
	DEBUG_STREAM << "RxEmulator::AdjustPolVAttenuation()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(RxEmulator::adjust_pol_vattenuation) ENABLED START -----*/
	
	//	Add your own code
	// == COMMAND BEHAVIOR ==
	// 1) Check if cmd mode-allowed {"STANDBY-LP","STANDBY-FP","MAINTENANCE","DATA-CAPTURE"} (DONE IN STATE MACHINE)
	// 2) Check if min/max offset are is exceeded. If so, throw exception.
	// 3) Change attenuationPolH attr by given offset
	
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string attr_name= "attenuationPolV";
	//===========================================================================

	//=====================================================
	//==        CHECK ARGIN
	//=====================================================
	Tango::DevFloat attenuation_offset= argin;
	_INFO_LOG("Adjusting current v pol attenuation by "<<attenuation_offset<<" ...");
	
	//Check min/max att offset that can be given
	//...

	
	//=====================================================
	//==        CHANGE ATTENUATION
	//=====================================================
	//Get current attenuation
	Tango::DevFloat attenuation_current;
	if(GetDynAttrValue(attenuation_current,attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("ADJUST_POL_V_ATTENUATION_FAILED",ss.str());
	}	

	//Set new attenuation
	Tango::DevFloat attenuation= attenuation_current + attenuation_offset;	
	if(SetDynAttrValue(attenuation,attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<attr_name<<" to "<<attenuation<<"!";
		_ERROR_LOG(ss.str());	
		_THROW_TANGO_EXCEPTION("ADJUST_POL_V_ATTENUATION_FAILED",ss.str());
	}

	/*----- PROTECTED REGION END -----*/	//	RxEmulator::adjust_pol_vattenuation
}
//--------------------------------------------------------
/**
 *	Command Shutdown related method
 *	Description: Shutdown RXPU
 *
 */
//--------------------------------------------------------
void RxEmulator::shutdown()
{
	DEBUG_STREAM << "RxEmulator::Shutdown()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(RxEmulator::shutdown) ENABLED START -----*/
	
	//	Add your own code
	//_THROW_TANGO_EXCEPTION("CMD_NOT_IMPLEMENTED","This command needs to be implemented yet");

	_INFO_LOG("Shutdown RXPU commanded ...");

	/*----- PROTECTED REGION END -----*/	//	RxEmulator::shutdown
}
//--------------------------------------------------------
/**
 *	Command dummyDynCmd related method
 *	Description: 
 *
 */
//--------------------------------------------------------
void RxEmulator::dummy_dyn_cmd(Tango::Command &command)
{
	DEBUG_STREAM << "RxEmulator::" << command.get_name() << "  - " << device_name << endl;
	/*----- PROTECTED REGION ID(RxEmulator::dummy_dyn_cmd) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	RxEmulator::dummy_dyn_cmd
}
//--------------------------------------------------------
/**
 *	Method      : RxEmulator::add_dynamic_commands()
 *	Description : Create the dynamic commands if any
 *                for specified device.
 */
//--------------------------------------------------------
void RxEmulator::add_dynamic_commands()
{
	//	Example to add dynamic command:
	//	Copy inside the folowing protected area to instanciate at startup.
	//	add_dummyDynCmd_dynamic_command("MydummyDynCmdCommand", true);
	
	/*----- PROTECTED REGION ID(RxEmulator::add_dynamic_commands) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic commands if any
	LMCDevice::add_dynamic_commands();

	/*----- PROTECTED REGION END -----*/	//	RxEmulator::add_dynamic_commands
}

/*----- PROTECTED REGION ID(RxEmulator::namespace_ending) ENABLED START -----*/

//	Additional Methods


int RxEmulator::InitCmdAttrStateMachine(){

	_DEBUG_LOG("Initializing the cmd-attr state machine for device "<<device_name<<"...");

	//=====================================
	//===     CMD STATE MACHINE RULES 
	//=====================================
	//- SetSubElementMode (DEPRECATED)
	_REGISTER_CMD_RULE(std::string,"SetSubElementMode","operatingMode",("STANDBY-LP","STANDBY-FP","DATA-CAPTURE","MAINTENANCE"));

	//- SetStandbyLPMode
	_REGISTER_CMD_RULE(std::string,"SetStandbyLPMode","operatingMode",("STANDBY-LP","STANDBY-FP","MAINTENANCE","DATA-CAPTURE"));//ADDED DATA CAPTURE (20 Apr 2018)
	//_REGISTER_CMD_RULE(std::string,"SetStandbyLPMode","operatingMode",("STANDBY-LP","STANDBY-FP","MAINTENANCE"));
	//_REGISTER_CMD_RULE(std::string,"SetStandbyLPMode","powerState",("LOW-POWER","FULL-POWER"));
	//_REGISTER_CMD_RULE(std::string,"SetStandbyLPMode","b1CapabilityState",("STANDBY","OPERATE"));
	//_REGISTER_CMD_RULE(std::string,"SetStandbyLPMode","b2CapabilityState",("STANDBY","OPERATE"));
	//_REGISTER_CMD_RULE(std::string,"SetStandbyLPMode","b3CapabilityState",("STANDBY","OPERATE"));
	//_REGISTER_CMD_RULE(std::string,"SetStandbyLPMode","b4CapabilityState",("STANDBY","OPERATE"));
	//_REGISTER_CMD_RULE(std::string,"SetStandbyLPMode","b5CapabilityState",("STANDBY","OPERATE"));

	//- SetStandbyFPMode
	_REGISTER_CMD_RULE(std::string,"SetStandbyFPMode","operatingMode",("STANDBY-LP","STANDBY-FP","MAINTENANCE","CONFIGURE","DATA-CAPTURE"));
	//_REGISTER_CMD_RULE(std::string,"SetStandbyFPMode","powerState",("LOW-POWER","FULL-POWER"));
	//_REGISTER_CMD_RULE(std::string,"SetStandbyFPMode","b1CapabilityState",("STANDBY","OPERATE"));
	//_REGISTER_CMD_RULE(std::string,"SetStandbyFPMode","b2CapabilityState",("STANDBY","OPERATE"));
	//_REGISTER_CMD_RULE(std::string,"SetStandbyFPMode","b3CapabilityState",("STANDBY","OPERATE"));
	//_REGISTER_CMD_RULE(std::string,"SetStandbyFPMode","b4CapabilityState",("STANDBY","OPERATE"));
	//_REGISTER_CMD_RULE(std::string,"SetStandbyFPMode","b5CapabilityState",("STANDBY","OPERATE"));

	//- SetMaintenanceMode
	_REGISTER_CMD_RULE(std::string,"SetMaintenanceMode","operatingMode",("STANDBY-LP","STANDBY-FP","MAINTENANCE","DATA-CAPTURE"));
	//_REGISTER_CMD_RULE(std::string,"SetMaintenanceMode","powerState",("LOW-POWER","FULL-POWER"));
	
	//- ConfigureBand
	_REGISTER_CMD_RULE(std::string,"ConfigureBand","operatingMode",("STANDBY-FP","DATA-CAPTURE","MAINTENANCE"));
	//_REGISTER_CMD_RULE(std::string,"ConfigureBand","b1CapabilityState",("STANDBY","OPERATE"));
	//_REGISTER_CMD_RULE(std::string,"ConfigureBand","b2CapabilityState",("STANDBY","OPERATE"));
	//_REGISTER_CMD_RULE(std::string,"ConfigureBand","b3CapabilityState",("STANDBY","OPERATE"));
	//_REGISTER_CMD_RULE(std::string,"ConfigureBand","b4CapabilityState",("STANDBY","OPERATE"));
	//_REGISTER_CMD_RULE(std::string,"ConfigureBand","b5CapabilityState",("STANDBY","OPERATE"));

	//- ConfigureBand1
	_REGISTER_CMD_RULE(std::string,"ConfigureBand1","operatingMode",("STANDBY-FP","DATA-CAPTURE","MAINTENANCE"));	

	//- ConfigureBand2
	_REGISTER_CMD_RULE(std::string,"ConfigureBand2","operatingMode",("STANDBY-FP","DATA-CAPTURE","MAINTENANCE"));	
	
	//- ConfigureBand3
	_REGISTER_CMD_RULE(std::string,"ConfigureBand3","operatingMode",("STANDBY-FP","DATA-CAPTURE","MAINTENANCE"));	
	
	//- ConfigureBand4
	_REGISTER_CMD_RULE(std::string,"ConfigureBand4","operatingMode",("STANDBY-FP","DATA-CAPTURE","MAINTENANCE"));	
	
	//- ConfigureBand5a
	_REGISTER_CMD_RULE(std::string,"ConfigureBand5a","operatingMode",("STANDBY-FP","DATA-CAPTURE","MAINTENANCE"));	
	
	//- ConfigureBand5b
	_REGISTER_CMD_RULE(std::string,"ConfigureBand5b","operatingMode",("STANDBY-FP","DATA-CAPTURE","MAINTENANCE"));	
	
	//- CaptureData
	_REGISTER_CMD_RULE(std::string,"CaptureData","operatingMode",("STANDBY-FP","DATA-CAPTURE"));
	//_REGISTER_CMD_RULE(std::string,"CaptureData","powerState",("FULL-POWER"));
	//_REGISTER_CMD_RULE(std::string,"CaptureData","b1CapabilityState",("STANDBY","OPERATE"));
	//_REGISTER_CMD_RULE(std::string,"CaptureData","b2CapabilityState",("STANDBY","OPERATE"));
	//_REGISTER_CMD_RULE(std::string,"CaptureData","b3CapabilityState",("STANDBY","OPERATE"));
	//_REGISTER_CMD_RULE(std::string,"CaptureData","b4CapabilityState",("STANDBY","OPERATE"));
	//_REGISTER_CMD_RULE(std::string,"CaptureData","b5CapabilityState",("STANDBY","OPERATE"));

	
	//- Synchronise
	_REGISTER_CMD_RULE(std::string,"Synchronise","operatingMode",("DATA-CAPTURE"));

	//- SetNoiseSourcePars (DEPRECATED)
	//_REGISTER_CMD_RULE(std::string,"SetNoiseSourcePars","operatingMode",("STANDBY-LP","STANDBY-FP","MAINTENANCE"));
	
	//- SetAttenuation (DEPRECATED)
	//_REGISTER_CMD_RULE(std::string,"SetAttenuation","operatingMode",("DATA-CAPTURE","MAINTENANCE","STANDBY-FP"));
	_REGISTER_CMD_RULE(std::string,"AdjustPolHAttenuation","operatingMode",("STANDBY-LP","STANDBY-FP","MAINTENANCE","DATA-CAPTURE"));
	_REGISTER_CMD_RULE(std::string,"AdjustPolVAttenuation","operatingMode",("STANDBY-LP","STANDBY-FP","MAINTENANCE","DATA-CAPTURE"));

	//- Synchronise
	_REGISTER_CMD_RULE(std::string,"EnableEngineeringMode","operatingMode",("STANDBY-LP","STANDBY-FP","MAINTENANCE","DATA-CAPTURE"));

	//- SetHighPowerState
	_REGISTER_CMD_RULE(std::string,"SetHighPowerState","operatingMode",("MAINTENANCE"));
	_REGISTER_CMD_RULE(bool,"SetHighPowerState","engineeringModeEnabled",(true));

	//- AdjustPolHAttenuation
	_REGISTER_CMD_RULE(std::string,"AdjustPolHAttenuation","operatingMode",("STANDBY-LP","STANDBY-FP","MAINTENANCE","DATA-CAPTURE"));
	_REGISTER_CMD_RULE(bool,"AdjustPolHAttenuation","engineeringModeEnabled",(true));

	//- AdjustPolVAttenuation
	_REGISTER_CMD_RULE(std::string,"AdjustPolHAttenuation","operatingMode",("STANDBY-LP","STANDBY-FP","MAINTENANCE","DATA-CAPTURE"));
	_REGISTER_CMD_RULE(bool,"AdjustPolVAttenuation","engineeringModeEnabled",(true));

	//- Shutdown
	_REGISTER_CMD_RULE(std::string,"Shutdown","operatingMode",("STANDBY-LP"));

	//DUMP_CMD_RULES();

	//=====================================
	//===     ATTR READ/WRITE RULES 
	//=====================================
	//- Operating mode (write only in test mode)
	_REGISTER_ATTR_WRITE_RULE(bool,"operatingMode","testMode",(true));

	//- Power state (write only in test mode)
	_REGISTER_ATTR_WRITE_RULE(bool,"powerState","testMode",(true));

	//- Band capabilities
	_REGISTER_ATTR_WRITE_RULE(bool,"b1CapabilityState","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b2CapabilityState","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b3CapabilityState","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b4CapabilityState","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b5aCapabilityState","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b5bCapabilityState","testMode",(true));
	
	//- Health state
	_REGISTER_ATTR_WRITE_RULE(bool,"healthState","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b1HealthState","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b2HealthState","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b3HealthState","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b4HealthState","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b5aHealthState","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b5bHealthState","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"rxpuHealthState","testMode",(true));

	//- Interface type
	_REGISTER_ATTR_WRITE_RULE(bool,"interfaceType","testMode",(true));
	
	//- Supply voltage/current/temp
	_REGISTER_ATTR_WRITE_RULE(bool,"b1SupplyVoltage","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b2SupplyVoltage","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b3SupplyVoltage","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b4SupplyVoltage","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b5aSupplyVoltage","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b5bSupplyVoltage","testMode",(true));
	
	_REGISTER_ATTR_WRITE_RULE(bool,"b1SupplyCurrent","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b2SupplyCurrent","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b3SupplyCurrent","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b4SupplyCurrent","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b5aSupplyCurrent","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b5bSupplyCurrent","testMode",(true));
	
	_REGISTER_ATTR_WRITE_RULE(bool,"b1Temperature","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b2Temperature","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b3Temperature","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b4Temperature","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b5aTemperature","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b5bTemperature","testMode",(true));
	
	//- Ctrl supply voltage/current/temp
	_REGISTER_ATTR_WRITE_RULE(bool,"rxpuSupplyVoltage","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"rxpuSupplyCurrent","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"rxpuTemperature","testMode",(true));

	//- ADC power/variance	
	_REGISTER_ATTR_WRITE_RULE(bool,"b1AdcPower","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b2AdcPower","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b3AdcPower","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b4AdcPower","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b5aAdcPower","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b5bAdcPower","testMode",(true));
		
	_REGISTER_ATTR_WRITE_RULE(bool,"b1AdcVariance","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b2AdcVariance","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b3AdcVariance","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b4AdcVariance","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b5aAdcVariance","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b5bAdcVariance","testMode",(true));
		
	//- Attenuation 
	_REGISTER_ATTR_WRITE_RULE(bool,"attenuationPolH","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"attenuationPolV","testMode",(true));

	//- Noise source pars
	_REGISTER_ATTR_WRITE_RULE(std::string,"noiseDiodeState","operatingMode",("STANDBY-LP","STANDBY-FP","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"periodicNoiseDiodePars","operatingMode",("STANDBY-LP","STANDBY-FP","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"pseudoRandomNoiseDiodePars","operatingMode",("STANDBY-LP","STANDBY-FP","MAINTENANCE"));
	
	//- configuredBand
	_REGISTER_ATTR_WRITE_RULE(bool,"configuredBand","engineeringModeEnabled",(true));
	
	//- samplingClockFrequency
	_REGISTER_ATTR_WRITE_RULE(bool,"samplingClockFrequency","engineeringModeEnabled",(true));
	
	//- Default sampling clock frequencies
	_REGISTER_ATTR_WRITE_RULE(std::string,"b1DefaultSamplingClockFrequency","operatingMode",("STANDBY-LP","STANDBY-FP","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b2DefaultSamplingClockFrequency","operatingMode",("STANDBY-LP","STANDBY-FP","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b3DefaultSamplingClockFrequency","operatingMode",("STANDBY-LP","STANDBY-FP","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b4DefaultSamplingClockFrequency","operatingMode",("STANDBY-LP","STANDBY-FP","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b5aDefaultSamplingClockFrequency","operatingMode",("STANDBY-LP","STANDBY-FP","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b5bDefaultSamplingClockFrequency","operatingMode",("STANDBY-LP","STANDBY-FP","MAINTENANCE"));
	

	//=====================================
	//===     ATTR TRANSITION RULES 
	//=====================================
	//- operatingMode
	_REGISTER_ATTR_RULE(std::string,"operatingMode","STARTUP",("STARTUP","STANDBY-LP"));
	_REGISTER_ATTR_RULE(std::string,"operatingMode","STANDBY-LP",("STANDBY-LP","STANDBY-FP","MAINTENANCE"));
	_REGISTER_ATTR_RULE(std::string,"operatingMode","STANDBY-FP",("STANDBY-FP","STANDBY-LP","MAINTENANCE","CONFIGURE","DATA-CAPTURE"));
	_REGISTER_ATTR_RULE(std::string,"operatingMode","CONFIGURE",("CONFIGURE","STANDBY-FP","DATA-CAPTURE"));
	_REGISTER_ATTR_RULE(std::string,"operatingMode","DATA-CAPTURE",("DATA-CAPTURE","STANDBY-FP","CONFIGURE","MAINTENANCE"));
	_REGISTER_ATTR_RULE(std::string,"operatingMode","MAINTENANCE",("MAINTENANCE","STANDBY-LP","STANDBY-FP","CONFIGURE"));

	//- capabilities
	//_REGISTER_ATTR_RULE(std::string,"b1CapabilityState","NONE",("NONE","STANDBY"));
	//_REGISTER_ATTR_RULE(std::string,"b1CapabilityState","UNAVAILABLE",("UNAVAILABLE","STANDBY"));
	_REGISTER_ATTR_RULE(std::string,"b1CapabilityState","UNAVAILABLE",("UNAVAILABLE","STANDBY","CONFIGURE","OPERATE"));	
	_REGISTER_ATTR_RULE(std::string,"b1CapabilityState","STANDBY",("STANDBY","UNAVAILABLE","CONFIGURE","OPERATE"));
	_REGISTER_ATTR_RULE(std::string,"b1CapabilityState","CONFIGURE",("CONFIGURE","STANDBY","OPERATE","UNAVAILABLE"));
	_REGISTER_ATTR_RULE(std::string,"b1CapabilityState","OPERATE",("OPERATE","STANDBY","CONFIGURE","UNAVAILABLE"));

	//_REGISTER_ATTR_RULE(std::string,"b2CapabilityState","NONE",("NONE","STANDBY"));
	//_REGISTER_ATTR_RULE(std::string,"b2CapabilityState","UNAVAILABLE",("UNAVAILABLE","STANDBY"));
	_REGISTER_ATTR_RULE(std::string,"b2CapabilityState","UNAVAILABLE",("UNAVAILABLE","STANDBY","CONFIGURE","OPERATE"));	
	_REGISTER_ATTR_RULE(std::string,"b2CapabilityState","STANDBY",("STANDBY","UNAVAILABLE","CONFIGURE","OPERATE"));
	_REGISTER_ATTR_RULE(std::string,"b2CapabilityState","CONFIGURE",("CONFIGURE","STANDBY","OPERATE","UNAVAILABLE"));
	_REGISTER_ATTR_RULE(std::string,"b2CapabilityState","OPERATE",("OPERATE","STANDBY","CONFIGURE","UNAVAILABLE"));

	//_REGISTER_ATTR_RULE(std::string,"b3CapabilityState","NONE",("NONE","STANDBY"));
	//_REGISTER_ATTR_RULE(std::string,"b3CapabilityState","UNAVAILABLE",("UNAVAILABLE","STANDBY"));
	_REGISTER_ATTR_RULE(std::string,"b3CapabilityState","UNAVAILABLE",("UNAVAILABLE","STANDBY","CONFIGURE","OPERATE"));	
	_REGISTER_ATTR_RULE(std::string,"b3CapabilityState","STANDBY",("STANDBY","UNAVAILABLE","CONFIGURE","OPERATE"));
	_REGISTER_ATTR_RULE(std::string,"b3CapabilityState","CONFIGURE",("CONFIGURE","STANDBY","OPERATE","UNAVAILABLE"));
	_REGISTER_ATTR_RULE(std::string,"b3CapabilityState","OPERATE",("OPERATE","STANDBY","CONFIGURE","UNAVAILABLE"));

	//_REGISTER_ATTR_RULE(std::string,"b4CapabilityState","NONE",("NONE","STANDBY"));
	//_REGISTER_ATTR_RULE(std::string,"b4CapabilityState","UNAVAILABLE",("UNAVAILABLE","STANDBY"));
	_REGISTER_ATTR_RULE(std::string,"b4CapabilityState","UNAVAILABLE",("UNAVAILABLE","STANDBY","CONFIGURE","OPERATE"));	
	_REGISTER_ATTR_RULE(std::string,"b4CapabilityState","STANDBY",("STANDBY","UNAVAILABLE","CONFIGURE","OPERATE"));
	_REGISTER_ATTR_RULE(std::string,"b4CapabilityState","CONFIGURE",("CONFIGURE","STANDBY","OPERATE","UNAVAILABLE"));
	_REGISTER_ATTR_RULE(std::string,"b4CapabilityState","OPERATE",("OPERATE","STANDBY","CONFIGURE","UNAVAILABLE"));

	//_REGISTER_ATTR_RULE(std::string,"b5aCapabilityState","NONE",("NONE","STANDBY"));
	//_REGISTER_ATTR_RULE(std::string,"b5aCapabilityState","UNAVAILABLE",("UNAVAILABLE","STANDBY"));
	_REGISTER_ATTR_RULE(std::string,"b5aCapabilityState","UNAVAILABLE",("UNAVAILABLE","STANDBY","CONFIGURE","OPERATE"));	
	_REGISTER_ATTR_RULE(std::string,"b5aCapabilityState","STANDBY",("STANDBY","UNAVAILABLE","CONFIGURE","OPERATE"));
	_REGISTER_ATTR_RULE(std::string,"b5aCapabilityState","CONFIGURE",("CONFIGURE","STANDBY","OPERATE","UNAVAILABLE"));
	_REGISTER_ATTR_RULE(std::string,"b5aCapabilityState","OPERATE",("OPERATE","STANDBY","CONFIGURE","UNAVAILABLE"));	

	//_REGISTER_ATTR_RULE(std::string,"b5bCapabilityState","NONE",("NONE","STANDBY"));
	//_REGISTER_ATTR_RULE(std::string,"b5bCapabilityState","UNAVAILABLE",("UNAVAILABLE","STANDBY"));
	_REGISTER_ATTR_RULE(std::string,"b5bCapabilityState","UNAVAILABLE",("UNAVAILABLE","STANDBY","CONFIGURE","OPERATE"));	
	_REGISTER_ATTR_RULE(std::string,"b5bCapabilityState","STANDBY",("STANDBY","UNAVAILABLE","CONFIGURE","OPERATE"));
	_REGISTER_ATTR_RULE(std::string,"b5bCapabilityState","CONFIGURE",("CONFIGURE","STANDBY","OPERATE","UNAVAILABLE"));
	_REGISTER_ATTR_RULE(std::string,"b5bCapabilityState","OPERATE",("OPERATE","STANDBY","CONFIGURE","UNAVAILABLE"));

	//DUMP_ATTR_RULES();

	return 0;

}//close InitCmdAttrStateMachine()


int RxEmulator::InitTask(){

	//## Initialize device task
	_DEBUG_LOG("Initializing device task config...");
	m_task = 0;

	//- Define task configuration
	RxEmulatorTask::Config cfg;
  cfg.task_activity_period_ms = 3000;
  cfg.host_device = this;
	cfg.enable_periodic_msg= false;
    
	//- Allocate and start the device task
	try {
		_INFO_LOG("Initializing device task...");
    m_task = new (std::nothrow) RxEmulatorTask(cfg);
	  if (!m_task){
    	throw std::bad_alloc();
		}

    _INFO_LOG("Starting the task...");
    m_task->go();
	}
  catch (const std::bad_alloc&) {
		std::string errMsg("Device task initialization failed (allocation failed)");
  	_ERROR_LOG(errMsg);
		set_state(Tango::FAULT);
    set_status(errMsg.c_str());
		return -1;
	}
  catch (Tango::DevFailed& e) {
		Tango::Except::print_exception(e);
		std::string errMsg("Device task initialization failed [see device log for details]");
  	_ERROR_LOG(errMsg);
		set_state(Tango::FAULT);
    set_status(errMsg.c_str());
    return -1;
  }
  catch (...) {
  	std::string errMsg("Device task initialization failed [unknown error]");
  	_ERROR_LOG(errMsg);
		set_state(Tango::FAULT);
    set_status(errMsg.c_str());
    return -1;
  }

	return 0;

}//close InitTask()

int RxEmulator::ClearTask(){

	if(!m_task) return 0;

	//## First signal waiting conditions
	m_task->signal_wait();

	//## Release the task: just ask task to quit
	//## NB: Never explicitly delete a yat4tango::DeviceTask
	m_task->exit();
  m_task = 0;

	return 0;

}//close ClearTask

int RxEmulator::Startup(){

	//## Prepare message data
	StartupMsg msg_data;
	msg_data.task_duration= startupTime;
	msg_data.enable_failure= enableStartupFailure;
	msg_data.failure_probability= startupFailureProbability;

	//## Execute Rx startup task
	bool isSynchronous= false;
	try {
		_INFO_LOG("Executing SPFRx startup...");
		m_task->execute_startup(msg_data, isSynchronous);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		std::string errMsg("Tango exception occurred while executing Rx startup!");
		_ERROR_LOG(errMsg);
		set_state(Tango::FAULT);
    set_status(errMsg.c_str());
    return -1;
	}	
	catch(...){
		std::string errMsg("Unknown C++ exception occurred while adding device to group!");
		_ERROR_LOG(errMsg);	
		set_state(Tango::FAULT);
    set_status(errMsg.c_str());
    return -1;
	}
	
	return 0;

}//close Startup()

void RxEmulator::SetConfigureStatus(std::string status,std::string info,bool clear){

	//Clear previously allocated string
	//NB: According to Tango doc it is safe to call free even if string is not allocated
	int nDim= 3;
	if(clear){
		for(int i=0;i<nDim;i++){
			if(*(attr_configureBandProgress_read+i)) CORBA::string_free( *(attr_configureBandProgress_read+i) );
		}
	}
		
	attr_configureBandProgress_read[0]= Tango::string_dup(status.c_str());
	attr_configureBandProgress_read[1]= Tango::string_dup(info.c_str());
	attr_configureBandProgress_read[2]= Tango::string_dup("");

}//close SetConfigureStatus()


void RxEmulator::SetUpdateFirmwareStatus(std::string status,std::string info,int firmwareId,std::string firmwareVersInfo,bool clear){

	//Clear previously allocated string
	//NB: According to Tango doc it is safe to call free even if string is not allocated
	int nDim= 4;
	if(clear){
		if(firmwareId==0){
			for(int i=0;i<nDim;i++){
				if(*(attr_firmware0UpdateProgress_read+i)) CORBA::string_free( *(attr_firmware0UpdateProgress_read+i) );
			}//end loop items
		}//close if firmware 0
		else if(firmwareId==1){
			for(int i=0;i<nDim;i++){
				if(*(attr_firmware1UpdateProgress_read+i)) CORBA::string_free( *(attr_firmware1UpdateProgress_read+i) );
			}//end loop items
		}//close if firmware 1
		else if(firmwareId==2){
			for(int i=0;i<nDim;i++){
				if(*(attr_firmware2UpdateProgress_read+i)) CORBA::string_free( *(attr_firmware2UpdateProgress_read+i) );
			}//end loop items
		}//close if firmware 2
		else if(firmwareId==3){
			for(int i=0;i<nDim;i++){
				if(*(attr_firmware3UpdateProgress_read+i)) CORBA::string_free( *(attr_firmware3UpdateProgress_read+i) );
			}//end loop items
		}//close if firmware 3
		else{
			std::stringstream ss;
			ss<<"Invalid firmware id ("<<firmwareId<<") specified!";
			_ERROR_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("SET_UPDATE_FIRMWARE_STATUS_FAILED",ss.str());
		}
	}//close if clear
		
	if(firmwareId==0){
		attr_firmware0UpdateProgress_read[0]= Tango::string_dup(status.c_str());
		attr_firmware0UpdateProgress_read[1]= Tango::string_dup("0");
		attr_firmware0UpdateProgress_read[2]= Tango::string_dup(firmwareVersInfo.c_str());
		attr_firmware0UpdateProgress_read[3]= Tango::string_dup(info.c_str());
	}
	else if(firmwareId==1){
		attr_firmware1UpdateProgress_read[0]= Tango::string_dup(status.c_str());
		attr_firmware1UpdateProgress_read[1]= Tango::string_dup("1");
		attr_firmware1UpdateProgress_read[2]= Tango::string_dup(firmwareVersInfo.c_str());
		attr_firmware1UpdateProgress_read[3]= Tango::string_dup(info.c_str());
	}//close if firmware 1
	else if(firmwareId==2){
		attr_firmware2UpdateProgress_read[0]= Tango::string_dup(status.c_str());
		attr_firmware2UpdateProgress_read[1]= Tango::string_dup("2");
		attr_firmware2UpdateProgress_read[2]= Tango::string_dup(firmwareVersInfo.c_str());
		attr_firmware2UpdateProgress_read[3]= Tango::string_dup(info.c_str());
	}//close if firmware 2
	else if(firmwareId==3){
		attr_firmware3UpdateProgress_read[0]= Tango::string_dup(status.c_str());
		attr_firmware3UpdateProgress_read[1]= Tango::string_dup("3");
		attr_firmware3UpdateProgress_read[2]= Tango::string_dup(firmwareVersInfo.c_str());
		attr_firmware3UpdateProgress_read[3]= Tango::string_dup(info.c_str());
	}//close if firmware 3
	else{
		std::stringstream ss;
		ss<<"Invalid firmware id ("<<firmwareId<<") specified!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_UPDATE_FIRMWARE_STATUS_FAILED",ss.str());
	}
	
}//close SetUpdateFirmwareStatus()


int RxEmulator::InitAttrsToDefault(){

	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	//std::string noiseSourcePars_attr_name= "noiseDiodeConfig";
	std::string noiseSourceState_attr_name= "noiseDiodeState";
	std::string periodic_noiseSourcePars_attr_name= "periodicNoiseDiodePars";
	std::string pseudorand_noiseSourcePars_attr_name= "pseudoRandomNoiseDiodePars";
	std::vector<Tango::DevFloat> periodic_noiseSourcePars_init_attr_values= periodicNoiseDiodeParsDefault;
	std::vector<Tango::DevFloat> pseudorand_noiseSourcePars_init_attr_values= pseudoRandomNoiseDiodeParsDefault;
	
	std::vector<std::string> attenuation_attr_names {
		"b1PolHAttenuationDefault",
		"b2PolHAttenuationDefault",
		"b3PolHAttenuationDefault",
		"b4PolHAttenuationDefault",
		"b5aPolHAttenuationDefault",
		"b5bPolHAttenuationDefault",
		"b1PolVAttenuationDefault",
		"b2PolVAttenuationDefault",
		"b3PolVAttenuationDefault",
		"b4PolVAttenuationDefault",
		"b5aPolVAttenuationDefault",
		"b5bPolVAttenuationDefault"
	};
	std::vector<Tango::DevFloat> attenuation_init_attr_values {
		b1PolHNominalAttenuation,
		b2PolHNominalAttenuation,
		b3PolHNominalAttenuation,
		b4PolHNominalAttenuation,
		b5aPolHNominalAttenuation,
		b5bPolHNominalAttenuation,
		b1PolVNominalAttenuation,
		b2PolVNominalAttenuation,
		b3PolVNominalAttenuation,
		b4PolVNominalAttenuation,
		b5aPolVNominalAttenuation,
		b5bPolVNominalAttenuation
	};
	//###########################################################################

	//=====================================================
	//==         INIT NOISE SOURCE ATTRIBUTES
	//=====================================================
	int status= 0;

	//Init noise gen model
	_DEBUG_LOG("Initializing attr "<<noiseSourceState_attr_name<<" to default value ...");
	if( SetDynAttrValue<Tango::DevEnum>(noiseDiodeStateDefault,noiseSourceState_attr_name)<0 ){
		std::stringstream ss;
		ss<<"Failed to set attr "<<noiseSourceState_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		status= -1;
	}	

	//Init periodic noise pars
	_DEBUG_LOG("Initializing attr "<<periodic_noiseSourcePars_attr_name<<" to default values ...");
	if( SetDynAttrValue<Tango::DevFloat>(periodic_noiseSourcePars_init_attr_values,periodic_noiseSourcePars_attr_name)<0 ){
		std::stringstream ss;
		ss<<"Failed to set attr "<<periodic_noiseSourcePars_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		status= -1;
	}

	//Init pseudo-random noise pars
	_DEBUG_LOG("Initializing attr "<<pseudorand_noiseSourcePars_attr_name<<" to default values ...");
	if( SetDynAttrValue<Tango::DevFloat>(pseudorand_noiseSourcePars_init_attr_values,pseudorand_noiseSourcePars_attr_name)<0 ){
		std::stringstream ss;
		ss<<"Failed to set attr "<<pseudorand_noiseSourcePars_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		status= -1;
	}

	//=====================================================
	//==         INIT ATTENUATION ATTRIBUTES
	//=====================================================
	//Init attenuation	
	for(size_t i=0;i<attenuation_attr_names.size();i++){
		Tango::DevFloat attr_value= attenuation_init_attr_values[i];
		std::string attr_name= attenuation_attr_names[i];

		//Check if a memorized value is already present for this attribute
		//If so, skip initialization to nominal property
		if(Utils_ns::TangoUtils::HasMemorizedValue(this,attr_name)){
			_INFO_LOG("Attr "<<attr_name<<" has already a memorized value stored, so it won't be initialized to corresponding default dev property...");
			continue;
		}

		//Initialize to nominal as no memorized value was found
		_INFO_LOG("Initializing attr "<<attr_name<<" to default value "<<attr_value<<" ...");
		if( SetDynAttrValue<Tango::DevFloat>(attr_value,attr_name)<0 ){
			std::stringstream ss;
			ss<<"Failed to set attr "<<attr_value<<" value!";
			_ERROR_LOG(ss.str());
			status= -1;
			continue;
		}
	}//end loop attenuation pars

	//Init gain attributes (FILL ME!)
	//...
	//...

	return status;

}//close InitAttrsToDefault()

void RxEmulator::ConfigureBand(Tango::DevShort bandId)
{
	// == COMMAND BEHAVIOR ==
	// 1) Check if mode-allowed (DONE IN STATE MACHINE FILE)
	// 2) Check given band argument
	// 3) Check if required band is already configured. If so, reconfigure (parameters could have changed before this command is invoked)
	//    NB: It would be better to check if the config pars have changed (define an attribute?). If not, reply quickly with "Band already configured"
	// 4) Stop data capture on active band and check mode (TBD)
	// 5) Set mode to CONFIGURE 
	// 6) Switch given band capability to CONFIGURE [transition may take up to 30 s]
	// 7) If successful, automatically start data capture and switch rx_mode to DATA-CAPTURE
	// 8) If successful, switch capability of selected band to OPERATE
	// 9) Update configuredBand attr
	//10) Set attenuationPolH/attenuationPolV to default values relative to chosen band 
	//11) Set samplingClockFrequency to default value relative to chosen band

	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string attr_name= "operatingMode";
	std::vector<std::string> cap_attr_names= {
		"b1CapabilityState",
		"b2CapabilityState",
		"b3CapabilityState",
		"b4CapabilityState",
		"b5aCapabilityState",
		"b5bCapabilityState",
	};
	std::string activeBand_attr_name= "configuredBand";	
	std::string attenuation_h_attr_name= "attenuationPolH";
	std::string attenuation_v_attr_name= "attenuationPolV";
	std::vector<std::string> attenuation_h_default_attr_names= {
		"b1PolHAttenuationDefault",
		"b2PolHAttenuationDefault",
		"b3PolHAttenuationDefault",
		"b4PolHAttenuationDefault",
		"b5aPolHAttenuationDefault",
		"b5bPolHAttenuationDefault",
	};
	std::vector<std::string> attenuation_v_default_attr_names= {
		"b1PolVAttenuationDefault",
		"b2PolVAttenuationDefault",
		"b3PolVAttenuationDefault",
		"b4PolVAttenuationDefault",
		"b5aPolVAttenuationDefault",
		"b5bPolVAttenuationDefault",
	};

	std::vector<std::string> samplingClockFrequency_default_attr_names= {
		"b1DefaultSamplingClockFrequency",
		"b2DefaultSamplingClockFrequency",
		"b3DefaultSamplingClockFrequency",
		"b4DefaultSamplingClockFrequency",
		"b5aDefaultSamplingClockFrequency",
		"b5bDefaultSamplingClockFrequency",
	};
	std::string samplingClockFrequency_attr_name= "samplingClockFrequency";
	std::string mode_str= "CONFIGURE";
	std::string mode_safe_str= "STANDBY-FP";
	std::string mode_final_str= "DATA-CAPTURE";
	std::string capability_str= "CONFIGURE";
	std::string capability_final_str= "OPERATE";
	std::string capability_safe_str= "STANDBY";
	std::string synchronise_attr_name= "samplingClockSynchronised";
	Tango::DevShort bandNotConfigured= 0;
	int nBands= 6;
	//============================================================================

	//=====================================================
	//==         INIT ARGUMENTS
	//=====================================================
	//## Check bandId arg 
	if(bandId<=0 || bandId>nBands){
		std::stringstream ss;
		ss<<"Invalid argument given (bandId="<<bandId<<"), valid values are in range ["<<1<<","<<nBands<<"]!";
		_ERROR_LOG(ss.str());
	
		//Set fault status	
		SetConfigureStatus("FAILED",ss.str(),true);

		_THROW_TANGO_EXCEPTION("CONFIGURE_FAILED",ss.str());
	}

	
	//=====================================================
	//==        CHECK CONFIGURED BAND ID
	//=====================================================
	//## Get band currently active (can be the same of given argument or different)
	Tango::DevShort activeBandId= 0;
	if(GetDynAttrValue(activeBandId,activeBand_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<activeBand_attr_name<<" value!";
		_ERROR_LOG(ss.str());

		//Set fault status	
		SetConfigureStatus("FAILED",ss.str(),true);
	
		_THROW_TANGO_EXCEPTION("CONFIGURE_BAND_FAILED",ss.str());
	}	

	bool hasActiveBand= (activeBandId != bandNotConfigured);
	bool isSameBandRequested= (bandId == activeBandId);
	if(isSameBandRequested && hasActiveBand){
		_INFO_LOG("Requested band (bandId="<<bandId<<") is already active, re-configuring...");
	}	
	

	//=====================================================
	//==         GET SET VALUES
	//=====================================================
	//Retrieve mode value corresponding to label
	Tango::DevShort mode;
	Tango::DevShort mode_safe;	
	Utils_ns::TangoUtils::GetEnumAttrValue(mode,this,attr_name,mode_str);
	Utils_ns::TangoUtils::GetEnumAttrValue(mode_safe,this,attr_name,mode_safe_str);
	
	//Retrieve capability corresponding to label
	std::string cap_attr_name= cap_attr_names[bandId-1];
	Tango::DevShort capability;
	Tango::DevShort capability_safe;
	Utils_ns::TangoUtils::GetEnumAttrValue(capability,this,cap_attr_name,capability_str);
	Utils_ns::TangoUtils::GetEnumAttrValue(capability_safe,this,cap_attr_name,capability_safe_str);

	//Retrieve default attenuations
	Tango::DevFloat attenuation_h_default;
	Tango::DevFloat attenuation_v_default;
	if(GetDynAttrValue(attenuation_h_default,attenuation_h_default_attr_names[bandId-1])<0){
		std::stringstream ss;
		ss<<"Failed to get dyn attr "<<attenuation_h_default_attr_names[bandId-1]<<" value!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("CONFIGURE_BAND_FAILED",ss.str());	
	}
	if(GetDynAttrValue(attenuation_v_default,attenuation_v_default_attr_names[bandId-1])<0){
		std::stringstream ss;
		ss<<"Failed to get dyn attr "<<attenuation_v_default_attr_names[bandId-1]<<" value!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("CONFIGURE_BAND_FAILED",ss.str());	
	}

	//Retrieve default sampling clock frequency
	Tango::DevLong samplingClockFrequency_default;
	if(GetDynAttrValue(samplingClockFrequency_default,samplingClockFrequency_default_attr_names[bandId-1])<0){
		std::stringstream ss;
		ss<<"Failed to get dyn attr "<<samplingClockFrequency_default_attr_names[bandId-1]<<" value!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("CONFIGURE_BAND_FAILED",ss.str());	
	}

	//=====================================================
	//==      STOP CAPTURE ON ACTIVE BAND (IF ANY)
	//=====================================================
	//Stop capture on active band
	if(hasActiveBand){
		_INFO_LOG("Stopping data capture on active band (if any)...");
		try {
			capture_data(false);
		}
		catch(Tango::DevFailed& e){
			std::stringstream ss;
			ss<<"Failed to stop data capture on active band "<<activeBandId<<"!";
			_ERROR_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("CONFIGURE_BAND_FAILED",ss.str());
		}//close catch
	}//close if hasActiveBand

	//=====================================================
	//==      SET SYNCHRONISE TO FALSE
	//=====================================================
	_INFO_LOG("Setting synchronise flag to FALSE ...");
	Tango::DevBoolean synchronised= false;
	if(SetDynAttrValue<Tango::DevBoolean>(synchronised,synchronise_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<synchronise_attr_name<<" to "<<synchronised<<"!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("CONFIGURE_BAND_FAILED",ss.str());
	}

	//=====================================================
	//==         SET MODE TO CONFIGURE
	//=====================================================
	_INFO_LOG("Setting mode to "<<mode<<" ("<<mode_str<<")...");
	if(SetSMDynAttrValue<Tango::DevShort>(mode,attr_name,&mode_safe)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<attr_name<<" to "<<mode<<"!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("CONFIGURE_BAND_FAILED",ss.str());
	}

	//=====================================================
	//==         SET CAPABILITY TO CONFIGURE
	//=====================================================
	//Set capability to CONFIGURE (check if allowed and if it fails revert it to STANDBY)
	_INFO_LOG("Setting capability to "<<capability<<" ("<<capability_str<<")...");
	if(SetSMDynAttrValue<Tango::DevShort>(capability,cap_attr_name,&capability_safe)<0){
		std::stringstream ss;
		ss<<"Failed to set capability "<<cap_attr_name<<" to "<<capability<<"!";
		_ERROR_LOG(ss.str());

		//Revert mode to STANDBY-FP	
		SetDynAttrValue<Tango::DevShort>(mode_safe,attr_name);
	
		//Throw exception
		_THROW_TANGO_EXCEPTION("CONFIGURE_BAND_FAILED",ss.str());
	}

	//=====================================================
	//==         SET ATTENUATION TO DEFAULT
	//=====================================================
	//Set attenuations for configured band 
	_INFO_LOG("Setting current attenuation for H/V channels to default value of band "<<bandId<<" ...");
	if(SetDynAttrValue<Tango::DevFloat>(attenuation_h_default,attenuation_h_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set h-channel attenuation attr "<<attenuation_h_attr_name<<" to "<<attenuation_h_default<<"!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("CONFIGURE_BAND_FAILED",ss.str());
	}
	if(SetDynAttrValue<Tango::DevFloat>(attenuation_v_default,attenuation_v_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set v-channel attenuation attr "<<attenuation_v_attr_name<<" to "<<attenuation_v_default<<"!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("CONFIGURE_BAND_FAILED",ss.str());
	}


	//=====================================================
	//==         SET SAMPLING CLOCK FREQUENCY TO DEFAULT
	//=====================================================
	//Set sampling clock frequency for configured band 
	_INFO_LOG("Setting current sampling clock frequency to default value of band "<<bandId<<" ...");
	if(SetDynAttrValue<Tango::DevLong>(samplingClockFrequency_default,samplingClockFrequency_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set sampling clock frequency attr "<<samplingClockFrequency_attr_name<<" to "<<samplingClockFrequency_default<<"!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("CONFIGURE_BAND_FAILED",ss.str());
	}

	//=====================================================
	//==        UPDATE SELECTED BAND (DO BEFORE START CAPTURE)
	//=====================================================
	//Set current band attr to the selected (MISSING IN ICD!!!)
	if(SetDynAttrValue<Tango::DevShort>(bandId,activeBand_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<activeBand_attr_name<<" to "<<bandId<<"!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("CONFIGURE_BAND_FAILED",ss.str());
	}

	//=====================================================
	//==      START CAPTURE ON SELECTED BAND
	//=====================================================
	//Start data capture: if successful mode=DATA-CAPTURE, cap=OPERATE
	_INFO_LOG("Starting data capture on new configured band ...");
	try {
		capture_data(true);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		std::stringstream ss;
		ss<<"Failed to stop data capture on selected band!";
		_ERROR_LOG(ss.str());

		//Revert mode to STANDBY-FP	(already done in capture)
		SetDynAttrValue<Tango::DevShort>(mode_safe,attr_name);
	
		//Revert capability to STANDBY (already done in capture)
		SetDynAttrValue<Tango::DevShort>(capability_safe,cap_attr_name);
	
		//Throw exception
		_THROW_TANGO_EXCEPTION("CONFIGURE_BAND_FAILED",ss.str());
	}//close catch

}//close ConfigureBand()

// //--------------------------------------------------------
// /**
//  *	Command SetNoiseSourcePars related method
//  *	Description: Set the noise diode start time, period and on/off time 
//  *               (duty cycle).
//  *               
//  *               Command allowed only in {STANDBY-LP, STANDBY-FP, MAINTENANCE} modes.
//  *
//  *	@param argin [0]: Start time of a new noise source
//  *               [1]: Noise source period (Duty cycle: time fraction in [0,1] in which the 
//  *               noise diode is turned on)
//  *               [2]: Noise source on time (Overall period of a on/off cycle in seconds)
//  *               [3]: Noise source off time
//  */
// //--------------------------------------------------------
// void RxEmulator::set_noise_source_pars(const Tango::DevVarFloatArray *argin)
// {
// 	DEBUG_STREAM << "RxEmulator::SetNoiseSourcePars()  - " << device_name << endl;
// 	
// 	//	Add your own code
// 	//###########################################################################
// 	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
// 	//###########################################################################
// 	std::vector<std::string> attr_names {
// 		"noiseSourceStartTime",
// 		"noiseSourcePeriod",
// 		"noiseSourceOnTime",
// 		"noiseSourceOffTime"
// 	};	
// 	//###########################################################################
// 	//## Check input args
// 	int nArgs= (int)argin->length();
// 	if(nArgs<4){
// 		std::string errMsg= "Invalid number of arguments given (4 are required)!";
// 		_ERROR_LOG(errMsg);
// 		_THROW_TANGO_EXCEPTION("SET_NOISE_SOURCE_FAILED",errMsg);	
// 	}
// 	//## Set noise source pars attributes
// 	for(unsigned int i=0;i<attr_names.size();i++){
// 		std::string attr_name= attr_names[i];
// 		Tango::DevFloat attr_value= (*argin)[i];
// 		if(SetDynAttrValue<Tango::DevFloat>(attr_value,attr_name)<0){
// 			std::stringstream ss;
// 			ss<<"Failed to set attr "<<attr_name<<" to "<<attr_value<<"!";
// 			_ERROR_LOG(ss.str());
// 			_THROW_TANGO_EXCEPTION("SET_NOISE_SOURCE_FAILED",ss.str());	
// 		}
// 	}//end loop attrs
// 		
// }

// //--------------------------------------------------------
// /**
//  *	Command SetAttenuation related method
//  *	Description: Sets the global attenuation.  Changing this value will 
//  *               set the attenuation across the system and will be 
//  *               applied to all bands.
//  *
//  *	@param argin Attenuation value
//  */
// //--------------------------------------------------------
// void RxEmulator::set_attenuation(Tango::DevFloat argin)
// {
// 	DEBUG_STREAM << "RxEmulator::SetAttenuation()  - " << device_name << endl;
// 	
// 	//	Add your own code
// 	//###########################################################################
// 	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
// 	//###########################################################################
// 	std::string attr_name= "attenuation";
// 	//###########################################################################
// 	//## Set attenuation attributes
// 	_INFO_LOG("Set attenuation attribute value (NB: THIS COMMAND IS DEPRECATED!)");
// 	
// 	if(SetDynAttrValue<Tango::DevFloat>(argin,attr_name)<0){
// 		std::stringstream ss;
// 		ss<<"Failed to set attr "<<attr_name<<" to "<<argin<<"!";
// 		_ERROR_LOG(ss.str());
// 		_THROW_TANGO_EXCEPTION("SET_ATTENUATION_FAILED",ss.str());	
// 	}
// 	
// }

// //--------------------------------------------------------
// /**
//  *	Read attribute configureFirmwareProgress related method
//  *	Description: 
//  *
//  *	Data type:	Tango::DevString
//  *	Attr type:	Spectrum max = 3
//  */
// //--------------------------------------------------------
// void RxEmulator::read_configureFirmwareProgress(Tango::Attribute &attr)
// {
// 	DEBUG_STREAM << "RxEmulator::read_configureFirmwareProgress(Tango::Attribute &attr) entering... " << endl;
// 	//	Set the attribute value
// 	attr.set_value(attr_configureFirmwareProgress_read, 3);
// 	
// }


/*----- PROTECTED REGION END -----*/	//	RxEmulator::namespace_ending
} //	namespace
