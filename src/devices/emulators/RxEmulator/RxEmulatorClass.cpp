/*----- PROTECTED REGION ID(RxEmulatorClass.cpp) ENABLED START -----*/
static const char *RcsId      = "$Id:  $";
static const char *TagName    = "$Name:  $";
static const char *CvsPath    = "$Source:  $";
static const char *SvnPath    = "$HeadURL:  $";
static const char *HttpServer = "http://www.esrf.eu/computing/cs/tango/tango_doc/ds_doc/";
//=============================================================================
//
// file :        RxEmulatorClass.cpp
//
// description : C++ source for the RxEmulatorClass.
//               A singleton class derived from DeviceClass.
//               It implements the command and attribute list
//               and all properties and methods required
//               by the RxEmulator once per process.
//
// project :     RxEmulator
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
// $Author:  $
//
// $Revision:  $
// $Date:  $
//
// $HeadURL:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <RxEmulatorClass.h>

#include <Logger.h>
#include <TangoUtils.h>

/*----- PROTECTED REGION END -----*/	//	RxEmulatorClass.cpp

//-------------------------------------------------------------------
/**
 *	Create RxEmulatorClass singleton and
 *	return it in a C function for Python usage
 */
//-------------------------------------------------------------------
extern "C" {
#ifdef _TG_WINDOWS_

__declspec(dllexport)

#endif

	Tango::DeviceClass *_create_RxEmulator_class(const char *name) {
		return RxEmulator_ns::RxEmulatorClass::init(name);
	}
}

namespace RxEmulator_ns
{
//===================================================================
//	Initialize pointer for singleton pattern
//===================================================================
RxEmulatorClass *RxEmulatorClass::_instance = NULL;

//--------------------------------------------------------
/**
 * method : 		RxEmulatorClass::RxEmulatorClass(string &s)
 * description : 	constructor for the RxEmulatorClass
 *
 * @param s	The class name
 */
//--------------------------------------------------------
RxEmulatorClass::RxEmulatorClass(string &s):LMCDevice_ns::LMCDeviceClass(s)
{
	cout2 << "Entering RxEmulatorClass constructor" << endl;
	set_default_property();
	write_class_property();

	/*----- PROTECTED REGION ID(RxEmulatorClass::constructor) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	RxEmulatorClass::constructor

	cout2 << "Leaving RxEmulatorClass constructor" << endl;
}

//--------------------------------------------------------
/**
 * method : 		RxEmulatorClass::~RxEmulatorClass()
 * description : 	destructor for the RxEmulatorClass
 */
//--------------------------------------------------------
RxEmulatorClass::~RxEmulatorClass()
{
	/*----- PROTECTED REGION ID(RxEmulatorClass::destructor) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	RxEmulatorClass::destructor

	_instance = NULL;
}


//--------------------------------------------------------
/**
 * method : 		RxEmulatorClass::init
 * description : 	Create the object if not already done.
 *                  Otherwise, just return a pointer to the object
 *
 * @param	name	The class name
 */
//--------------------------------------------------------
RxEmulatorClass *RxEmulatorClass::init(const char *name)
{
	if (_instance == NULL)
	{
		try
		{
			string s(name);
			_instance = new RxEmulatorClass(s);
		}
		catch (bad_alloc &)
		{
			throw;
		}
	}
	return _instance;
}

//--------------------------------------------------------
/**
 * method : 		RxEmulatorClass::instance
 * description : 	Check if object already created,
 *                  and return a pointer to the object
 */
//--------------------------------------------------------
RxEmulatorClass *RxEmulatorClass::instance()
{
	if (_instance == NULL)
	{
		cerr << "Class is not initialised !!" << endl;
		exit(-1);
	}
	return _instance;
}



//===================================================================
//	Command execution method calls
//===================================================================
//--------------------------------------------------------
/**
 * method : 		SynchroniseClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *SynchroniseClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "SynchroniseClass::execute(): arrived" << endl;
	((static_cast<RxEmulator *>(device))->synchronise());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		ConfigureBandClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *ConfigureBandClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "ConfigureBandClass::execute(): arrived" << endl;
	Tango::DevShort argin;
	extract(in_any, argin);
	((static_cast<RxEmulator *>(device))->configure_band(argin));
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		ConfigureBand1Class::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *ConfigureBand1Class::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "ConfigureBand1Class::execute(): arrived" << endl;
	((static_cast<RxEmulator *>(device))->configure_band1());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		ConfigureBand2Class::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *ConfigureBand2Class::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "ConfigureBand2Class::execute(): arrived" << endl;
	((static_cast<RxEmulator *>(device))->configure_band2());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		ConfigureBand3Class::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *ConfigureBand3Class::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "ConfigureBand3Class::execute(): arrived" << endl;
	((static_cast<RxEmulator *>(device))->configure_band3());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		ConfigureBand4Class::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *ConfigureBand4Class::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "ConfigureBand4Class::execute(): arrived" << endl;
	((static_cast<RxEmulator *>(device))->configure_band4());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		ConfigureBand5aClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *ConfigureBand5aClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "ConfigureBand5aClass::execute(): arrived" << endl;
	((static_cast<RxEmulator *>(device))->configure_band5a());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		ConfigureBand5bClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *ConfigureBand5bClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "ConfigureBand5bClass::execute(): arrived" << endl;
	((static_cast<RxEmulator *>(device))->configure_band5b());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		ConfigureBandAsyncClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *ConfigureBandAsyncClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "ConfigureBandAsyncClass::execute(): arrived" << endl;
	Tango::DevShort argin;
	extract(in_any, argin);
	return insert((static_cast<RxEmulator *>(device))->configure_band_async(argin));
}

//--------------------------------------------------------
/**
 * method : 		CaptureDataClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *CaptureDataClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "CaptureDataClass::execute(): arrived" << endl;
	Tango::DevBoolean argin;
	extract(in_any, argin);
	((static_cast<RxEmulator *>(device))->capture_data(argin));
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		SetSubElementModeClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *SetSubElementModeClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "SetSubElementModeClass::execute(): arrived" << endl;
	Tango::DevShort argin;
	extract(in_any, argin);
	((static_cast<RxEmulator *>(device))->set_sub_element_mode(argin));
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		SetSubElementModeStrClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *SetSubElementModeStrClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "SetSubElementModeStrClass::execute(): arrived" << endl;
	Tango::DevString argin;
	extract(in_any, argin);
	((static_cast<RxEmulator *>(device))->set_sub_element_mode_str(argin));
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		SetStandbyLPModeClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *SetStandbyLPModeClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "SetStandbyLPModeClass::execute(): arrived" << endl;
	((static_cast<RxEmulator *>(device))->set_standby_lpmode());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		SetStandbyFPModeClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *SetStandbyFPModeClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "SetStandbyFPModeClass::execute(): arrived" << endl;
	((static_cast<RxEmulator *>(device))->set_standby_fpmode());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		SetMaintenanceModeClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *SetMaintenanceModeClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "SetMaintenanceModeClass::execute(): arrived" << endl;
	((static_cast<RxEmulator *>(device))->set_maintenance_mode());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		EnableEngineeringModeClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *EnableEngineeringModeClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "EnableEngineeringModeClass::execute(): arrived" << endl;
	Tango::DevBoolean argin;
	extract(in_any, argin);
	((static_cast<RxEmulator *>(device))->enable_engineering_mode(argin));
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		UpdateFirmwareClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *UpdateFirmwareClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "UpdateFirmwareClass::execute(): arrived" << endl;
	Tango::DevShort argin;
	extract(in_any, argin);
	((static_cast<RxEmulator *>(device))->update_firmware(argin));
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		SetHighPowerStateClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *SetHighPowerStateClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "SetHighPowerStateClass::execute(): arrived" << endl;
	Tango::DevBoolean argin;
	extract(in_any, argin);
	((static_cast<RxEmulator *>(device))->set_high_power_state(argin));
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		AdjustPolHAttenuationClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *AdjustPolHAttenuationClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "AdjustPolHAttenuationClass::execute(): arrived" << endl;
	Tango::DevFloat argin;
	extract(in_any, argin);
	((static_cast<RxEmulator *>(device))->adjust_pol_hattenuation(argin));
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		AdjustPolVAttenuationClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *AdjustPolVAttenuationClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "AdjustPolVAttenuationClass::execute(): arrived" << endl;
	Tango::DevFloat argin;
	extract(in_any, argin);
	((static_cast<RxEmulator *>(device))->adjust_pol_vattenuation(argin));
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		ShutdownClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *ShutdownClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "ShutdownClass::execute(): arrived" << endl;
	((static_cast<RxEmulator *>(device))->shutdown());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		dummyDynCmdClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *dummyDynCmdClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "dummyDynCmdClass::execute(): arrived" << endl;
	((static_cast<RxEmulator *>(device))->dummy_dyn_cmd(*this));
	return new CORBA::Any();
}


//===================================================================
//	Properties management
//===================================================================
//--------------------------------------------------------
/**
 *	Method      : RxEmulatorClass::get_class_property()
 *	Description : Get the class property for specified name.
 */
//--------------------------------------------------------
Tango::DbDatum RxEmulatorClass::get_class_property(string &prop_name)
{
	for (unsigned int i=0 ; i<cl_prop.size() ; i++)
		if (cl_prop[i].name == prop_name)
			return cl_prop[i];
	//	if not found, returns  an empty DbDatum
	return Tango::DbDatum(prop_name);
}

//--------------------------------------------------------
/**
 *	Method      : RxEmulatorClass::get_default_device_property()
 *	Description : Return the default value for device property.
 */
//--------------------------------------------------------
Tango::DbDatum RxEmulatorClass::get_default_device_property(string &prop_name)
{
	for (unsigned int i=0 ; i<dev_def_prop.size() ; i++)
		if (dev_def_prop[i].name == prop_name)
			return dev_def_prop[i];
	//	if not found, return  an empty DbDatum
	return Tango::DbDatum(prop_name);
}

//--------------------------------------------------------
/**
 *	Method      : RxEmulatorClass::get_default_class_property()
 *	Description : Return the default value for class property.
 */
//--------------------------------------------------------
Tango::DbDatum RxEmulatorClass::get_default_class_property(string &prop_name)
{
	for (unsigned int i=0 ; i<cl_def_prop.size() ; i++)
		if (cl_def_prop[i].name == prop_name)
			return cl_def_prop[i];
	//	if not found, return  an empty DbDatum
	return Tango::DbDatum(prop_name);
}


//--------------------------------------------------------
/**
 *	Method      : RxEmulatorClass::set_default_property()
 *	Description : Set default property (class and device) for wizard.
 *                For each property, add to wizard property name and description.
 *                If default value has been set, add it to wizard property and
 *                store it in a DbDatum.
 */
//--------------------------------------------------------
void RxEmulatorClass::set_default_property()
{
	string	prop_name;
	string	prop_desc;
	string	prop_def;
	vector<string>	vect_data;

	//	Set Default Class Properties

	//	Set Default device Properties
	prop_name = "StartupTime";
	prop_desc = "Average time for starting up Rx in seconds";
	prop_def  = "10";
	vect_data.clear();
	vect_data.push_back("10");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "ConfigureTime";
	prop_desc = "Average time taken for configuring a band";
	prop_def  = "2";
	vect_data.clear();
	vect_data.push_back("2");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "EnableStartupFailure";
	prop_desc = "Enable/disable simulation of startup failures";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "StartupFailureProbability";
	prop_desc = "Startup failure probability in range (0,1)";
	prop_def  = "0.1";
	vect_data.clear();
	vect_data.push_back("0.1");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "EnableConfigureFailure";
	prop_desc = "Enable/disable simulation of configure failures during configure step";
	prop_def  = "false";
	vect_data.clear();
	vect_data.push_back("false");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "ConfigureFailureProbability";
	prop_desc = "Failure probability in range (0,1) for configure stage";
	prop_def  = "0.1";
	vect_data.clear();
	vect_data.push_back("0.1");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "B1NominalGain";
	prop_desc = "Default gain (in dB) expected to be achieved when the \nNominal Attenuation is applied to the SPFRx.  These gain \nvalues are on a per band basis.\nThe purpose of this value is for informational purposes only.  \nThis will be configured at build/integration for each device.\n\nB1 range: 0-12 dB, default=TBD";
	prop_def  = "6";
	vect_data.clear();
	vect_data.push_back("6");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "B2NominalGain";
	prop_desc = "Default gain (in dB) expected to be achieved when the \nNominal Attenuation is applied to the SPFRx.  These gain \nvalues are on a per band basis.\nThe purpose of this value is for informational purposes only.  \nThis will be configured at build/integration for each device.\n\nB2 range 0-8 dB, default=TBD";
	prop_def  = "4";
	vect_data.clear();
	vect_data.push_back("4");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "B3NominalGain";
	prop_desc = "Default gain (in dB) expected to be achieved when the \nNominal Attenuation is applied to the SPFRx.  These gain \nvalues are on a per band basis.\nThe purpose of this value is for informational purposes only.  \nThis will be configured at build/integration for each device.\n\nB3 range 0-8 dB, default=TBD";
	prop_def  = "4";
	vect_data.clear();
	vect_data.push_back("4");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "B4NominalGain";
	prop_desc = "Default gain (in dB) expected to be achieved when the \nNominal Attenuation is applied to the SPFRx.  These gain \nvalues are on a per band basis.\nThe purpose of this value is for informational purposes only.  \nThis will be configured at build/integration for each device.\n\nB4: TBD";
	prop_def  = "4";
	vect_data.clear();
	vect_data.push_back("4");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "B5aNominalGain";
	prop_desc = "Default gain (in dB) expected to be achieved when the \nNominal Attenuation is applied to the SPFRx.  These gain \nvalues are on a per band basis.\nThe purpose of this value is for informational purposes only.  \nThis will be configured at build/integration for each device.\n\nB5a: TBD";
	prop_def  = "4";
	vect_data.clear();
	vect_data.push_back("4");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "B5bNominalGain";
	prop_desc = "Default gain (in dB) expected to be achieved when the \nNominal Attenuation is applied to the SPFRx.  These gain \nvalues are on a per band basis.\nThe purpose of this value is for informational purposes only.  \nThis will be configured at build/integration for each device.\n\nB5b: TBD";
	prop_def  = "5";
	vect_data.clear();
	vect_data.push_back("5");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "B1MaxGain";
	prop_desc = "The Maximum Gain value (in dB) possible by the hardware \nfor each band.  This is determined experimentally for each \ndigitizer and will be unlikely to change unless hardware \ncharacterization changes.  It will be configured in the system \nat deployment for each receiver. \n\nB1: by up to 46 dB, default=TBD";
	prop_def  = "30";
	vect_data.clear();
	vect_data.push_back("30");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "B2MaxGain";
	prop_desc = "The Maximum Gain value (in dB) possible by the hardware \nfor each band.  This is determined experimentally for each \ndigitizer and will be unlikely to change unless hardware \ncharacterization changes.  It will be configured in the system \nat deployment for each receiver. \n\nB2: by up to 46 dB, default=TBD";
	prop_def  = "30";
	vect_data.clear();
	vect_data.push_back("30");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "B3MaxGain";
	prop_desc = "The Maximum Gain value (in dB) possible by the hardware \nfor each band.  This is determined experimentally for each \ndigitizer and will be unlikely to change unless hardware \ncharacterization changes.  It will be configured in the system \nat deployment for each receiver. \n\nB3: by up to 42 dB, default=TBD";
	prop_def  = "30";
	vect_data.clear();
	vect_data.push_back("30");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "B4MaxGain";
	prop_desc = "The Maximum Gain value (in dB) possible by the hardware \nfor each band.  This is determined experimentally for each \ndigitizer and will be unlikely to change unless hardware \ncharacterization changes.  It will be configured in the system \nat deployment for each receiver. \n\nB4: TBD";
	prop_def  = "30";
	vect_data.clear();
	vect_data.push_back("30");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "B5aMaxGain";
	prop_desc = "The Maximum Gain value (in dB) possible by the hardware \nfor each band.  This is determined experimentally for each \ndigitizer and will be unlikely to change unless hardware \ncharacterization changes.  It will be configured in the system \nat deployment for each receiver. \n\nB5: TBD";
	prop_def  = "30";
	vect_data.clear();
	vect_data.push_back("30");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "B5bMaxGain";
	prop_desc = "The Maximum Gain value (in dB) possible by the hardware \nfor each band.  This is determined experimentally for each \ndigitizer and will be unlikely to change unless hardware \ncharacterization changes.  It will be configured in the system \nat deployment for each receiver. \n\nB5: TBD";
	prop_def  = "30";
	vect_data.clear();
	vect_data.push_back("30");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "B1PolHNominalAttenuation";
	prop_desc = "The default attenuation in dB that is expected to be applied to \nthe receiver by default when capturing data.  The attenuation is \ndefined on per band (1...5b) and on a per polarization \n(horizontal and vertical) basis and is the attenuation required \nto achieve the nominal gain.\n\nDefault value is determined at build/integration time and is \ndevice dependent.";
	prop_def  = "0";
	vect_data.clear();
	vect_data.push_back("0");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "B2PolHNominalAttenuation";
	prop_desc = "The default attenuation in dB that is expected to be applied to \nthe receiver by default when capturing data.  The attenuation is \ndefined on per band (1...5b) and on a per polarization \n(horizontal and vertical) basis and is the attenuation required \nto achieve the nominal gain.";
	prop_def  = "0";
	vect_data.clear();
	vect_data.push_back("0");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "B3PolHNominalAttenuation";
	prop_desc = "The default attenuation in dB that is expected to be applied to \nthe receiver by default when capturing data.  The attenuation is \ndefined on per band (1...5b) and on a per polarization \n(horizontal and vertical) basis and is the attenuation required \nto achieve the nominal gain.";
	prop_def  = "0";
	vect_data.clear();
	vect_data.push_back("0");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "B4PolHNominalAttenuation";
	prop_desc = "The default attenuation in dB that is expected to be applied to \nthe receiver by default when capturing data.  The attenuation is \ndefined on per band (1...5b) and on a per polarization \n(horizontal and vertical) basis and is the attenuation required \nto achieve the nominal gain.";
	prop_def  = "0";
	vect_data.clear();
	vect_data.push_back("0");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "B5aPolHNominalAttenuation";
	prop_desc = "The default attenuation in dB that is expected to be applied to \nthe receiver by default when capturing data.  The attenuation is \ndefined on per band (1...5b) and on a per polarization \n(horizontal and vertical) basis and is the attenuation required \nto achieve the nominal gain.";
	prop_def  = "0";
	vect_data.clear();
	vect_data.push_back("0");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "B5bPolHNominalAttenuation";
	prop_desc = "The default attenuation in dB that is expected to be applied to \nthe receiver by default when capturing data.  The attenuation is \ndefined on per band (1...5b) and on a per polarization \n(horizontal and vertical) basis and is the attenuation required \nto achieve the nominal gain.";
	prop_def  = "0";
	vect_data.clear();
	vect_data.push_back("0");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "B1PolVNominalAttenuation";
	prop_desc = "The default attenuation in dB that is expected to be applied to \nthe receiver by default when capturing data.  The attenuation is \ndefined on per band (1...5b) and on a per polarization \n(horizontal and vertical) basis and is the attenuation required \nto achieve the nominal gain.";
	prop_def  = "0";
	vect_data.clear();
	vect_data.push_back("0");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "B2PolVNominalAttenuation";
	prop_desc = "The default attenuation in dB that is expected to be applied to \nthe receiver by default when capturing data.  The attenuation is \ndefined on per band (1...5b) and on a per polarization \n(horizontal and vertical) basis and is the attenuation required \nto achieve the nominal gain.";
	prop_def  = "0";
	vect_data.clear();
	vect_data.push_back("0");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "B3PolVNominalAttenuation";
	prop_desc = "The default attenuation in dB that is expected to be applied to \nthe receiver by default when capturing data.  The attenuation is \ndefined on per band (1...5b) and on a per polarization \n(horizontal and vertical) basis and is the attenuation required \nto achieve the nominal gain.";
	prop_def  = "0";
	vect_data.clear();
	vect_data.push_back("0");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "B4PolVNominalAttenuation";
	prop_desc = "The default attenuation in dB that is expected to be applied to \nthe receiver by default when capturing data.  The attenuation is \ndefined on per band (1...5b) and on a per polarization \n(horizontal and vertical) basis and is the attenuation required \nto achieve the nominal gain.";
	prop_def  = "0";
	vect_data.clear();
	vect_data.push_back("0");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "B5aPolVNominalAttenuation";
	prop_desc = "The default attenuation in dB that is expected to be applied to \nthe receiver by default when capturing data.  The attenuation is \ndefined on per band (1...5b) and on a per polarization \n(horizontal and vertical) basis and is the attenuation required \nto achieve the nominal gain.";
	prop_def  = "0";
	vect_data.clear();
	vect_data.push_back("0");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "B5bPolVNominalAttenuation";
	prop_desc = "The default attenuation in dB that is expected to be applied to \nthe receiver by default when capturing data.  The attenuation is \ndefined on per band (1...5b) and on a per polarization \n(horizontal and vertical) basis and is the attenuation required \nto achieve the nominal gain.";
	prop_def  = "0";
	vect_data.clear();
	vect_data.push_back("0");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "NoiseDiodeStateDefault";
	prop_desc = "Default noise diode generation model \n(0=OFF, 1=PERIODIC, 2=PSEUDO-RANDOM)";
	prop_def  = "0";
	vect_data.clear();
	vect_data.push_back("0");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "PeriodicNoiseDiodeParsDefault";
	prop_desc = "Default noise source config parameters \n(start time, period, on time, off time) for periodic model.\nDefault values are TBD";
	prop_def  = "0";
	vect_data.clear();
	vect_data.push_back("0");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "PseudoRandomNoiseDiodeParsDefault";
	prop_desc = "Default noise source config parameters \n(start time, on time, off time, seed) for pseudo-random model.\nDefault values are TBD";
	prop_def  = "0";
	vect_data.clear();
	vect_data.push_back("0");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "B1NominalSamplingClockFrequency";
	prop_desc = "Nominal band sampling clock frequency.\nThese will define a nominal frequency for the sampling clock that will be used when no other Sampling Clock Frequency has been defined. These can be configured at integration time at each dish";
	prop_def  = "1";
	vect_data.clear();
	vect_data.push_back("1");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "B2NominalSamplingClockFrequency";
	prop_desc = "Nominal band sampling clock frequency.\nThese will define a nominal frequency for the sampling clock that will be used when no other Sampling Clock Frequency has been defined. These can be configured at integration time at each dish.";
	prop_def  = "2";
	vect_data.clear();
	vect_data.push_back("2");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "B3NominalSamplingClockFrequency";
	prop_desc = "Nominal band sampling clock frequency.\nThese will define a nominal frequency for the sampling clock that will be used when no other Sampling Clock Frequency has been defined. These can be configured at integration time at each dish.";
	prop_def  = "3";
	vect_data.clear();
	vect_data.push_back("3");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "B4NominalSamplingClockFrequency";
	prop_desc = "Nominal band sampling clock frequency.\nThese will define a nominal frequency for the sampling clock that will be used when no other Sampling Clock Frequency has been defined. These can be configured at integration time at each dish.";
	prop_def  = "4";
	vect_data.clear();
	vect_data.push_back("4");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "B5aNominalSamplingClockFrequency";
	prop_desc = "Nominal band sampling clock frequency.\nThese will define a nominal frequency for the sampling clock that will be used when no other Sampling Clock Frequency has been defined. These can be configured at integration time at each dish";
	prop_def  = "5";
	vect_data.clear();
	vect_data.push_back("5");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "B5bNominalSamplingClockFrequency";
	prop_desc = "Nominal band sampling clock frequency.\nThese will define a nominal frequency for the sampling clock that will be used when no other Sampling Clock Frequency has been defined. These can be configured at integration time at each dish.";
	prop_def  = "6";
	vect_data.clear();
	vect_data.push_back("6");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "ConfiguredBandDefault";
	prop_desc = "Default configured band";
	prop_def  = "0";
	vect_data.clear();
	vect_data.push_back("0");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "ExpectedOnlineDefault";
	prop_desc = "Default value for expected online flags";
	prop_def  = "0";
	vect_data.clear();
	vect_data.push_back("0");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
}

//--------------------------------------------------------
/**
 *	Method      : RxEmulatorClass::write_class_property()
 *	Description : Set class description fields as property in database
 */
//--------------------------------------------------------
void RxEmulatorClass::write_class_property()
{
	//	First time, check if database used
	if (Tango::Util::_UseDb == false)
		return;

	Tango::DbData	data;
	string	classname = get_name();
	string	header;
	string::size_type	start, end;

	//	Put title
	Tango::DbDatum	title("ProjectTitle");
	string	str_title("RxEmulator");
	title << str_title;
	data.push_back(title);

	//	Put Description
	Tango::DbDatum	description("Description");
	vector<string>	str_desc;
	str_desc.push_back("RxEmulator");
	description << str_desc;
	data.push_back(description);

	//  Put inheritance
	Tango::DbDatum	inher_datum("InheritedFrom");
	vector<string> inheritance;
	inheritance.push_back("TANGO_BASE_CLASS");
	inher_datum << inheritance;
	data.push_back(inher_datum);

	//	Call database and and values
	get_db_class()->put_property(data);
}

//===================================================================
//	Factory methods
//===================================================================

//--------------------------------------------------------
/**
 *	Method      : RxEmulatorClass::device_factory()
 *	Description : Create the device object(s)
 *                and store them in the device list
 */
//--------------------------------------------------------
void RxEmulatorClass::device_factory(const Tango::DevVarStringArray *devlist_ptr)
{
	/*----- PROTECTED REGION ID(RxEmulatorClass::device_factory_before) ENABLED START -----*/
	
	//	Add your own code
	/*
	for (unsigned long i=1 ; i<=devlist_ptr->length() ; i++) {
		RxEmulator *dev = static_cast<RxEmulator *>(device_list[device_list.size()-i]);

		//## Remove attributes from dam and device (if enabled)
  	if(dev->EraseDynAttrManager()<0){
			__ERROR_LOG(dev,"Failed to cleanup dyn attr manager...");
			continue;
		}		
	}//end loop devices
	*/
	/*----- PROTECTED REGION END -----*/	//	RxEmulatorClass::device_factory_before

	//	Create devices and add it into the device list
	for (unsigned long i=0 ; i<devlist_ptr->length() ; i++)
	{
		cout4 << "Device name : " << (*devlist_ptr)[i].in() << endl;
		device_list.push_back(new RxEmulator(this, (*devlist_ptr)[i]));
	}

	//	Manage dynamic attributes if any
	erase_dynamic_attributes(devlist_ptr, get_class_attr()->get_attr_list());

	//	Export devices to the outside world
	for (unsigned long i=1 ; i<=devlist_ptr->length() ; i++)
	{
		//	Add dynamic attributes if any
		RxEmulator *dev = static_cast<RxEmulator *>(device_list[device_list.size()-i]);
		dev->add_dynamic_attributes();
		dev->add_dynamic_commands();

		//	Check before if database used.
		if ((Tango::Util::_UseDb == true) && (Tango::Util::_FileDb == false))
			export_device(dev);
		else
			export_device(dev, dev->get_name().c_str());
	}

	/*----- PROTECTED REGION ID(RxEmulatorClass::device_factory_after) ENABLED START -----*/
	
	//	Add your own code
	
	//## Initialize task
	//## NB: This is done here and not inside init_device because dynamic attributes need to be registered first in device (done in add_dynamic_attributes)
	for (unsigned long i=1 ; i<=devlist_ptr->length() ; i++) {

		//	Add dynamic attributes if any
		RxEmulator *dev = static_cast<RxEmulator *>(device_list[device_list.size()-i]);

		//## Execute Rx startup task
		if(dev->Startup()<0){
			std::string errMsg("SPFRx startup failed!");
			__ERROR_LOG(dev,errMsg);
			dev->set_state(Tango::FAULT);
			dev->set_status(errMsg.c_str());
			continue;
		}

		//## Set state to ON
		//dev->set_state(Tango::ON);
		//dev->set_status("SPFRx is running");

	}//end loop devices
	
	/*----- PROTECTED REGION END -----*/	//	RxEmulatorClass::device_factory_after
}
//--------------------------------------------------------
/**
 *	Method      : RxEmulatorClass::attribute_factory()
 *	Description : Create the attribute object(s)
 *                and store them in the attribute list
 */
//--------------------------------------------------------
void RxEmulatorClass::attribute_factory(vector<Tango::Attr *> &att_list)
{
	/*----- PROTECTED REGION ID(RxEmulatorClass::attribute_factory_before) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	RxEmulatorClass::attribute_factory_before
	//	Call atribute_factory for inherited class
	LMCDevice_ns::LMCDeviceClass::attribute_factory(att_list);

	//	Attribute : loggingLevelCentral - Check if not concrete in inherited class
	Tango::Attr *loggingLevelCentralAttr = get_attr_object_by_name(att_list, "loggingLevelCentral");
	if (loggingLevelCentralAttr == NULL)
	{
	}

	//	Attribute : loggingLevelElement - Check if not concrete in inherited class
	Tango::Attr *loggingLevelElementAttr = get_attr_object_by_name(att_list, "loggingLevelElement");
	if (loggingLevelElementAttr == NULL)
	{
	}

	//	Attribute : loggingLevelStorage - Check if not concrete in inherited class
	Tango::Attr *loggingLevelStorageAttr = get_attr_object_by_name(att_list, "loggingLevelStorage");
	if (loggingLevelStorageAttr == NULL)
	{
	}

	//	Attribute : loggingLevelConsole - Check if not concrete in inherited class
	Tango::Attr *loggingLevelConsoleAttr = get_attr_object_by_name(att_list, "loggingLevelConsole");
	if (loggingLevelConsoleAttr == NULL)
	{
	}

	//	Attribute : buildState - Check if not concrete in inherited class
	Tango::Attr *buildStateAttr = get_attr_object_by_name(att_list, "buildState");
	if (buildStateAttr == NULL)
	{
	}

	//	Attribute : centralLoggerStatus - Check if not concrete in inherited class
	Tango::Attr *centralLoggerStatusAttr = get_attr_object_by_name(att_list, "centralLoggerStatus");
	if (centralLoggerStatusAttr == NULL)
	{
	}

	//	Attribute : elementLoggerStatus - Check if not concrete in inherited class
	Tango::Attr *elementLoggerStatusAttr = get_attr_object_by_name(att_list, "elementLoggerStatus");
	if (elementLoggerStatusAttr == NULL)
	{
	}

	//	Attribute : storageLoggerStatus - Check if not concrete in inherited class
	Tango::Attr *storageLoggerStatusAttr = get_attr_object_by_name(att_list, "storageLoggerStatus");
	if (storageLoggerStatusAttr == NULL)
	{
	}

	//	Attribute : eventRate - Check if not concrete in inherited class
	Tango::Attr *eventRateAttr = get_attr_object_by_name(att_list, "eventRate");
	if (eventRateAttr == NULL)
	{
	}

	//	Attribute : exceptionRate - Check if not concrete in inherited class
	Tango::Attr *exceptionRateAttr = get_attr_object_by_name(att_list, "exceptionRate");
	if (exceptionRateAttr == NULL)
	{
	}

	//	Attribute : fwdAttrInitStatus - Check if not concrete in inherited class
	Tango::Attr *fwdAttrInitStatusAttr = get_attr_object_by_name(att_list, "fwdAttrInitStatus");
	if (fwdAttrInitStatusAttr == NULL)
	{
	}

	//	Attribute : centralLoggerEnabled - Check if not concrete in inherited class
	Tango::Attr *centralLoggerEnabledAttr = get_attr_object_by_name(att_list, "centralLoggerEnabled");
	if (centralLoggerEnabledAttr == NULL)
	{
	}

	//	Attribute : elementLoggerEnabled - Check if not concrete in inherited class
	Tango::Attr *elementLoggerEnabledAttr = get_attr_object_by_name(att_list, "elementLoggerEnabled");
	if (elementLoggerEnabledAttr == NULL)
	{
	}

	//	Attribute : storageLoggerEnabled - Check if not concrete in inherited class
	Tango::Attr *storageLoggerEnabledAttr = get_attr_object_by_name(att_list, "storageLoggerEnabled");
	if (storageLoggerEnabledAttr == NULL)
	{
	}

	//	Attribute : loggingTargetCentral - Check if not concrete in inherited class
	Tango::Attr *loggingTargetCentralAttr = get_attr_object_by_name(att_list, "loggingTargetCentral");
	if (loggingTargetCentralAttr == NULL)
	{
	}

	//	Attribute : loggingTargetElement - Check if not concrete in inherited class
	Tango::Attr *loggingTargetElementAttr = get_attr_object_by_name(att_list, "loggingTargetElement");
	if (loggingTargetElementAttr == NULL)
	{
	}

	//	Attribute : loggingTargetStorage - Check if not concrete in inherited class
	Tango::Attr *loggingTargetStorageAttr = get_attr_object_by_name(att_list, "loggingTargetStorage");
	if (loggingTargetStorageAttr == NULL)
	{
	}

	//	Attribute : attrRandomizationEnabled - Check if not concrete in inherited class
	Tango::Attr *attrRandomizationEnabledAttr = get_attr_object_by_name(att_list, "attrRandomizationEnabled");
	if (attrRandomizationEnabledAttr == NULL)
	{
	}

	//	Attribute : attrRandomizationPeriod - Check if not concrete in inherited class
	Tango::Attr *attrRandomizationPeriodAttr = get_attr_object_by_name(att_list, "attrRandomizationPeriod");
	if (attrRandomizationPeriodAttr == NULL)
	{
	}

	//	Attribute : configureBandProgress
	configureBandProgressAttrib	*configurebandprogress = new configureBandProgressAttrib();
	Tango::UserDefaultAttrProp	configurebandprogress_prop;
	//	description	not set for configureBandProgress
	//	label	not set for configureBandProgress
	//	unit	not set for configureBandProgress
	//	standard_unit	not set for configureBandProgress
	//	display_unit	not set for configureBandProgress
	//	format	not set for configureBandProgress
	//	max_value	not set for configureBandProgress
	//	min_value	not set for configureBandProgress
	//	max_alarm	not set for configureBandProgress
	//	min_alarm	not set for configureBandProgress
	//	max_warning	not set for configureBandProgress
	//	min_warning	not set for configureBandProgress
	//	delta_t	not set for configureBandProgress
	//	delta_val	not set for configureBandProgress
	configurebandprogress_prop.set_event_period("10000");
	
	configurebandprogress->set_default_properties(configurebandprogress_prop);
	configurebandprogress->set_polling_period(3000);
	configurebandprogress->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	configurebandprogress->set_change_event(true, false);
	att_list.push_back(configurebandprogress);

	//	Attribute : firmware0UpdateProgress
	firmware0UpdateProgressAttrib	*firmware0updateprogress = new firmware0UpdateProgressAttrib();
	Tango::UserDefaultAttrProp	firmware0updateprogress_prop;
	firmware0updateprogress_prop.set_description("Firmware update command status progress.  Will indicate the progress of a firmware update to update the FPGA firmware code at the designated location.\n\n[0]: status label {?COMPLETED?,?RUNNING?,?FAILED?,...}\n[1] : Firmware location { ?0?, ?1?, ?2?, ?3? }\n[2]: Firmware version information\n[3]: Informational information regarding status.");
	//	label	not set for firmware0UpdateProgress
	//	unit	not set for firmware0UpdateProgress
	//	standard_unit	not set for firmware0UpdateProgress
	//	display_unit	not set for firmware0UpdateProgress
	//	format	not set for firmware0UpdateProgress
	//	max_value	not set for firmware0UpdateProgress
	//	min_value	not set for firmware0UpdateProgress
	//	max_alarm	not set for firmware0UpdateProgress
	//	min_alarm	not set for firmware0UpdateProgress
	//	max_warning	not set for firmware0UpdateProgress
	//	min_warning	not set for firmware0UpdateProgress
	//	delta_t	not set for firmware0UpdateProgress
	//	delta_val	not set for firmware0UpdateProgress
	firmware0updateprogress_prop.set_event_period("3000");
	firmware0updateprogress_prop.set_archive_event_period("3000");
	
	firmware0updateprogress->set_default_properties(firmware0updateprogress_prop);
	firmware0updateprogress->set_polling_period(3000);
	firmware0updateprogress->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	firmware0updateprogress->set_change_event(true, false);
	firmware0updateprogress->set_archive_event(true, false);
	att_list.push_back(firmware0updateprogress);

	//	Attribute : firmware1UpdateProgress
	firmware1UpdateProgressAttrib	*firmware1updateprogress = new firmware1UpdateProgressAttrib();
	Tango::UserDefaultAttrProp	firmware1updateprogress_prop;
	firmware1updateprogress_prop.set_description(".Firmware update command status progress.  Will indicate the progress of a firmware update to update the FPGA firmware code at the designated location.\n\n[0]: status label {?COMPLETED?,?RUNNING?,?FAILED?,...}\n[1] : Firmware location { ?0?, ?1?, ?2?, ?3? }\n[2]: Firmware version information\n[3]: Informational information regarding status.");
	//	label	not set for firmware1UpdateProgress
	//	unit	not set for firmware1UpdateProgress
	//	standard_unit	not set for firmware1UpdateProgress
	//	display_unit	not set for firmware1UpdateProgress
	//	format	not set for firmware1UpdateProgress
	//	max_value	not set for firmware1UpdateProgress
	//	min_value	not set for firmware1UpdateProgress
	//	max_alarm	not set for firmware1UpdateProgress
	//	min_alarm	not set for firmware1UpdateProgress
	//	max_warning	not set for firmware1UpdateProgress
	//	min_warning	not set for firmware1UpdateProgress
	//	delta_t	not set for firmware1UpdateProgress
	//	delta_val	not set for firmware1UpdateProgress
	firmware1updateprogress_prop.set_event_period("3000");
	firmware1updateprogress_prop.set_archive_event_period("3000");
	
	firmware1updateprogress->set_default_properties(firmware1updateprogress_prop);
	firmware1updateprogress->set_polling_period(3000);
	firmware1updateprogress->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	firmware1updateprogress->set_change_event(true, false);
	firmware1updateprogress->set_archive_event(true, false);
	att_list.push_back(firmware1updateprogress);

	//	Attribute : firmware2UpdateProgress
	firmware2UpdateProgressAttrib	*firmware2updateprogress = new firmware2UpdateProgressAttrib();
	Tango::UserDefaultAttrProp	firmware2updateprogress_prop;
	firmware2updateprogress_prop.set_description("Firmware update command status progress.  Will indicate the progress of a firmware update to update the FPGA firmware code at the designated location.\n\n[0]: status label {?COMPLETED?,?RUNNING?,?FAILED?,...}\n[1] : Firmware location { ?0?, ?1?, ?2?, ?3? }\n[2]: Firmware version information\n[3]: Informational information regarding status.");
	//	label	not set for firmware2UpdateProgress
	//	unit	not set for firmware2UpdateProgress
	//	standard_unit	not set for firmware2UpdateProgress
	//	display_unit	not set for firmware2UpdateProgress
	//	format	not set for firmware2UpdateProgress
	//	max_value	not set for firmware2UpdateProgress
	//	min_value	not set for firmware2UpdateProgress
	//	max_alarm	not set for firmware2UpdateProgress
	//	min_alarm	not set for firmware2UpdateProgress
	//	max_warning	not set for firmware2UpdateProgress
	//	min_warning	not set for firmware2UpdateProgress
	//	delta_t	not set for firmware2UpdateProgress
	//	delta_val	not set for firmware2UpdateProgress
	firmware2updateprogress_prop.set_event_period("3000");
	firmware2updateprogress_prop.set_archive_event_period("3000");
	
	firmware2updateprogress->set_default_properties(firmware2updateprogress_prop);
	firmware2updateprogress->set_polling_period(3000);
	firmware2updateprogress->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	firmware2updateprogress->set_change_event(true, false);
	firmware2updateprogress->set_archive_event(true, false);
	att_list.push_back(firmware2updateprogress);

	//	Attribute : firmware3UpdateProgress
	firmware3UpdateProgressAttrib	*firmware3updateprogress = new firmware3UpdateProgressAttrib();
	Tango::UserDefaultAttrProp	firmware3updateprogress_prop;
	firmware3updateprogress_prop.set_description("Firmware update command status progress.  Will indicate the progress of a firmware update to update the FPGA firmware code at the designated location.\n\n[0]: status label {?COMPLETED?,?RUNNING?,?FAILED?,...}\n[1] : Firmware location { ?0?, ?1?, ?2?, ?3? }\n[2]: Firmware version information\n[3]: Informational information regarding status.");
	//	label	not set for firmware3UpdateProgress
	//	unit	not set for firmware3UpdateProgress
	//	standard_unit	not set for firmware3UpdateProgress
	//	display_unit	not set for firmware3UpdateProgress
	//	format	not set for firmware3UpdateProgress
	//	max_value	not set for firmware3UpdateProgress
	//	min_value	not set for firmware3UpdateProgress
	//	max_alarm	not set for firmware3UpdateProgress
	//	min_alarm	not set for firmware3UpdateProgress
	//	max_warning	not set for firmware3UpdateProgress
	//	min_warning	not set for firmware3UpdateProgress
	//	delta_t	not set for firmware3UpdateProgress
	//	delta_val	not set for firmware3UpdateProgress
	firmware3updateprogress_prop.set_event_period("3000");
	firmware3updateprogress_prop.set_archive_event_period("3000");
	
	firmware3updateprogress->set_default_properties(firmware3updateprogress_prop);
	firmware3updateprogress->set_polling_period(3000);
	firmware3updateprogress->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	firmware3updateprogress->set_change_event(true, false);
	firmware3updateprogress->set_archive_event(true, false);
	att_list.push_back(firmware3updateprogress);


	//	Create a list of static attributes
	create_static_attribute_list(get_class_attr()->get_attr_list());
	/*----- PROTECTED REGION ID(RxEmulatorClass::attribute_factory_after) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	RxEmulatorClass::attribute_factory_after
}
//--------------------------------------------------------
/**
 *	Method      : RxEmulatorClass::pipe_factory()
 *	Description : Create the pipe object(s)
 *                and store them in the pipe list
 */
//--------------------------------------------------------
void RxEmulatorClass::pipe_factory()
{
	/*----- PROTECTED REGION ID(RxEmulatorClass::pipe_factory_before) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	RxEmulatorClass::pipe_factory_before
	/*----- PROTECTED REGION ID(RxEmulatorClass::pipe_factory_after) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	RxEmulatorClass::pipe_factory_after
}
//--------------------------------------------------------
/**
 *	Method      : RxEmulatorClass::command_factory()
 *	Description : Create the command object(s)
 *                and store them in the command list
 */
//--------------------------------------------------------
void RxEmulatorClass::command_factory()
{
	/*----- PROTECTED REGION ID(RxEmulatorClass::command_factory_before) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	RxEmulatorClass::command_factory_before
	//	Call command_factory for inherited class
	LMCDevice_ns::LMCDeviceClass::command_factory();




	//	Command Synchronise
	SynchroniseClass	*pSynchroniseCmd =
		new SynchroniseClass("Synchronise",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pSynchroniseCmd);

	//	Command ConfigureBand
	ConfigureBandClass	*pConfigureBandCmd =
		new ConfigureBandClass("ConfigureBand",
			Tango::DEV_SHORT, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pConfigureBandCmd);

	//	Command ConfigureBand1
	ConfigureBand1Class	*pConfigureBand1Cmd =
		new ConfigureBand1Class("ConfigureBand1",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pConfigureBand1Cmd);

	//	Command ConfigureBand2
	ConfigureBand2Class	*pConfigureBand2Cmd =
		new ConfigureBand2Class("ConfigureBand2",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pConfigureBand2Cmd);

	//	Command ConfigureBand3
	ConfigureBand3Class	*pConfigureBand3Cmd =
		new ConfigureBand3Class("ConfigureBand3",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pConfigureBand3Cmd);

	//	Command ConfigureBand4
	ConfigureBand4Class	*pConfigureBand4Cmd =
		new ConfigureBand4Class("ConfigureBand4",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pConfigureBand4Cmd);

	//	Command ConfigureBand5a
	ConfigureBand5aClass	*pConfigureBand5aCmd =
		new ConfigureBand5aClass("ConfigureBand5a",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pConfigureBand5aCmd);

	//	Command ConfigureBand5b
	ConfigureBand5bClass	*pConfigureBand5bCmd =
		new ConfigureBand5bClass("ConfigureBand5b",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pConfigureBand5bCmd);

	//	Command ConfigureBandAsync
	ConfigureBandAsyncClass	*pConfigureBandAsyncCmd =
		new ConfigureBandAsyncClass("ConfigureBandAsync",
			Tango::DEV_SHORT, Tango::DEVVAR_LONGSTRINGARRAY,
			"Band id",
			"",
			Tango::OPERATOR);
	command_list.push_back(pConfigureBandAsyncCmd);

	//	Command CaptureData
	CaptureDataClass	*pCaptureDataCmd =
		new CaptureDataClass("CaptureData",
			Tango::DEV_BOOLEAN, Tango::DEV_VOID,
			"Flag value start/stop (0/1)",
			"",
			Tango::EXPERT);
	command_list.push_back(pCaptureDataCmd);

	//	Command SetSubElementMode
	SetSubElementModeClass	*pSetSubElementModeCmd =
		new SetSubElementModeClass("SetSubElementMode",
			Tango::DEV_SHORT, Tango::DEV_VOID,
			"Operational mode \n{Data_Capture | Standby_FP | Standby_LP | Maintenance}",
			"",
			Tango::OPERATOR);
	command_list.push_back(pSetSubElementModeCmd);



	//	Command SetSubElementModeStr
	SetSubElementModeStrClass	*pSetSubElementModeStrCmd =
		new SetSubElementModeStrClass("SetSubElementModeStr",
			Tango::DEV_STRING, Tango::DEV_VOID,
			"Requested mode. Allowed values are:\n\n{``STANDBY-LP``,``STANDBY-FP``,``DATA-CAPTURE``,``MAINTENANCE``}",
			"",
			Tango::OPERATOR);
	command_list.push_back(pSetSubElementModeStrCmd);

	//	Command SetStandbyLPMode
	SetStandbyLPModeClass	*pSetStandbyLPModeCmd =
		new SetStandbyLPModeClass("SetStandbyLPMode",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pSetStandbyLPModeCmd);

	//	Command SetStandbyFPMode
	SetStandbyFPModeClass	*pSetStandbyFPModeCmd =
		new SetStandbyFPModeClass("SetStandbyFPMode",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pSetStandbyFPModeCmd);

	//	Command SetMaintenanceMode
	SetMaintenanceModeClass	*pSetMaintenanceModeCmd =
		new SetMaintenanceModeClass("SetMaintenanceMode",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pSetMaintenanceModeCmd);
























	//	Command EnableEngineeringMode
	EnableEngineeringModeClass	*pEnableEngineeringModeCmd =
		new EnableEngineeringModeClass("EnableEngineeringMode",
			Tango::DEV_BOOLEAN, Tango::DEV_VOID,
			"Ture to enable engineering mode.  False to return to regular operations mode.",
			"",
			Tango::OPERATOR);
	command_list.push_back(pEnableEngineeringModeCmd);

	//	Command UpdateFirmware
	UpdateFirmwareClass	*pUpdateFirmwareCmd =
		new UpdateFirmwareClass("UpdateFirmware",
			Tango::DEV_SHORT, Tango::DEV_VOID,
			"Firmware Position to Update",
			"",
			Tango::OPERATOR);
	command_list.push_back(pUpdateFirmwareCmd);

	//	Command SetHighPowerState
	SetHighPowerStateClass	*pSetHighPowerStateCmd =
		new SetHighPowerStateClass("SetHighPowerState",
			Tango::DEV_BOOLEAN, Tango::DEV_VOID,
			"",
			"",
			Tango::EXPERT);
	command_list.push_back(pSetHighPowerStateCmd);

	//	Command AdjustPolHAttenuation
	AdjustPolHAttenuationClass	*pAdjustPolHAttenuationCmd =
		new AdjustPolHAttenuationClass("AdjustPolHAttenuation",
			Tango::DEV_FLOAT, Tango::DEV_VOID,
			"attenuationOffset",
			"",
			Tango::EXPERT);
	command_list.push_back(pAdjustPolHAttenuationCmd);

	//	Command AdjustPolVAttenuation
	AdjustPolVAttenuationClass	*pAdjustPolVAttenuationCmd =
		new AdjustPolVAttenuationClass("AdjustPolVAttenuation",
			Tango::DEV_FLOAT, Tango::DEV_VOID,
			"attenuationOffset",
			"",
			Tango::EXPERT);
	command_list.push_back(pAdjustPolVAttenuationCmd);


	//	Command Shutdown
	ShutdownClass	*pShutdownCmd =
		new ShutdownClass("Shutdown",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pShutdownCmd);


	/*----- PROTECTED REGION ID(RxEmulatorClass::command_factory_after) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	RxEmulatorClass::command_factory_after
}

//===================================================================
//	Dynamic attributes related methods
//===================================================================

//--------------------------------------------------------
/**
 * method : 		RxEmulatorClass::create_static_attribute_list
 * description : 	Create the a list of static attributes
 *
 * @param	att_list	the ceated attribute list
 */
//--------------------------------------------------------
void RxEmulatorClass::create_static_attribute_list(vector<Tango::Attr *> &att_list)
{
	for (unsigned long i=0 ; i<att_list.size() ; i++)
	{
		string att_name(att_list[i]->get_name());
		transform(att_name.begin(), att_name.end(), att_name.begin(), ::tolower);
		defaultAttList.push_back(att_name);
	}

	cout2 << defaultAttList.size() << " attributes in default list" << endl;

	/*----- PROTECTED REGION ID(RxEmulatorClass::create_static_att_list) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	RxEmulatorClass::create_static_att_list
}


//--------------------------------------------------------
/**
 * method : 		RxEmulatorClass::erase_dynamic_attributes
 * description : 	delete the dynamic attributes if any.
 *
 * @param	devlist_ptr	the device list pointer
 * @param	list of all attributes
 */
//--------------------------------------------------------
void RxEmulatorClass::erase_dynamic_attributes(const Tango::DevVarStringArray *devlist_ptr, vector<Tango::Attr *> &att_list)
{
	Tango::Util *tg = Tango::Util::instance();

	for (unsigned long i=0 ; i<devlist_ptr->length() ; i++)
	{
		Tango::DeviceImpl *dev_impl = tg->get_device_by_name(((string)(*devlist_ptr)[i]).c_str());
		RxEmulator *dev = static_cast<RxEmulator *> (dev_impl);

		vector<Tango::Attribute *> &dev_att_list = dev->get_device_attr()->get_attribute_list();
		vector<Tango::Attribute *>::iterator ite_att;
		for (ite_att=dev_att_list.begin() ; ite_att != dev_att_list.end() ; ++ite_att)
		{
			string att_name((*ite_att)->get_name_lower());
			if ((att_name == "state") || (att_name == "status"))
				continue;
			vector<string>::iterator ite_str = find(defaultAttList.begin(), defaultAttList.end(), att_name);
			if (ite_str == defaultAttList.end())
			{
				cout2 << att_name << " is a UNWANTED dynamic attribute for device " << (*devlist_ptr)[i] << endl;
				Tango::Attribute &att = dev->get_device_attr()->get_attr_by_name(att_name.c_str());
				dev->remove_attribute(att_list[att.get_attr_idx()], true, false);
				--ite_att;
			}
		}
	}
	/*----- PROTECTED REGION ID(RxEmulatorClass::erase_dynamic_attributes) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	RxEmulatorClass::erase_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Method      : RxEmulatorClass::get_attr_by_name()
 *	Description : returns Tango::Attr * object found by name
 */
//--------------------------------------------------------
Tango::Attr *RxEmulatorClass::get_attr_object_by_name(vector<Tango::Attr *> &att_list, string attname)
{
	vector<Tango::Attr *>::iterator it;
	for (it=att_list.begin() ; it<att_list.end() ; ++it)
		if ((*it)->get_name()==attname)
			return (*it);
	//	Attr does not exist
	return NULL;
}


/*----- PROTECTED REGION ID(RxEmulatorClass::Additional Methods) ENABLED START -----*/

/*----- PROTECTED REGION END -----*/	//	RxEmulatorClass::Additional Methods
} //	namespace
