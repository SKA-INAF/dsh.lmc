/*----- PROTECTED REGION ID(SPFEmulator.cpp) ENABLED START -----*/
static const char *RcsId = "$Id:  $";

// **************************************************************************
// * License and Disclaimer                                                 *
// *                                                                        *
// * Copyright 2016 Simone Riggi																			      *
// *																																	      *
// * This file is part of SKA DSH.LMC 																		  *
// * SKA DSH.LMC is free software: you can redistribute it and/or modify it *
// * under the terms of the GNU General Public License as published by      *
// * the Free Software Foundation, either * version 3 of the License,       * 
// * or (at your option) any later version.                                 * 
// * DSH.LMC is distributed in the hope that it will be useful, but 			  *
// * WITHOUT ANY WARRANTY; without even the implied warranty of             * 
// * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                   *
// * See the GNU General Public License for more details. You should        * 
// * have received a copy of the GNU General Public License along with      * 
// * DSH.LMC. If not, see http://www.gnu.org/licenses/.                     *
// **************************************************************************

//=============================================================================
//
// file :        SPFEmulator.cpp
//
// description : C++ source for the SPFEmulator class and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               SPFEmulator are implemented in this file.
//
// project :     SPFEmulator
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
// $Author:  $
//
// $Revision:  $
// $Date:  $
//
// $HeadURL:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <SPFEmulator.h>
#include <SPFEmulatorClass.h>

#include <TangoUtils.h>

#include <map>
#include <utility>

/*----- PROTECTED REGION END -----*/	//	SPFEmulator.cpp

/**
 *  SPFEmulator class description:
 *    Device server to emulate SPF-LMC interface
 */

//================================================================
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name                        |  Method name
//================================================================
//  State                               |  Inherited (no method)
//  Status                              |  Inherited (no method)
//  InitializeLoggers                   |  Inherited (no method)
//  InitializeFwdAttrs                  |  Inherited (no method)
//  RandomizeDynAttrs                   |  Inherited (no method)
//  InitializeDevProxies                |  Inherited (no method)
//  SetLNAHPowerState                   |  set_lnahpower_state
//  SetLNAVPowerState                   |  set_lnavpower_state
//  SetAmp2HPowerState                  |  set_amp2_hpower_state
//  SetAmp2VPowerState                  |  set_amp2_vpower_state
//  SetRFE1TempSetPoint                 |  set_rfe1_temp_set_point
//  SetRFE2TempCntrState                |  set_rfe2_temp_cntr_state
//  SetCryoMotorState                   |  set_cryo_motor_state
//  SetCryoMotorSpeed                   |  set_cryo_motor_speed
//  SetVaValveState                     |  set_va_valve_state
//  SetSubElementMode                   |  set_sub_element_mode
//  SetFeedMode                         |  set_feed_mode
//  SendFeedCommand                     |  send_feed_command
//  SetVacuumMode                       |  set_vacuum_mode
//  SendVacuumCommand                   |  send_vacuum_command
//  SetHeliumMode                       |  set_helium_mode
//  SendHeliumCommand                   |  send_helium_command
//  SetMCStartState                     |  set_mcstart_state
//  SetStandbyLPMode                    |  set_standby_lpmode
//  SetOperateMode                      |  set_operate_mode
//  SetMaintenanceMode                  |  set_maintenance_mode
//  GetRegisteredProxies                |  Inherited (no method)
//  GetRegisteredEvents                 |  Inherited (no method)
//  InitializeAttrFormulas              |  Inherited (no method)
//  GetRegisteredFormulas               |  Inherited (no method)
//  GetInitializedFormulas              |  Inherited (no method)
//  GetNRunningTasks                    |  Inherited (no method)
//  GetNQueuedTasks                     |  Inherited (no method)
//  GetNIdleTasks                       |  Inherited (no method)
//  GetNTasks                           |  Inherited (no method)
//  GetNFailedTasks                     |  Inherited (no method)
//  GetNTotFailedTasks                  |  Inherited (no method)
//  IsTaskQuotaReached                  |  Inherited (no method)
//  FlushTaskQueue                      |  Inherited (no method)
//  GetQueuedTaskInfo                   |  Inherited (no method)
//  GetTaskInfo                         |  Inherited (no method)
//  ClearTasks                          |  Inherited (no method)
//  SetSubElementModeStr                |  set_sub_element_mode_str
//  InitializeFormulas                  |  Inherited (no method)
//  UpdateStatusAttrs                   |  Inherited (no method)
//  MonitorProxies                      |  Inherited (no method)
//  UpdateFormulaAttrs                  |  Inherited (no method)
//  RevokeTask                          |  Inherited (no method)
//  Halt                                |  halt
//  Shutdown                            |  shutdown
//  Restart                             |  restart
//  SetFeedOperateMode                  |  set_feed_operate_mode
//  SetFeedStandbyLPMode                |  set_feed_standby_lpmode
//  SetFeedMaintenanceMode              |  set_feed_maintenance_mode
//  SetFeedClearErrorsAndRestartMode    |  set_feed_clear_errors_and_restart_mode
//  SetFeedRegenerationMode             |  set_feed_regeneration_mode
//  GetFormulaData                      |  Inherited (no method)
//  SendTestLogMsg                      |  Inherited (no method)
//  RevokeTaskSequence                  |  Inherited (no method)
//  SetCalSourceTempSetPointsToDefault  |  set_cal_source_temp_set_points_to_default
//  SetTempSetPointsToDefault           |  set_temp_set_points_to_default
//================================================================

//================================================================
//  Attributes managed are:
//================================================================
//  loggingLevelCentral                |  Tango::DevLong	Scalar
//  loggingLevelElement                |  Tango::DevLong	Scalar
//  loggingLevelStorage                |  Tango::DevLong	Scalar
//  loggingLevelConsole                |  Tango::DevLong	Scalar
//  buildState                         |  Tango::DevString	Scalar
//  centralLoggerStatus                |  Tango::DevEnum	Scalar
//  elementLoggerStatus                |  Tango::DevEnum	Scalar
//  storageLoggerStatus                |  Tango::DevEnum	Scalar
//  eventRate                          |  Tango::DevFloat	Scalar
//  exceptionRate                      |  Tango::DevFloat	Scalar
//  fwdAttrInitStatus                  |  Tango::DevEnum	Scalar
//  centralLoggerEnabled               |  Tango::DevBoolean	Scalar
//  elementLoggerEnabled               |  Tango::DevBoolean	Scalar
//  storageLoggerEnabled               |  Tango::DevBoolean	Scalar
//  loggingTargetCentral               |  Tango::DevString	Scalar
//  loggingTargetElement               |  Tango::DevString	Scalar
//  loggingTargetStorage               |  Tango::DevString	Scalar
//  attrRandomizationEnabled           |  Tango::DevBoolean	Scalar
//  attrRandomizationPeriod            |  Tango::DevULong	Scalar
//  setB1FeedOperateModeProgress       |  Tango::DevString	Spectrum  ( max = 3)
//  setB1FeedRegenerationModeProgress  |  Tango::DevString	Spectrum  ( max = 3)
//  setB2FeedOperateModeProgress       |  Tango::DevString	Spectrum  ( max = 3)
//  setB2FeedRegenerationModeProgress  |  Tango::DevString	Spectrum  ( max = 3)
//  setB3FeedOperateModeProgress       |  Tango::DevString	Spectrum  ( max = 3)
//  setB3FeedRegenerationModeProgress  |  Tango::DevString	Spectrum  ( max = 3)
//  setB4FeedOperateModeProgress       |  Tango::DevString	Spectrum  ( max = 3)
//  setB4FeedRegenerationModeProgress  |  Tango::DevString	Spectrum  ( max = 3)
//  setB5FeedOperateModeProgress       |  Tango::DevString	Spectrum  ( max = 3)
//  setB5FeedRegenerationModeProgress  |  Tango::DevString	Spectrum  ( max = 3)
//  setOperateModeProgress             |  Tango::DevString	Spectrum  ( max = 3)
//  setStandbyLPModeProgress           |  Tango::DevString	Spectrum  ( max = 3)
//  setMaintenanceModeProgress         |  Tango::DevString	Spectrum  ( max = 3)
//  setB1FeedStandbyLPModeProgress     |  Tango::DevString	Spectrum  ( max = 3)
//  setB2FeedStandbyLPModeProgress     |  Tango::DevString	Spectrum  ( max = 3)
//  setB3FeedStandbyLPModeProgress     |  Tango::DevString	Spectrum  ( max = 3)
//  setB4FeedStandbyLPModeProgress     |  Tango::DevString	Spectrum  ( max = 3)
//  setB5FeedStandbyLPModeProgress     |  Tango::DevString	Spectrum  ( max = 3)
//================================================================

namespace SPFEmulator_ns
{
/*----- PROTECTED REGION ID(SPFEmulator::namespace_starting) ENABLED START -----*/

//	static initializations

/*----- PROTECTED REGION END -----*/	//	SPFEmulator::namespace_starting

//--------------------------------------------------------
/**
 *	Method      : SPFEmulator::SPFEmulator()
 *	Description : Constructors for a Tango device
 *                implementing the classSPFEmulator
 */
//--------------------------------------------------------
SPFEmulator::SPFEmulator(Tango::DeviceClass *cl, string &s)
 : LMCDevice(cl, s.c_str())
{
	/*----- PROTECTED REGION ID(SPFEmulator::constructor_1) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::constructor_1
}
//--------------------------------------------------------
SPFEmulator::SPFEmulator(Tango::DeviceClass *cl, const char *s)
 : LMCDevice(cl, s)
{
	/*----- PROTECTED REGION ID(SPFEmulator::constructor_2) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::constructor_2
}
//--------------------------------------------------------
SPFEmulator::SPFEmulator(Tango::DeviceClass *cl, const char *s, const char *d)
 : LMCDevice(cl, s, d)
{
	/*----- PROTECTED REGION ID(SPFEmulator::constructor_3) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::constructor_3
}

//--------------------------------------------------------
/**
 *	Method      : SPFEmulator::delete_device()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void SPFEmulator::delete_device()
{
	DEBUG_STREAM << "SPFEmulator::delete_device() " << device_name << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::delete_device) ENABLED START -----*/
	
	//	Delete device allocated objects

	//## Delete allocated memory
	for(int i=0;i<3;i++){
		CORBA::string_free(*(attr_setOperateModeProgress_read+i));
		CORBA::string_free(*(attr_setStandbyLPModeProgress_read+i));
		CORBA::string_free(*(attr_setMaintenanceModeProgress_read+i));

		CORBA::string_free(*(attr_setB1FeedOperateModeProgress_read+i));
		CORBA::string_free(*(attr_setB2FeedOperateModeProgress_read+i));
		CORBA::string_free(*(attr_setB3FeedOperateModeProgress_read+i));
		CORBA::string_free(*(attr_setB4FeedOperateModeProgress_read+i));
		CORBA::string_free(*(attr_setB5FeedOperateModeProgress_read+i));
		CORBA::string_free(*(attr_setB1FeedRegenerationModeProgress_read+i));
		CORBA::string_free(*(attr_setB2FeedRegenerationModeProgress_read+i));
		CORBA::string_free(*(attr_setB3FeedRegenerationModeProgress_read+i));
		CORBA::string_free(*(attr_setB4FeedRegenerationModeProgress_read+i));
		CORBA::string_free(*(attr_setB5FeedRegenerationModeProgress_read+i));

		CORBA::string_free(*(attr_setB1FeedStandbyLPModeProgress_read+i));
		CORBA::string_free(*(attr_setB2FeedStandbyLPModeProgress_read+i));
		CORBA::string_free(*(attr_setB3FeedStandbyLPModeProgress_read+i));
		CORBA::string_free(*(attr_setB4FeedStandbyLPModeProgress_read+i));
		CORBA::string_free(*(attr_setB5FeedStandbyLPModeProgress_read+i));
	}

	//## Clear task: notify wait cond & exit
	if(ClearTask()<0){
		_ERROR_LOG("Failed to clearup task thread");
	}


	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::delete_device
	delete[] attr_setB1FeedOperateModeProgress_read;
	delete[] attr_setB1FeedRegenerationModeProgress_read;
	delete[] attr_setB2FeedOperateModeProgress_read;
	delete[] attr_setB2FeedRegenerationModeProgress_read;
	delete[] attr_setB3FeedOperateModeProgress_read;
	delete[] attr_setB3FeedRegenerationModeProgress_read;
	delete[] attr_setB4FeedOperateModeProgress_read;
	delete[] attr_setB4FeedRegenerationModeProgress_read;
	delete[] attr_setB5FeedOperateModeProgress_read;
	delete[] attr_setB5FeedRegenerationModeProgress_read;
	delete[] attr_setOperateModeProgress_read;
	delete[] attr_setStandbyLPModeProgress_read;
	delete[] attr_setMaintenanceModeProgress_read;
	delete[] attr_setB1FeedStandbyLPModeProgress_read;
	delete[] attr_setB2FeedStandbyLPModeProgress_read;
	delete[] attr_setB3FeedStandbyLPModeProgress_read;
	delete[] attr_setB4FeedStandbyLPModeProgress_read;
	delete[] attr_setB5FeedStandbyLPModeProgress_read;

	if (Tango::Util::instance()->is_svr_shutting_down()==false  &&
		Tango::Util::instance()->is_device_restarting(device_name)==false &&
		Tango::Util::instance()->is_svr_starting()==false)
	{
		//	If not shutting down call delete device for inherited object
		LMCDevice_ns::LMCDevice::delete_device();
	}
}

//--------------------------------------------------------
/**
 *	Method      : SPFEmulator::init_device()
 *	Description : will be called at device initialization.
 */
//--------------------------------------------------------
void SPFEmulator::init_device()
{
	DEBUG_STREAM << "SPFEmulator::init_device() create device " << device_name << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::init_device_before) ENABLED START -----*/
	
	//	Initialization before get_device_property() call
	
	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::init_device_before
	
	if (Tango::Util::instance()->is_svr_starting() == false  &&
		Tango::Util::instance()->is_device_restarting(device_name)==false)
	{
		//	If not starting up call init device for inherited object
		LMCDevice_ns::LMCDevice::init_device();
	}

	//	Get the device properties from database
	get_device_property();
	
	attr_setB1FeedOperateModeProgress_read = new Tango::DevString[3];
	attr_setB1FeedRegenerationModeProgress_read = new Tango::DevString[3];
	attr_setB2FeedOperateModeProgress_read = new Tango::DevString[3];
	attr_setB2FeedRegenerationModeProgress_read = new Tango::DevString[3];
	attr_setB3FeedOperateModeProgress_read = new Tango::DevString[3];
	attr_setB3FeedRegenerationModeProgress_read = new Tango::DevString[3];
	attr_setB4FeedOperateModeProgress_read = new Tango::DevString[3];
	attr_setB4FeedRegenerationModeProgress_read = new Tango::DevString[3];
	attr_setB5FeedOperateModeProgress_read = new Tango::DevString[3];
	attr_setB5FeedRegenerationModeProgress_read = new Tango::DevString[3];
	attr_setOperateModeProgress_read = new Tango::DevString[3];
	attr_setStandbyLPModeProgress_read = new Tango::DevString[3];
	attr_setMaintenanceModeProgress_read = new Tango::DevString[3];
	attr_setB1FeedStandbyLPModeProgress_read = new Tango::DevString[3];
	attr_setB2FeedStandbyLPModeProgress_read = new Tango::DevString[3];
	attr_setB3FeedStandbyLPModeProgress_read = new Tango::DevString[3];
	attr_setB4FeedStandbyLPModeProgress_read = new Tango::DevString[3];
	attr_setB5FeedStandbyLPModeProgress_read = new Tango::DevString[3];
	//	No longer if mandatory property not set. 
	if (mandatoryNotDefined)
		return;

	/*----- PROTECTED REGION ID(SPFEmulator::init_device) ENABLED START -----*/
	
	//	Initialize device
	INFO_STREAM<<"SPFEmulator::init_device() - Initializing SPFEmulator device..."<<endl;


	//## Set init device state
	set_state(Tango::INIT);
	set_status("Device " + device_name + " is initializing");
	
	//## Init attributes
	SetOperateStatus("INIT","No set OPERATE mode task commanded yet",false);
	SetStandbyLPStatus("INIT","No set STANDBY-LP mode task commanded yet",false);
	SetMaintenanceStatus("INIT","No set MAINTENANCE mode task commanded yet",false);

	int nBands= 5;
	for(int i=0;i<nBands;i++){
		SetFeedOperateStatus(i+1,"INIT","No set feed OPERATE mode task commanded yet",false);
		SetFeedRegenerationStatus(i+1,"INIT","No set feed REGENERATION mode task commanded yet",false);
		SetFeedStandbyLPStatus(i+1,"INIT","No set feed STANDBY-LP mode task commanded yet",false);
	}

	//## Initialize and start device task thread
	if(InitTask()<0){
		_ERROR_LOG("Failed to initialize and start device task!");
	}
	
	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::init_device
}

//--------------------------------------------------------
/**
 *	Method      : SPFEmulator::get_device_property()
 *	Description : Read database to initialize property data members.
 */
//--------------------------------------------------------
void SPFEmulator::get_device_property()
{
	/*----- PROTECTED REGION ID(SPFEmulator::get_device_property_before) ENABLED START -----*/
	
	//	Initialize property data members
	
	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::get_device_property_before

	mandatoryNotDefined = false;

	//	Read device properties from database.
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("CentralLoggerEnabledDefault"));
	dev_prop.push_back(Tango::DbDatum("ElementLoggerEnabledDefault"));
	dev_prop.push_back(Tango::DbDatum("StorageLoggerEnabledDefault"));
	dev_prop.push_back(Tango::DbDatum("LoggingTargetCentralDefault"));
	dev_prop.push_back(Tango::DbDatum("LoggingTargetElementDefault"));
	dev_prop.push_back(Tango::DbDatum("LoggingTargetStorageDefault"));
	dev_prop.push_back(Tango::DbDatum("SkaLevel"));
	dev_prop.push_back(Tango::DbDatum("SyslogFacility"));
	dev_prop.push_back(Tango::DbDatum("SyslogHost"));
	dev_prop.push_back(Tango::DbDatum("LoggingLevelCentralDefault"));
	dev_prop.push_back(Tango::DbDatum("LoggingLevelElementDefault"));
	dev_prop.push_back(Tango::DbDatum("LoggingLevelStorageDefault"));
	dev_prop.push_back(Tango::DbDatum("ConfigFile"));
	dev_prop.push_back(Tango::DbDatum("EnableConfigFromFile"));
	dev_prop.push_back(Tango::DbDatum("EnableDynAttrCleanup"));
	dev_prop.push_back(Tango::DbDatum("EnableDynAttrRandomize"));
	dev_prop.push_back(Tango::DbDatum("DynAttrRandomizePeriod"));
	dev_prop.push_back(Tango::DbDatum("ProxyDevices"));
	dev_prop.push_back(Tango::DbDatum("StartupTime"));
	dev_prop.push_back(Tango::DbDatum("GoOperationalTime"));
	dev_prop.push_back(Tango::DbDatum("EnableStartupFailure"));
	dev_prop.push_back(Tango::DbDatum("StartupFailureProbability"));
	dev_prop.push_back(Tango::DbDatum("EnableOperationalFailure"));
	dev_prop.push_back(Tango::DbDatum("OperationalFailureProbability"));
	dev_prop.push_back(Tango::DbDatum("EnableAutoStartup"));
	dev_prop.push_back(Tango::DbDatum("FormulaVarMaxTimeInterval"));
	dev_prop.push_back(Tango::DbDatum("EnableProxyMonitoring"));
	dev_prop.push_back(Tango::DbDatum("ProxyMonitoringPeriod"));
	dev_prop.push_back(Tango::DbDatum("ProxyStatusAttrPollPeriod"));
	dev_prop.push_back(Tango::DbDatum("ProxyStatusAttrPeriodicEventPeriod"));
	dev_prop.push_back(Tango::DbDatum("ProxyStatusAttrArchiveEventPeriod"));
	dev_prop.push_back(Tango::DbDatum("ProxyTimeout"));
	dev_prop.push_back(Tango::DbDatum("EventSubscriptions"));
	dev_prop.push_back(Tango::DbDatum("EventHandlers"));
	dev_prop.push_back(Tango::DbDatum("MaxQueueableTask"));
	dev_prop.push_back(Tango::DbDatum("MaxTrackableTasks"));
	dev_prop.push_back(Tango::DbDatum("TaskHistoryTimeDepth"));
	dev_prop.push_back(Tango::DbDatum("DefaultTaskTimeout"));
	dev_prop.push_back(Tango::DbDatum("TaskSequenceStatusAttrList"));
	dev_prop.push_back(Tango::DbDatum("TaskStatusAttrList"));
	dev_prop.push_back(Tango::DbDatum("EnableEventRateMonitoring"));
	dev_prop.push_back(Tango::DbDatum("GoStandbyLPTime"));
	dev_prop.push_back(Tango::DbDatum("GoMaintenanceTime"));
	dev_prop.push_back(Tango::DbDatum("EnableStandbyLPFailure"));
	dev_prop.push_back(Tango::DbDatum("StandbyLPFailureProbability"));
	dev_prop.push_back(Tango::DbDatum("EnableMaintenanceFailure"));
	dev_prop.push_back(Tango::DbDatum("MaintenanceFailureProbability"));
	dev_prop.push_back(Tango::DbDatum("EnableLoggerInitPolling"));
	dev_prop.push_back(Tango::DbDatum("LoggerInitPollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableDevProxyInitPolling"));
	dev_prop.push_back(Tango::DbDatum("DevProxyInitPollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableFwdAttrInitPolling"));
	dev_prop.push_back(Tango::DbDatum("FwdAttrInitPollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableFormulaAttrUpdatePolling"));
	dev_prop.push_back(Tango::DbDatum("FormulaAttrUpdatePollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableStatusAttrUpdatePolling"));
	dev_prop.push_back(Tango::DbDatum("StatusAttrUpdatePollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableClearTaskPolling"));
	dev_prop.push_back(Tango::DbDatum("ClearTaskPollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableProxyStatusAttrCreation"));
	dev_prop.push_back(Tango::DbDatum("EnableAutoAdminProxyRegistration"));
	dev_prop.push_back(Tango::DbDatum("ProcessEventsInQueueThread"));
	dev_prop.push_back(Tango::DbDatum("Rfe1TempSetPointDefault"));
	dev_prop.push_back(Tango::DbDatum("CalSourceTempSetPointDefault"));
	dev_prop.push_back(Tango::DbDatum("Rfe2TempSetPointDefault"));
	dev_prop.push_back(Tango::DbDatum("ExpectedOnlineDefault"));

	//	is there at least one property to be read ?
	if (dev_prop.size()>0)
	{
		//	Call database and extract values
		if (Tango::Util::instance()->_UseDb==true)
			get_db_device()->get_property(dev_prop);
	
		//	get instance on SPFEmulatorClass to get class property
		Tango::DbDatum	def_prop, cl_prop;
		SPFEmulatorClass	*ds_class =
			(static_cast<SPFEmulatorClass *>(get_device_class()));
		int	i = -1;

		//	Try to initialize CentralLoggerEnabledDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  centralLoggerEnabledDefault;
		else {
			//	Try to initialize CentralLoggerEnabledDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  centralLoggerEnabledDefault;
		}
		//	And try to extract CentralLoggerEnabledDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  centralLoggerEnabledDefault;

		//	Try to initialize ElementLoggerEnabledDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  elementLoggerEnabledDefault;
		else {
			//	Try to initialize ElementLoggerEnabledDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  elementLoggerEnabledDefault;
		}
		//	And try to extract ElementLoggerEnabledDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  elementLoggerEnabledDefault;

		//	Try to initialize StorageLoggerEnabledDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  storageLoggerEnabledDefault;
		else {
			//	Try to initialize StorageLoggerEnabledDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  storageLoggerEnabledDefault;
		}
		//	And try to extract StorageLoggerEnabledDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  storageLoggerEnabledDefault;

		//	Try to initialize LoggingTargetCentralDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingTargetCentralDefault;
		else {
			//	Try to initialize LoggingTargetCentralDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingTargetCentralDefault;
		}
		//	And try to extract LoggingTargetCentralDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingTargetCentralDefault;

		//	Try to initialize LoggingTargetElementDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingTargetElementDefault;
		else {
			//	Try to initialize LoggingTargetElementDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingTargetElementDefault;
		}
		//	And try to extract LoggingTargetElementDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingTargetElementDefault;

		//	Try to initialize LoggingTargetStorageDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingTargetStorageDefault;
		else {
			//	Try to initialize LoggingTargetStorageDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingTargetStorageDefault;
		}
		//	And try to extract LoggingTargetStorageDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingTargetStorageDefault;

		//	Try to initialize SkaLevel from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  skaLevel;
		else {
			//	Try to initialize SkaLevel from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  skaLevel;
		}
		//	And try to extract SkaLevel value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  skaLevel;

		//	Try to initialize SyslogFacility from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  syslogFacility;
		else {
			//	Try to initialize SyslogFacility from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  syslogFacility;
		}
		//	And try to extract SyslogFacility value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  syslogFacility;

		//	Try to initialize SyslogHost from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  syslogHost;
		else {
			//	Try to initialize SyslogHost from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  syslogHost;
		}
		//	And try to extract SyslogHost value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  syslogHost;

		//	Try to initialize LoggingLevelCentralDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingLevelCentralDefault;
		else {
			//	Try to initialize LoggingLevelCentralDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingLevelCentralDefault;
		}
		//	And try to extract LoggingLevelCentralDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingLevelCentralDefault;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize LoggingLevelElementDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingLevelElementDefault;
		else {
			//	Try to initialize LoggingLevelElementDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingLevelElementDefault;
		}
		//	And try to extract LoggingLevelElementDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingLevelElementDefault;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize LoggingLevelStorageDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingLevelStorageDefault;
		else {
			//	Try to initialize LoggingLevelStorageDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingLevelStorageDefault;
		}
		//	And try to extract LoggingLevelStorageDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingLevelStorageDefault;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize ConfigFile from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  configFile;
		else {
			//	Try to initialize ConfigFile from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  configFile;
		}
		//	And try to extract ConfigFile value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  configFile;

		//	Try to initialize EnableConfigFromFile from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableConfigFromFile;
		else {
			//	Try to initialize EnableConfigFromFile from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableConfigFromFile;
		}
		//	And try to extract EnableConfigFromFile value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableConfigFromFile;

		//	Try to initialize EnableDynAttrCleanup from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableDynAttrCleanup;
		else {
			//	Try to initialize EnableDynAttrCleanup from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableDynAttrCleanup;
		}
		//	And try to extract EnableDynAttrCleanup value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableDynAttrCleanup;

		//	Try to initialize EnableDynAttrRandomize from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableDynAttrRandomize;
		else {
			//	Try to initialize EnableDynAttrRandomize from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableDynAttrRandomize;
		}
		//	And try to extract EnableDynAttrRandomize value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableDynAttrRandomize;

		//	Try to initialize DynAttrRandomizePeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  dynAttrRandomizePeriod;
		else {
			//	Try to initialize DynAttrRandomizePeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  dynAttrRandomizePeriod;
		}
		//	And try to extract DynAttrRandomizePeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  dynAttrRandomizePeriod;

		//	Try to initialize ProxyDevices from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyDevices;
		else {
			//	Try to initialize ProxyDevices from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyDevices;
		}
		//	And try to extract ProxyDevices value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyDevices;

		//	Try to initialize StartupTime from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  startupTime;
		else {
			//	Try to initialize StartupTime from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  startupTime;
		}
		//	And try to extract StartupTime value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  startupTime;

		//	Try to initialize GoOperationalTime from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  goOperationalTime;
		else {
			//	Try to initialize GoOperationalTime from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  goOperationalTime;
		}
		//	And try to extract GoOperationalTime value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  goOperationalTime;

		//	Try to initialize EnableStartupFailure from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableStartupFailure;
		else {
			//	Try to initialize EnableStartupFailure from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableStartupFailure;
		}
		//	And try to extract EnableStartupFailure value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableStartupFailure;

		//	Try to initialize StartupFailureProbability from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  startupFailureProbability;
		else {
			//	Try to initialize StartupFailureProbability from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  startupFailureProbability;
		}
		//	And try to extract StartupFailureProbability value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  startupFailureProbability;

		//	Try to initialize EnableOperationalFailure from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableOperationalFailure;
		else {
			//	Try to initialize EnableOperationalFailure from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableOperationalFailure;
		}
		//	And try to extract EnableOperationalFailure value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableOperationalFailure;

		//	Try to initialize OperationalFailureProbability from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  operationalFailureProbability;
		else {
			//	Try to initialize OperationalFailureProbability from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  operationalFailureProbability;
		}
		//	And try to extract OperationalFailureProbability value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  operationalFailureProbability;

		//	Try to initialize EnableAutoStartup from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableAutoStartup;
		else {
			//	Try to initialize EnableAutoStartup from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableAutoStartup;
		}
		//	And try to extract EnableAutoStartup value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableAutoStartup;

		//	Try to initialize FormulaVarMaxTimeInterval from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  formulaVarMaxTimeInterval;
		else {
			//	Try to initialize FormulaVarMaxTimeInterval from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  formulaVarMaxTimeInterval;
		}
		//	And try to extract FormulaVarMaxTimeInterval value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  formulaVarMaxTimeInterval;

		//	Try to initialize EnableProxyMonitoring from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableProxyMonitoring;
		else {
			//	Try to initialize EnableProxyMonitoring from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableProxyMonitoring;
		}
		//	And try to extract EnableProxyMonitoring value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableProxyMonitoring;

		//	Try to initialize ProxyMonitoringPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyMonitoringPeriod;
		else {
			//	Try to initialize ProxyMonitoringPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyMonitoringPeriod;
		}
		//	And try to extract ProxyMonitoringPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyMonitoringPeriod;

		//	Try to initialize ProxyStatusAttrPollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyStatusAttrPollPeriod;
		else {
			//	Try to initialize ProxyStatusAttrPollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyStatusAttrPollPeriod;
		}
		//	And try to extract ProxyStatusAttrPollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyStatusAttrPollPeriod;

		//	Try to initialize ProxyStatusAttrPeriodicEventPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyStatusAttrPeriodicEventPeriod;
		else {
			//	Try to initialize ProxyStatusAttrPeriodicEventPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyStatusAttrPeriodicEventPeriod;
		}
		//	And try to extract ProxyStatusAttrPeriodicEventPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyStatusAttrPeriodicEventPeriod;

		//	Try to initialize ProxyStatusAttrArchiveEventPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyStatusAttrArchiveEventPeriod;
		else {
			//	Try to initialize ProxyStatusAttrArchiveEventPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyStatusAttrArchiveEventPeriod;
		}
		//	And try to extract ProxyStatusAttrArchiveEventPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyStatusAttrArchiveEventPeriod;

		//	Try to initialize ProxyTimeout from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyTimeout;
		else {
			//	Try to initialize ProxyTimeout from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyTimeout;
		}
		//	And try to extract ProxyTimeout value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyTimeout;

		//	Try to initialize EventSubscriptions from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  eventSubscriptions;
		else {
			//	Try to initialize EventSubscriptions from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  eventSubscriptions;
		}
		//	And try to extract EventSubscriptions value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  eventSubscriptions;

		//	Try to initialize EventHandlers from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  eventHandlers;
		else {
			//	Try to initialize EventHandlers from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  eventHandlers;
		}
		//	And try to extract EventHandlers value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  eventHandlers;

		//	Try to initialize MaxQueueableTask from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  maxQueueableTask;
		else {
			//	Try to initialize MaxQueueableTask from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  maxQueueableTask;
		}
		//	And try to extract MaxQueueableTask value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  maxQueueableTask;

		//	Try to initialize MaxTrackableTasks from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  maxTrackableTasks;
		else {
			//	Try to initialize MaxTrackableTasks from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  maxTrackableTasks;
		}
		//	And try to extract MaxTrackableTasks value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  maxTrackableTasks;

		//	Try to initialize TaskHistoryTimeDepth from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  taskHistoryTimeDepth;
		else {
			//	Try to initialize TaskHistoryTimeDepth from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  taskHistoryTimeDepth;
		}
		//	And try to extract TaskHistoryTimeDepth value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  taskHistoryTimeDepth;

		//	Try to initialize DefaultTaskTimeout from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  defaultTaskTimeout;
		else {
			//	Try to initialize DefaultTaskTimeout from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  defaultTaskTimeout;
		}
		//	And try to extract DefaultTaskTimeout value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  defaultTaskTimeout;

		//	Try to initialize TaskSequenceStatusAttrList from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  taskSequenceStatusAttrList;
		else {
			//	Try to initialize TaskSequenceStatusAttrList from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  taskSequenceStatusAttrList;
		}
		//	And try to extract TaskSequenceStatusAttrList value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  taskSequenceStatusAttrList;

		//	Try to initialize TaskStatusAttrList from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  taskStatusAttrList;
		else {
			//	Try to initialize TaskStatusAttrList from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  taskStatusAttrList;
		}
		//	And try to extract TaskStatusAttrList value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  taskStatusAttrList;

		//	Try to initialize EnableEventRateMonitoring from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableEventRateMonitoring;
		else {
			//	Try to initialize EnableEventRateMonitoring from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableEventRateMonitoring;
		}
		//	And try to extract EnableEventRateMonitoring value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableEventRateMonitoring;

		//	Try to initialize GoStandbyLPTime from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  goStandbyLPTime;
		else {
			//	Try to initialize GoStandbyLPTime from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  goStandbyLPTime;
		}
		//	And try to extract GoStandbyLPTime value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  goStandbyLPTime;

		//	Try to initialize GoMaintenanceTime from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  goMaintenanceTime;
		else {
			//	Try to initialize GoMaintenanceTime from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  goMaintenanceTime;
		}
		//	And try to extract GoMaintenanceTime value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  goMaintenanceTime;

		//	Try to initialize EnableStandbyLPFailure from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableStandbyLPFailure;
		else {
			//	Try to initialize EnableStandbyLPFailure from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableStandbyLPFailure;
		}
		//	And try to extract EnableStandbyLPFailure value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableStandbyLPFailure;

		//	Try to initialize StandbyLPFailureProbability from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  standbyLPFailureProbability;
		else {
			//	Try to initialize StandbyLPFailureProbability from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  standbyLPFailureProbability;
		}
		//	And try to extract StandbyLPFailureProbability value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  standbyLPFailureProbability;

		//	Try to initialize EnableMaintenanceFailure from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableMaintenanceFailure;
		else {
			//	Try to initialize EnableMaintenanceFailure from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableMaintenanceFailure;
		}
		//	And try to extract EnableMaintenanceFailure value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableMaintenanceFailure;

		//	Try to initialize MaintenanceFailureProbability from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  maintenanceFailureProbability;
		else {
			//	Try to initialize MaintenanceFailureProbability from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  maintenanceFailureProbability;
		}
		//	And try to extract MaintenanceFailureProbability value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  maintenanceFailureProbability;

		//	Try to initialize EnableLoggerInitPolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableLoggerInitPolling;
		else {
			//	Try to initialize EnableLoggerInitPolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableLoggerInitPolling;
		}
		//	And try to extract EnableLoggerInitPolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableLoggerInitPolling;

		//	Try to initialize LoggerInitPollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggerInitPollPeriod;
		else {
			//	Try to initialize LoggerInitPollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggerInitPollPeriod;
		}
		//	And try to extract LoggerInitPollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggerInitPollPeriod;

		//	Try to initialize EnableDevProxyInitPolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableDevProxyInitPolling;
		else {
			//	Try to initialize EnableDevProxyInitPolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableDevProxyInitPolling;
		}
		//	And try to extract EnableDevProxyInitPolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableDevProxyInitPolling;

		//	Try to initialize DevProxyInitPollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  devProxyInitPollPeriod;
		else {
			//	Try to initialize DevProxyInitPollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  devProxyInitPollPeriod;
		}
		//	And try to extract DevProxyInitPollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  devProxyInitPollPeriod;

		//	Try to initialize EnableFwdAttrInitPolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableFwdAttrInitPolling;
		else {
			//	Try to initialize EnableFwdAttrInitPolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableFwdAttrInitPolling;
		}
		//	And try to extract EnableFwdAttrInitPolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableFwdAttrInitPolling;

		//	Try to initialize FwdAttrInitPollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  fwdAttrInitPollPeriod;
		else {
			//	Try to initialize FwdAttrInitPollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  fwdAttrInitPollPeriod;
		}
		//	And try to extract FwdAttrInitPollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  fwdAttrInitPollPeriod;

		//	Try to initialize EnableFormulaAttrUpdatePolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableFormulaAttrUpdatePolling;
		else {
			//	Try to initialize EnableFormulaAttrUpdatePolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableFormulaAttrUpdatePolling;
		}
		//	And try to extract EnableFormulaAttrUpdatePolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableFormulaAttrUpdatePolling;

		//	Try to initialize FormulaAttrUpdatePollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  formulaAttrUpdatePollPeriod;
		else {
			//	Try to initialize FormulaAttrUpdatePollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  formulaAttrUpdatePollPeriod;
		}
		//	And try to extract FormulaAttrUpdatePollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  formulaAttrUpdatePollPeriod;

		//	Try to initialize EnableStatusAttrUpdatePolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableStatusAttrUpdatePolling;
		else {
			//	Try to initialize EnableStatusAttrUpdatePolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableStatusAttrUpdatePolling;
		}
		//	And try to extract EnableStatusAttrUpdatePolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableStatusAttrUpdatePolling;

		//	Try to initialize StatusAttrUpdatePollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  statusAttrUpdatePollPeriod;
		else {
			//	Try to initialize StatusAttrUpdatePollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  statusAttrUpdatePollPeriod;
		}
		//	And try to extract StatusAttrUpdatePollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  statusAttrUpdatePollPeriod;

		//	Try to initialize EnableClearTaskPolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableClearTaskPolling;
		else {
			//	Try to initialize EnableClearTaskPolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableClearTaskPolling;
		}
		//	And try to extract EnableClearTaskPolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableClearTaskPolling;

		//	Try to initialize ClearTaskPollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  clearTaskPollPeriod;
		else {
			//	Try to initialize ClearTaskPollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  clearTaskPollPeriod;
		}
		//	And try to extract ClearTaskPollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  clearTaskPollPeriod;

		//	Try to initialize EnableProxyStatusAttrCreation from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableProxyStatusAttrCreation;
		else {
			//	Try to initialize EnableProxyStatusAttrCreation from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableProxyStatusAttrCreation;
		}
		//	And try to extract EnableProxyStatusAttrCreation value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableProxyStatusAttrCreation;

		//	Try to initialize EnableAutoAdminProxyRegistration from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableAutoAdminProxyRegistration;
		else {
			//	Try to initialize EnableAutoAdminProxyRegistration from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableAutoAdminProxyRegistration;
		}
		//	And try to extract EnableAutoAdminProxyRegistration value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableAutoAdminProxyRegistration;

		//	Try to initialize ProcessEventsInQueueThread from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  processEventsInQueueThread;
		else {
			//	Try to initialize ProcessEventsInQueueThread from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  processEventsInQueueThread;
		}
		//	And try to extract ProcessEventsInQueueThread value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  processEventsInQueueThread;

		//	Try to initialize Rfe1TempSetPointDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  rfe1TempSetPointDefault;
		else {
			//	Try to initialize Rfe1TempSetPointDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  rfe1TempSetPointDefault;
		}
		//	And try to extract Rfe1TempSetPointDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  rfe1TempSetPointDefault;

		//	Try to initialize CalSourceTempSetPointDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  calSourceTempSetPointDefault;
		else {
			//	Try to initialize CalSourceTempSetPointDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  calSourceTempSetPointDefault;
		}
		//	And try to extract CalSourceTempSetPointDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  calSourceTempSetPointDefault;

		//	Try to initialize Rfe2TempSetPointDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  rfe2TempSetPointDefault;
		else {
			//	Try to initialize Rfe2TempSetPointDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  rfe2TempSetPointDefault;
		}
		//	And try to extract Rfe2TempSetPointDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  rfe2TempSetPointDefault;

		//	Try to initialize ExpectedOnlineDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  expectedOnlineDefault;
		else {
			//	Try to initialize ExpectedOnlineDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  expectedOnlineDefault;
		}
		//	And try to extract ExpectedOnlineDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  expectedOnlineDefault;

	}

	/*----- PROTECTED REGION ID(SPFEmulator::get_device_property_after) ENABLED START -----*/
	
	//	Check device property data members init
	
	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::get_device_property_after
}
//--------------------------------------------------------
/**
 *	Method      : SPFEmulator::check_mandatory_property()
 *	Description : For mandatory properties check if defined in database.
 */
//--------------------------------------------------------
void SPFEmulator::check_mandatory_property(Tango::DbDatum &class_prop, Tango::DbDatum &dev_prop)
{
	//	Check if all properties are empty
	if (class_prop.is_empty() && dev_prop.is_empty())
	{
		TangoSys_OMemStream	tms;
		tms << endl <<"Property \'" << dev_prop.name;
		if (Tango::Util::instance()->_UseDb==true)
			tms << "\' is mandatory but not defined in database";
		else
			tms << "\' is mandatory but cannot be defined without database";
		string	status(get_status());
		status += tms.str();
		set_status(status);
		mandatoryNotDefined = true;
		/*----- PROTECTED REGION ID(SPFEmulator::check_mandatory_property) ENABLED START -----*/
		cerr << tms.str() << " for " << device_name << endl;
		
		/*----- PROTECTED REGION END -----*/	//	SPFEmulator::check_mandatory_property
	}
}


//--------------------------------------------------------
/**
 *	Method      : SPFEmulator::always_executed_hook()
 *	Description : method always executed before any command is executed
 */
//--------------------------------------------------------
void SPFEmulator::always_executed_hook()
{
	DEBUG_STREAM << "SPFEmulator::always_executed_hook()  " << device_name << endl;
	if (mandatoryNotDefined)
	{
		string	status(get_status());
		Tango::Except::throw_exception(
					(const char *)"PROPERTY_NOT_SET",
					status.c_str(),
					(const char *)"SPFEmulator::always_executed_hook()");
	}
	/*----- PROTECTED REGION ID(SPFEmulator::always_executed_hook) ENABLED START -----*/
	
	//	code always executed before all requests
	
	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::always_executed_hook
}

//--------------------------------------------------------
/**
 *	Method      : SPFEmulator::read_attr_hardware()
 *	Description : Hardware acquisition for attributes
 */
//--------------------------------------------------------
void SPFEmulator::read_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "SPFEmulator::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::read_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::read_attr_hardware
}
//--------------------------------------------------------
/**
 *	Method      : SPFEmulator::write_attr_hardware()
 *	Description : Hardware writing for attributes
 */
//--------------------------------------------------------
void SPFEmulator::write_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "SPFEmulator::write_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::write_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::write_attr_hardware
}

//--------------------------------------------------------
/**
 *	Read attribute setB1FeedOperateModeProgress related method
 *	Description: 
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 3
 */
//--------------------------------------------------------
void SPFEmulator::read_setB1FeedOperateModeProgress(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SPFEmulator::read_setB1FeedOperateModeProgress(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::read_setB1FeedOperateModeProgress) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_setB1FeedOperateModeProgress_read, 3);
	
	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::read_setB1FeedOperateModeProgress
}
//--------------------------------------------------------
/**
 *	Read attribute setB1FeedRegenerationModeProgress related method
 *	Description: 
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 3
 */
//--------------------------------------------------------
void SPFEmulator::read_setB1FeedRegenerationModeProgress(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SPFEmulator::read_setB1FeedRegenerationModeProgress(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::read_setB1FeedRegenerationModeProgress) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_setB1FeedRegenerationModeProgress_read, 3);
	
	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::read_setB1FeedRegenerationModeProgress
}
//--------------------------------------------------------
/**
 *	Read attribute setB2FeedOperateModeProgress related method
 *	Description: 
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 3
 */
//--------------------------------------------------------
void SPFEmulator::read_setB2FeedOperateModeProgress(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SPFEmulator::read_setB2FeedOperateModeProgress(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::read_setB2FeedOperateModeProgress) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_setB2FeedOperateModeProgress_read, 3);
	
	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::read_setB2FeedOperateModeProgress
}
//--------------------------------------------------------
/**
 *	Read attribute setB2FeedRegenerationModeProgress related method
 *	Description: 
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 3
 */
//--------------------------------------------------------
void SPFEmulator::read_setB2FeedRegenerationModeProgress(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SPFEmulator::read_setB2FeedRegenerationModeProgress(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::read_setB2FeedRegenerationModeProgress) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_setB2FeedRegenerationModeProgress_read, 3);
	
	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::read_setB2FeedRegenerationModeProgress
}
//--------------------------------------------------------
/**
 *	Read attribute setB3FeedOperateModeProgress related method
 *	Description: 
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 3
 */
//--------------------------------------------------------
void SPFEmulator::read_setB3FeedOperateModeProgress(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SPFEmulator::read_setB3FeedOperateModeProgress(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::read_setB3FeedOperateModeProgress) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_setB3FeedOperateModeProgress_read, 3);
	
	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::read_setB3FeedOperateModeProgress
}
//--------------------------------------------------------
/**
 *	Read attribute setB3FeedRegenerationModeProgress related method
 *	Description: 
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 3
 */
//--------------------------------------------------------
void SPFEmulator::read_setB3FeedRegenerationModeProgress(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SPFEmulator::read_setB3FeedRegenerationModeProgress(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::read_setB3FeedRegenerationModeProgress) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_setB3FeedRegenerationModeProgress_read, 3);
	
	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::read_setB3FeedRegenerationModeProgress
}
//--------------------------------------------------------
/**
 *	Read attribute setB4FeedOperateModeProgress related method
 *	Description: 
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 3
 */
//--------------------------------------------------------
void SPFEmulator::read_setB4FeedOperateModeProgress(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SPFEmulator::read_setB4FeedOperateModeProgress(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::read_setB4FeedOperateModeProgress) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_setB4FeedOperateModeProgress_read, 3);
	
	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::read_setB4FeedOperateModeProgress
}
//--------------------------------------------------------
/**
 *	Read attribute setB4FeedRegenerationModeProgress related method
 *	Description: 
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 3
 */
//--------------------------------------------------------
void SPFEmulator::read_setB4FeedRegenerationModeProgress(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SPFEmulator::read_setB4FeedRegenerationModeProgress(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::read_setB4FeedRegenerationModeProgress) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_setB4FeedRegenerationModeProgress_read, 3);
	
	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::read_setB4FeedRegenerationModeProgress
}
//--------------------------------------------------------
/**
 *	Read attribute setB5FeedOperateModeProgress related method
 *	Description: 
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 3
 */
//--------------------------------------------------------
void SPFEmulator::read_setB5FeedOperateModeProgress(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SPFEmulator::read_setB5FeedOperateModeProgress(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::read_setB5FeedOperateModeProgress) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_setB5FeedOperateModeProgress_read, 3);
	
	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::read_setB5FeedOperateModeProgress
}
//--------------------------------------------------------
/**
 *	Read attribute setB5FeedRegenerationModeProgress related method
 *	Description: 
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 3
 */
//--------------------------------------------------------
void SPFEmulator::read_setB5FeedRegenerationModeProgress(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SPFEmulator::read_setB5FeedRegenerationModeProgress(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::read_setB5FeedRegenerationModeProgress) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_setB5FeedRegenerationModeProgress_read, 3);
	
	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::read_setB5FeedRegenerationModeProgress
}
//--------------------------------------------------------
/**
 *	Read attribute setOperateModeProgress related method
 *	Description: 
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 3
 */
//--------------------------------------------------------
void SPFEmulator::read_setOperateModeProgress(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SPFEmulator::read_setOperateModeProgress(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::read_setOperateModeProgress) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_setOperateModeProgress_read, 3);
	
	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::read_setOperateModeProgress
}
//--------------------------------------------------------
/**
 *	Read attribute setStandbyLPModeProgress related method
 *	Description: 
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 3
 */
//--------------------------------------------------------
void SPFEmulator::read_setStandbyLPModeProgress(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SPFEmulator::read_setStandbyLPModeProgress(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::read_setStandbyLPModeProgress) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_setStandbyLPModeProgress_read, 3);
	
	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::read_setStandbyLPModeProgress
}
//--------------------------------------------------------
/**
 *	Read attribute setMaintenanceModeProgress related method
 *	Description: 
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 3
 */
//--------------------------------------------------------
void SPFEmulator::read_setMaintenanceModeProgress(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SPFEmulator::read_setMaintenanceModeProgress(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::read_setMaintenanceModeProgress) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_setMaintenanceModeProgress_read, 3);
	
	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::read_setMaintenanceModeProgress
}
//--------------------------------------------------------
/**
 *	Read attribute setB1FeedStandbyLPModeProgress related method
 *	Description: 
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 3
 */
//--------------------------------------------------------
void SPFEmulator::read_setB1FeedStandbyLPModeProgress(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SPFEmulator::read_setB1FeedStandbyLPModeProgress(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::read_setB1FeedStandbyLPModeProgress) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_setB1FeedStandbyLPModeProgress_read, 3);
	
	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::read_setB1FeedStandbyLPModeProgress
}
//--------------------------------------------------------
/**
 *	Read attribute setB2FeedStandbyLPModeProgress related method
 *	Description: 
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 3
 */
//--------------------------------------------------------
void SPFEmulator::read_setB2FeedStandbyLPModeProgress(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SPFEmulator::read_setB2FeedStandbyLPModeProgress(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::read_setB2FeedStandbyLPModeProgress) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_setB2FeedStandbyLPModeProgress_read, 3);
	
	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::read_setB2FeedStandbyLPModeProgress
}
//--------------------------------------------------------
/**
 *	Read attribute setB3FeedStandbyLPModeProgress related method
 *	Description: 
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 3
 */
//--------------------------------------------------------
void SPFEmulator::read_setB3FeedStandbyLPModeProgress(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SPFEmulator::read_setB3FeedStandbyLPModeProgress(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::read_setB3FeedStandbyLPModeProgress) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_setB3FeedStandbyLPModeProgress_read, 3);
	
	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::read_setB3FeedStandbyLPModeProgress
}
//--------------------------------------------------------
/**
 *	Read attribute setB4FeedStandbyLPModeProgress related method
 *	Description: 
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 3
 */
//--------------------------------------------------------
void SPFEmulator::read_setB4FeedStandbyLPModeProgress(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SPFEmulator::read_setB4FeedStandbyLPModeProgress(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::read_setB4FeedStandbyLPModeProgress) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_setB4FeedStandbyLPModeProgress_read, 3);
	
	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::read_setB4FeedStandbyLPModeProgress
}
//--------------------------------------------------------
/**
 *	Read attribute setB5FeedStandbyLPModeProgress related method
 *	Description: 
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 3
 */
//--------------------------------------------------------
void SPFEmulator::read_setB5FeedStandbyLPModeProgress(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SPFEmulator::read_setB5FeedStandbyLPModeProgress(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::read_setB5FeedStandbyLPModeProgress) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_setB5FeedStandbyLPModeProgress_read, 3);
	
	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::read_setB5FeedStandbyLPModeProgress
}

//--------------------------------------------------------
/**
 *	Method      : SPFEmulator::add_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *                for specified device.
 */
//--------------------------------------------------------
void SPFEmulator::add_dynamic_attributes()
{
	/*----- PROTECTED REGION ID(SPFEmulator::add_dynamic_attributes) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic attributes if any
	LMCDevice::add_dynamic_attributes();

	/*
	//===== DEBUG (DECOMMENT IF ABOVE LINE NOT WORKING) =====
	//Add dynamic attributes from config file
	if(AddDynAttrs()<0){
		std::string errMsg("Failed to create dyn attributes!");
		_ERROR_LOG(errMsg);
		set_status(errMsg.c_str());
		set_state(Tango::FAULT);
		return;
	}
	
	//Configure state machine for cmd & attrs
	if(InitCmdAttrStateMachine()<0){
		std::string errMsg("Failed to create cmd & attr state machines for dyn attributes!");
		_ERROR_LOG(errMsg);
		set_status(errMsg.c_str());
		set_state(Tango::FAULT);
		return;
	}
	*/

	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::add_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Command SetLNAHPowerState related method
 *	Description: Switch the H-channel LNA power on/off.
 *               
 *               == Allowed mode/state ==
 *               spf_mode= {OPERATE,MAINTENANCE (TBD)}
 *               
 *               == Expected behavior ==
 *               1) Depending on command bandId argument set value of device 
 *               attributes: 
 *               b1_lna_h_powerState, ..., b5_lna_h_powerState
 *               
 *               2) Switch SPF power state to FULL-POWER?
 *               
 *               NB: This command is deprecated from ICD release 2.
 *               Replaced by writable attributes.
 *
 *	@param argin [0]: bandId
 *               [1]: 0/1: enable/disable
 */
//--------------------------------------------------------
void SPFEmulator::set_lnahpower_state(const Tango::DevVarShortArray *argin)
{
	DEBUG_STREAM << "SPFEmulator::SetLNAHPowerState()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::set_lnahpower_state) ENABLED START -----*/
	
	//	Add your own code
	
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::vector<std::string> bandAttrNames= {
		"b1LnaHPowerState",	
		"b2LnaHPowerState",
		"b3LnaHPowerState",
		"b4LnaHPowerState",
		"b5LnaHPowerState"
	};
	//============================================================================

	//## Get argin (args already checked in StateMachine class)
	Tango::DevShort bandId= (*argin)[0];
	Tango::DevShort enableFlag= (*argin)[1];
	bool flag= false;
	if(enableFlag==1) flag= true;

	//## Set attribute value
	if(SetDynAttrValue<Tango::DevBoolean>(flag,bandAttrNames[bandId-1])<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<bandAttrNames[bandId-1]<<" to "<<flag<<"!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_LNA_H_POWER_STATE_FAILED",ss.str());
	}
	
	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::set_lnahpower_state
}
//--------------------------------------------------------
/**
 *	Command SetLNAVPowerState related method
 *	Description: Switch the V-channel LNA power on/off
 *               
 *               NB: This command is deprecated from ICD release 2.
 *               Replaced by writable attributes.
 *
 *	@param argin [0]: bandId
 *               [1]: 0/1: enable/disable
 */
//--------------------------------------------------------
void SPFEmulator::set_lnavpower_state(const Tango::DevVarShortArray *argin)
{
	DEBUG_STREAM << "SPFEmulator::SetLNAVPowerState()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::set_lnavpower_state) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::vector<std::string> bandAttrNames= {
		"b1LnaVPowerState",	
		"b2LnaVPowerState",
		"b3LnaVPowerState",
		"b4LnaVPowerState",
		"b5LnaVPowerState"
	};
	//============================================================================

	//## Get argin (args already checked in StateMachine class)
	Tango::DevShort bandId= (*argin)[0];
	Tango::DevShort enableFlag= (*argin)[1];
	bool flag= false;
	if(enableFlag==1) flag= true;

	//## Set attribute value
	if(SetDynAttrValue<Tango::DevBoolean>(flag,bandAttrNames[bandId-1])<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<bandAttrNames[bandId-1]<<" to "<<flag<<"!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_LNA_V_POWER_STATE_FAILED",ss.str());
	}
	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::set_lnavpower_state
}
//--------------------------------------------------------
/**
 *	Command SetAmp2HPowerState related method
 *	Description: Switch the 2nd stage H-channel amplifier power on/off
 *               
 *               NB: This command is deprecated from ICD release 2.
 *               Replaced by writable attributes.
 *
 *	@param argin [0]: majorComponentBand
 *               [1]: enable/disable
 */
//--------------------------------------------------------
void SPFEmulator::set_amp2_hpower_state(const Tango::DevVarShortArray *argin)
{
	DEBUG_STREAM << "SPFEmulator::SetAmp2HPowerState()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::set_amp2_hpower_state) ENABLED START -----*/
	
	//	Add your own code
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::vector<std::string> bandAttrNames= {
		"b1Amp2HPowerState",	
		"b2Amp2HPowerState",
		"b3Amp2HPowerState",
		"b4Amp2HPowerState",
		"b5Amp2HPowerState"
	};
	//============================================================================

	//## Get argin (args already checked in StateMachine class)
	Tango::DevShort bandId= (*argin)[0];
	Tango::DevShort enableFlag= (*argin)[1];
	bool flag= false;
	if(enableFlag==1) flag= true;

	//Set attribute value
	if(SetDynAttrValue<Tango::DevBoolean>(flag,bandAttrNames[bandId-1])<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<bandAttrNames[bandId-1]<<" to "<<flag<<"!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_AMP2_H_POWER_FAILED",ss.str());
	}

	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::set_amp2_hpower_state
}
//--------------------------------------------------------
/**
 *	Command SetAmp2VPowerState related method
 *	Description: Switch the 2nd stage V-channel amplifier power on/off.
 *               
 *               NB: This command is deprecated from ICD release 2.
 *               Replaced by writable attributes.
 *
 *	@param argin [0]: majorComponentBand
 *               [1]: enable/disable
 */
//--------------------------------------------------------
void SPFEmulator::set_amp2_vpower_state(const Tango::DevVarShortArray *argin)
{
	DEBUG_STREAM << "SPFEmulator::SetAmp2VPowerState()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::set_amp2_vpower_state) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::vector<std::string> bandAttrNames= {
		"b1Amp2VPowerState",	
		"b2Amp2VPowerState",
		"b3Amp2VPowerState",
		"b4Amp2VPowerState",
		"b5Amp2VPowerState"
	};
	//============================================================================

	//## Get argin (args already checked in StateMachine class)
	Tango::DevShort bandId= (*argin)[0];
	Tango::DevShort enableFlag= (*argin)[1];
	bool flag= false;
	if(enableFlag==1) flag= true;

	//Set attribute value
	if(SetDynAttrValue<Tango::DevBoolean>(flag,bandAttrNames[bandId-1])<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<bandAttrNames[bandId-1]<<" to "<<flag<<"!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_AMP2_V_POWER_FAILED",ss.str());
	}

	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::set_amp2_vpower_state
}
//--------------------------------------------------------
/**
 *	Command SetRFE1TempSetPoint related method
 *	Description: Change the current RFE 1st stage temperature control 
 *               setpoint. This will not influence the default value. 
 *               An extra parameter ?warm? is included in these service 
 *               mode messages.
 *               
 *               NB: This command is deprecated from ICD release 2.
 *               Replaced by writable attributes.
 *
 *	@param argin [0]: Major component band {B1,B2,B3,B4,B5}
 *               [1]: temp set point 
 *               {?disable? | ?sp1? | ?sp2? | ?sp3? | ?sp4? | ?sp5? | ?sp6? | ?warm?}
 */
//--------------------------------------------------------
void SPFEmulator::set_rfe1_temp_set_point(const Tango::DevVarShortArray *argin)
{
	DEBUG_STREAM << "SPFEmulator::SetRFE1TempSetPoint()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::set_rfe1_temp_set_point) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::vector< std::vector<std::string> > bandAttrNames= {
		//{"b1Rfe1TempSetPoint"},
		{"b1LnaHTempSetPoint","b1LnaVTempSetPoint"},
		{"b2Rfe1TempSetPoint"},
		{"b3Rfe1TempSetPoint"},
		{"b4Rfe1TempSetPoint"},
		{"b5Rfe1TempSetPoint"}
	};
	//============================================================================

	//## Get argin (args already checked in StateMachine class)
	Tango::DevShort bandId= (*argin)[0];
	Tango::DevShort setpointId= (*argin)[1];

	//Set attribute value (enum check performed internally)
	for(size_t j=0;j<bandAttrNames[bandId-1].size();j++){
		if(SetDynAttrValue<Tango::DevEnum>(setpointId,bandAttrNames[bandId-1][j])<0){
			std::stringstream ss;
			ss<<"Failed to set attr "<<bandAttrNames[bandId-1][j]<<" to "<<setpointId<<"!";
			_ERROR_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("SET_RFE1_TEMP_SETPOINT_FAILED",ss.str());
		}
	}//end loop attrs for this band

	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::set_rfe1_temp_set_point
}
//--------------------------------------------------------
/**
 *	Command SetRFE2TempCntrState related method
 *	Description: Enable or disable the RFE 2nd stage temperature 
 *               controller.
 *               
 *               NB: This command is deprecated from ICD release 2.
 *               Replaced by writable attributes.
 *
 *	@param argin [0]: Major component band {B1,B2,B3,B4,B5,B6}
 *               [1]: Enable/disable
 */
//--------------------------------------------------------
void SPFEmulator::set_rfe2_temp_cntr_state(const Tango::DevVarShortArray *argin)
{
	DEBUG_STREAM << "SPFEmulator::SetRFE2TempCntrState()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::set_rfe2_temp_cntr_state) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::vector<bool> hasAttr {0,0,1,1,1};
	std::vector<std::string> bandAttrNames= {
		"b1Rfe2TempCtrlState",	
		"b2Rfe2TempCtrlState",
		"b3Rfe2TempCtrlState",
		"b4Rfe2TempCtrlState",
		"b5Rfe2TempCtrlState"
	};
	//============================================================================

	//## Get argin (args already checked in StateMachine class)
	Tango::DevShort bandId= (*argin)[0];
	Tango::DevShort enableFlag= (*argin)[1];
	bool flag= false;
	if(enableFlag==1) flag= true;

	if(!hasAttr[bandId-1]){
		std::stringstream ss;
		ss<<"Attr "<<bandAttrNames[bandId-1]<<" does not exist in device!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_RFE2_TEMP_CNTR_FAILED",ss.str());
	}

	//Set attribute value
	if(SetDynAttrValue<Tango::DevBoolean>(flag,bandAttrNames[bandId-1])<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<bandAttrNames[bandId-1]<<" to "<<flag<<"!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_RFE2_TEMP_CNTR_FAILED",ss.str());
	}

	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::set_rfe2_temp_cntr_state
}
//--------------------------------------------------------
/**
 *	Command SetCryoMotorState related method
 *	Description: Enable or disable the cryocooler (motor)
 *               
 *               NB: This command is deprecated from ICD release 2.
 *               Replaced by writable attributes.
 *
 *	@param argin [0]: cryoStat {B1,B2,B345}
 *               [1]: enable/disable
 */
//--------------------------------------------------------
void SPFEmulator::set_cryo_motor_state(const Tango::DevVarShortArray *argin)
{
	DEBUG_STREAM << "SPFEmulator::SetCryoMotorState()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::set_cryo_motor_state) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string cmd_name= "SetCryoMotorState";
	std::vector<std::string> bandAttrNames= {
		"b1CryoMotorState",	
		"b2CryoMotorState",
		"b345CryoMotorState",
		"b345CryoMotorState",
		"b345CryoMotorState"
	};
	std::vector<std::string> cryoStepperMotorSpeedAttrNames= {
		"b1CryoMotorSpeed",	
		"b2CryoMotorSpeed",
		"b345CryoMotorSpeed",
		"b345CryoMotorSpeed",
		"b345CryoMotorSpeed"
	};
	//=================================================================
	
	//## Get argin (args already checked in StateMachine class)
	Tango::DevShort bandId= (*argin)[0];
	Tango::DevShort enableFlag= (*argin)[1];
	bool flag= false;
	if(enableFlag==1) flag= true;

	//Set attribute value
	if(SetDynAttrValue<Tango::DevBoolean>(flag,bandAttrNames[bandId-1])<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<bandAttrNames[bandId-1]<<" to "<<flag<<"!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_CRYO_MOTOR_STATE_FAILED",ss.str());
	}

	//Set also cryo motor speed to 0 (see ICD)
	Tango::DevShort cryoStepperMotorSpeed= 0;
	if(SetDynAttrValue<Tango::DevShort>(cryoStepperMotorSpeed,cryoStepperMotorSpeedAttrNames[bandId-1])<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<cryoStepperMotorSpeedAttrNames[bandId-1]<<" to "<<cryoStepperMotorSpeed<<"!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_CRYO_MOTOR_STATE_FAILED",ss.str());
	}

	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::set_cryo_motor_state
}
//--------------------------------------------------------
/**
 *	Command SetCryoMotorSpeed related method
 *	Description: Set the motor speed in rpm [45 - 90].
 *               
 *               NB: This command is deprecated from ICD release 2.
 *               Replaced by writable attributes.
 *
 *	@param argin [0]: cryo stat {B1,B2,B345}
 *               [1]: Speed in rpm {45,46,...90}
 */
//--------------------------------------------------------
void SPFEmulator::set_cryo_motor_speed(const Tango::DevVarShortArray *argin)
{
	DEBUG_STREAM << "SPFEmulator::SetCryoMotorSpeed()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::set_cryo_motor_speed) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string cmd_name= "SetCryoMotorSpeed";
	std::vector<std::string> bandAttrNames= {
		"b1CryoMotorSpeed",	
		"b2CryoMotorSpeed",
		"b345CryoMotorSpeed",
		"b345CryoMotorSpeed",
		"b345CryoMotorSpeed"
	};
	//=================================================================
	
	//## Get argin (args already checked in StateMachine class)
	Tango::DevShort bandId= (*argin)[0];
	Tango::DevShort motorSpeed= (*argin)[1];

	//Set attribute value
	if(SetDynAttrValue<Tango::DevShort>(motorSpeed,bandAttrNames[bandId-1])<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<bandAttrNames[bandId-1]<<" to "<<motorSpeed<<"!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_CRYO_MOTOR_SPEED_FAILED",ss.str());
	}

	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::set_cryo_motor_speed
}
//--------------------------------------------------------
/**
 *	Command SetVaValveState related method
 *	Description: Open/close the vacuum valve.
 *               
 *               NB: This command is deprecated from ICD release 2.
 *               Replaced by writable attributes.
 *
 *	@param argin Enable/disable
 */
//--------------------------------------------------------
void SPFEmulator::set_va_valve_state(Tango::DevBoolean argin)
{
	DEBUG_STREAM << "SPFEmulator::SetVaValveState()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::set_va_valve_state) ENABLED START -----*/
	
	//	Add your own code

	/*
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string attr_name= "vaValveState";
	//=================================================================
	
	//## Get argin (args already checked in StateMachine class)
	Tango::DevBoolean flag= argin;

	//Set attribute value
	if(SetDynAttrValue<Tango::DevBoolean>(flag,attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<attr_name<<" to "<<flag<<"!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_VA_VALVE_STATE_FAILED",ss.str());
	}
	*/

	_THROW_TANGO_EXCEPTION("CMD_NOT_IMPLEMENTED_AND_DEPRECATED","This command is not implemented and deprecated!!!");

	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::set_va_valve_state
}
//--------------------------------------------------------
/**
 *	Command SetSubElementMode related method
 *	Description: Set the sub-element mode.
 *               
 *               NB: This command was deprecated from ICD v2. 
 *               Replaced by single commands for each operating mode.
 *
 *	@param argin spfMode to be set. Allowed values are:
 *               {Operate | Standby_LP | Maintenance}
 */
//--------------------------------------------------------
void SPFEmulator::set_sub_element_mode(Tango::DevShort argin)
{
	DEBUG_STREAM << "SPFEmulator::SetSubElementMode()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::set_sub_element_mode) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string attr_name= "operatingMode";
	std::vector<std::string> cap_attr_names= {
		"b1CapabilityState",
		"b2CapabilityState",
		"b3CapabilityState",
		"b4CapabilityState",
		"b5CapabilityState",
	};
	std::string activeBand_attr_name= "activeBandId";
	std::string powerState_attr_name= "powerState";
	//============================================================================


	//=====================================================
	//==         GET ARGS
	//=====================================================
	//Get args (INTEGRITY CHECK PERFORMED IN STATE MACHINE CLASS)
	Tango::DevShort mode= argin;
	
	//Get string label
	std::string mode_str= "";
	Utils_ns::TangoUtils::GetEnumAttrLabelValue(mode_str,this,attr_name,mode);

	//=====================================================
	//==         CHECK MODE
	//=====================================================
	//Retrieve current mode attr value
	Tango::DevShort current_mode;
	if(GetDynAttrValue(current_mode,attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_SUB_ELEMENT_MODE_FAILED",ss.str());
	}

	//Check if same mode is given
	if(mode==current_mode){
		_INFO_LOG("Mode is already selected, nothing to be done");
		return;
	}	
	
	//=====================================================
	//==         SET MODE
	//=====================================================

	//Set attribute value
	if(mode_str=="STANDBY-LP"){
		set_standby_lpmode();
		return;
	}
	else if(mode_str=="OPERATE"){
		set_operate_mode();
		return;
	}
	else if(mode_str=="MAINTENANCE"){
		set_maintenance_mode();
		return;
	}
	else{//should not get here
		std::stringstream ss;
		ss<<"Invalid mode requested ("<<mode_str<<")!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_SUB_ELEMENT_MODE_FAILED",ss.str());
	}

	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::set_sub_element_mode
}
//--------------------------------------------------------
/**
 *	Command SetFeedMode related method
 *	Description: Request feed to go to a different state. 
 *               Each receiver keeps track of its own errors in an 
 *               error-register when it enters its error state. An FMECA 
 *               sensor will indicate the fault to be corrected. 
 *               After the fault is corrected by a technician 
 *               the ``clear-errors-and-restart`` request should be sent to 
 *               clear the errors in the feed error register in order to 
 *               restart the feed.
 *               
 *               Valid values for mcBand argument are: {1-5}.
 *               Valid values for feedMode argument are: {0,2}, 
 *               where each enum code corresponds to:
 *               
 *               0= STANDBY-LP
 *               1= OPERATE
 *               2= MAINTENANCE
 *
 *	@param argin [0]: Major component band {B1,B2,B3,B4,B5}
 *               [1]: seFeedMode {0,1,2}
 *               
 *               0= STANDBY-LP
 *               1= OPERATE
 *               2= MAINTENANCE
 *	@returns 
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *SPFEmulator::set_feed_mode(const Tango::DevVarShortArray *argin)
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "SPFEmulator::SetFeedMode()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::set_feed_mode) ENABLED START -----*/
	
	//	Add your own code
	//_THROW_TANGO_EXCEPTION("CMD_NOT_IMPLEMENTED","This command needs to be implemented yet");

	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string cmd_name= "SetFeedMode";
	std::string mode_attr_name= "operatingMode";
	std::vector<std::string> feed_mode_attr_names {
		"b1OperatingState",
		"b2OperatingState",	
		"b3OperatingState",
		"b4OperatingState",
		"b5OperatingState"
	};
	int nBands= 5;
	//============================================================================

	//=====================================================
	//==         CHECK STATE MACHINE
	//=====================================================
	_DEBUG_LOG("Check if cmd "<<__FUNCTION__<<" is allowed...");
	bool check_cmd= true;
	try {
		IsCmdAllowed(__FUNCTION__,check_cmd);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		throw;
	}

	//=====================================================
	//==         GET ARGS
	//=====================================================
	//Check args size
	if(argin->length()<2){
		std::stringstream ss;
		ss<<"Invalid number of arguments given (must be 2)";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_FEED_MODE_FAILED",ss.str());
	}
	Tango::DevShort bandId= (*argin)[0];
	Tango::DevShort feed_mode= (*argin)[1];

	//Check bandId arg
	if(bandId<=0 || bandId>nBands){
		std::stringstream ss;
		ss<<"Invalid bandId arg given ("<<bandId<<"), valid values are in range [1,"<<nBands<<"]!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_FEED_MODE_FAILED",ss.str());
	}
	
	/*
	//Check feed mode arg (if valid enumeration)
	//DEPRECATED after ICD update (July 2017)
	std::string feed_mode_str= "";
	if(Utils_ns::TangoUtils::GetEnumAttrLabelValue(feed_mode_str,this,feed_mode_attr_names[bandId-1],feed_mode)<0){
		std::stringstream ss;
		ss<<"Invalid enumeration ("<<feed_mode<<") given for attr "<< feed_mode_attr_names[bandId-1]<<"!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_FEED_MODE_FAILED",ss.str());
	}
	*/
	

	//=====================================================
	//==         SET FEED MODE
	//=====================================================

	//Set attribute value
	if(feed_mode==0){
		return set_feed_standby_lpmode(bandId);
	}
	else if(feed_mode==1){
		return set_feed_operate_mode(bandId);
	}
	else if(feed_mode==2){
		return set_feed_maintenance_mode(bandId);
	}
	else{//should not get here
		std::stringstream ss;
		ss<<"Invalid feed mode option given ("<<feed_mode<<"), valid values are {0,1,2}!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_FEED_MODE_FAILED",ss.str());
	}

	/*
	//DEPRECATED AFTER ICD UPDATE (JULY 2017)
	if(feed_mode_str=="STANDBY-LP"){
		return set_feed_standby_lpmode(bandId);
	}
	else if(feed_mode_str=="OPERATE"){
		return set_feed_operate_mode(bandId);
	}
	else if(feed_mode_str=="MAINTENANCE"){
		return set_feed_maintenance_mode(bandId);
	}
	else if(feed_mode_str=="ERROR"){//Not sure this can be actually set
		return set_feed_clear_errors_and_restart_mode(bandId);
	}
	else if(feed_mode_str=="REGENERATION"){
		return set_feed_regeneration_mode(bandId);
	}
	else{//should not get here
		std::stringstream ss;
		ss<<"Invalid feed mode requested ("<<feed_mode_str<<")!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_FEED_MODE_FAILED",ss.str());
	}
	*/

	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::set_feed_mode
	return argout;
}
//--------------------------------------------------------
/**
 *	Command SendFeedCommand related method
 *	Description: Send a once-off command directly to the feed. 
 *               Each feed can have different commands defined, and 
 *               currently they are all defined in the same manner.
 *               
 *               Command is valid in spf mode {STANDBY-LP, OPERATE, MAINTENANCE}
 *               
 *               
 *               Valid values for mcBand argument are: {1-5}.
 *               Valid values for feedComamnd argument are: {0,1}, 
 *               where each enum code corresponds to:
 *               
 *               0 = REGENERATE
 *               1 = CLEAR-ERRORS
 *               
 *               Other additional commands defined in the future 
 *               will follow from the above list into separate lists for 
 *               each feed.
 *
 *	@param argin [0]: mcBand
 *               [1]: feedCommand
 */
//--------------------------------------------------------
void SPFEmulator::send_feed_command(const Tango::DevVarShortArray *argin)
{
	DEBUG_STREAM << "SPFEmulator::SendFeedCommand()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::send_feed_command) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string cmd_name= "SendFeedCommand";
	std::string mode_attr_name= "operatingMode";
	std::vector<std::string> feed_mode_attr_names {
		"b1OperatingState",
		"b2OperatingState",	
		"b3OperatingState",
		"b4OperatingState",
		"b5OperatingState"
	};
	int nBands= 5;
	//============================================================================

	//=====================================================
	//==         CHECK STATE MACHINE
	//=====================================================
	_DEBUG_LOG("Check if cmd "<<__FUNCTION__<<" is allowed...");
	bool check_cmd= true;
	try {
		IsCmdAllowed(__FUNCTION__,check_cmd);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		throw;
	}

	//=====================================================
	//==         GET ARGS
	//=====================================================
	//Check args size
	if(argin->length()<2){
		std::stringstream ss;
		ss<<"Invalid number of arguments given (must be 2)";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SEND_FEED_COMMAND_FAILED",ss.str());
	}
	Tango::DevShort bandId= (*argin)[0];
	Tango::DevShort feed_cmd= (*argin)[1];

	//Check bandId arg
	if(bandId<=0 || bandId>nBands){
		std::stringstream ss;
		ss<<"Invalid bandId arg given ("<<bandId<<"), valid values are in range [1,"<<nBands<<"]!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SEND_FEED_COMMAND_FAILED",ss.str());
	}
	
	
	//=====================================================
	//==         SEND FEED COMMAND
	//=====================================================

	if(feed_cmd==0){
		set_feed_regeneration_mode(bandId);
	}
	else if(feed_cmd==1){
		set_feed_clear_errors_and_restart_mode(bandId); 
	}
	else{//should not get here
		std::stringstream ss;
		ss<<"Invalid feed command requested ("<<feed_cmd<<")!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SEND_FEED_COMMAND_FAILED",ss.str());
	}


	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::send_feed_command
}
//--------------------------------------------------------
/**
 *	Command SetVacuumMode related method
 *	Description: The SPF Vacuum service will nominally operate from its 
 *               STANDBY-LP mode and will be mainly controlled by the 
 *               feeds. In the case where lower level maintenance 
 *               commands need to be performed, the vacuum service 
 *               can be switched to maintenance mode. It will then be 
 *               unavailable for use by a feed.
 *               
 *               Allowed only in MAINTENANCE mode
 *
 *	@param argin vaMode {STANDBY-LP, MAINTENANCE}
 */
//--------------------------------------------------------
void SPFEmulator::set_vacuum_mode(Tango::DevShort argin)
{
	DEBUG_STREAM << "SPFEmulator::SetVacuumMode()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::set_vacuum_mode) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string vaState_attr_name= "vaOperatingState";
	std::vector<std::string> vaModes_str {
		"STANDBY-LP", 
		"MAINTENANCE"
	};
	//############################################################################

	//_THROW_TANGO_EXCEPTION("CMD_NOT_IMPLEMENTED","This command needs to be implemented yet");

	//## Check argin
	if(argin<0 || argin>=(signed)(vaModes_str.size())){
		std::stringstream ss;
		ss<<"Invalid vacuum mode ("<<argin<<") given, valid values are in range [0,"<<vaModes_str.size()-1<<"]";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_VACUUM_MODE_FAILED",ss.str());
	}

	//## Retrieve current mode attr value
	Tango::DevShort vaMode;	
	if(Utils_ns::TangoUtils::GetEnumAttrValue(vaMode,this,vaState_attr_name,vaModes_str[argin])<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<vaState_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_VACUUM_MODE_FAILED",ss.str());
	}

	//## Set vacuum state
	if(SetDynAttrValue(vaMode,vaState_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<vaState_attr_name<<" to "<<vaMode<<"!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_VACUUM_MODE_FAILED",ss.str());	
	}

	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::set_vacuum_mode
}
//--------------------------------------------------------
/**
 *	Command SendVacuumCommand related method
 *	Description: Send a once-off command directly to the SPF Vacuum 
 *               service. Other additional commands defined 
 *               in the future will follow from the above list.
 *               
 *               Allowed only in MAINTENANCE mode
 *
 *	@param argin vaCommand {RESET, CLEAR-ERRORS}
 */
//--------------------------------------------------------
void SPFEmulator::send_vacuum_command(Tango::DevShort argin)
{
	DEBUG_STREAM << "SPFEmulator::SendVacuumCommand()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::send_vacuum_command) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	int nCmds= 2;
	//============================================================================

	//=====================================================
	//==         CHECK STATE MACHINE
	//=====================================================
	_DEBUG_LOG("Check if cmd "<<__FUNCTION__<<" is allowed...");
	bool check_cmd= true;
	try {
		IsCmdAllowed(__FUNCTION__,check_cmd);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		throw;
	}

	//=====================================================
	//==         GET ARGS
	//=====================================================

	//Check argin
	Tango::DevShort va_cmd= argin;
	if(va_cmd<0 || va_cmd>=nCmds){
		std::stringstream ss;
		ss<<"Invalid vacuum command arg given ("<<va_cmd<<"), valid values are in range [0,"<<nCmds<<"]!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SEND_VACUUM_COMMAND_FAILED",ss.str());
	}
	
	
	//=====================================================
	//==         SEND VACUUM COMMAND
	//=====================================================

	if(va_cmd==0){
		_INFO_LOG("Setting RESET vacuum command...");
		//...
	}
	else if(va_cmd==1){
		_INFO_LOG("Setting CLEAR-ERRORS vacuum command...");
		//...
	}
	else{//should not get here
		std::stringstream ss;
		ss<<"Invalid vacuum command requested ("<<va_cmd<<")!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SEND_VACUUM_COMMAND_FAILED",ss.str());
	}

	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::send_vacuum_command
}
//--------------------------------------------------------
/**
 *	Command SetHeliumMode related method
 *	Description: The SPF Helium service will nominally operate from 
 *               its STANDBY-LP mode and will be mainly controlled 
 *               by the feeds. In the case where lower level maintenance 
 *               commands need to be performed, the helium service 
 *               can be switched to maintenance mode. It will then be 
 *               unavailable for use by a feed.
 *               
 *               Allowed only in MAINTENANCE mode
 *
 *	@param argin heMode
 *               {STANDBY-LP, MAINTENANCE}
 */
//--------------------------------------------------------
void SPFEmulator::set_helium_mode(Tango::DevShort argin)
{
	DEBUG_STREAM << "SPFEmulator::SetHeliumMode()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::set_helium_mode) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string heState_attr_name= "heOperatingState";
	std::vector<std::string> heModes_str {
		"STANDBY-LP", 
		"MAINTENANCE"
	};
	//############################################################################

	//_THROW_TANGO_EXCEPTION("CMD_NOT_IMPLEMENTED","This command needs to be implemented yet");

	//## Check argin
	if(argin<0 || argin>=(signed)(heModes_str.size())){
		std::stringstream ss;
		ss<<"Invalid helium mode ("<<argin<<") given, valid values are in range [0,"<<heModes_str.size()-1<<"]";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_HELIUM_MODE_FAILED",ss.str());
	}

	//## Retrieve current mode attr value
	Tango::DevShort heMode;	
	if(Utils_ns::TangoUtils::GetEnumAttrValue(heMode,this,heState_attr_name,heModes_str[argin])<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<heState_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_HELIUM_MODE_FAILED",ss.str());
	}

	//## Set vacuum state
	if(SetDynAttrValue(heMode,heState_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<heState_attr_name<<" to "<<heMode<<"!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_HELIUM_MODE_FAILED",ss.str());	
	}
	
	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::set_helium_mode
}
//--------------------------------------------------------
/**
 *	Command SendHeliumCommand related method
 *	Description: Send a once-off command directly to the SPF Helium 
 *               service. 
 *               Other additional commands defined in the future will 
 *               follow from the above list.
 *               
 *               Command allowed only in MAINTENANCE mode
 *
 *	@param argin heCommand {RESET, CLEAR-ERRORS}
 */
//--------------------------------------------------------
void SPFEmulator::send_helium_command(Tango::DevShort argin)
{
	DEBUG_STREAM << "SPFEmulator::SendHeliumCommand()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::send_helium_command) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	int nCmds= 2;
	//============================================================================

	//=====================================================
	//==         CHECK STATE MACHINE
	//=====================================================
	_DEBUG_LOG("Check if cmd "<<__FUNCTION__<<" is allowed...");
	bool check_cmd= true;
	try {
		IsCmdAllowed(__FUNCTION__,check_cmd);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		throw;
	}

	//=====================================================
	//==         GET ARGS
	//=====================================================

	//Check argin
	Tango::DevShort he_cmd= argin;
	if(he_cmd<0 || he_cmd>=nCmds){
		std::stringstream ss;
		ss<<"Invalid helium command arg given ("<<he_cmd<<"), valid values are in range [0,"<<nCmds<<"]!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SEND_HELIUM_COMMAND_FAILED",ss.str());
	}
	
	
	//=====================================================
	//==         SEND VACUUM COMMAND
	//=====================================================

	if(he_cmd==0){
		_INFO_LOG("Setting RESET helium command...");
		//...
	}
	else if(he_cmd==1){
		_INFO_LOG("Setting CLEAR-ERRORS helium command...");
		//...
	}
	else{//should not get here
		std::stringstream ss;
		ss<<"Invalid helium command requested ("<<he_cmd<<")!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SEND_HELIUM_COMMAND_FAILED",ss.str());
	}

	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::send_helium_command
}
//--------------------------------------------------------
/**
 *	Command SetMCStartState related method
 *	Description: Set a major component default start-up state.
 *
 *	@param argin [0]: majorComponent {B1, B2, B3, B4, B5, He, Va, SPFC}
 *               [1]: mcStartupState
 */
//--------------------------------------------------------
void SPFEmulator::set_mcstart_state(const Tango::DevVarShortArray *argin)
{
	DEBUG_STREAM << "SPFEmulator::SetMCStartState()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::set_mcstart_state) ENABLED START -----*/
	
	//	Add your own code
	_THROW_TANGO_EXCEPTION("CMD_NOT_IMPLEMENTED","This command needs to be implemented yet");

	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::set_mcstart_state
}
//--------------------------------------------------------
/**
 *	Command SetStandbyLPMode related method
 *	Description: Set SPF in STANDBY-LP mode
 *
 *	@returns 
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *SPFEmulator::set_standby_lpmode()
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "SPFEmulator::SetStandbyLPMode()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::set_standby_lpmode) ENABLED START -----*/
	
	//	Add your own code
	// == COMMAND BEHAVIOR ==
	// 1) Check if cmd mode-allowed {"OPERATE","MAINTENANCE"} (DONE IN STATE MACHINE)
	// 2) Check if mode transition allowed {"OPERATE","MAINTENANCE"}-->"STANDBY-LP" (DONE IN STATE MACHINE)
	// 3) Check if powerState transition allowed {"LOW-POWER","FULL-POWER"}-->"LOW-POWER" (DONE IN STATE MACHINE)
	// 4) Turn off all LNAs 
	// 5) Close the vacuum valves (=1)
	// 6) Switch off all the RF amplifiers.
	// 7) Disable the cryocooler 
	// 8) Disable both temp controllers
	// 9) The SM will pause for 2 seconds to ensure that the valve closing mechanism has been closed properly before the vacuum pump can be switched off. 
	//    It then releases the requests for the vacuum pump and the compressor.
	// 10) Set power state to LOW-POWER
	// 11) Set capabilities to STANDBY 
	// 12) Set mode to STANDBY-LP and feed modes to GO-STANDBY

	//Init output argument
	argout= new Tango::DevVarLongStringArray;
	argout->svalue.length(1);
	argout->lvalue.length(1);	

	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string mode_attr_name= "operatingMode";
	std::string powerState_attr_name= "powerState";
	std::vector<std::string> cap_attr_names= {
		"b1CapabilityState",
		"b2CapabilityState",
		"b3CapabilityState",
		"b4CapabilityState",
		"b5CapabilityState",
	};
	std::vector<std::string> feed_mode_attr_names {
		"b1OperatingState",
		"b2OperatingState",	
		"b3OperatingState",
		"b4OperatingState",
		"b5OperatingState"
	};
	std::string activeBand_attr_name= "activeBandId";
	std::vector<std::string> lnaHPowerState_attr_names= {
		"b1LnaHPowerState",
		"b2LnaHPowerState",
		"b3LnaHPowerState",
		"b4LnaHPowerState",
		"b5LnaHPowerState"
	};
	std::vector<std::string> lnaVPowerState_attr_names= {
		"b1LnaVPowerState",
		"b2LnaVPowerState",
		"b3LnaVPowerState",
		"b4LnaVPowerState",
		"b5LnaVPowerState"
	};
	std::vector<std::string> cryoMotorState_attr_names= {
		"b1CryoMotorState",
		"b2CryoMotorState",
		"b345CryoMotorState"
	};
	
	std::vector<std::string> rfe2TempCtrl_attr_names= {
		//"b1Rfe2TempCtrlState",
		//"b2Rfe2TempCtrlState",
		"b3Rfe2TempCtrlState",
		"b4Rfe2TempCtrlState",
		"b5Rfe2TempCtrlState"
	};
	std::vector<std::string> vaValveState_attr_names= {
		"b1VaValveState",
		"b2VaValveState",
		"b345VaValveState"
	};
	std::vector<std::string> amp2_h_attr_names= {
		"b1Amp2HPowerState",
		"b2Amp2HPowerState",
		"b3Amp2HPowerState",
		"b4Amp2HPowerState",
		"b5Amp2HPowerState"
	};	
	std::vector<std::string> amp2_v_attr_names= {
		"b1Amp2VPowerState",
		"b2Amp2VPowerState",
		"b3Amp2VPowerState",
		"b4Amp2VPowerState",
		"b5Amp2VPowerState"
	};
	std::string mode_str= "STANDBY-LP"; 
	std::string feed_mode_str= "STANDBY-LP";
	std::string powerState_str= "LOW-POWER";
	std::string capability_str= "STANDBY"; 
	std::string capability_operate_str= "OPERATE-FULL"; 
	std::string capability_degraded_str= "OPERATE-DEGRADED"; 
	std::string capability_faulty_str= "UNAVAILABLE"; 
	//===========================================================================

	//=====================================================
	//==         CHECK IF CMD ALLOWED
	//=====================================================
	_DEBUG_LOG("Check if cmd "<<__FUNCTION__<<" is allowed...");
	bool check_cmd= true;
	try {
		IsCmdAllowed(__FUNCTION__,check_cmd);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		throw;
	}

	//=====================================================
	//==         CHECK IF TASK IS ALREADY RUNNING
	//=====================================================
	_DEBUG_LOG("Check if a previous set STANDBY-LP mode task is already running...");
	if( strcmp(attr_setStandbyLPModeProgress_read[0],"RUNNING")==0  || strcmp(attr_setStandbyLPModeProgress_read[0],"IDLE")==0 ){
		std::stringstream ss;
		ss<<"Another set OPERATE mode task is running or waiting for execution in device!";
		_INFO_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STANDBY_LP_MODE_FAILED",ss.str());
	}

	//=====================================================
	//==         GET INIT VALUES
	//=====================================================
	//Retrieve mode value corresponding to label
	Tango::DevShort mode;
	Utils_ns::TangoUtils::GetEnumAttrValue(mode,this,mode_attr_name,mode_str);

	//Retrieve powerState value corresponding to label
	Tango::DevShort powerState;
	Utils_ns::TangoUtils::GetEnumAttrValue(powerState,this,powerState_attr_name,powerState_str);

	//Retrieve capabilities corresponding to label
	std::vector<Tango::DevShort> capabilities;
	for(unsigned int i=0;i<cap_attr_names.size();i++){
		Tango::DevShort capability= -1;
		Utils_ns::TangoUtils::GetEnumAttrValue(capability,this,cap_attr_names[i],capability_str);
		capabilities.push_back(capability);
	}

	//Retrieve mode value corresponding to label
	std::vector<Tango::DevShort> feed_modes;
	for(unsigned int i=0;i<feed_mode_attr_names.size();i++){
		Tango::DevShort feed_mode;
		Utils_ns::TangoUtils::GetEnumAttrValue(feed_mode,this,feed_mode_attr_names[i],feed_mode_str);
		feed_modes.push_back(feed_mode);
	}

	//=====================================================
	//==      CHECK CURRENT MODE/POWER/CAPABILITIES
	//=====================================================
	//Get current mode
	Tango::DevShort mode_current;	
	if(GetDynAttrValue(mode_current,mode_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<mode_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STANDBY_LP_MODE_FAILED",ss.str());
	}	

	//Get current powerState
	Tango::DevShort powerState_current= -1;	
	if(GetDynAttrValue(powerState_current,powerState_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<powerState_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STANDBY_LP_MODE_FAILED",ss.str());
	}	

	//Get capability values
	std::vector<Tango::DevShort> capabilities_current;
	
	std::vector<std::string> capabilities_current_str;	
	for(unsigned int i=0;i<cap_attr_names.size();i++){
		Tango::DevShort cap;	
		if(GetDynAttrValue(cap,cap_attr_names[i])<0){
			std::stringstream ss;
			ss<<"Failed to get attr "<<cap_attr_names[i]<<" value!";
			_ERROR_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("SET_STANDBY_LP_MODE_FAILED",ss.str());
		}		
		capabilities_current.push_back(cap);

		std::string cap_str= "";
		Utils_ns::TangoUtils::GetEnumAttrLabelValue(cap_str,this,cap_attr_names[i],cap);
		capabilities_current_str.push_back(cap_str);
	}//end loop capabilities

	//Get capabilities degraded enum
	std::vector<Tango::DevShort> capabilities_degraded;
	for(unsigned int i=0;i<cap_attr_names.size();i++){
		Tango::DevShort cap;	
		Utils_ns::TangoUtils::GetEnumAttrValue(cap,this,cap_attr_names[i],capability_degraded_str);	
		capabilities_degraded.push_back(cap);
	}

	//Check if requested attr values are already activated
	bool alreadyActive= ( 
		(mode==mode_current) && 
		(powerState==powerState_current) 
	);
	if(alreadyActive){
		_INFO_LOG("Requested mode is already active, nothing to be done!");	
		SetStandbyLPStatus("COMPLETED","STANDBY-LP mode already active",true);

		argout->svalue[0] = CORBA::string_dup("STANDBY-LP mode already active");	
		argout->lvalue[0] = 0;
		return argout;
	}


	//=====================================================
	//==    GO STANDBY-LP TASK (PERFORMED IN TASK THREAD)
	//=====================================================
	_INFO_LOG("SetStandbyLP mode task being scheduled...");

	//Prepare message data
	GoStandbyLPMsg msg_data;
	msg_data.task_duration= goStandbyLPTime;
	msg_data.enable_failure= enableStandbyLPFailure;
	msg_data.failure_probability= standbyLPFailureProbability;

	//Init status attr
	SetStandbyLPStatus("IDLE","SetStandbyLP mode command requested",true);
	
	//Post configure message to queue
	bool isSynchronous= false;
	try {	
		m_task->execute_go_standbylp(msg_data, isSynchronous);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		std::string errMsg("Tango exception occurred while executing SetStandbyLP task!");
		_ERROR_LOG(errMsg);
		SetStandbyLPStatus("ABORTED","SetStandbyLP command failed to be scheduled!",true);
		throw;
	}	
	catch(...){
		std::string errMsg("Unknown C++ exception occurred while setting mode to STANDBY-LP!");
		_ERROR_LOG(errMsg);	
		SetStandbyLPStatus("ABORTED","SetStandbyLP command failed to be scheduled!",true);
		_THROW_TANGO_EXCEPTION("SET_STANDBY_LP_MODE_FAILED",errMsg);
	}

	//Set reply 
	argout->svalue[0] = CORBA::string_dup("Go STANDBY-LP mode scheduled");	
	argout->lvalue[0] = 1;

	
	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::set_standby_lpmode
	return argout;
}
//--------------------------------------------------------
/**
 *	Command SetOperateMode related method
 *	Description: Set the SPF sub-element to OPERATE mode. 
 *               This command is expected to last 30 seconds 
 *               at maximum by requirements (TBC) and uses 
 *               the pattern 3 in ICD for reply.
 *               Corresponding command progress status attribute 
 *               is named operateStatus.
 *               
 *               Expected actions on SPF internal components:
 *               
 *               - Close the vacuum valve (if not closed)
 *               - Set the temp set point for all bands (setpoint is set to the default)
 *               - Enable temp controllers for all bands (if not enabled)
 *               - Enable the cryocooler (if not enabled, motor speed set to default)
 *               - Enable LNAs (TBC)
 *               - Set mode attribute to OPERATE
 *
 *	@returns == Long field ==
 *           [0]: return code  {0=OK, 1=QUEUED, 2=FAILED}
 *           
 *           == String field ==
 *           [0]: informative message or description of error/fault
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *SPFEmulator::set_operate_mode()
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "SPFEmulator::SetOperateMode()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::set_operate_mode) ENABLED START -----*/
	
	//	Add your own code
	// == COMMAND BEHAVIOR ==
	// 1) Check if cmd mode-allowed {"STANDBY-LP","MAINTENANCE","OPERATE"} (DONE IN STATE MACHINE)
	// 2) Check if mode transition allowed {"STANDBY-LP","MAINTENANCE","OPERATE"}-->"OPERATE" (DONE IN STATE MACHINE)
	// 3) Check if powerState transition allowed {"LOW-POWER","FULL-POWER"}-->"FULL-POWER" (DONE IN STATE MACHINE)
	// 4) Set spf_mode to OPERATE (there is no transitional mode in ICD!)
	// 5) Set all capabilities to OPERATE-DEGRADED 
	// 6) Start the go cold/operational task [transition may take minutes!]
	// 7) If successful, set power state to FULL-POWER
	// 8) If successful, set capabilities to OPERATE-FULL 
	// 9) Set mode to OPERATE (already done before)

	//Init output argument
	argout= new Tango::DevVarLongStringArray;
	argout->svalue.length(1);
	argout->lvalue.length(1);	
	
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string mode_attr_name= "operatingMode";
	std::string powerState_attr_name= "powerState";
	std::vector<std::string> cap_attr_names= {
		"b1CapabilityState",
		"b2CapabilityState",
		"b3CapabilityState",
		"b4CapabilityState",
		"b5CapabilityState",
	};
	std::string activeBand_attr_name= "activeBandId";
	std::string mode_str= "OPERATE"; 
	std::string mode_safe_str= "STANDBY-LP";
	std::string mode_fault_str= "ERROR"; 
	std::string mode_final_str= "OPERATE";
	std::string powerState_str= "FULL-POWER";
	std::string capability_str= "OPERATE-DEGRADED";
	std::string capability_final_str= "OPERATE-FULL";
	std::string capability_safe_str= "STANDBY";
	std::string capability_faulty_str= "UNAVAILABLE"; 
	//===========================================================================

	_INFO_LOG("Setting SPF to OPERATE mode...");

	//=====================================================
	//==         CHECK IF CMD ALLOWED
	//=====================================================
	_DEBUG_LOG("Check if cmd "<<__FUNCTION__<<" is allowed...");
	bool check_cmd= true;
	try {
		IsCmdAllowed(__FUNCTION__,check_cmd);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		throw;
	}

	//=====================================================
	//==         CHECK IF TASK IS ALREADY RUNNING
	//=====================================================
	_DEBUG_LOG("Check if a previous set OPERATE mode task is already running...");
	if( strcmp(attr_setOperateModeProgress_read[0],"RUNNING")==0  || strcmp(attr_setOperateModeProgress_read[0],"IDLE")==0 ){
		std::stringstream ss;
		ss<<"Another set OPERATE mode task is running or waiting for execution in device!";
		_INFO_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_OPERATE_MODE_FAILED",ss.str());
	}
	
	//=====================================================
	//==         GET INIT VALUES
	//=====================================================
	//Retrieve mode value corresponding to label
	Tango::DevShort mode;
	Tango::DevShort mode_fault;
	Utils_ns::TangoUtils::GetEnumAttrValue(mode,this,mode_attr_name,mode_str);	
	Utils_ns::TangoUtils::GetEnumAttrValue(mode_fault,this,mode_attr_name,mode_fault_str);

	//Retrieve powerState value corresponding to label
	Tango::DevShort powerState;
	Utils_ns::TangoUtils::GetEnumAttrValue(powerState,this,powerState_attr_name,powerState_str);

	//Retrieve powerState value corresponding to label
	Tango::DevShort capability_fault;
	Utils_ns::TangoUtils::GetEnumAttrValue(capability_fault,this,cap_attr_names[0],capability_faulty_str);


	//=====================================================
	//==         INIT CAPABILITY
	//=====================================================
	std::vector<Tango::DevShort> capabilities;
	for(unsigned int i=0;i<cap_attr_names.size();i++){
		Tango::DevShort capability= -1;
		Utils_ns::TangoUtils::GetEnumAttrValue(capability,this,cap_attr_names[i],capability_str);
		capabilities.push_back(capability);
	}

	//=====================================================
	//==      CHECK CURRENT MODE/POWER/CAPABILITIES
	//=====================================================
	//Get current mode
	Tango::DevShort mode_current;	
	if(GetDynAttrValue(mode_current,mode_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<mode_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_OPERATE_MODE_FAILED",ss.str());
	}	

	//Get current powerState
	Tango::DevShort powerState_current;	
	if(GetDynAttrValue(powerState_current,powerState_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<powerState_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_OPERATE_MODE_FAILED",ss.str());
	}	

	//Get capability values
	std::vector<Tango::DevShort> capabilities_current;
	std::vector<std::string> capabilities_current_str;	
	for(unsigned int i=0;i<cap_attr_names.size();i++){
		Tango::DevShort cap;	
		if(GetDynAttrValue(cap,cap_attr_names[i])<0){
			std::stringstream ss;
			ss<<"Failed to get attr "<<cap_attr_names[i]<<" value!";
			_ERROR_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("SET_OPERATE_MODE_FAILED",ss.str());
		}		
		capabilities_current.push_back(cap);

		std::string cap_str= "";
		Utils_ns::TangoUtils::GetEnumAttrLabelValue(cap_str,this,cap_attr_names[i],cap);
		capabilities_current_str.push_back(cap_str);
	}//end loop capabilities

	//Check if requested attr values are already activated
	bool alreadyActive= ( 
		(mode==mode_current) && 
		(powerState==powerState_current)
	);
	if(alreadyActive){
		_INFO_LOG("Requested mode is already active, nothing to be done!");	
		SetOperateStatus("COMPLETED","Operate mode already active",true);

		argout->svalue[0] = CORBA::string_dup("Operate mode already active");	
		argout->lvalue[0] = 0;
		return argout;
	}

	
	//=====================================================
	//==        SET CAPABILITY
	//=====================================================
	//Set capability to OPERATE-DEGRADED and revert back to previous ones in case of fault
	for(unsigned int i=0;i<cap_attr_names.size();i++){
		if(capabilities_current_str[i]!=capability_faulty_str && SetSMDynAttrValue(capabilities[i],cap_attr_names[i],&capabilities_current[i])<0){
			std::stringstream ss;
			ss<<"Failed to set attr "<<cap_attr_names[i]<<" to "<<capabilities[i]<<"!";
			_ERROR_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("SET_OPERATE_MODE_FAILED",ss.str());
		}
	}//end loop capabilities


	//=====================================================
	//==    GO OPERATE TASK (PERFORMED IN TASK THREAD)
	//=====================================================
	_INFO_LOG("Operate task being scheduled...");

	//Prepare message data
	GoOperationalMsg msg_data;
	msg_data.task_duration= goOperationalTime;
	msg_data.enable_failure= enableOperationalFailure;
	msg_data.failure_probability= operationalFailureProbability;

	//Init status attr
	SetOperateStatus("IDLE","Set OPERATE mode command requested",true);
	
	//Post configure message to queue
	bool isSynchronous= false;
	try {	
		m_task->execute_go_operational(msg_data, isSynchronous);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		std::string errMsg("Tango exception occurred while executing SetOperateMode task!");
		_ERROR_LOG(errMsg);
		SetOperateStatus("ABORTED","Operate command failed to be scheduled!",true);
		throw;
	}	
	catch(...){
		std::string errMsg("Unknown C++ exception occurred while setting mode to OPERATE!");
		_ERROR_LOG(errMsg);	
		SetOperateStatus("ABORTED","Operate command failed to be scheduled!",true);
		_THROW_TANGO_EXCEPTION("SET_OPERATE_MODE_FAILED",errMsg);
	}

	//Set reply 
	argout->svalue[0] = CORBA::string_dup("Go operate mode scheduled");	
	argout->lvalue[0] = 1;
	
	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::set_operate_mode
	return argout;
}
//--------------------------------------------------------
/**
 *	Command SetMaintenanceMode related method
 *	Description: Set SPF in MAINTENANCE mode
 *
 *	@returns 
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *SPFEmulator::set_maintenance_mode()
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "SPFEmulator::SetMaintenanceMode()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::set_maintenance_mode) ENABLED START -----*/
	
	//	Add your own code
	// == COMMAND BEHAVIOR ==
	// 1) Check if cmd mode-allowed {"STANDBY-LP","MAINTENANCE","OPERATE"} (DONE IN STATE MACHINE)
	// 2) Check if mode transition allowed {"STANDBY-LP","MAINTENANCE","OPERATE"}-->"MAINTENANCE" (DONE IN STATE MACHINE)
	// 3) Leave power state unchanged
	// 4) Leave capabilities unchanged
	// 5) Set mode to MAINTENANCE
	
	//Init output argument
	argout= new Tango::DevVarLongStringArray;
	argout->svalue.length(1);
	argout->lvalue.length(1);	

	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string mode_attr_name= "operatingMode";
	std::string powerState_attr_name= "powerState";
	std::vector<std::string> cap_attr_names= {
		"b1CapabilityState",
		"b2CapabilityState",
		"b3CapabilityState",
		"b4CapabilityState",
		"b5CapabilityState",
	};
	std::string activeBand_attr_name= "activeBandId";
	std::string mode_str= "MAINTENANCE"; 
	std::string powerState_str= "FULL-POWER";
	std::string capability_str= "STANDBY"; 
	std::string capability_faulty_str= "UNAVAILABLE"; 
	//===========================================================================

	//=====================================================
	//==         CHECK IF CMD ALLOWED
	//=====================================================
	_DEBUG_LOG("Check if cmd "<<__FUNCTION__<<" is allowed...");
	bool check_cmd= true;
	try {
		IsCmdAllowed(__FUNCTION__,check_cmd);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		throw;
	}

	//=====================================================
	//==         CHECK IF TASK IS ALREADY RUNNING
	//=====================================================
	_DEBUG_LOG("Check if a previous set MAINTENANCE mode task is already running...");
	if( strcmp(attr_setMaintenanceModeProgress_read[0],"RUNNING")==0  || strcmp(attr_setMaintenanceModeProgress_read[0],"IDLE")==0 ){
		std::stringstream ss;
		ss<<"Another set MAINTENANCE mode task is running or waiting for execution in device!";
		_INFO_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_MAINTENANCE_MODE_FAILED",ss.str());
	}

	//=====================================================
	//==      CHECK CURRENT MODE
	//=====================================================
	//Retrieve mode value corresponding to label
	Tango::DevShort mode;
	Utils_ns::TangoUtils::GetEnumAttrValue(mode,this,mode_attr_name,mode_str);

	//Get current mode
	Tango::DevShort mode_current;	
	if(GetDynAttrValue(mode_current,mode_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<mode_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_MAINTENANCE_MODE_FAILED",ss.str());
	}	

	//Check if maintenance mode is already active	
	if(mode==mode_current){
		_INFO_LOG("Requested mode "<<mode_str<<" is already active, nothing to be done!");	
		SetMaintenanceStatus("COMPLETED","MAINTENANCE mode already active",true);

		argout->svalue[0] = CORBA::string_dup("MAINTENANCE mode already active");	
		argout->lvalue[0] = 0;
		return argout;
	}
	
	//=====================================================
	//==    GO MAINTENANCE TASK (PERFORMED IN TASK THREAD)
	//=====================================================
	_INFO_LOG("Maintenance task being scheduled...");

	//Prepare message data
	GoMaintenanceMsg msg_data;
	msg_data.task_duration= goMaintenanceTime;
	msg_data.enable_failure= enableMaintenanceFailure;
	msg_data.failure_probability= maintenanceFailureProbability;

	//Init status attr
	SetMaintenanceStatus("IDLE","Set MAINTENANCE mode command requested",true);
	
	//Post configure message to queue
	bool isSynchronous= false;
	try {	
		m_task->execute_go_maintenance(msg_data, isSynchronous);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		std::string errMsg("Tango exception occurred while executing SetMaintenanceMode task!");
		_ERROR_LOG(errMsg);
		SetMaintenanceStatus("ABORTED","Go maintenance command failed to be scheduled!",true);
		throw;
	}	
	catch(...){
		std::string errMsg("Unknown C++ exception occurred while setting mode to MAINTENANCE!");
		_ERROR_LOG(errMsg);	
		SetMaintenanceStatus("ABORTED","Go maintenance command failed to be scheduled!",true);
		_THROW_TANGO_EXCEPTION("SET_MAINTENANCE_MODE_FAILED",errMsg);
	}

	//Set reply 
	argout->svalue[0] = CORBA::string_dup("Go maintenance mode scheduled");	
	argout->lvalue[0] = 1;
	

	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::set_maintenance_mode
	return argout;
}
//--------------------------------------------------------
/**
 *	Command SetSubElementModeStr related method
 *	Description: 
 *
 *	@param argin String mode
 */
//--------------------------------------------------------
void SPFEmulator::set_sub_element_mode_str(Tango::DevString argin)
{
	DEBUG_STREAM << "SPFEmulator::SetSubElementModeStr()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::set_sub_element_mode_str) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string attr_name= "operatingMode";
	//============================================================================

	//=====================================================
	//==         CHECK ARGS
	//=====================================================
	//Get args (INTEGRITY CHECK PERFORMED IN STATE MACHINE CLASS)
	std::string mode_str= std::string(argin);

	//=====================================================
	//==         SET MODE
	//=====================================================
	//Get mode corresponding to string label (ALREADY CHECKED IN STATE MACHINE CLASS)
	Tango::DevShort mode;
	Utils_ns::TangoUtils::GetEnumAttrValue(mode,this,attr_name,mode_str);

	//Return SetSubElementMode cmd
	return set_sub_element_mode(mode);

	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::set_sub_element_mode_str
}
//--------------------------------------------------------
/**
 *	Command Halt related method
 *	Description: Terminate the SPF components, excluding this 
 *               SPFController, in a graceful way and hand over the 
 *               builtin watchdog timer (WDT) to the Linux OS 
 *               so that it will not reset the hardware.
 *               
 *               NB: Once invoked the system cannot be 
 *               started again from the SPFController device. 
 *               For this a manual command over an SSH login terminal 
 *               is required.
 *
 */
//--------------------------------------------------------
void SPFEmulator::halt()
{
	DEBUG_STREAM << "SPFEmulator::Halt()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::halt) ENABLED START -----*/
	
	//	Add your own code
	_THROW_TANGO_EXCEPTION("CMD_NOT_IMPLEMENTED","This command needs to be implemented yet");

	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::halt
}
//--------------------------------------------------------
/**
 *	Command Shutdown related method
 *	Description: Shutdown the SPF components, including the 
 *               SPFController. Only invoked from a STANDBY-LP mode. 
 *               This command has to be used when a power cut occurs 
 *               in the Dish. (TBC)
 *
 */
//--------------------------------------------------------
void SPFEmulator::shutdown()
{
	DEBUG_STREAM << "SPFEmulator::Shutdown()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::shutdown) ENABLED START -----*/
	
	//	Add your own code
	//_THROW_TANGO_EXCEPTION("CMD_NOT_IMPLEMENTED","This command needs to be implemented yet");

	_INFO_LOG("Shutdown SPFC commanded ...");

	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::shutdown
}
//--------------------------------------------------------
/**
 *	Command Restart related method
 *	Description: Performs a complete restart of SPF software components 
 *               excluding the SPFController Tango device itself. 
 *               To restart the SPFController device the corresponding 
 *               Tango adm commands are to be used.
 *               
 *               NB: The command will also cause a hardware reset 
 *               of the SPFC using the built-in watchdog timer (WDT) of 
 *               the ARM processor.
 *
 */
//--------------------------------------------------------
void SPFEmulator::restart()
{
	DEBUG_STREAM << "SPFEmulator::Restart()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::restart) ENABLED START -----*/
	
	//	Add your own code
	_THROW_TANGO_EXCEPTION("CMD_NOT_IMPLEMENTED","This command needs to be implemented yet");

	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::restart
}
//--------------------------------------------------------
/**
 *	Command SetFeedOperateMode related method
 *	Description: Set feed mode to OPERATE mode
 *
 *	@param argin Band id
 *	@returns 
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *SPFEmulator::set_feed_operate_mode(Tango::DevShort argin)
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "SPFEmulator::SetFeedOperateMode()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::set_feed_operate_mode) ENABLED START -----*/
	
	//	Add your own code
	
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string cmd_name= "SetFeedOperateMode";
	std::string mode_attr_name= "operatingMode";
	std::vector<std::string> feed_mode_attr_names {
		"b1OperatingState",
		"b2OperatingState",	
		"b3OperatingState",
		"b4OperatingState",
		"b5OperatingState"
	};
	int nBands= 5;
	//============================================================================

	//Init output argument
	argout= new Tango::DevVarLongStringArray;
	argout->svalue.length(1);
	argout->lvalue.length(1);	

	//=====================================================
	//==         CHECK STATE MACHINE
	//=====================================================
	_DEBUG_LOG("Check if cmd "<<__FUNCTION__<<" is allowed...");
	bool check_cmd= true;
	try {
		IsCmdAllowed(__FUNCTION__,check_cmd);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		throw;
	}

	//=====================================================
	//==         GET ARGS
	//=====================================================
	Tango::DevShort bandId= argin;
	
	//Check bandId arg
	if(bandId<=0 || bandId>nBands){
		std::stringstream ss;
		ss<<"Invalid bandId arg given ("<<bandId<<"), valid values are in range [1,"<<nBands<<"]!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_FEED_OPERATE_MODE_FAILED",ss.str());
	}

	//=====================================================
	//==         CHECK IF TASK IS ALREADY RUNNING
	//=====================================================
	_DEBUG_LOG("Check if a set feed OPERATE task is already running...");
	std::string taskStatus= "";
	if(bandId==1) taskStatus= std::string(attr_setB1FeedOperateModeProgress_read[0]);
	else if(bandId==2) taskStatus= std::string(attr_setB2FeedOperateModeProgress_read[0]);
	else if(bandId==3) taskStatus= std::string(attr_setB3FeedOperateModeProgress_read[0]);
	else if(bandId==4) taskStatus= std::string(attr_setB4FeedOperateModeProgress_read[0]);
	else if(bandId==5) taskStatus= std::string(attr_setB5FeedOperateModeProgress_read[0]);

	if( taskStatus=="RUNNING"  || taskStatus=="IDLE" ){
		std::stringstream ss;
		ss<<"Another set feed OPERATE task for band "<<bandId<<" is running or waiting for execution in device!";
		_INFO_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_FEED_OPERATE_MODE_FAILED",ss.str());	
	}


	//=====================================================
	//==         CHECK FEED MODE
	//=====================================================
	//Retrieve current feed mode attr value
	Tango::DevShort current_feed_mode;
	if(GetDynAttrValue(current_feed_mode,feed_mode_attr_names[bandId-1])<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<feed_mode_attr_names[bandId-1]<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_FEED_OPERATE_MODE_FAILED",ss.str());
	}

	//Check feed mode arg (if valid enumeration)
	std::string current_feed_mode_str= "";
	Utils_ns::TangoUtils::GetEnumAttrLabelValue(current_feed_mode_str,this,feed_mode_attr_names[bandId-1],current_feed_mode);

	//Check if same feed mode is given
	if(current_feed_mode_str=="OPERATE"){
		_INFO_LOG("Requested feed mode is already active, nothing to be done!");	
		SetFeedOperateStatus(bandId,"COMPLETED","Requested feed mode already active",true);

		argout->svalue[0] = CORBA::string_dup("Requested feed mode already active");	
		argout->lvalue[0] = 0;
		return argout;
	}	
	

	//=====================================================
	//==    SET FEED OPERATE TASK (PERFORMED IN TASK THREAD)
	//=====================================================
	_INFO_LOG("Set feed to OPERATE mode task being scheduled...");

	//Prepare message data
	FeedGoOperateMsg msg_data;
	msg_data.task_duration= goOperationalTime;
	msg_data.enable_failure= enableOperationalFailure;
	msg_data.failure_probability= operationalFailureProbability;
	msg_data.bandId= bandId;

	//Init status attr
	SetFeedOperateStatus(bandId,"IDLE","Set feed to OPERATE mode command requested",true);
	
	//Post configure message to queue
	bool isSynchronous= false;
	try {	
		m_task->execute_go_feed_operate(msg_data, isSynchronous);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		std::string errMsg("Tango exception occurred while commading task!");
		_ERROR_LOG(errMsg);
		SetFeedOperateStatus(bandId,"ABORTED","Set feed to OPERATE command failed to be scheduled!",true);
		throw;
	}	
	catch(...){
		std::string errMsg("Unknown C++ exception occurred while commanding task!");
		_ERROR_LOG(errMsg);	
		SetFeedOperateStatus(bandId,"ABORTED","Set feed to OPERATE command failed to be scheduled!",true);
		_THROW_TANGO_EXCEPTION("SET_FEED_OPERATE_MODE_FAILED",errMsg);
	}

	//Set reply 
	argout->svalue[0] = CORBA::string_dup("Set feed mode to OPERATE scheduled");	
	argout->lvalue[0] = 1;

	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::set_feed_operate_mode
	return argout;
}
//--------------------------------------------------------
/**
 *	Command SetFeedStandbyLPMode related method
 *	Description: Set feed to STANDBY-LP mode
 *
 *	@param argin Band id
 *	@returns 
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *SPFEmulator::set_feed_standby_lpmode(Tango::DevShort argin)
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "SPFEmulator::SetFeedStandbyLPMode()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::set_feed_standby_lpmode) ENABLED START -----*/
	
	//	Add your own code

	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string cmd_name= "SetFeedStandbyLPMode";
	std::string mode_attr_name= "operatingMode";
	std::vector<std::string> feed_mode_attr_names {
		"b1OperatingState",
		"b2OperatingState",	
		"b3OperatingState",
		"b4OperatingState",
		"b5OperatingState"
	};
	std::vector<std::string> cap_attr_names= {
		"b1CapabilityState",
		"b2CapabilityState",
		"b3CapabilityState",
		"b4CapabilityState",
		"b5CapabilityState",
	};
	std::string feed_mode_str= "STANDBY-LP";
	std::string capability_str= "STANDBY";
	int nBands= 5;
	//============================================================================

	//Init output argument
	argout= new Tango::DevVarLongStringArray;
	argout->svalue.length(1);
	argout->lvalue.length(1);	

	//=====================================================
	//==         CHECK STATE MACHINE
	//=====================================================
	_DEBUG_LOG("Check if cmd "<<__FUNCTION__<<" is allowed...");
	bool check_cmd= true;
	try {
		IsCmdAllowed(__FUNCTION__,check_cmd);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		throw;
	}

	//=====================================================
	//==         GET ARGS
	//=====================================================
	Tango::DevShort bandId= argin;
	
	//Check bandId arg
	if(bandId<=0 || bandId>nBands){
		std::stringstream ss;
		ss<<"Invalid bandId arg given ("<<bandId<<"), valid values are in range [1,"<<nBands<<"]!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_FEED_STANDBY_LP_MODE_FAILED",ss.str());
	}

	//=====================================================
	//==         CHECK IF TASK IS ALREADY RUNNING
	//=====================================================
	_DEBUG_LOG("Check if a set feed STANDBY-LP task is already running...");
	
	std::string taskStatus= "";
	if(bandId==1) taskStatus= std::string(attr_setB1FeedStandbyLPModeProgress_read[0]);
	else if(bandId==2) taskStatus= std::string(attr_setB2FeedStandbyLPModeProgress_read[0]);
	else if(bandId==3) taskStatus= std::string(attr_setB3FeedStandbyLPModeProgress_read[0]);
	else if(bandId==4) taskStatus= std::string(attr_setB4FeedStandbyLPModeProgress_read[0]);
	else if(bandId==5) taskStatus= std::string(attr_setB5FeedStandbyLPModeProgress_read[0]);

	if( taskStatus=="RUNNING"  || taskStatus=="IDLE" ){
		std::stringstream ss;
		ss<<"Another set feed STANDBY-LP task for band "<<bandId<<" is running or waiting for execution in device!";
		_INFO_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_FEED_STANDBY_LP_MODE_FAILED",ss.str());	
	}
	
	//=====================================================
	//==         CHECK FEED MODE
	//=====================================================
	//Retrieve current feed mode attr value
	Tango::DevShort current_feed_mode;
	if(GetDynAttrValue(current_feed_mode,feed_mode_attr_names[bandId-1])<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<feed_mode_attr_names[bandId-1]<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_FEED_STANDBY_LP_MODE_FAILED",ss.str());
	}

	//Check feed mode arg (if valid enumeration)
	std::string current_feed_mode_str= "";
	Utils_ns::TangoUtils::GetEnumAttrLabelValue(current_feed_mode_str,this,feed_mode_attr_names[bandId-1],current_feed_mode);

	//Check if same feed mode is given
	if(current_feed_mode_str=="STANDBY-LP"){
		_INFO_LOG("Requested feed mode is already active, nothing to be done!");	
		SetFeedStandbyLPStatus(bandId,"COMPLETED","Requested feed mode already active",true);

		argout->svalue[0] = CORBA::string_dup("Requested feed mode already active");	
		argout->lvalue[0] = 0;
		return argout;
	}	
	

	//=====================================================
	//==    GO FEED STANDBY TASK (PERFORMED IN TASK THREAD)
	//=====================================================
	_INFO_LOG("Set feed to STANDBY-LP mode task being scheduled...");

	//Prepare message data
	FeedGoStandbyLPMsg msg_data;
	msg_data.task_duration= goStandbyLPTime;
	msg_data.enable_failure= enableStandbyLPFailure;
	msg_data.failure_probability= standbyLPFailureProbability;
	msg_data.bandId= bandId;

	//Init status attr
	SetFeedStandbyLPStatus(bandId,"IDLE","Set feed to STANDBY-LP mode command requested",true);
	
	//Post configure message to queue
	bool isSynchronous= false;
	try {	
		m_task->execute_go_feed_standby_lp(msg_data, isSynchronous);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		std::string errMsg("Tango exception occurred while commading task!");
		_ERROR_LOG(errMsg);
		SetFeedOperateStatus(bandId,"ABORTED","Set feed to STANDBY-LP mode command failed to be scheduled!",true);
		throw;
	}	
	catch(...){
		std::string errMsg("Unknown C++ exception occurred while commanding task!");
		_ERROR_LOG(errMsg);	
		SetFeedOperateStatus(bandId,"ABORTED","Set feed to STANDBY_LP mode command failed to be scheduled!",true);
		_THROW_TANGO_EXCEPTION("SET_FEED_STANDBY_LP_MODE_FAILED",errMsg);
	}

	//Set reply 
	argout->svalue[0] = CORBA::string_dup("Set feed mode to STANDBY-LP scheduled");	
	argout->lvalue[0] = 1;

	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::set_feed_standby_lpmode
	return argout;
}
//--------------------------------------------------------
/**
 *	Command SetFeedMaintenanceMode related method
 *	Description: Set feed to MAINTENANCE mode
 *
 *	@param argin bandId
 *	@returns 
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *SPFEmulator::set_feed_maintenance_mode(Tango::DevShort argin)
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "SPFEmulator::SetFeedMaintenanceMode()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::set_feed_maintenance_mode) ENABLED START -----*/
	
	//	Add your own code

	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string cmd_name= "SetFeedMaintenanceMode";
	std::string mode_attr_name= "operatingMode";
	std::vector<std::string> feed_mode_attr_names {
		"b1OperatingState",
		"b2OperatingState",	
		"b3OperatingState",
		"b4OperatingState",
		"b5OperatingState"
	};
	std::string feed_mode_str= "MAINTENANCE";
	int nBands= 5;
	//============================================================================

	//Init output argument
	argout= new Tango::DevVarLongStringArray;
	argout->svalue.length(1);
	argout->lvalue.length(1);	

	//=====================================================
	//==         CHECK STATE MACHINE
	//=====================================================
	_DEBUG_LOG("Check if cmd "<<__FUNCTION__<<" is allowed...");
	bool check_cmd= true;
	try {
		IsCmdAllowed(__FUNCTION__,check_cmd);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		throw;
	}

	//=====================================================
	//==         GET ARGS
	//=====================================================
	Tango::DevShort bandId= argin;
	
	//Check bandId arg
	if(bandId<=0 || bandId>nBands){
		std::stringstream ss;
		ss<<"Invalid bandId arg given ("<<bandId<<"), valid values are in range [1,"<<nBands<<"]!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_FEED_MAINTENANCE_MODE_FAILED",ss.str());
	}

	
	//=====================================================
	//==         CHECK FEED MODE
	//=====================================================
	//Retrieve current feed mode attr value
	Tango::DevShort current_feed_mode;
	if(GetDynAttrValue(current_feed_mode,feed_mode_attr_names[bandId-1])<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<feed_mode_attr_names[bandId-1]<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_FEED_MAINTENANCE_MODE_FAILED",ss.str());
	}

	//Check feed mode arg (if valid enumeration)
	std::string current_feed_mode_str= "";
	Utils_ns::TangoUtils::GetEnumAttrLabelValue(current_feed_mode_str,this,feed_mode_attr_names[bandId-1],current_feed_mode);

	//Check if same feed mode is given
	if(current_feed_mode_str==feed_mode_str){
		_INFO_LOG("Requested feed mode is already active, nothing to be done!");	
		argout->svalue[0] = CORBA::string_dup("Requested feed mode already active");	
		argout->lvalue[0] = 0;
		return argout;
	}	
	

	//=====================================================
	//==      SET FEED MODE TO MAINTENANCE
	//=====================================================
	//Set feed mode to MAINTENANCE
	Tango::DevShort feed_mode;
	Utils_ns::TangoUtils::GetEnumAttrValue(feed_mode,this,feed_mode_attr_names[bandId-1],feed_mode_str);	

	if(SetSMDynAttrValue(feed_mode,feed_mode_attr_names[bandId-1],&current_feed_mode)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<feed_mode_attr_names[bandId-1]<<" to "<<feed_mode<<"!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_FEED_MAINTENANCE_MODE_FAILED",ss.str());
	}
	

	//Reply
	argout->svalue[0] = CORBA::string_dup("Set feed to MAINTENANCE mode completed with success");	
	argout->lvalue[0] = 0;

	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::set_feed_maintenance_mode
	return argout;
}
//--------------------------------------------------------
/**
 *	Command SetFeedClearErrorsAndRestartMode related method
 *	Description: Set feed to ERROR mode
 *               
 *               NB: Deprecated after ICD update in July 2017
 *
 *	@param argin bandId
 *	@returns 
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *SPFEmulator::set_feed_clear_errors_and_restart_mode(Tango::DevShort argin)
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "SPFEmulator::SetFeedClearErrorsAndRestartMode()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::set_feed_clear_errors_and_restart_mode) ENABLED START -----*/
	
	//	Add your own code

	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string cmd_name= "SetFeedClearErrorsAndRestartMode";
	std::string mode_attr_name= "operatingMode";
	std::vector<std::string> feed_mode_attr_names {
		"b1OperatingState",
		"b2OperatingState",	
		"b3OperatingState",
		"b4OperatingState",
		"b5OperatingState"
	};
	std::string feed_mode_str= "ERROR";
	int nBands= 5;
	//============================================================================

	//Init output argument
	argout= new Tango::DevVarLongStringArray;
	argout->svalue.length(1);
	argout->lvalue.length(1);	

	//=====================================================
	//==         CHECK STATE MACHINE
	//=====================================================
	_DEBUG_LOG("Check if cmd "<<__FUNCTION__<<" is allowed...");
	bool check_cmd= true;
	try {
		IsCmdAllowed(__FUNCTION__,check_cmd);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		throw;
	}

	//=====================================================
	//==         GET ARGS
	//=====================================================
	Tango::DevShort bandId= argin;
	
	//Check bandId arg
	if(bandId<=0 || bandId>nBands){
		std::stringstream ss;
		ss<<"Invalid bandId arg given ("<<bandId<<"), valid values are in range [1,"<<nBands<<"]!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_FEED_CLEAR_ERRORS_AND_RESTART_MODE_FAILED",ss.str());
	}

	
	//=====================================================
	//==         CHECK FEED MODE
	//=====================================================
	//Retrieve current feed mode attr value
	Tango::DevShort current_feed_mode;
	if(GetDynAttrValue(current_feed_mode,feed_mode_attr_names[bandId-1])<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<feed_mode_attr_names[bandId-1]<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_FEED_CLEAR_ERRORS_AND_RESTART_MODE_FAILED",ss.str());
	}

	//Check feed mode arg (if valid enumeration)
	std::string current_feed_mode_str= "";
	Utils_ns::TangoUtils::GetEnumAttrLabelValue(current_feed_mode_str,this,feed_mode_attr_names[bandId-1],current_feed_mode);

	//Check if same feed mode is given
	if(current_feed_mode_str==feed_mode_str){
		_INFO_LOG("Requested feed mode is already active, nothing to be done!");	
		argout->svalue[0] = CORBA::string_dup("Requested feed mode already active");	
		argout->lvalue[0] = 0;
		return argout;
	}	
	

	//=====================================================
	//==      SET FEED MODE TO CLEAR-ERRORS-AND-RESTART
	//=====================================================
	//Set feed mode to CLEAR-ERRORS-AND-RESTART 
	Tango::DevShort feed_mode;
	Utils_ns::TangoUtils::GetEnumAttrValue(feed_mode,this,feed_mode_attr_names[bandId-1],feed_mode_str);	

	if(SetSMDynAttrValue(feed_mode,feed_mode_attr_names[bandId-1],&current_feed_mode)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<feed_mode_attr_names[bandId-1]<<" to "<<feed_mode<<"!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_FEED_CLEAR_ERRORS_AND_RESTART_MODE_FAILED",ss.str());
	}
	

	//Reply
	argout->svalue[0] = CORBA::string_dup("Set feed in ERROR mode completed with success");	
	argout->lvalue[0] = 0;

	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::set_feed_clear_errors_and_restart_mode
	return argout;
}
//--------------------------------------------------------
/**
 *	Command SetFeedRegenerationMode related method
 *	Description: Set feed to REGENERATION mode
 *               
 *               NB: Deprecated after ICD update in July 2017
 *
 *	@param argin bandId
 *	@returns 
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *SPFEmulator::set_feed_regeneration_mode(Tango::DevShort argin)
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "SPFEmulator::SetFeedRegenerationMode()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::set_feed_regeneration_mode) ENABLED START -----*/
	
	//	Add your own code
	
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string cmd_name= "SetFeedRegenerationMode";
	std::string mode_attr_name= "operatingMode";
	std::vector<std::string> feed_mode_attr_names {
		"b1OperatingState",
		"b2OperatingState",	
		"b3OperatingState",
		"b4OperatingState",
		"b5OperatingState"
	};
	int nBands= 5;
	//============================================================================

	//Init output argument
	argout= new Tango::DevVarLongStringArray;
	argout->svalue.length(1);
	argout->lvalue.length(1);	


	//=====================================================
	//==         CHECK STATE MACHINE
	//=====================================================
	_DEBUG_LOG("Check if cmd "<<__FUNCTION__<<" is allowed...");
	bool check_cmd= true;
	try {
		IsCmdAllowed(__FUNCTION__,check_cmd);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		throw;
	}

	//=====================================================
	//==         GET ARGS
	//=====================================================
	Tango::DevShort bandId= argin;
	
	//Check bandId arg
	if(bandId<=0 || bandId>nBands){
		std::stringstream ss;
		ss<<"Invalid bandId arg given ("<<bandId<<"), valid values are in range [1,"<<nBands<<"]!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_FEED_REGENERATION_MODE_FAILED",ss.str());
	}

	//=====================================================
	//==         CHECK IF TASK IS ALREADY RUNNING
	//=====================================================
	_DEBUG_LOG("Check if a set feed REGENERATION task is already running...");
	
	std::string taskStatus= "";
	if(bandId==1) taskStatus= std::string(attr_setB1FeedRegenerationModeProgress_read[0]);
	else if(bandId==2) taskStatus= std::string(attr_setB2FeedRegenerationModeProgress_read[0]);
	else if(bandId==3) taskStatus= std::string(attr_setB3FeedRegenerationModeProgress_read[0]);
	else if(bandId==4) taskStatus= std::string(attr_setB4FeedRegenerationModeProgress_read[0]);
	else if(bandId==5) taskStatus= std::string(attr_setB5FeedRegenerationModeProgress_read[0]);

	if( taskStatus=="RUNNING"  || taskStatus=="IDLE" ){
		std::stringstream ss;
		ss<<"Another set feed REGENERATION task for band "<<bandId<<" is running or waiting for execution in device!";
		_INFO_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_FEED_REGENERATION_MODE_FAILED",ss.str());	
	}
	
	//=====================================================
	//==         CHECK FEED MODE
	//=====================================================
	//Retrieve current feed mode attr value
	Tango::DevShort current_feed_mode;
	if(GetDynAttrValue(current_feed_mode,feed_mode_attr_names[bandId-1])<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<feed_mode_attr_names[bandId-1]<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_FEED_REGENERATION_MODE_FAILED",ss.str());
	}

	//Check feed mode arg (if valid enumeration)
	std::string current_feed_mode_str= "";
	Utils_ns::TangoUtils::GetEnumAttrLabelValue(current_feed_mode_str,this,feed_mode_attr_names[bandId-1],current_feed_mode);

	//Check if same feed mode is given
	if(current_feed_mode_str=="REGENERATION"){
		_INFO_LOG("Requested feed mode is already active, nothing to be done!");	
		SetFeedRegenerationStatus(bandId,"COMPLETED","Requested feed mode already active",true);

		argout->svalue[0] = CORBA::string_dup("Requested feed mode already active");	
		argout->lvalue[0] = 0;
		return argout;
	}	
	

	//=====================================================
	//==    GO FEED REGENERATION TASK (PERFORMED IN TASK THREAD)
	//=====================================================
	_INFO_LOG("Set feed to REGENERATION mode task being scheduled...");

	//Prepare message data
	FeedGoRegenerationMsg msg_data;
	msg_data.task_duration= goOperationalTime;
	msg_data.enable_failure= enableOperationalFailure;
	msg_data.failure_probability= operationalFailureProbability;
	msg_data.bandId= bandId;

	//Init status attr
	SetFeedRegenerationStatus(bandId,"IDLE","Set feed to REGENERATION mode command requested",true);
	
	//Post configure message to queue
	bool isSynchronous= false;
	try {	
		m_task->execute_go_feed_regeneration(msg_data, isSynchronous);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		std::string errMsg("Tango exception occurred while commading task!");
		_ERROR_LOG(errMsg);
		SetFeedRegenerationStatus(bandId,"ABORTED","Set feed to regeneration command failed to be scheduled!",true);
		throw;
	}	
	catch(...){
		std::string errMsg("Unknown C++ exception occurred while commanding task!");
		_ERROR_LOG(errMsg);	
		SetFeedRegenerationStatus(bandId,"ABORTED","Set feed to regeneration command failed to be scheduled!",true);
		_THROW_TANGO_EXCEPTION("SET_OPERATE_MODE_FAILED",errMsg);
	}

	//Set reply 
	argout->svalue[0] = CORBA::string_dup("Set feed mode to REGENERATION scheduled");	
	argout->lvalue[0] = 1;

	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::set_feed_regeneration_mode
	return argout;
}
//--------------------------------------------------------
/**
 *	Command SetCalSourceTempSetPointsToDefault related method
 *	Description: Set calibration source temperature setpoints for all bands to default values
 *
 */
//--------------------------------------------------------
void SPFEmulator::set_cal_source_temp_set_points_to_default()
{
	DEBUG_STREAM << "SPFEmulator::SetCalSourceTempSetPointsToDefault()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::set_cal_source_temp_set_points_to_default) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::vector<std::string> calSourceDefaultSetPointAttrNames= {
		"b1DefaultCalSourceTempSetPoint",	
		"b2DefaultCalSourceTempSetPoint",
		"b3DefaultCalSourceTempSetPoint",
		"b4DefaultCalSourceTempSetPoint",
		"b5DefaultCalSourceTempSetPoint"
	};	
	std::vector<std::string> calSourceSetPointAttrNames= {
		"b1CalSourceTempSetPoint",	
		"b2CalSourceTempSetPoint",
		"b3CalSourceTempSetPoint",
		"b4CalSourceTempSetPoint",
		"b5CalSourceTempSetPoint"
	};
	//============================================================================

	//=====================================================
	//==         SET CAL SOURCE SET POINT TO DEFAULT
	//=====================================================
	//Initialize cal source temp set point to default values
	_DEBUG_LOG("Setting SPF cal source temp set point to defaults...");

	for(size_t i=0;i<calSourceSetPointAttrNames.size();i++){
		//- Get default setpoint		
		Tango::DevShort calSourceSetPointDefaultValue;
		if(GetDynAttrValue<Tango::DevShort>(calSourceSetPointDefaultValue,calSourceDefaultSetPointAttrNames[i])<0){
			std::stringstream ss;
			ss<<"Failed to get attr "<<calSourceDefaultSetPointAttrNames[i]<<" value!";
			_ERROR_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("SET_CAL_SOURCE_TEMP_SETPOINTS_TO_DEFAULT_FAILED",ss.str());
		}	
	
		//- Set setpoint to current default
		std::string attr_name= calSourceSetPointAttrNames[i];
		if( SetDynAttrValue<Tango::DevEnum>(calSourceSetPointDefaultValue,attr_name)<0 ){
			std::stringstream ss;
			ss<<"Failed to set attr "<<attr_name<<" value!";
			_ERROR_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("SET_CAL_SOURCE_TEMP_SETPOINTS_TO_DEFAULT_FAILED",ss.str());
		}	
	}//end loop cal source setpoints

	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::set_cal_source_temp_set_points_to_default
}
//--------------------------------------------------------
/**
 *	Command SetTempSetPointsToDefault related method
 *	Description: Set temperature set points to default values
 *
 */
//--------------------------------------------------------
void SPFEmulator::set_temp_set_points_to_default()
{
	DEBUG_STREAM << "SPFEmulator::SetTempSetPointsToDefault()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::set_temp_set_points_to_default) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::vector<std::string> rfe1DefaultSetPointAttrNames= {
		"b1DefaultLnaHTempSetPoint",
		"b1DefaultLnaVTempSetPoint",
		"b2DefaultRfe1TempSetPoint",
		"b3DefaultRfe1TempSetPoint",
		"b4DefaultRfe1TempSetPoint",
		"b5DefaultRfe1TempSetPoint"
	};	
	std::vector<std::string> rfe1SetPointAttrNames= {
		//"b1Rfe1TempSetPoint",	
		"b1LnaHTempSetPoint",
		"b1LnaVTempSetPoint",
		"b2Rfe1TempSetPoint",
		"b3Rfe1TempSetPoint",
		"b4Rfe1TempSetPoint",
		"b5Rfe1TempSetPoint"
	};

	std::vector<std::string> rfe2DefaultSetPointAttrNames= {
		//"b1DefaultRfe2TempSetPoint",	
		"b3DefaultRfe2TempSetPoint",
		"b4DefaultRfe2TempSetPoint",
		"b5DefaultRfe2TempSetPoint"
	};	
	std::vector<std::string> rfe2SetPointAttrNames= {
		//"b1Rfe2TempSetPoint",	
		"b3Rfe2TempSetPoint",
		"b4Rfe2TempSetPoint",
		"b5Rfe2TempSetPoint"
	};
	//============================================================================

	//=====================================================
	//==         SET RFE-1 SET POINT TO DEFAULT
	//=====================================================
	//Initialize RFE1 temp set point to default values
	_DEBUG_LOG("Initializing SPF rfe1_tempSetPoint...");

	for(size_t i=0;i<rfe1SetPointAttrNames.size();i++){
		//- Get RFE default setpoint		
		Tango::DevShort rfe1SetPointDefaultValue;
		if(GetDynAttrValue<Tango::DevShort>(rfe1SetPointDefaultValue,rfe1DefaultSetPointAttrNames[i])<0){
			std::stringstream ss;
			ss<<"Failed to get attr "<<rfe1DefaultSetPointAttrNames[i]<<" value!";
			_ERROR_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("SET_TEMP_SETPOINTS_TO_DEFAULT_FAILED",ss.str());
		}	
	
		//- Set RFE setpoint to current default
		std::string rfe_attr_name= rfe1SetPointAttrNames[i];
		if( SetDynAttrValue<Tango::DevEnum>(rfe1SetPointDefaultValue,rfe_attr_name)<0 ){
			std::stringstream ss;
			ss<<"Failed to set attr "<<rfe_attr_name<<" value!";
			_ERROR_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("SET_TEMP_SETPOINTS_TO_DEFAULT_FAILED",ss.str());
		}	
	}//end loop rfe setpoints

	//=====================================================
	//==         SET RFE-2 SET POINT TO DEFAULT
	//=====================================================
	//Initialize RFE2 temp set point to default values
	_DEBUG_LOG("Initializing SPF rfe2_tempSetPoint...");

	for(size_t i=0;i<rfe2SetPointAttrNames.size();i++){
		//- Get RFE default setpoint		
		Tango::DevShort rfe2SetPointDefaultValue;
		if(GetDynAttrValue<Tango::DevShort>(rfe2SetPointDefaultValue,rfe2DefaultSetPointAttrNames[i])<0){
			std::stringstream ss;
			ss<<"Failed to get attr "<<rfe2DefaultSetPointAttrNames[i]<<" value!";
			_ERROR_LOG(ss.str());	
			_THROW_TANGO_EXCEPTION("SET_TEMP_SETPOINTS_TO_DEFAULT_FAILED",ss.str());
		}	
	
		//- Set RFE setpoint to current default
		std::string rfe_attr_name= rfe2SetPointAttrNames[i];
		if( SetDynAttrValue<Tango::DevEnum>(rfe2SetPointDefaultValue,rfe_attr_name)<0 ){
			std::stringstream ss;
			ss<<"Failed to set attr "<<rfe_attr_name<<" value!";
			_ERROR_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("SET_TEMP_SETPOINTS_TO_DEFAULT_FAILED",ss.str());
		}	
	}//end loop rfe setpoints

	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::set_temp_set_points_to_default
}
//--------------------------------------------------------
/**
 *	Command dummyDynCmd related method
 *	Description: 
 *
 */
//--------------------------------------------------------
void SPFEmulator::dummy_dyn_cmd(Tango::Command &command)
{
	DEBUG_STREAM << "SPFEmulator::" << command.get_name() << "  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SPFEmulator::dummy_dyn_cmd) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::dummy_dyn_cmd
}
//--------------------------------------------------------
/**
 *	Method      : SPFEmulator::add_dynamic_commands()
 *	Description : Create the dynamic commands if any
 *                for specified device.
 */
//--------------------------------------------------------
void SPFEmulator::add_dynamic_commands()
{
	//	Example to add dynamic command:
	//	Copy inside the folowing protected area to instanciate at startup.
	//	add_dummyDynCmd_dynamic_command("MydummyDynCmdCommand", true);
	
	/*----- PROTECTED REGION ID(SPFEmulator::add_dynamic_commands) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic commands if any
	
	/*----- PROTECTED REGION END -----*/	//	SPFEmulator::add_dynamic_commands
}

/*----- PROTECTED REGION ID(SPFEmulator::namespace_ending) ENABLED START -----*/

//	Additional Methods
int SPFEmulator::InitCmdAttrStateMachine(){

	_DEBUG_LOG("Initializing the cmd-attr state machine for device "<<device_name<<"...");

	//===============================================
	//==     ATTR WRITE RULES
	//===============================================

	//- Operating mode (write only in test mode)
	_REGISTER_ATTR_WRITE_RULE(bool,"operatingMode","testMode",(true));

	//- Power state (write only in test mode)
	_REGISTER_ATTR_WRITE_RULE(bool,"powerState","testMode",(true));

	//- Band capabilities
	_REGISTER_ATTR_WRITE_RULE(bool,"b1CapabilityState","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b2CapabilityState","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b3CapabilityState","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b4CapabilityState","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b5CapabilityState","testMode",(true));
	
	//- Health state
	_REGISTER_ATTR_WRITE_RULE(bool,"healthState","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b1HealthState","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b2HealthState","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b3HealthState","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b4HealthState","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b5HealthState","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"heHealthState","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"vaHealthState","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"spfcHealthState","testMode",(true));

	//- Operating state
	_REGISTER_ATTR_WRITE_RULE(bool,"b1OperatingState","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b2OperatingState","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b3OperatingState","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b4OperatingState","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b5OperatingState","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"heOperatingState","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"vaOperatingState","testMode",(true));

	//- Controller supply voltage/current/temp
	_REGISTER_ATTR_WRITE_RULE(bool,"spfcSupplyVoltage","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"spfcSupplyCurrent","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"spfcTemperature","testMode",(true));
	
	//- Helium compressor supply pressure/temp
	_REGISTER_ATTR_WRITE_RULE(bool,"heCompSupplyPressure","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"heCompReturnPressure","testMode",(true));
	
	//- LNA attrs
	_REGISTER_ATTR_WRITE_RULE(bool,"b1LnaHDrainVoltage","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b2LnaHDrainVoltage","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b3LnaHDrainVoltage","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b4LnaHDrainVoltage","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b5LnaHDrainVoltage","testMode",(true));
	
	_REGISTER_ATTR_WRITE_RULE(bool,"b1LnaVDrainVoltage","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b2LnaVDrainVoltage","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b3LnaVDrainVoltage","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b4LnaVDrainVoltage","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b5LnaVDrainVoltage","testMode",(true));

	_REGISTER_ATTR_WRITE_RULE(bool,"b1LnaHGateVoltage","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b2LnaHGateVoltage","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b3LnaHGateVoltage","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b4LnaHGateVoltage","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b5LnaHGateVoltage","testMode",(true));

	_REGISTER_ATTR_WRITE_RULE(bool,"b1LnaVGateVoltage","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b2LnaVGateVoltage","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b3LnaVGateVoltage","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b4LnaVGateVoltage","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b5LnaVGateVoltage","testMode",(true));
	
	_REGISTER_ATTR_WRITE_RULE(bool,"b1LnaHDrainCurrent","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b2LnaHDrainCurrent","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b3LnaHDrainCurrent","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b4LnaHDrainCurrent","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b5LnaHDrainCurrent","testMode",(true));

	_REGISTER_ATTR_WRITE_RULE(bool,"b1LnaVDrainCurrent","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b2LnaVDrainCurrent","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b3LnaVDrainCurrent","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b4LnaVDrainCurrent","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b5LnaVDrainCurrent","testMode",(true));

	//- Amp2 attrs
	_REGISTER_ATTR_WRITE_RULE(bool,"b1Amp2HVoltage","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b2Amp2HVoltage","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b3Amp2HVoltage","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b4Amp2HVoltage","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b5Amp2HVoltage","testMode",(true));

	_REGISTER_ATTR_WRITE_RULE(bool,"b1Amp2VVoltage","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b2Amp2VVoltage","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b3Amp2VVoltage","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b4Amp2VVoltage","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b5Amp2VVoltage","testMode",(true));
	
	_REGISTER_ATTR_WRITE_RULE(bool,"b1Amp2HCurrent","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b2Amp2HCurrent","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b3Amp2HCurrent","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b4Amp2HCurrent","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b5Amp2HCurrent","testMode",(true));

	_REGISTER_ATTR_WRITE_RULE(bool,"b1Amp2VCurrent","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b2Amp2VCurrent","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b3Amp2VCurrent","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b4Amp2VCurrent","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b5Amp2VCurrent","testMode",(true));

	//- Cal source attrs
	_REGISTER_ATTR_WRITE_RULE(bool,"b1CalSourceCurrent","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b2CalSourceCurrent","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b3CalSourceCurrent","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b4CalSourceCurrent","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b5CalSourceCurrent","testMode",(true));

	_REGISTER_ATTR_WRITE_RULE(bool,"b1CalSourceVoltage","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b2CalSourceVoltage","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b3CalSourceVoltage","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b4CalSourceVoltage","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b5CalSourceVoltage","testMode",(true));
	
	_REGISTER_ATTR_WRITE_RULE(bool,"b1CalSourceTemp","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b2CalSourceTemp","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b3CalSourceTemp","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b4CalSourceTemp","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b5CalSourceTemp","testMode",(true));


	//- RFE attrs
	_REGISTER_ATTR_WRITE_RULE(bool,"b1Rfe1PidCurrent","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b2Rfe1PidCurrent","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b3Rfe1PidCurrent","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b4Rfe1PidCurrent","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b5Rfe1PidCurrent","testMode",(true));

	_REGISTER_ATTR_WRITE_RULE(bool,"b1Rfe2PidCurrent","testMode",(true));
	//_REGISTER_ATTR_WRITE_RULE(bool,"b2Rfe2PidCurrent","testMode",(true));//NOT PRESENT IN B2
	_REGISTER_ATTR_WRITE_RULE(bool,"b3Rfe2PidCurrent","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b4Rfe2PidCurrent","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b5Rfe2PidCurrent","testMode",(true));
	
	_REGISTER_ATTR_WRITE_RULE(bool,"b1CalSourcePidCurrent","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b2CalSourcePidCurrent","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b3CalSourcePidCurrent","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b4CalSourcePidCurrent","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b5CalSourcePidCurrent","testMode",(true));
	
	//- Cryo attrs
	//_REGISTER_ATTR_WRITE_RULE(bool,"b1CryoPressure","testMode",(true));//NOT PRESENT in B1
	_REGISTER_ATTR_WRITE_RULE(bool,"b2CryoPressure","testMode",(true));	
	_REGISTER_ATTR_WRITE_RULE(bool,"b345CryoPressure","testMode",(true));	
	
	//_REGISTER_ATTR_WRITE_RULE(bool,"b1ManifoldPressure","testMode",(true));//NOT PRESENT IN B1
	_REGISTER_ATTR_WRITE_RULE(bool,"b2ManifoldPressure","testMode",(true));	
	_REGISTER_ATTR_WRITE_RULE(bool,"b345ManifoldPressure","testMode",(true));	
	
	//- RFE1/2 temp
	//_REGISTER_ATTR_WRITE_RULE(bool,"b1Rfe1Temperature","testMode",(true));//RENAMED IN B1 IN b1LnaHTemperature/b1LnaVTemperature
	_REGISTER_ATTR_WRITE_RULE(bool,"b1LnaHTemperature","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b1LnaVTemperature","testMode",(true));		
	_REGISTER_ATTR_WRITE_RULE(bool,"b2Rfe1Temperature","testMode",(true));	
	_REGISTER_ATTR_WRITE_RULE(bool,"b3Rfe1Temperature","testMode",(true));	
	_REGISTER_ATTR_WRITE_RULE(bool,"b4Rfe1Temperature","testMode",(true));	
	_REGISTER_ATTR_WRITE_RULE(bool,"b5Rfe1Temperature","testMode",(true));	
	
	//_REGISTER_ATTR_WRITE_RULE(bool,"b1Rfe2Temperature","testMode",(true));//NOT PRESENT IN B1
	//_REGISTER_ATTR_WRITE_RULE(bool,"b2Rfe2Temperature","testMode",(true));//NOT PRESENT IN B2
	_REGISTER_ATTR_WRITE_RULE(bool,"b3Rfe2Temperature","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b4Rfe2Temperature","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b5Rfe2Temperature","testMode",(true));
	
	//- Omt temp
	//_REGISTER_ATTR_WRITE_RULE(bool,"b1OmtTemperature","testMode",(true));//NOT PRESENT IN B1
	_REGISTER_ATTR_WRITE_RULE(bool,"b2OmtTemperature","testMode",(true));	
	_REGISTER_ATTR_WRITE_RULE(bool,"b3OmtTemperature","testMode",(true));	
	_REGISTER_ATTR_WRITE_RULE(bool,"b4OmtTemperature","testMode",(true));	
	_REGISTER_ATTR_WRITE_RULE(bool,"b5OmtTemperature","testMode",(true));	
	
	_REGISTER_ATTR_WRITE_RULE(bool,"b1CryocoolStage1Temp","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b2CryocoolStage1Temp","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b3CryocoolStage1Temp","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b4CryocoolStage1Temp","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b5CryocoolStage1Temp","testMode",(true));

	//_REGISTER_ATTR_WRITE_RULE(bool,"b1CryostatBodyTemp","testMode",(true));//RENAMED IN b1ChamberBodyTemp
	_REGISTER_ATTR_WRITE_RULE(bool,"b1ChamberBodyTemp","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b2CryostatBodyTemp","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b345CryostatBodyTemp","testMode",(true));
	
	//- LNA mean gain
	_REGISTER_ATTR_WRITE_RULE(bool,"b1LnaHMeanGain","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b2LnaHMeanGain","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b3LnaHMeanGain","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b4LnaHMeanGain","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b5LnaHMeanGain","testMode",(true));

	_REGISTER_ATTR_WRITE_RULE(bool,"b1LnaVMeanGain","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b2LnaVMeanGain","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b3LnaVMeanGain","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b4LnaVMeanGain","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"b5LnaVMeanGain","testMode",(true));
	
	

	//- bXLnaIlluminationEnabled (X=1,...,5)
	//_REGISTER_ATTR_WRITE_RULE(std::string,"b1LnaIlluminationEnabled","operatingMode",("MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b2LnaIlluminationEnabled","operatingMode",("MAINTENANCE"));
	//_REGISTER_ATTR_WRITE_RULE(std::string,"b3LnaIlluminationEnabled","operatingMode",("MAINTENANCE"));
	//_REGISTER_ATTR_WRITE_RULE(std::string,"b4LnaIlluminationEnabled","operatingMode",("MAINTENANCE"));
	//_REGISTER_ATTR_WRITE_RULE(std::string,"b5LnaIlluminationEnabled","operatingMode",("MAINTENANCE"));

	//- bXLnaHPowerState (X=1,...,5)
	_REGISTER_ATTR_WRITE_RULE(std::string,"b1LnaHPowerState","operatingMode",("OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b2LnaHPowerState","operatingMode",("OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b3LnaHPowerState","operatingMode",("OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b4LnaHPowerState","operatingMode",("OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b5LnaHPowerState","operatingMode",("OPERATE","MAINTENANCE"));

	//- bXLnaVPowerState (X=1,...,5)
	_REGISTER_ATTR_WRITE_RULE(std::string,"b1LnaVPowerState","operatingMode",("OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b2LnaVPowerState","operatingMode",("OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b3LnaVPowerState","operatingMode",("OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b4LnaVPowerState","operatingMode",("OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b5LnaVPowerState","operatingMode",("OPERATE","MAINTENANCE"));

	//- bXAmp2HPowerState (X=1,...,5)
	_REGISTER_ATTR_WRITE_RULE(std::string,"b1Amp2HPowerState","operatingMode",("OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b2Amp2HPowerState","operatingMode",("OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b3Amp2HPowerState","operatingMode",("OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b4Amp2HPowerState","operatingMode",("OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b5Amp2HPowerState","operatingMode",("OPERATE","MAINTENANCE"));

	//- bXAmp2VPowerState (X=1,...,5)
	_REGISTER_ATTR_WRITE_RULE(std::string,"b1Amp2VPowerState","operatingMode",("OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b2Amp2VPowerState","operatingMode",("OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b3Amp2VPowerState","operatingMode",("OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b4Amp2VPowerState","operatingMode",("OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b5Amp2VPowerState","operatingMode",("OPERATE","MAINTENANCE"));


	//- bXCalSourcePowerState (X=1,...,5)
	_REGISTER_ATTR_WRITE_RULE(std::string,"b1CalSourcePowerState","operatingMode",("OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b2CalSourcePowerState","operatingMode",("OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b3CalSourcePowerState","operatingMode",("OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b4CalSourcePowerState","operatingMode",("OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b5CalSourcePowerState","operatingMode",("OPERATE","MAINTENANCE"));

	//- bXRfe1TempSetPoint (X=1,...,5)
	//_REGISTER_ATTR_WRITE_RULE(std::string,"b1Rfe1TempSetPoint","operatingMode",("STANDBY-LP","OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b1LnaHTempSetPoint","operatingMode",("STANDBY-LP","OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b1LnaVTempSetPoint","operatingMode",("STANDBY-LP","OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b2Rfe1TempSetPoint","operatingMode",("STANDBY-LP","OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b3Rfe1TempSetPoint","operatingMode",("STANDBY-LP","OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b4Rfe1TempSetPoint","operatingMode",("STANDBY-LP","OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b5Rfe1TempSetPoint","operatingMode",("STANDBY-LP","OPERATE","MAINTENANCE"));

	//- bXDefaultRfe1TempSetPoint (X=1,...,5)	
	//  NB: Memorized attr is written at startup, that's why write in STARTUP mode is allowed
	//_REGISTER_ATTR_WRITE_RULE(std::string,"b1DefaultRfe1TempSetPoint","operatingMode",("OFF","STARTUP","STANDBY-LP","OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b1DefaultLnaHTempSetPoint","operatingMode",("OFF","STARTUP","STANDBY-LP","OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b1DefaultLnaVTempSetPoint","operatingMode",("OFF","STARTUP","STANDBY-LP","OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b2DefaultRfe1TempSetPoint","operatingMode",("OFF","STARTUP","STANDBY-LP","OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b3DefaultRfe1TempSetPoint","operatingMode",("OFF","STARTUP","STANDBY-LP","OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b4DefaultRfe1TempSetPoint","operatingMode",("OFF","STARTUP","STANDBY-LP","OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b5DefaultRfe1TempSetPoint","operatingMode",("OFF","STARTUP","STANDBY-LP","OPERATE","MAINTENANCE"));

	//- bXRfe1TempCtrlState (X=1,...,5)
	//_REGISTER_ATTR_WRITE_RULE(std::string,"b1Rfe1TempCtrlState","operatingMode",("MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b1LnaHTempCtrlState","operatingMode",("OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b1LnaVTempCtrlState","operatingMode",("OPERATE","MAINTENANCE"));		
	_REGISTER_ATTR_WRITE_RULE(std::string,"b2Rfe1TempCtrlState","operatingMode",("OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b3Rfe1TempCtrlState","operatingMode",("OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b4Rfe1TempCtrlState","operatingMode",("OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b5Rfe1TempCtrlState","operatingMode",("OPERATE","MAINTENANCE"));


	//- bXRfe2TempSetPoint (X=1,...,5)
	//_REGISTER_ATTR_WRITE_RULE(std::string,"b1Rfe2TempSetPoint","operatingMode",("STANDBY-LP","OPERATE","MAINTENANCE"));
	//_REGISTER_ATTR_WRITE_RULE(std::string,"b2Rfe2TempSetPoint","operatingMode",("STANDBY-LP","OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b3Rfe2TempSetPoint","operatingMode",("STANDBY-LP","OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b4Rfe2TempSetPoint","operatingMode",("STANDBY-LP","OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b5Rfe2TempSetPoint","operatingMode",("STANDBY-LP","OPERATE","MAINTENANCE"));

	//- bXDefaultRfe2TempSetPoint (X=1,...,5) 
	//  NB: Memorized attr is written at startup, that's why write in STARTUP mode is allowed
	//_REGISTER_ATTR_WRITE_RULE(std::string,"b1DefaultRfe2TempSetPoint","operatingMode",("OFF","STARTUP","STANDBY-LP","OPERATE","MAINTENANCE"));
	//_REGISTER_ATTR_WRITE_RULE(std::string,"b2DefaultRfe2TempSetPoint","operatingMode",("OFF","STARTUP","STANDBY-LP","OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b3DefaultRfe2TempSetPoint","operatingMode",("OFF","STARTUP","STANDBY-LP","OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b4DefaultRfe2TempSetPoint","operatingMode",("OFF","STARTUP","STANDBY-LP","OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b5DefaultRfe2TempSetPoint","operatingMode",("OFF","STARTUP","STANDBY-LP","OPERATE","MAINTENANCE"));

	//- bXRfe2TempCtrlState (X=1,...,5)
	//_REGISTER_ATTR_WRITE_RULE(std::string,"b1Rfe2TempCtrlState","operatingMode",("MAINTENANCE"));
	//_REGISTER_ATTR_WRITE_RULE(std::string,"b2Rfe2TempCtrlState","operatingMode",("MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b3Rfe2TempCtrlState","operatingMode",("MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b4Rfe2TempCtrlState","operatingMode",("MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b5Rfe2TempCtrlState","operatingMode",("MAINTENANCE"));

	//- bXCalSourceTempSetPoint (X=1,...,5)
	_REGISTER_ATTR_WRITE_RULE(std::string,"b1CalSourceTempSetPoint","operatingMode",("STANDBY-LP","OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b2CalSourceTempSetPoint","operatingMode",("STANDBY-LP","OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b3CalSourceTempSetPoint","operatingMode",("STANDBY-LP","OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b4CalSourceTempSetPoint","operatingMode",("STANDBY-LP","OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b5CalSourceTempSetPoint","operatingMode",("STANDBY-LP","OPERATE","MAINTENANCE"));


	//- bXDefaultCalSourceTempSetPoint (X=1,...,5)
	//  NB: Memorized attr is written at startup, that's why write in STARTUP mode is allowed
	_REGISTER_ATTR_WRITE_RULE(std::string,"b1DefaultCalSourceTempSetPoint","operatingMode",("OFF","STARTUP","STANDBY-LP","OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b2DefaultCalSourceTempSetPoint","operatingMode",("OFF","STARTUP","STANDBY-LP","OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b3DefaultCalSourceTempSetPoint","operatingMode",("OFF","STARTUP","STANDBY-LP","OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b4DefaultCalSourceTempSetPoint","operatingMode",("OFF","STARTUP","STANDBY-LP","OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b5DefaultCalSourceTempSetPoint","operatingMode",("OFF","STARTUP","STANDBY-LP","OPERATE","MAINTENANCE"));

	//- bXCalSourceTempCtrlState (X=1,...,5)
	_REGISTER_ATTR_WRITE_RULE(std::string,"b1CalSourceTempCtrlState","operatingMode",("OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b2CalSourceTempCtrlState","operatingMode",("OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b3CalSourceTempCtrlState","operatingMode",("OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b4CalSourceTempCtrlState","operatingMode",("OPERATE","MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b5CalSourceTempCtrlState","operatingMode",("OPERATE","MAINTENANCE"));


	//- bXCryoMotorState (X=1,...,5)
	//_REGISTER_ATTR_WRITE_RULE(std::string,"b1CryoMotorState","operatingMode",("MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b2CryoMotorState","operatingMode",("MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b345CryoMotorState","operatingMode",("MAINTENANCE"));
	
	//- bXCryoMotorSpeed (X=1,...,5)
	//_REGISTER_ATTR_WRITE_RULE(std::string,"b1CryoMotorSpeed","operatingMode",("MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b2CryoMotorSpeed","operatingMode",("MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b345CryoMotorSpeed","operatingMode",("MAINTENANCE"));
	
	//- vaValveState 
	//_REGISTER_ATTR_WRITE_RULE(std::string,"b1VaValveState","operatingMode",("MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b2VaValveState","operatingMode",("MAINTENANCE"));
	_REGISTER_ATTR_WRITE_RULE(std::string,"b345VaValveState","operatingMode",("MAINTENANCE"));
	

	//===  Add cmd rules ===
	//- IlluminateLNA
	//_REGISTER_CMD_RULE(std::string,"IlluminateLNA","operatingMode",("OPERATE","MAINTENANCE"));

	//- SetLNAHPowerState
	_REGISTER_CMD_RULE(std::string,"SetLNAHPowerState","operatingMode",("OPERATE","MAINTENANCE"));
	_REGISTER_CMD_RULE(std::string,"SetLNAHPowerState","powerState",("FULL-POWER"));

	//- SetLNAVPowerState
	_REGISTER_CMD_RULE(std::string,"SetLNAVPowerState","operatingMode",("OPERATE","MAINTENANCE"));
	_REGISTER_CMD_RULE(std::string,"SetLNAVPowerState","powerState",("FULL-POWER"));

	//- SetAmp2HPowerState
	_REGISTER_CMD_RULE(std::string,"SetAmp2HPowerState","operatingMode",("OPERATE","MAINTENANCE"));
	_REGISTER_CMD_RULE(std::string,"SetAmp2HPowerState","powerState",("FULL-POWER"));

	//- SetAmp2VPowerState
	_REGISTER_CMD_RULE(std::string,"SetAmp2VPowerState","operatingMode",("OPERATE","MAINTENANCE"));
	_REGISTER_CMD_RULE(std::string,"SetAmp2VPowerState","powerState",("FULL-POWER"));

	//- SetRFE1TempSetPoint
	_REGISTER_CMD_RULE(std::string,"SetRFE1TempSetPoint","operatingMode",("OPERATE","MAINTENANCE","STANDBY-LP"));
		
	//- SetRFE2TempCntrState
	_REGISTER_CMD_RULE(std::string,"SetRFE2TempCntrState","operatingMode",("OPERATE","MAINTENANCE","STANDBY-LP"));
	
	//- SetCryoMotorState
	_REGISTER_CMD_RULE(std::string,"SetCryoMotorState","operatingMode",("OPERATE","MAINTENANCE","STANDBY-LP"));
	
	//- SetCryoMotorSpeed
	_REGISTER_CMD_RULE(std::string,"SetCryoMotorSpeed","operatingMode",("OPERATE","MAINTENANCE","STANDBY-LP"));
	
	//- SetVaValveState
	_REGISTER_CMD_RULE(std::string,"SetVaValveState","operatingMode",("OPERATE","MAINTENANCE","STANDBY-LP"));
	
	//- SetSubElementMode
	_REGISTER_CMD_RULE(std::string,"SetSubElementMode","operatingMode",("STANDBY-LP","OPERATE","MAINTENANCE"));

	//- SetStandbyLPMode
	_REGISTER_CMD_RULE(std::string,"SetStandbyLPMode","operatingMode",("STANDBY-LP","OPERATE","MAINTENANCE"));
	//_REGISTER_CMD_RULE(std::string,"SetStandbyLPMode","powerState",("LOW-POWER","FULL-POWER"));
	//_REGISTER_CMD_RULE(std::string,"SetStandbyLPMode","b1CapabilityState",("STANDBY","OPERATE-FULL","OPERATE-DEGRADED"));
	//_REGISTER_CMD_RULE(std::string,"SetStandbyLPMode","b2CapabilityState",("STANDBY","OPERATE-FULL","OPERATE-DEGRADED"));
	//_REGISTER_CMD_RULE(std::string,"SetStandbyLPMode","b3CapabilityState",("STANDBY","OPERATE-FULL","OPERATE-DEGRADED"));
	//_REGISTER_CMD_RULE(std::string,"SetStandbyLPMode","b4CapabilityState",("STANDBY","OPERATE-FULL","OPERATE-DEGRADED"));
	//_REGISTER_CMD_RULE(std::string,"SetStandbyLPMode","b5CapabilityState",("STANDBY","OPERATE-FULL","OPERATE-DEGRADED"));

	//- SetOperateMode
	_REGISTER_CMD_RULE(std::string,"SetOperateMode","operatingMode",("STANDBY-LP","OPERATE","MAINTENANCE"));
	//_REGISTER_CMD_RULE(std::string,"SetOperateMode","powerState",("LOW-POWER","FULL-POWER"));
	//_REGISTER_CMD_RULE(std::string,"SetOperateMode","b1CapabilityState",("STANDBY","OPERATE-FULL","OPERATE-DEGRADED"));
	//_REGISTER_CMD_RULE(std::string,"SetOperateMode","b2CapabilityState",("STANDBY","OPERATE-FULL","OPERATE-DEGRADED"));
	//_REGISTER_CMD_RULE(std::string,"SetOperateMode","b3CapabilityState",("STANDBY","OPERATE-FULL","OPERATE-DEGRADED"));
	//_REGISTER_CMD_RULE(std::string,"SetOperateMode","b4CapabilityState",("STANDBY","OPERATE-FULL","OPERATE-DEGRADED"));
	//_REGISTER_CMD_RULE(std::string,"SetOperateMode","b5CapabilityState",("STANDBY","OPERATE-FULL","OPERATE-DEGRADED"));

	//- SetMaintenanceMode
	_REGISTER_CMD_RULE(std::string,"SetMaintenanceMode","operatingMode",("STANDBY-LP","OPERATE","MAINTENANCE"));
	//_REGISTER_CMD_RULE(std::string,"SetMaintenanceMode","powerState",("LOW-POWER","FULL-POWER"));
	
	//- SetFeedMode
	_REGISTER_CMD_RULE(std::string,"SetFeedMode","operatingMode",("STANDBY-LP","OPERATE","MAINTENANCE"));
	_REGISTER_CMD_RULE(std::string,"SetFeedStandbyLPMode","operatingMode",("STANDBY-LP","OPERATE","MAINTENANCE"));
	_REGISTER_CMD_RULE(std::string,"SetFeedRegenerationMode","operatingMode",("STANDBY-LP","OPERATE","MAINTENANCE"));
	_REGISTER_CMD_RULE(std::string,"SetFeedOperateMode","operatingMode",("STANDBY-LP","OPERATE","MAINTENANCE"));
	_REGISTER_CMD_RULE(std::string,"SetFeedClearErrorsAndRestartMode","operatingMode",("STANDBY-LP","OPERATE","MAINTENANCE"));
	_REGISTER_CMD_RULE(std::string,"SetFeedMaintenanceMode","operatingMode",("STANDBY-LP","OPERATE","MAINTENANCE"));
		
	//- SendFeedCommand
	_REGISTER_CMD_RULE(std::string,"SendFeedCommand","operatingMode",("STANDBY-LP","OPERATE","MAINTENANCE"));

	//- SetVacuumMode
	_REGISTER_CMD_RULE(std::string,"SetVacuumMode","operatingMode",("MAINTENANCE"));

	//- SendVacuumCommand
	_REGISTER_CMD_RULE(std::string,"SendVacuumCommand","operatingMode",("MAINTENANCE"));

	//- SetHeliumMode
	_REGISTER_CMD_RULE(std::string,"SetHeliumMode","operatingMode",("MAINTENANCE"));

	//- SendHeliumCommand
	_REGISTER_CMD_RULE(std::string,"SendHeliumCommand","operatingMode",("MAINTENANCE"));

	//- Shutdown
	_REGISTER_CMD_RULE(std::string,"Shutdown","operatingMode",("STANDBY-LP"));


	//DUMP_CMD_RULES();

	//===  Add attribute rules ===
	//- operatingMode
	_REGISTER_ATTR_RULE(std::string,"operatingMode","STARTUP",("STARTUP","STANDBY-LP","ERROR"));
	_REGISTER_ATTR_RULE(std::string,"operatingMode","STANDBY-LP",("STANDBY-LP","OPERATE","MAINTENANCE","ERROR"));
	_REGISTER_ATTR_RULE(std::string,"operatingMode","OPERATE",("OPERATE","STANDBY-LP","MAINTENANCE","ERROR"));
	_REGISTER_ATTR_RULE(std::string,"operatingMode","MAINTENANCE",("MAINTENANCE","STANDBY-LP","OPERATE","ERROR"));

	//- capabilities
	_REGISTER_ATTR_RULE(std::string,"b1CapabilityState","NONE",("NONE","STANDBY"));
	_REGISTER_ATTR_RULE(std::string,"b1CapabilityState","UNAVAILABLE",("UNAVAILABLE","STANDBY"));
	_REGISTER_ATTR_RULE(std::string,"b1CapabilityState","STANDBY",("STANDBY","UNAVAILABLE","OPERATE-DEGRADED","OPERATE-FULL"));
	_REGISTER_ATTR_RULE(std::string,"b1CapabilityState","OPERATE-DEGRADED",("OPERATE-DEGRADED","OPERATE-FULL","STANDBY","UNAVAILABLE"));
	_REGISTER_ATTR_RULE(std::string,"b1CapabilityState","OPERATE-FULL",("OPERATE-FULL","OPERATE-DEGRADED","STANDBY","UNAVAILABLE"));

	_REGISTER_ATTR_RULE(std::string,"b2CapabilityState","NONE",("NONE","STANDBY"));
	_REGISTER_ATTR_RULE(std::string,"b2CapabilityState","UNAVAILABLE",("UNAVAILABLE","STANDBY"));
	_REGISTER_ATTR_RULE(std::string,"b2CapabilityState","STANDBY",("STANDBY","UNAVAILABLE","OPERATE-DEGRADED","OPERATE-FULL"));
	_REGISTER_ATTR_RULE(std::string,"b2CapabilityState","OPERATE-DEGRADED",("OPERATE-DEGRADED","OPERATE-FULL","STANDBY","UNAVAILABLE"));
	_REGISTER_ATTR_RULE(std::string,"b2CapabilityState","OPERATE-FULL",("OPERATE-FULL","OPERATE-DEGRADED","STANDBY","UNAVAILABLE"));

	_REGISTER_ATTR_RULE(std::string,"b3CapabilityState","NONE",("NONE","STANDBY"));
	_REGISTER_ATTR_RULE(std::string,"b3CapabilityState","UNAVAILABLE",("UNAVAILABLE","STANDBY"));
	_REGISTER_ATTR_RULE(std::string,"b3CapabilityState","STANDBY",("STANDBY","UNAVAILABLE","OPERATE-DEGRADED","OPERATE-FULL"));
	_REGISTER_ATTR_RULE(std::string,"b3CapabilityState","OPERATE-DEGRADED",("OPERATE-DEGRADED","OPERATE-FULL","STANDBY","UNAVAILABLE"));
	_REGISTER_ATTR_RULE(std::string,"b3CapabilityState","OPERATE-FULL",("OPERATE-FULL","OPERATE-DEGRADED","STANDBY","UNAVAILABLE"));

	_REGISTER_ATTR_RULE(std::string,"b4CapabilityState","NONE",("NONE","STANDBY"));
	_REGISTER_ATTR_RULE(std::string,"b4CapabilityState","UNAVAILABLE",("UNAVAILABLE","STANDBY"));
	_REGISTER_ATTR_RULE(std::string,"b4CapabilityState","STANDBY",("STANDBY","UNAVAILABLE","OPERATE-DEGRADED","OPERATE-FULL"));
	_REGISTER_ATTR_RULE(std::string,"b4CapabilityState","OPERATE-DEGRADED",("OPERATE-DEGRADED","OPERATE-FULL","STANDBY","UNAVAILABLE"));
	_REGISTER_ATTR_RULE(std::string,"b4CapabilityState","OPERATE-FULL",("OPERATE-FULL","OPERATE-DEGRADED","STANDBY","UNAVAILABLE"));

	_REGISTER_ATTR_RULE(std::string,"b5CapabilityState","NONE",("NONE","STANDBY"));
	_REGISTER_ATTR_RULE(std::string,"b5CapabilityState","UNAVAILABLE",("UNAVAILABLE","STANDBY"));
	_REGISTER_ATTR_RULE(std::string,"b5CapabilityState","STANDBY",("STANDBY","UNAVAILABLE","OPERATE-DEGRADED","OPERATE-FULL"));
	_REGISTER_ATTR_RULE(std::string,"b5CapabilityState","OPERATE-DEGRADED",("OPERATE-DEGRADED","OPERATE-FULL","STANDBY","UNAVAILABLE"));
	_REGISTER_ATTR_RULE(std::string,"b5CapabilityState","OPERATE-FULL",("OPERATE-FULL","OPERATE-DEGRADED","STANDBY","UNAVAILABLE"));

	//DUMP_ATTR_RULES();

	//===============================================
	//==     ATTR WRITE PRE/POST ACTIONS
	//===============================================
	_REGISTER_ATTR_WRITE_PRE_ACTION("b1CalSourcePowerState",("SetCalSourceTempSetPointsToDefault"));	
	_REGISTER_ATTR_WRITE_PRE_ACTION("b2CalSourcePowerState",("SetCalSourceTempSetPointsToDefault"));	
	_REGISTER_ATTR_WRITE_PRE_ACTION("b3CalSourcePowerState",("SetCalSourceTempSetPointsToDefault"));	
	_REGISTER_ATTR_WRITE_PRE_ACTION("b4CalSourcePowerState",("SetCalSourceTempSetPointsToDefault"));	
	_REGISTER_ATTR_WRITE_PRE_ACTION("b5CalSourcePowerState",("SetCalSourceTempSetPointsToDefault"));	

	return 0;

}//close InitCmdAttrStateMachine()

int SPFEmulator::InitTask(){

	//## Initialize device task
	_DEBUG_LOG("Initializing device task config...");
	m_task = 0;

	//- Define task configuration
	SPFEmulatorTask::Config cfg;
  cfg.task_activity_period_ms = 3000;
  cfg.host_device = this;
	cfg.enable_periodic_msg= false;
    
	//- Allocate and start the device task
	try {
		_INFO_LOG("Initializing device task...");
    m_task = new (std::nothrow) SPFEmulatorTask(cfg);
	  if (!m_task){
    	throw std::bad_alloc();
		}

    _INFO_LOG("Starting the task...");
    m_task->go();
	}
  catch (const std::bad_alloc&) {
		std::string errMsg("Device task initialization failed (allocation failed)");
  	_ERROR_LOG(errMsg);
		set_state(Tango::FAULT);
    set_status(errMsg.c_str());
		return -1;
	}
  catch (Tango::DevFailed& e) {
		Tango::Except::print_exception(e);
		std::string errMsg("Device task initialization failed [see device log for details]");
  	_ERROR_LOG(errMsg);
		set_state(Tango::FAULT);
    set_status(errMsg.c_str());
    return -1;
  }
  catch (...) {
  	std::string errMsg("Device task initialization failed [unknown error]");
  	_ERROR_LOG(errMsg);
		set_state(Tango::FAULT);
    set_status(errMsg.c_str());
    return -1;
  }

	return 0;

}//close InitTask()

int SPFEmulator::ClearTask(){

	if(!m_task) return 0;

	//## First signal waiting conditions
	m_task->signal_wait();

	//## Release the task: just ask task to quit
	//## NB: Never explicitly delete a yat4tango::DeviceTask
	m_task->exit();
  m_task = 0;

	return 0;

}//close ClearTask

int SPFEmulator::Startup(){

	//## Prepare message data
	StartupMsg msg_data;
	msg_data.task_duration= startupTime;
	msg_data.enable_failure= enableStartupFailure;
	msg_data.failure_probability= startupFailureProbability;

	//## Execute SPF startup task
	bool isSynchronous= false;
	try {
		m_task->execute_startup(msg_data, isSynchronous);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		std::string errMsg("Tango exception occurred while executing SPF startup!");
		_ERROR_LOG(errMsg);
		set_state(Tango::FAULT);
    set_status(errMsg.c_str());
    return -1;
	}	
	catch(...){
		std::string errMsg("Unknown C++ exception occurred while adding device to group!");
		_ERROR_LOG(errMsg);	
		set_state(Tango::FAULT);
    set_status(errMsg.c_str());
    return -1;
	}
	
	return 0;

}//close Startup()


void SPFEmulator::SetOperateStatus(std::string status,std::string info,bool clear){

	//Clear previously allocated string
	//NB: According to Tango doc it is safe to call free even if string is not allocated
	int nDim= 3;
	if(clear){
		for(int i=0;i<nDim;i++){
			CORBA::string_free( *(attr_setOperateModeProgress_read+i) );
		}
	}
		
	attr_setOperateModeProgress_read[0]= Tango::string_dup(status.c_str());
	attr_setOperateModeProgress_read[1]= Tango::string_dup(info.c_str());
	attr_setOperateModeProgress_read[2]= Tango::string_dup("");

}//close SetOperateStatus()

void SPFEmulator::SetStandbyLPStatus(std::string status,std::string info,bool clear){

	//Clear previously allocated string
	//NB: According to Tango doc it is safe to call free even if string is not allocated
	int nDim= 3;
	if(clear){
		for(int i=0;i<nDim;i++){
			CORBA::string_free( *(attr_setStandbyLPModeProgress_read+i) );
		}
	}
		
	attr_setStandbyLPModeProgress_read[0]= Tango::string_dup(status.c_str());
	attr_setStandbyLPModeProgress_read[1]= Tango::string_dup(info.c_str());
	attr_setStandbyLPModeProgress_read[2]= Tango::string_dup("");

}//close SetStandbyLPStatus()

void SPFEmulator::SetMaintenanceStatus(std::string status,std::string info,bool clear){

	//Clear previously allocated string
	//NB: According to Tango doc it is safe to call free even if string is not allocated
	int nDim= 3;
	if(clear){
		for(int i=0;i<nDim;i++){
			CORBA::string_free( *(attr_setMaintenanceModeProgress_read+i) );
		}
	}
		
	attr_setMaintenanceModeProgress_read[0]= Tango::string_dup(status.c_str());
	attr_setMaintenanceModeProgress_read[1]= Tango::string_dup(info.c_str());
	attr_setMaintenanceModeProgress_read[2]= Tango::string_dup("");

}//close SetMaintenanceStatus()


void SPFEmulator::SetFeedOperateStatus(int bandId,std::string status,std::string info,bool clear){

	int nBands= 5;
	int nDim= 3;
	if(bandId<-1 || bandId>nBands) {
		_WARN_LOG("Invalid bandId ("<<bandId<<") argument given, nothing will be set!");
		return;
	}

	//Clear previously allocated string
	//NB: According to Tango doc it is safe to call free even if string is not allocated
	if(bandId==1){
		if(clear) {
			for(int i=0;i<nDim;i++) CORBA::string_free( *(attr_setB1FeedOperateModeProgress_read+i) );
		}
		attr_setB1FeedOperateModeProgress_read[0]= Tango::string_dup(status.c_str());
		attr_setB1FeedOperateModeProgress_read[1]= Tango::string_dup(info.c_str());
		attr_setB1FeedOperateModeProgress_read[2]= Tango::string_dup("");
	}
	else if(bandId==2){
		if(clear) {
			for(int i=0;i<nDim;i++) CORBA::string_free( *(attr_setB2FeedOperateModeProgress_read+i) );
		}
		attr_setB2FeedOperateModeProgress_read[0]= Tango::string_dup(status.c_str());
		attr_setB2FeedOperateModeProgress_read[1]= Tango::string_dup(info.c_str());
		attr_setB2FeedOperateModeProgress_read[2]= Tango::string_dup("");
	}
	else if(bandId==3){
		if(clear) {
			for(int i=0;i<nDim;i++) CORBA::string_free( *(attr_setB3FeedOperateModeProgress_read+i) );
		}
		attr_setB3FeedOperateModeProgress_read[0]= Tango::string_dup(status.c_str());
		attr_setB3FeedOperateModeProgress_read[1]= Tango::string_dup(info.c_str());
		attr_setB3FeedOperateModeProgress_read[2]= Tango::string_dup("");
	}
	else if(bandId==4){
		if(clear) {
			for(int i=0;i<nDim;i++) CORBA::string_free( *(attr_setB4FeedOperateModeProgress_read+i) );
		}
		attr_setB4FeedOperateModeProgress_read[0]= Tango::string_dup(status.c_str());
		attr_setB4FeedOperateModeProgress_read[1]= Tango::string_dup(info.c_str());
		attr_setB4FeedOperateModeProgress_read[2]= Tango::string_dup("");
	}
	else if(bandId==5){
		if(clear) {
			for(int i=0;i<nDim;i++) CORBA::string_free( *(attr_setB5FeedOperateModeProgress_read+i) );
		}
		attr_setB5FeedOperateModeProgress_read[0]= Tango::string_dup(status.c_str());
		attr_setB5FeedOperateModeProgress_read[1]= Tango::string_dup(info.c_str());
		attr_setB5FeedOperateModeProgress_read[2]= Tango::string_dup("");
	}
	else if(bandId==-1){
		if(clear) {
			for(int i=0;i<nDim;i++) {
				CORBA::string_free( *(attr_setB1FeedOperateModeProgress_read+i) );
				CORBA::string_free( *(attr_setB2FeedOperateModeProgress_read+i) );
				CORBA::string_free( *(attr_setB3FeedOperateModeProgress_read+i) );
				CORBA::string_free( *(attr_setB4FeedOperateModeProgress_read+i) );
				CORBA::string_free( *(attr_setB5FeedOperateModeProgress_read+i) );
			}
		}
		attr_setB1FeedOperateModeProgress_read[0]= Tango::string_dup(status.c_str());
		attr_setB1FeedOperateModeProgress_read[1]= Tango::string_dup(info.c_str());
		attr_setB1FeedOperateModeProgress_read[2]= Tango::string_dup("");
		
		attr_setB2FeedOperateModeProgress_read[0]= Tango::string_dup(status.c_str());
		attr_setB2FeedOperateModeProgress_read[1]= Tango::string_dup(info.c_str());
		attr_setB2FeedOperateModeProgress_read[2]= Tango::string_dup("");
	
		attr_setB3FeedOperateModeProgress_read[0]= Tango::string_dup(status.c_str());
		attr_setB3FeedOperateModeProgress_read[1]= Tango::string_dup(info.c_str());
		attr_setB3FeedOperateModeProgress_read[2]= Tango::string_dup("");

		attr_setB4FeedOperateModeProgress_read[0]= Tango::string_dup(status.c_str());
		attr_setB4FeedOperateModeProgress_read[1]= Tango::string_dup(info.c_str());
		attr_setB4FeedOperateModeProgress_read[2]= Tango::string_dup("");

		attr_setB5FeedOperateModeProgress_read[0]= Tango::string_dup(status.c_str());
		attr_setB5FeedOperateModeProgress_read[1]= Tango::string_dup(info.c_str());
		attr_setB5FeedOperateModeProgress_read[2]= Tango::string_dup("");
	}
	else {
		_WARN_LOG("Invalid bandId ("<<bandId<<") argument given, nothing will be set!");
	}
	

}//close SetFeedOperateStatus()



void SPFEmulator::SetFeedRegenerationStatus(int bandId,std::string status,std::string info,bool clear){

	int nBands= 5;
	int nDim= 3;
	if(bandId<-1 || bandId>nBands) {
		_WARN_LOG("Invalid bandId ("<<bandId<<") argument given, nothing will be set!");
		return;
	}

	//Clear previously allocated string
	//NB: According to Tango doc it is safe to call free even if string is not allocated
	if(bandId==1){
		if(clear) {
			for(int i=0;i<nDim;i++) CORBA::string_free( *(attr_setB1FeedRegenerationModeProgress_read+i) );
		}
		attr_setB1FeedRegenerationModeProgress_read[0]= Tango::string_dup(status.c_str());
		attr_setB1FeedRegenerationModeProgress_read[1]= Tango::string_dup(info.c_str());
		attr_setB1FeedRegenerationModeProgress_read[2]= Tango::string_dup("");
	}
	else if(bandId==2){
		if(clear) {
			for(int i=0;i<nDim;i++) CORBA::string_free( *(attr_setB2FeedRegenerationModeProgress_read+i) );
		}
		attr_setB2FeedRegenerationModeProgress_read[0]= Tango::string_dup(status.c_str());
		attr_setB2FeedRegenerationModeProgress_read[1]= Tango::string_dup(info.c_str());
		attr_setB2FeedRegenerationModeProgress_read[2]= Tango::string_dup("");
	}
	else if(bandId==3){
		if(clear) {
			for(int i=0;i<nDim;i++) CORBA::string_free( *(attr_setB3FeedRegenerationModeProgress_read+i) );
		}
		attr_setB3FeedRegenerationModeProgress_read[0]= Tango::string_dup(status.c_str());
		attr_setB3FeedRegenerationModeProgress_read[1]= Tango::string_dup(info.c_str());	
		attr_setB3FeedRegenerationModeProgress_read[2]= Tango::string_dup("");
	}
	else if(bandId==4){
		if(clear) {
			for(int i=0;i<nDim;i++) CORBA::string_free( *(attr_setB4FeedRegenerationModeProgress_read+i) );
		}
		attr_setB4FeedRegenerationModeProgress_read[0]= Tango::string_dup(status.c_str());
		attr_setB4FeedRegenerationModeProgress_read[1]= Tango::string_dup(info.c_str());
		attr_setB4FeedRegenerationModeProgress_read[2]= Tango::string_dup("");
	}
	else if(bandId==5){
		if(clear) {
			for(int i=0;i<nDim;i++) CORBA::string_free( *(attr_setB5FeedRegenerationModeProgress_read+i) );
		}
		attr_setB5FeedRegenerationModeProgress_read[0]= Tango::string_dup(status.c_str());
		attr_setB5FeedRegenerationModeProgress_read[1]= Tango::string_dup(info.c_str());
		attr_setB5FeedRegenerationModeProgress_read[2]= Tango::string_dup("");
	}
	else if(bandId==-1){
		if(clear) {
			for(int i=0;i<nDim;i++) {
				CORBA::string_free( *(attr_setB1FeedRegenerationModeProgress_read+i) );
				CORBA::string_free( *(attr_setB2FeedRegenerationModeProgress_read+i) );
				CORBA::string_free( *(attr_setB3FeedRegenerationModeProgress_read+i) );
				CORBA::string_free( *(attr_setB4FeedRegenerationModeProgress_read+i) );
				CORBA::string_free( *(attr_setB5FeedRegenerationModeProgress_read+i) );
			}
		}
		attr_setB1FeedRegenerationModeProgress_read[0]= Tango::string_dup(status.c_str());
		attr_setB1FeedRegenerationModeProgress_read[1]= Tango::string_dup(info.c_str());
		attr_setB1FeedRegenerationModeProgress_read[2]= Tango::string_dup("");
		
		attr_setB2FeedRegenerationModeProgress_read[0]= Tango::string_dup(status.c_str());
		attr_setB2FeedRegenerationModeProgress_read[1]= Tango::string_dup(info.c_str());
		attr_setB2FeedRegenerationModeProgress_read[2]= Tango::string_dup("");
	
		attr_setB3FeedRegenerationModeProgress_read[0]= Tango::string_dup(status.c_str());
		attr_setB3FeedRegenerationModeProgress_read[1]= Tango::string_dup(info.c_str());
		attr_setB3FeedRegenerationModeProgress_read[2]= Tango::string_dup("");

		attr_setB4FeedRegenerationModeProgress_read[0]= Tango::string_dup(status.c_str());
		attr_setB4FeedRegenerationModeProgress_read[1]= Tango::string_dup(info.c_str());
		attr_setB4FeedRegenerationModeProgress_read[2]= Tango::string_dup("");

		attr_setB5FeedRegenerationModeProgress_read[0]= Tango::string_dup(status.c_str());
		attr_setB5FeedRegenerationModeProgress_read[1]= Tango::string_dup(info.c_str());
		attr_setB5FeedRegenerationModeProgress_read[2]= Tango::string_dup("");
	}
	else {
		_WARN_LOG("Invalid bandId ("<<bandId<<") argument given, nothing will be set!");
	}
	
}//close SetFeedRegenerationStatus()




void SPFEmulator::SetFeedStandbyLPStatus(int bandId,std::string status,std::string info,bool clear){

	int nBands= 5;
	int nDim= 3;
	if(bandId<-1 || bandId>nBands) {
		_WARN_LOG("Invalid bandId ("<<bandId<<") argument given, nothing will be set!");
		return;
	}

	//Clear previously allocated string
	//NB: According to Tango doc it is safe to call free even if string is not allocated
	if(bandId==1){
		if(clear) {
			for(int i=0;i<nDim;i++) CORBA::string_free( *(attr_setB1FeedStandbyLPModeProgress_read+i) );
		}
		attr_setB1FeedStandbyLPModeProgress_read[0]= Tango::string_dup(status.c_str());
		attr_setB1FeedStandbyLPModeProgress_read[1]= Tango::string_dup(info.c_str());
		attr_setB1FeedStandbyLPModeProgress_read[2]= Tango::string_dup("");
	}
	else if(bandId==2){
		if(clear) {
			for(int i=0;i<nDim;i++) CORBA::string_free( *(attr_setB2FeedStandbyLPModeProgress_read+i) );
		}
		attr_setB2FeedStandbyLPModeProgress_read[0]= Tango::string_dup(status.c_str());
		attr_setB2FeedStandbyLPModeProgress_read[1]= Tango::string_dup(info.c_str());
		attr_setB2FeedStandbyLPModeProgress_read[2]= Tango::string_dup("");
	}
	else if(bandId==3){
		if(clear) {
			for(int i=0;i<nDim;i++) CORBA::string_free( *(attr_setB3FeedStandbyLPModeProgress_read+i) );
		}
		attr_setB3FeedStandbyLPModeProgress_read[0]= Tango::string_dup(status.c_str());
		attr_setB3FeedStandbyLPModeProgress_read[1]= Tango::string_dup(info.c_str());
		attr_setB3FeedStandbyLPModeProgress_read[2]= Tango::string_dup("");
	}
	else if(bandId==4){
		if(clear) {
			for(int i=0;i<nDim;i++) CORBA::string_free( *(attr_setB4FeedStandbyLPModeProgress_read+i) );
		}
		attr_setB4FeedStandbyLPModeProgress_read[0]= Tango::string_dup(status.c_str());
		attr_setB4FeedStandbyLPModeProgress_read[1]= Tango::string_dup(info.c_str());
		attr_setB4FeedStandbyLPModeProgress_read[2]= Tango::string_dup("");
	}
	else if(bandId==5){
		if(clear) {
			for(int i=0;i<nDim;i++) CORBA::string_free( *(attr_setB5FeedStandbyLPModeProgress_read+i) );
		}
		attr_setB5FeedStandbyLPModeProgress_read[0]= Tango::string_dup(status.c_str());
		attr_setB5FeedStandbyLPModeProgress_read[1]= Tango::string_dup(info.c_str());
		attr_setB5FeedStandbyLPModeProgress_read[2]= Tango::string_dup("");
	}
	else if(bandId==-1){
		if(clear) {
			for(int i=0;i<nDim;i++) {
				CORBA::string_free( *(attr_setB1FeedStandbyLPModeProgress_read+i) );
				CORBA::string_free( *(attr_setB2FeedStandbyLPModeProgress_read+i) );
				CORBA::string_free( *(attr_setB3FeedStandbyLPModeProgress_read+i) );
				CORBA::string_free( *(attr_setB4FeedStandbyLPModeProgress_read+i) );
				CORBA::string_free( *(attr_setB5FeedStandbyLPModeProgress_read+i) );
			}
		}
		attr_setB1FeedStandbyLPModeProgress_read[0]= Tango::string_dup(status.c_str());
		attr_setB1FeedStandbyLPModeProgress_read[1]= Tango::string_dup(info.c_str());
		attr_setB1FeedStandbyLPModeProgress_read[2]= Tango::string_dup("");
		
		attr_setB2FeedStandbyLPModeProgress_read[0]= Tango::string_dup(status.c_str());
		attr_setB2FeedStandbyLPModeProgress_read[1]= Tango::string_dup(info.c_str());
		attr_setB2FeedStandbyLPModeProgress_read[2]= Tango::string_dup("");
	
		attr_setB3FeedStandbyLPModeProgress_read[0]= Tango::string_dup(status.c_str());
		attr_setB3FeedStandbyLPModeProgress_read[1]= Tango::string_dup(info.c_str());
		attr_setB3FeedStandbyLPModeProgress_read[2]= Tango::string_dup("");

		attr_setB4FeedStandbyLPModeProgress_read[0]= Tango::string_dup(status.c_str());
		attr_setB4FeedStandbyLPModeProgress_read[1]= Tango::string_dup(info.c_str());
		attr_setB4FeedStandbyLPModeProgress_read[2]= Tango::string_dup("");

		attr_setB5FeedStandbyLPModeProgress_read[0]= Tango::string_dup(status.c_str());
		attr_setB5FeedStandbyLPModeProgress_read[1]= Tango::string_dup(info.c_str());
		attr_setB5FeedStandbyLPModeProgress_read[2]= Tango::string_dup("");
	}
	else {
		_WARN_LOG("Invalid bandId ("<<bandId<<") argument given, nothing will be set!");
	}
	

}//close SetFeedStandbyLPStatus()


/*----- PROTECTED REGION END -----*/	//	SPFEmulator::namespace_ending
} //	namespace
