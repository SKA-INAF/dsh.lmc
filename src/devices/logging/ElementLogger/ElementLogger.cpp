/*----- PROTECTED REGION ID(ElementLogger.cpp) ENABLED START -----*/
static const char *RcsId = "$Id:  $";
//=============================================================================
//
// file :        ElementLogger.cpp
//
// description : C++ source for the ElementLogger class and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               ElementLogger are implemented in this file.
//
// project :     ElementLogger
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
// $Author:  $
//
// $Revision:  $
// $Date:  $
//
// $HeadURL:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <ElementLogger.h>
#include <ElementLoggerClass.h>

#include <Logger.h>
#include <CodeUtils.h>
#include <TangoUtils.h>

/*----- PROTECTED REGION END -----*/	//	ElementLogger.cpp

/**
 *  ElementLogger class description:
 *    ElementLogger
 */

//================================================================
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name             |  Method name
//================================================================
//  State                    |  Inherited (no method)
//  Status                   |  Inherited (no method)
//  InitializeLoggers        |  Inherited (no method)
//  InitializeFwdAttrs       |  Inherited (no method)
//  RandomizeDynAttrs        |  Inherited (no method)
//  InitializeDevProxies     |  Inherited (no method)
//  GetRegisteredProxies     |  Inherited (no method)
//  GetRegisteredEvents      |  Inherited (no method)
//  GetRegisteredFormulas    |  Inherited (no method)
//  GetInitializedFormulas   |  Inherited (no method)
//  GetNRunningTasks         |  Inherited (no method)
//  GetNQueuedTasks          |  Inherited (no method)
//  GetNIdleTasks            |  Inherited (no method)
//  GetNTasks                |  Inherited (no method)
//  GetNFailedTasks          |  Inherited (no method)
//  GetNTotFailedTasks       |  Inherited (no method)
//  IsTaskQuotaReached       |  Inherited (no method)
//  FlushTaskQueue           |  Inherited (no method)
//  GetQueuedTaskInfo        |  Inherited (no method)
//  GetTaskInfo              |  Inherited (no method)
//  ClearTasks               |  Inherited (no method)
//  UpdateFormulaAttrs       |  Inherited (no method)
//  UpdateStatusAttrs        |  Inherited (no method)
//  MonitorProxies           |  Inherited (no method)
//  RevokeTask               |  Inherited (no method)
//  log                      |  log
//  TestLog                  |  test_log
//  AddLogSource             |  add_log_source
//  RemoveLogSource          |  remove_log_source
//  InitializeLogSources     |  initialize_log_sources
//  InitializeSELogSources   |  initialize_selog_sources
//  AddSELogSource           |  add_selog_source
//  RemoveSELogSource        |  remove_selog_source
//  GetFormulaData           |  Inherited (no method)
//  SendTestLogMsg           |  Inherited (no method)
//  SetLoggingLevelCentral   |  set_logging_level_central
//  SetLoggingLevelElement   |  set_logging_level_element
//  SetLoggingLevelStorage   |  set_logging_level_storage
//  SetSPFLoggingLevel       |  set_spflogging_level
//  SetRxLoggingLevel        |  set_rx_logging_level
//  SetSPFLoggingTarget      |  set_spflogging_target
//  SetRxLoggingTarget       |  set_rx_logging_target
//  EnableCentralLogger      |  enable_central_logger
//  DisableCentralLogger     |  disable_central_logger
//  EnableElementLogger      |  enable_element_logger
//  DisableElementLogger     |  disable_element_logger
//  EnableStorageLogger      |  enable_storage_logger
//  DisableStorageLogger     |  disable_storage_logger
//  SetLoggingTargetCentral  |  set_logging_target_central
//  SetLoggingTargetElement  |  set_logging_target_element
//  SetLoggingTargetStorage  |  set_logging_target_storage
//  RevokeTaskSequence       |  Inherited (no method)
//  ClearTaskHistory         |  Inherited (no method)
//  GetLogAppenderInfo       |  Inherited (no method)
//================================================================

//================================================================
//  Attributes managed are:
//================================================================
//  loggingLevelCentral       |  Tango::DevLong	Scalar
//  loggingLevelElement       |  Tango::DevLong	Scalar
//  loggingLevelStorage       |  Tango::DevLong	Scalar
//  loggingLevelConsole       |  Tango::DevLong	Scalar
//  buildState                |  Tango::DevString	Scalar
//  centralLoggerStatus       |  Tango::DevEnum	Scalar
//  elementLoggerStatus       |  Tango::DevEnum	Scalar
//  storageLoggerStatus       |  Tango::DevEnum	Scalar
//  eventRate                 |  Tango::DevFloat	Scalar
//  exceptionRate             |  Tango::DevFloat	Scalar
//  fwdAttrInitStatus         |  Tango::DevEnum	Scalar
//  centralLoggerEnabled      |  Tango::DevBoolean	Scalar
//  elementLoggerEnabled      |  Tango::DevBoolean	Scalar
//  storageLoggerEnabled      |  Tango::DevBoolean	Scalar
//  loggingTargetCentral      |  Tango::DevString	Scalar
//  loggingTargetElement      |  Tango::DevString	Scalar
//  loggingTargetStorage      |  Tango::DevString	Scalar
//  attrRandomizationEnabled  |  Tango::DevBoolean	Scalar
//  attrRandomizationPeriod   |  Tango::DevULong	Scalar
//================================================================

namespace ElementLogger_ns
{
/*----- PROTECTED REGION ID(ElementLogger::namespace_starting) ENABLED START -----*/

//	static initializations

/*----- PROTECTED REGION END -----*/	//	ElementLogger::namespace_starting

//--------------------------------------------------------
/**
 *	Method      : ElementLogger::ElementLogger()
 *	Description : Constructors for a Tango device
 *                implementing the classElementLogger
 */
//--------------------------------------------------------
ElementLogger::ElementLogger(Tango::DeviceClass *cl, string &s)
 : LMCDevice(cl, s.c_str())
{
	/*----- PROTECTED REGION ID(ElementLogger::constructor_1) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	ElementLogger::constructor_1
}
//--------------------------------------------------------
ElementLogger::ElementLogger(Tango::DeviceClass *cl, const char *s)
 : LMCDevice(cl, s)
{
	/*----- PROTECTED REGION ID(ElementLogger::constructor_2) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	ElementLogger::constructor_2
}
//--------------------------------------------------------
ElementLogger::ElementLogger(Tango::DeviceClass *cl, const char *s, const char *d)
 : LMCDevice(cl, s, d)
{
	/*----- PROTECTED REGION ID(ElementLogger::constructor_3) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	ElementLogger::constructor_3
}

//--------------------------------------------------------
/**
 *	Method      : ElementLogger::delete_device()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void ElementLogger::delete_device()
{
	DEBUG_STREAM << "ElementLogger::delete_device() " << device_name << endl;
	/*----- PROTECTED REGION ID(ElementLogger::delete_device) ENABLED START -----*/
	
	//	Delete device allocated objects

	//## Delete log source group
	if(m_managedLogDeviceGroup){
		_DEBUG_LOG("Deleting group instance...");	
		delete m_managedLogDeviceGroup;
		m_managedLogDeviceGroup= 0;
	}	

	//## Delete SE log source map
	std::map<std::string,Tango::DeviceProxy*>::iterator it= m_managedSELogAdminDeviceMap.begin();
	for(it=m_managedSELogAdminDeviceMap.begin();it!=m_managedSELogAdminDeviceMap.end();it++){
		if(it->second){
			delete it->second;
			it->second= 0;
		}
	}
	m_managedSELogAdminDeviceMap.clear();


	/*----- PROTECTED REGION END -----*/	//	ElementLogger::delete_device

	if (Tango::Util::instance()->is_svr_shutting_down()==false  &&
		Tango::Util::instance()->is_device_restarting(device_name)==false &&
		Tango::Util::instance()->is_svr_starting()==false)
	{
		//	If not shutting down call delete device for inherited object
		LMCDevice_ns::LMCDevice::delete_device();
	}
}

//--------------------------------------------------------
/**
 *	Method      : ElementLogger::init_device()
 *	Description : will be called at device initialization.
 */
//--------------------------------------------------------
void ElementLogger::init_device()
{
	DEBUG_STREAM << "ElementLogger::init_device() create device " << device_name << endl;
	/*----- PROTECTED REGION ID(ElementLogger::init_device_before) ENABLED START -----*/
	
	//	Initialization before get_device_property() call
	
	/*----- PROTECTED REGION END -----*/	//	ElementLogger::init_device_before
	
	if (Tango::Util::instance()->is_svr_starting() == false  &&
		Tango::Util::instance()->is_device_restarting(device_name)==false)
	{
		//	If not starting up call init device for inherited object
		LMCDevice_ns::LMCDevice::init_device();
	}

	//	Get the device properties from database
	get_device_property();
	
	//	No longer if mandatory property not set. 
	if (mandatoryNotDefined)
		return;

	/*----- PROTECTED REGION ID(ElementLogger::init_device) ENABLED START -----*/
	
	//	Initialize device
	set_state(Tango::INIT);
	set_status("Initializing ElementLogger...");
	
	/*----- PROTECTED REGION END -----*/	//	ElementLogger::init_device
}

//--------------------------------------------------------
/**
 *	Method      : ElementLogger::get_device_property()
 *	Description : Read database to initialize property data members.
 */
//--------------------------------------------------------
void ElementLogger::get_device_property()
{
	/*----- PROTECTED REGION ID(ElementLogger::get_device_property_before) ENABLED START -----*/
	
	//	Initialize property data members
	
	/*----- PROTECTED REGION END -----*/	//	ElementLogger::get_device_property_before

	mandatoryNotDefined = false;

	//	Read device properties from database.
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("StorageLoggerEnabledDefault"));
	dev_prop.push_back(Tango::DbDatum("SyslogFacility"));
	dev_prop.push_back(Tango::DbDatum("SkaLevel"));
	dev_prop.push_back(Tango::DbDatum("LoggingLevelCentralDefault"));
	dev_prop.push_back(Tango::DbDatum("LoggingLevelElementDefault"));
	dev_prop.push_back(Tango::DbDatum("LoggingLevelStorageDefault"));
	dev_prop.push_back(Tango::DbDatum("LoggingTargetCentralDefault"));
	dev_prop.push_back(Tango::DbDatum("LoggingTargetElementDefault"));
	dev_prop.push_back(Tango::DbDatum("LoggingTargetStorageDefault"));
	dev_prop.push_back(Tango::DbDatum("ElementLoggerEnabledDefault"));
	dev_prop.push_back(Tango::DbDatum("CentralLoggerEnabledDefault"));
	dev_prop.push_back(Tango::DbDatum("EnableLogForwardDefault"));
	dev_prop.push_back(Tango::DbDatum("LogForwardSources"));
	dev_prop.push_back(Tango::DbDatum("ManagedLogDevicesDefault"));
	dev_prop.push_back(Tango::DbDatum("SyslogHost"));
	dev_prop.push_back(Tango::DbDatum("ConfigFile"));
	dev_prop.push_back(Tango::DbDatum("EnableConfigFromFile"));
	dev_prop.push_back(Tango::DbDatum("EnableDynAttrCleanup"));
	dev_prop.push_back(Tango::DbDatum("EnableDynAttrRandomize"));
	dev_prop.push_back(Tango::DbDatum("DynAttrRandomizePeriod"));
	dev_prop.push_back(Tango::DbDatum("ProxyDevices"));
	dev_prop.push_back(Tango::DbDatum("FormulaVarMaxTimeInterval"));
	dev_prop.push_back(Tango::DbDatum("EnableProxyMonitoring"));
	dev_prop.push_back(Tango::DbDatum("ProxyMonitoringPeriod"));
	dev_prop.push_back(Tango::DbDatum("ProxyStatusAttrPollPeriod"));
	dev_prop.push_back(Tango::DbDatum("ProxyStatusAttrPeriodicEventPeriod"));
	dev_prop.push_back(Tango::DbDatum("ProxyStatusAttrArchiveEventPeriod"));
	dev_prop.push_back(Tango::DbDatum("ProxyTimeout"));
	dev_prop.push_back(Tango::DbDatum("EventSubscriptions"));
	dev_prop.push_back(Tango::DbDatum("EventHandlers"));
	dev_prop.push_back(Tango::DbDatum("MaxQueueableTask"));
	dev_prop.push_back(Tango::DbDatum("MaxTrackableTasks"));
	dev_prop.push_back(Tango::DbDatum("TaskHistoryTimeDepth"));
	dev_prop.push_back(Tango::DbDatum("DefaultTaskTimeout"));
	dev_prop.push_back(Tango::DbDatum("TaskSequenceStatusAttrList"));
	dev_prop.push_back(Tango::DbDatum("TaskStatusAttrList"));
	dev_prop.push_back(Tango::DbDatum("EnableEventRateMonitoring"));
	dev_prop.push_back(Tango::DbDatum("ManagedSELogDevicesDefault"));
	dev_prop.push_back(Tango::DbDatum("RxControllerAddress"));
	dev_prop.push_back(Tango::DbDatum("SpfControllerAddress"));
	dev_prop.push_back(Tango::DbDatum("EnableLoggerInitPolling"));
	dev_prop.push_back(Tango::DbDatum("LoggerInitPollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableDevProxyInitPolling"));
	dev_prop.push_back(Tango::DbDatum("DevProxyInitPollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableFwdAttrInitPolling"));
	dev_prop.push_back(Tango::DbDatum("FwdAttrInitPollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableFormulaAttrUpdatePolling"));
	dev_prop.push_back(Tango::DbDatum("FormulaAttrUpdatePollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableStatusAttrUpdatePolling"));
	dev_prop.push_back(Tango::DbDatum("StatusAttrUpdatePollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableClearTaskPolling"));
	dev_prop.push_back(Tango::DbDatum("ClearTaskPollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableProxyStatusAttrCreation"));
	dev_prop.push_back(Tango::DbDatum("EnableAutoAdminProxyRegistration"));
	dev_prop.push_back(Tango::DbDatum("ProcessEventsInQueueThread"));
	dev_prop.push_back(Tango::DbDatum("SELogLevelDefault"));

	//	is there at least one property to be read ?
	if (dev_prop.size()>0)
	{
		//	Call database and extract values
		if (Tango::Util::instance()->_UseDb==true)
			get_db_device()->get_property(dev_prop);
	
		//	get instance on ElementLoggerClass to get class property
		Tango::DbDatum	def_prop, cl_prop;
		ElementLoggerClass	*ds_class =
			(static_cast<ElementLoggerClass *>(get_device_class()));
		int	i = -1;

		//	Try to initialize StorageLoggerEnabledDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  storageLoggerEnabledDefault;
		else {
			//	Try to initialize StorageLoggerEnabledDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  storageLoggerEnabledDefault;
		}
		//	And try to extract StorageLoggerEnabledDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  storageLoggerEnabledDefault;

		//	Try to initialize SyslogFacility from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  syslogFacility;
		else {
			//	Try to initialize SyslogFacility from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  syslogFacility;
		}
		//	And try to extract SyslogFacility value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  syslogFacility;

		//	Try to initialize SkaLevel from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  skaLevel;
		else {
			//	Try to initialize SkaLevel from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  skaLevel;
		}
		//	And try to extract SkaLevel value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  skaLevel;

		//	Try to initialize LoggingLevelCentralDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingLevelCentralDefault;
		else {
			//	Try to initialize LoggingLevelCentralDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingLevelCentralDefault;
		}
		//	And try to extract LoggingLevelCentralDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingLevelCentralDefault;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize LoggingLevelElementDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingLevelElementDefault;
		else {
			//	Try to initialize LoggingLevelElementDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingLevelElementDefault;
		}
		//	And try to extract LoggingLevelElementDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingLevelElementDefault;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize LoggingLevelStorageDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingLevelStorageDefault;
		else {
			//	Try to initialize LoggingLevelStorageDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingLevelStorageDefault;
		}
		//	And try to extract LoggingLevelStorageDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingLevelStorageDefault;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize LoggingTargetCentralDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingTargetCentralDefault;
		else {
			//	Try to initialize LoggingTargetCentralDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingTargetCentralDefault;
		}
		//	And try to extract LoggingTargetCentralDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingTargetCentralDefault;

		//	Try to initialize LoggingTargetElementDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingTargetElementDefault;
		else {
			//	Try to initialize LoggingTargetElementDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingTargetElementDefault;
		}
		//	And try to extract LoggingTargetElementDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingTargetElementDefault;

		//	Try to initialize LoggingTargetStorageDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingTargetStorageDefault;
		else {
			//	Try to initialize LoggingTargetStorageDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingTargetStorageDefault;
		}
		//	And try to extract LoggingTargetStorageDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingTargetStorageDefault;

		//	Try to initialize ElementLoggerEnabledDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  elementLoggerEnabledDefault;
		else {
			//	Try to initialize ElementLoggerEnabledDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  elementLoggerEnabledDefault;
		}
		//	And try to extract ElementLoggerEnabledDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  elementLoggerEnabledDefault;

		//	Try to initialize CentralLoggerEnabledDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  centralLoggerEnabledDefault;
		else {
			//	Try to initialize CentralLoggerEnabledDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  centralLoggerEnabledDefault;
		}
		//	And try to extract CentralLoggerEnabledDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  centralLoggerEnabledDefault;

		//	Try to initialize EnableLogForwardDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableLogForwardDefault;
		else {
			//	Try to initialize EnableLogForwardDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableLogForwardDefault;
		}
		//	And try to extract EnableLogForwardDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableLogForwardDefault;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize LogForwardSources from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  logForwardSources;
		else {
			//	Try to initialize LogForwardSources from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  logForwardSources;
		}
		//	And try to extract LogForwardSources value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  logForwardSources;

		//	Try to initialize ManagedLogDevicesDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  managedLogDevicesDefault;
		else {
			//	Try to initialize ManagedLogDevicesDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  managedLogDevicesDefault;
		}
		//	And try to extract ManagedLogDevicesDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  managedLogDevicesDefault;

		//	Try to initialize SyslogHost from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  syslogHost;
		else {
			//	Try to initialize SyslogHost from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  syslogHost;
		}
		//	And try to extract SyslogHost value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  syslogHost;

		//	Try to initialize ConfigFile from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  configFile;
		else {
			//	Try to initialize ConfigFile from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  configFile;
		}
		//	And try to extract ConfigFile value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  configFile;

		//	Try to initialize EnableConfigFromFile from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableConfigFromFile;
		else {
			//	Try to initialize EnableConfigFromFile from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableConfigFromFile;
		}
		//	And try to extract EnableConfigFromFile value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableConfigFromFile;

		//	Try to initialize EnableDynAttrCleanup from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableDynAttrCleanup;
		else {
			//	Try to initialize EnableDynAttrCleanup from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableDynAttrCleanup;
		}
		//	And try to extract EnableDynAttrCleanup value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableDynAttrCleanup;

		//	Try to initialize EnableDynAttrRandomize from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableDynAttrRandomize;
		else {
			//	Try to initialize EnableDynAttrRandomize from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableDynAttrRandomize;
		}
		//	And try to extract EnableDynAttrRandomize value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableDynAttrRandomize;

		//	Try to initialize DynAttrRandomizePeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  dynAttrRandomizePeriod;
		else {
			//	Try to initialize DynAttrRandomizePeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  dynAttrRandomizePeriod;
		}
		//	And try to extract DynAttrRandomizePeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  dynAttrRandomizePeriod;

		//	Try to initialize ProxyDevices from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyDevices;
		else {
			//	Try to initialize ProxyDevices from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyDevices;
		}
		//	And try to extract ProxyDevices value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyDevices;

		//	Try to initialize FormulaVarMaxTimeInterval from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  formulaVarMaxTimeInterval;
		else {
			//	Try to initialize FormulaVarMaxTimeInterval from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  formulaVarMaxTimeInterval;
		}
		//	And try to extract FormulaVarMaxTimeInterval value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  formulaVarMaxTimeInterval;

		//	Try to initialize EnableProxyMonitoring from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableProxyMonitoring;
		else {
			//	Try to initialize EnableProxyMonitoring from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableProxyMonitoring;
		}
		//	And try to extract EnableProxyMonitoring value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableProxyMonitoring;

		//	Try to initialize ProxyMonitoringPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyMonitoringPeriod;
		else {
			//	Try to initialize ProxyMonitoringPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyMonitoringPeriod;
		}
		//	And try to extract ProxyMonitoringPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyMonitoringPeriod;

		//	Try to initialize ProxyStatusAttrPollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyStatusAttrPollPeriod;
		else {
			//	Try to initialize ProxyStatusAttrPollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyStatusAttrPollPeriod;
		}
		//	And try to extract ProxyStatusAttrPollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyStatusAttrPollPeriod;

		//	Try to initialize ProxyStatusAttrPeriodicEventPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyStatusAttrPeriodicEventPeriod;
		else {
			//	Try to initialize ProxyStatusAttrPeriodicEventPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyStatusAttrPeriodicEventPeriod;
		}
		//	And try to extract ProxyStatusAttrPeriodicEventPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyStatusAttrPeriodicEventPeriod;

		//	Try to initialize ProxyStatusAttrArchiveEventPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyStatusAttrArchiveEventPeriod;
		else {
			//	Try to initialize ProxyStatusAttrArchiveEventPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyStatusAttrArchiveEventPeriod;
		}
		//	And try to extract ProxyStatusAttrArchiveEventPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyStatusAttrArchiveEventPeriod;

		//	Try to initialize ProxyTimeout from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyTimeout;
		else {
			//	Try to initialize ProxyTimeout from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyTimeout;
		}
		//	And try to extract ProxyTimeout value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyTimeout;

		//	Try to initialize EventSubscriptions from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  eventSubscriptions;
		else {
			//	Try to initialize EventSubscriptions from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  eventSubscriptions;
		}
		//	And try to extract EventSubscriptions value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  eventSubscriptions;

		//	Try to initialize EventHandlers from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  eventHandlers;
		else {
			//	Try to initialize EventHandlers from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  eventHandlers;
		}
		//	And try to extract EventHandlers value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  eventHandlers;

		//	Try to initialize MaxQueueableTask from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  maxQueueableTask;
		else {
			//	Try to initialize MaxQueueableTask from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  maxQueueableTask;
		}
		//	And try to extract MaxQueueableTask value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  maxQueueableTask;

		//	Try to initialize MaxTrackableTasks from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  maxTrackableTasks;
		else {
			//	Try to initialize MaxTrackableTasks from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  maxTrackableTasks;
		}
		//	And try to extract MaxTrackableTasks value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  maxTrackableTasks;

		//	Try to initialize TaskHistoryTimeDepth from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  taskHistoryTimeDepth;
		else {
			//	Try to initialize TaskHistoryTimeDepth from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  taskHistoryTimeDepth;
		}
		//	And try to extract TaskHistoryTimeDepth value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  taskHistoryTimeDepth;

		//	Try to initialize DefaultTaskTimeout from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  defaultTaskTimeout;
		else {
			//	Try to initialize DefaultTaskTimeout from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  defaultTaskTimeout;
		}
		//	And try to extract DefaultTaskTimeout value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  defaultTaskTimeout;

		//	Try to initialize TaskSequenceStatusAttrList from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  taskSequenceStatusAttrList;
		else {
			//	Try to initialize TaskSequenceStatusAttrList from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  taskSequenceStatusAttrList;
		}
		//	And try to extract TaskSequenceStatusAttrList value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  taskSequenceStatusAttrList;

		//	Try to initialize TaskStatusAttrList from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  taskStatusAttrList;
		else {
			//	Try to initialize TaskStatusAttrList from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  taskStatusAttrList;
		}
		//	And try to extract TaskStatusAttrList value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  taskStatusAttrList;

		//	Try to initialize EnableEventRateMonitoring from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableEventRateMonitoring;
		else {
			//	Try to initialize EnableEventRateMonitoring from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableEventRateMonitoring;
		}
		//	And try to extract EnableEventRateMonitoring value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableEventRateMonitoring;

		//	Try to initialize ManagedSELogDevicesDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  managedSELogDevicesDefault;
		else {
			//	Try to initialize ManagedSELogDevicesDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  managedSELogDevicesDefault;
		}
		//	And try to extract ManagedSELogDevicesDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  managedSELogDevicesDefault;

		//	Try to initialize RxControllerAddress from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  rxControllerAddress;
		else {
			//	Try to initialize RxControllerAddress from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  rxControllerAddress;
		}
		//	And try to extract RxControllerAddress value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  rxControllerAddress;

		//	Try to initialize SpfControllerAddress from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  spfControllerAddress;
		else {
			//	Try to initialize SpfControllerAddress from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  spfControllerAddress;
		}
		//	And try to extract SpfControllerAddress value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  spfControllerAddress;

		//	Try to initialize EnableLoggerInitPolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableLoggerInitPolling;
		else {
			//	Try to initialize EnableLoggerInitPolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableLoggerInitPolling;
		}
		//	And try to extract EnableLoggerInitPolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableLoggerInitPolling;

		//	Try to initialize LoggerInitPollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggerInitPollPeriod;
		else {
			//	Try to initialize LoggerInitPollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggerInitPollPeriod;
		}
		//	And try to extract LoggerInitPollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggerInitPollPeriod;

		//	Try to initialize EnableDevProxyInitPolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableDevProxyInitPolling;
		else {
			//	Try to initialize EnableDevProxyInitPolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableDevProxyInitPolling;
		}
		//	And try to extract EnableDevProxyInitPolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableDevProxyInitPolling;

		//	Try to initialize DevProxyInitPollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  devProxyInitPollPeriod;
		else {
			//	Try to initialize DevProxyInitPollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  devProxyInitPollPeriod;
		}
		//	And try to extract DevProxyInitPollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  devProxyInitPollPeriod;

		//	Try to initialize EnableFwdAttrInitPolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableFwdAttrInitPolling;
		else {
			//	Try to initialize EnableFwdAttrInitPolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableFwdAttrInitPolling;
		}
		//	And try to extract EnableFwdAttrInitPolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableFwdAttrInitPolling;

		//	Try to initialize FwdAttrInitPollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  fwdAttrInitPollPeriod;
		else {
			//	Try to initialize FwdAttrInitPollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  fwdAttrInitPollPeriod;
		}
		//	And try to extract FwdAttrInitPollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  fwdAttrInitPollPeriod;

		//	Try to initialize EnableFormulaAttrUpdatePolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableFormulaAttrUpdatePolling;
		else {
			//	Try to initialize EnableFormulaAttrUpdatePolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableFormulaAttrUpdatePolling;
		}
		//	And try to extract EnableFormulaAttrUpdatePolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableFormulaAttrUpdatePolling;

		//	Try to initialize FormulaAttrUpdatePollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  formulaAttrUpdatePollPeriod;
		else {
			//	Try to initialize FormulaAttrUpdatePollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  formulaAttrUpdatePollPeriod;
		}
		//	And try to extract FormulaAttrUpdatePollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  formulaAttrUpdatePollPeriod;

		//	Try to initialize EnableStatusAttrUpdatePolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableStatusAttrUpdatePolling;
		else {
			//	Try to initialize EnableStatusAttrUpdatePolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableStatusAttrUpdatePolling;
		}
		//	And try to extract EnableStatusAttrUpdatePolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableStatusAttrUpdatePolling;

		//	Try to initialize StatusAttrUpdatePollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  statusAttrUpdatePollPeriod;
		else {
			//	Try to initialize StatusAttrUpdatePollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  statusAttrUpdatePollPeriod;
		}
		//	And try to extract StatusAttrUpdatePollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  statusAttrUpdatePollPeriod;

		//	Try to initialize EnableClearTaskPolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableClearTaskPolling;
		else {
			//	Try to initialize EnableClearTaskPolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableClearTaskPolling;
		}
		//	And try to extract EnableClearTaskPolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableClearTaskPolling;

		//	Try to initialize ClearTaskPollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  clearTaskPollPeriod;
		else {
			//	Try to initialize ClearTaskPollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  clearTaskPollPeriod;
		}
		//	And try to extract ClearTaskPollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  clearTaskPollPeriod;

		//	Try to initialize EnableProxyStatusAttrCreation from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableProxyStatusAttrCreation;
		else {
			//	Try to initialize EnableProxyStatusAttrCreation from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableProxyStatusAttrCreation;
		}
		//	And try to extract EnableProxyStatusAttrCreation value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableProxyStatusAttrCreation;

		//	Try to initialize EnableAutoAdminProxyRegistration from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableAutoAdminProxyRegistration;
		else {
			//	Try to initialize EnableAutoAdminProxyRegistration from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableAutoAdminProxyRegistration;
		}
		//	And try to extract EnableAutoAdminProxyRegistration value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableAutoAdminProxyRegistration;

		//	Try to initialize ProcessEventsInQueueThread from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  processEventsInQueueThread;
		else {
			//	Try to initialize ProcessEventsInQueueThread from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  processEventsInQueueThread;
		}
		//	And try to extract ProcessEventsInQueueThread value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  processEventsInQueueThread;

		//	Try to initialize SELogLevelDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  sELogLevelDefault;
		else {
			//	Try to initialize SELogLevelDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  sELogLevelDefault;
		}
		//	And try to extract SELogLevelDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  sELogLevelDefault;

	}

	/*----- PROTECTED REGION ID(ElementLogger::get_device_property_after) ENABLED START -----*/
	
	//	Check device property data members init
	
	/*----- PROTECTED REGION END -----*/	//	ElementLogger::get_device_property_after
}
//--------------------------------------------------------
/**
 *	Method      : ElementLogger::check_mandatory_property()
 *	Description : For mandatory properties check if defined in database.
 */
//--------------------------------------------------------
void ElementLogger::check_mandatory_property(Tango::DbDatum &class_prop, Tango::DbDatum &dev_prop)
{
	//	Check if all properties are empty
	if (class_prop.is_empty() && dev_prop.is_empty())
	{
		TangoSys_OMemStream	tms;
		tms << endl <<"Property \'" << dev_prop.name;
		if (Tango::Util::instance()->_UseDb==true)
			tms << "\' is mandatory but not defined in database";
		else
			tms << "\' is mandatory but cannot be defined without database";
		string	status(get_status());
		status += tms.str();
		set_status(status);
		mandatoryNotDefined = true;
		/*----- PROTECTED REGION ID(ElementLogger::check_mandatory_property) ENABLED START -----*/
		cerr << tms.str() << " for " << device_name << endl;
		
		/*----- PROTECTED REGION END -----*/	//	ElementLogger::check_mandatory_property
	}
}


//--------------------------------------------------------
/**
 *	Method      : ElementLogger::always_executed_hook()
 *	Description : method always executed before any command is executed
 */
//--------------------------------------------------------
void ElementLogger::always_executed_hook()
{
	DEBUG_STREAM << "ElementLogger::always_executed_hook()  " << device_name << endl;
	if (mandatoryNotDefined)
	{
		string	status(get_status());
		Tango::Except::throw_exception(
					(const char *)"PROPERTY_NOT_SET",
					status.c_str(),
					(const char *)"ElementLogger::always_executed_hook()");
	}
	/*----- PROTECTED REGION ID(ElementLogger::always_executed_hook) ENABLED START -----*/
	
	//	code always executed before all requests
	
	/*----- PROTECTED REGION END -----*/	//	ElementLogger::always_executed_hook
}

//--------------------------------------------------------
/**
 *	Method      : ElementLogger::read_attr_hardware()
 *	Description : Hardware acquisition for attributes
 */
//--------------------------------------------------------
void ElementLogger::read_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "ElementLogger::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(ElementLogger::read_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	ElementLogger::read_attr_hardware
}
//--------------------------------------------------------
/**
 *	Method      : ElementLogger::write_attr_hardware()
 *	Description : Hardware writing for attributes
 */
//--------------------------------------------------------
void ElementLogger::write_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "ElementLogger::write_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(ElementLogger::write_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	ElementLogger::write_attr_hardware
}


//--------------------------------------------------------
/**
 *	Method      : ElementLogger::add_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *                for specified device.
 */
//--------------------------------------------------------
void ElementLogger::add_dynamic_attributes()
{
	/*----- PROTECTED REGION ID(ElementLogger::add_dynamic_attributes) ENABLED START -----*/
	
	
	//	Add your own code to create and add dynamic attributes if any
	LMCDevice::add_dynamic_attributes();
	
	/*
	//Add dynamic attributes from config file
	if(AddDynAttrs()<0){
		std::string errMsg("Failed to create dyn attributes!");
		_ERROR_LOG(errMsg);
		set_status(errMsg.c_str());
		set_state(Tango::FAULT);
		return;
	}
	
	//Configure state machine for cmd & attrs
	if(InitCmdAttrStateMachine()<0){
		std::string errMsg("Failed to create cmd & attr state machines for dyn attributes!");
		_ERROR_LOG(errMsg);
		set_status(errMsg.c_str());
		set_state(Tango::FAULT);
		return;
	}
	*/

	/*----- PROTECTED REGION END -----*/	//	ElementLogger::add_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Command log related method
 *	Description: Command to handle logs received from devices
 *
 *	@param argin Logging info received from emitter devices
 */
//--------------------------------------------------------
void ElementLogger::log(const Tango::DevVarStringArray *argin)
{
	DEBUG_STREAM << "ElementLogger::log()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(ElementLogger::log) ENABLED START -----*/
	
	//	Add your own code

	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string logForwardingEnabled_attr_name= "enableLogForward";
	//###########################################################################

	//If log forwarding is disabled return
	Tango::DevBoolean logForwardingEnabled= false;
	if(GetDynAttrValue(logForwardingEnabled,logForwardingEnabled_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<logForwardingEnabled_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		return;
	}
	if(!logForwardingEnabled){
		_DEBUG_LOG("Log received, but log forwarding is disabled, nothing to be done");
		return;
	}
	

	//Get info of received log
	try {
		int n= argin->length();
		std::string log_level= std::string( (*argin)[1] );
		std::string log_source= std::string( (*argin)[2] ); 
		std::string log_msg= std::string( (*argin)[3] );
		double timestamp_ms = atof((*argin)[0]);
    unsigned long timestamp_sec = (unsigned long)(timestamp_ms/1000.);
    unsigned long timestamp_musec = (unsigned long)((timestamp_ms - timestamp_sec*1000.) * 1000);
    log4tango::TimeStamp t(timestamp_sec, timestamp_musec);
		_INFO_LOG("Log received (n="<<n<<") @ time="<<timestamp_ms<<", level="<<log_level<<", source="<<log_source<<", msg="<<log_msg);

		// Convert from string log level to tango enum log level
		log4tango::Level::Value log4_level= Utils_ns::TangoUtils::GetTangoLogLevelFromString(log_level);

		//Check if log source is within the selected devices 
		//int pos= -1;
		//bool isWithinFwSources= Utils_ns::CodeUtils::FindItem(logForwardSources,log_source,pos);
		bool isWithinFwSources= IsForwardedLogSource(log_source);

		//Forward log with same timestamp & source
		if(isWithinFwSources){
			(this->get_logger())->forward_log(log_source, t, log4_level, log_msg); 
	  }
	}//close try
	catch(Tango::DevFailed& e){
		_ERROR_LOG("Tango exception occurred while re-logging incoming log!");
		return;
	}
	catch(...){
		_ERROR_LOG("Unknown exception occurred while re-logging incoming log!");
		return;
	}

	
	/*----- PROTECTED REGION END -----*/	//	ElementLogger::log
}
//--------------------------------------------------------
/**
 *	Command TestLog related method
 *	Description: Generate a log in the device according to the given level.
 *               Used for testing purposes.
 *
 *	@param argin Long arg
 *               [0]: Level of log message
 *               (0=OFF, 1=FATAL, 2=ERROR, 3=WARNING, 4=INFO, 5=DEBUG)
 *               
 *               String arg
 *               [0]: log message
 */
//--------------------------------------------------------
void ElementLogger::test_log(const Tango::DevVarLongStringArray *argin)
{
	DEBUG_STREAM << "ElementLogger::TestLog()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(ElementLogger::test_log) ENABLED START -----*/
	
	//	Add your own code
	//Check args
	int nArgs_s= (int)((argin->svalue).length());
	int nArgs_l= (int)((argin->lvalue).length());
	if(nArgs_s<=0 || nArgs_l<=0){
		std::string errMsg("No arguments specified!");
		_THROW_TANGO_EXCEPTION("TEST_LOG_FAILED",errMsg);	
	}

	//Generate a log message
	Tango::DevLong log_level= (argin->lvalue)[0];
	//std::string log_level_str= Utils_ns::Logger::GetStringMappedLogLevel(log_level);
	std::string log_level_str= Utils_ns::TangoUtils::GetStringMappedLogLevel(log_level);	
	std::string log_msg( (argin->svalue)[0] );
	_INFO_LOG("Logging a test message (msg="<<log_msg<<") with level "<<log_level<<" ("<<log_level_str<<")...");
	_DEV_LOG(log_level_str,log_msg);

	/*----- PROTECTED REGION END -----*/	//	ElementLogger::test_log
}
//--------------------------------------------------------
/**
 *	Command AddLogSource related method
 *	Description: Add a device log source to the list of managed devices
 *
 *	@param argin Device name
 */
//--------------------------------------------------------
void ElementLogger::add_log_source(Tango::DevString argin)
{
	DEBUG_STREAM << "ElementLogger::AddLogSource()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(ElementLogger::add_log_source) ENABLED START -----*/
	
	//	Add your own code

	//Check argin
	std::string dev_name= std::string(argin);
	if(dev_name==""){
		std::string errMsg("Invalid argument given (empty string)!");
		_THROW_TANGO_EXCEPTION("ADD_LOG_SOURCE_FAILED",errMsg);
	}

	//Add log source to group
	if(AddLogSourceToGroup(dev_name)<0){
		std::stringstream ss;
		ss<<"Failed to add device "<<dev_name<<" to group!";
		_THROW_TANGO_EXCEPTION("ADD_LOG_SOURCE_FAILED",ss.str());	
	}

	/*----- PROTECTED REGION END -----*/	//	ElementLogger::add_log_source
}
//--------------------------------------------------------
/**
 *	Command RemoveLogSource related method
 *	Description: Remove a device log source from the list of managed devices
 *
 *	@param argin Device name
 */
//--------------------------------------------------------
void ElementLogger::remove_log_source(Tango::DevString argin)
{
	DEBUG_STREAM << "ElementLogger::RemoveLogSource()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(ElementLogger::remove_log_source) ENABLED START -----*/
	
	//	Add your own code

	//Check argin
	std::string dev_name= std::string(argin);
	if(dev_name==""){
		std::string errMsg("Invalid argument given (empty string)!");
		_THROW_TANGO_EXCEPTION("REMOVE_LOG_SOURCE_FAILED",errMsg);
	}

	//Remove log source device
	if(RemoveLogSourceFromGroup(dev_name)<0){
		std::stringstream ss;
		ss<<"Failed to remove device "<<dev_name<<" from group!";
		_THROW_TANGO_EXCEPTION("REMOVE_LOG_SOURCE_FAILED",ss.str());
	}

	/*----- PROTECTED REGION END -----*/	//	ElementLogger::remove_log_source
}
//--------------------------------------------------------
/**
 *	Command InitializeLogSources related method
 *	Description: Initialize log source group
 *
 */
//--------------------------------------------------------
void ElementLogger::initialize_log_sources()
{
	DEBUG_STREAM << "ElementLogger::InitializeLogSources()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(ElementLogger::initialize_log_sources) ENABLED START -----*/
	
	//	Add your own code

	//Init log source devices
	for(unsigned int i=0;i<m_log_source_devices.size();i++){
		std::string dev_name= m_log_source_devices[i];
		_DEBUG_LOG("Adding device "<<dev_name<<" to log sources...");
		if(AddLogSourceToGroup(dev_name)<0){
			_WARN_LOG("Failed to add log source device "<<dev_name<<", skip to next...");
			continue;
		}		
	}//end loop log source devices

	/*----- PROTECTED REGION END -----*/	//	ElementLogger::initialize_log_sources
}
//--------------------------------------------------------
/**
 *	Command InitializeSELogSources related method
 *	Description: Initialize Sub-Element log sources
 *
 */
//--------------------------------------------------------
void ElementLogger::initialize_selog_sources()
{
	DEBUG_STREAM << "ElementLogger::InitializeSELogSources()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(ElementLogger::initialize_selog_sources) ENABLED START -----*/
	
	//	Add your own code
	//Init SE log source devices
	for(unsigned int i=0;i<m_se_log_source_devices.size();i++){
		std::string dev_name= m_se_log_source_devices[i];
		_DEBUG_LOG("Adding device "<<dev_name<<" to log sources...");
		if(AddSELogSourceToGroup(dev_name)<0){
			_WARN_LOG("Failed to add SE log source device "<<dev_name<<", skip to next...");
			continue;
		}		
	}//end loop SE log source devices

	/*----- PROTECTED REGION END -----*/	//	ElementLogger::initialize_selog_sources
}
//--------------------------------------------------------
/**
 *	Command AddSELogSource related method
 *	Description: Add a device to SubElement log source group
 *
 *	@param argin Device name
 */
//--------------------------------------------------------
void ElementLogger::add_selog_source(Tango::DevString argin)
{
	DEBUG_STREAM << "ElementLogger::AddSELogSource()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(ElementLogger::add_selog_source) ENABLED START -----*/
	
	//	Add your own code
	//Check argin
	std::string dev_name= std::string(argin);
	if(dev_name==""){
		std::string errMsg("Invalid argument given (empty string)!");
		_THROW_TANGO_EXCEPTION("ADD_SE_LOG_SOURCE_FAILED",errMsg);
	}

	//Add log source to group
	if(AddSELogSourceToGroup(dev_name)<0){
		std::stringstream ss;
		ss<<"Failed to add device "<<dev_name<<" to group!";
		_THROW_TANGO_EXCEPTION("ADD_SE_LOG_SOURCE_FAILED",ss.str());	
	}

	/*----- PROTECTED REGION END -----*/	//	ElementLogger::add_selog_source
}
//--------------------------------------------------------
/**
 *	Command RemoveSELogSource related method
 *	Description: Remove a device from SubElement log source group
 *
 *	@param argin Device name
 */
//--------------------------------------------------------
void ElementLogger::remove_selog_source(Tango::DevString argin)
{
	DEBUG_STREAM << "ElementLogger::RemoveSELogSource()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(ElementLogger::remove_selog_source) ENABLED START -----*/
	
	//	Add your own code
	//Check argin
	std::string dev_name= std::string(argin);
	if(dev_name==""){
		std::string errMsg("Invalid argument given (empty string)!");
		_THROW_TANGO_EXCEPTION("REMOVE_SE_LOG_SOURCE_FAILED",errMsg);
	}

	//Remove log source device
	if(RemoveSELogSourceFromGroup(dev_name)<0){
		std::stringstream ss;
		ss<<"Failed to remove device "<<dev_name<<" from group!";
		_THROW_TANGO_EXCEPTION("REMOVE_SE_LOG_SOURCE_FAILED",ss.str());
	}
	/*----- PROTECTED REGION END -----*/	//	ElementLogger::remove_selog_source
}
//--------------------------------------------------------
/**
 *	Command SetLoggingLevelCentral related method
 *	Description: Update logging level to Central logger for specific devices.
 *               Typically used by TM/CentralLogger to configure 
 *               remote logging.
 *
 *	@param argin Long arg
 *               [0]: log level in Tango format
 *               
 *               String arg
 *               [0]: device 1
 *               [1]: device 2
 *               ...
 *               [N-1]: device N-1
 */
//--------------------------------------------------------
void ElementLogger::set_logging_level_central(const Tango::DevVarLongStringArray *argin)
{
	DEBUG_STREAM << "ElementLogger::SetLoggingLevelCentral()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(ElementLogger::set_logging_level_central) ENABLED START -----*/
	
	//	Add your own code
	//===================================================
	//==           HARD-CODED PARS
	//===================================================
	std::string attr_name= "loggingLevelCentral";
	//===================================================
	
	//## Check args
	int nArgs_s= (int)((argin->svalue).length());
	int nArgs_l= (int)((argin->lvalue).length());
	if(nArgs_l<=0){
		std::string errMsg("No arguments specified!");
		_THROW_TANGO_EXCEPTION("SET_LOGGING_LEVEL_CENTRAL_FAILED",errMsg);	
	}
	bool isSubGroup= true;	
	if(nArgs_s<=0) isSubGroup= false;
	
	Tango::DevLong log_level= (argin->lvalue)[0];
	std::vector<std::string> dev_names; 
	for(int i=0;i<nArgs_s;i++){ 
		std::string dev_name( (argin->svalue)[i] );
		dev_names.push_back(dev_name);
	}

	//## Check group
	if(!m_managedLogDeviceGroup){
		std::string errMsg("Log source group was not instantiated!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("SET_LOGGING_LEVEL_CENTRAL_FAILED",errMsg);	
	}

	if(m_managedLogDeviceGroup->get_size()<=0){
		std::string errMsg("Log source group is empty!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("SET_LOGGING_LEVEL_CENTRAL_FAILED",errMsg);	
	}

	
	//## Extract subgroup
	Tango::Group* grp= 0;
	if(isSubGroup){
		bool requireDevOnline= false;
		grp= Utils_ns::TangoUtils::GetSubGroup(this,m_managedLogDeviceGroup,dev_names,requireDevOnline);
		if(!grp){
			std::string errMsg("Failed to extract given devices from group (invalid/not existing device names?)");
			_THROW_TANGO_EXCEPTION("SET_LOGGING_LEVEL_CENTRAL_FAILED",errMsg);	
		}
	}
	else {
		grp= m_managedLogDeviceGroup;
	}

	//## Write attr to group
	try {
		if(Utils_ns::TangoUtils::WriteAttrToGroup<Tango::DevLong>(this,grp,attr_name,log_level)<0){		
			std::string errMsg("Failed to write attr to group (null ptr passed?)");
			_THROW_TANGO_EXCEPTION("SET_LOGGING_LEVEL_CENTRAL_FAILED",errMsg);
		}
	}//close try
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Failed to write attr to group!");
		throw;
	}
	
	//## If successful, change logging level of this device (make sense if all managed devices are changed)
	if(!isSubGroup) {
		try {
			_INFO_LOG("Changing central logging level...");
			Tango::WAttribute& wattr= get_device_attr()->get_w_attr_by_name(attr_name.c_str());
			wattr.set_write_value (log_level);
			LMCDevice::write_loggingLevelCentral(wattr);
		}
		catch(Tango::DevFailed& e){
			Tango::Except::print_exception(e);
			_ERROR_LOG("Failed to write attr "<<attr_name<<" to this device!");
			throw;
		}
	}//close if
	
	/*----- PROTECTED REGION END -----*/	//	ElementLogger::set_logging_level_central
}
//--------------------------------------------------------
/**
 *	Command SetLoggingLevelElement related method
 *	Description: Update logging level to Element logger for specific devices.
 *               Typically used by TM/Central logger or ElementLogger 
 *               to configure Element level logging.
 *
 *	@param argin Long arg
 *               [0]: log level in Tango format
 *               
 *               String arg
 *               [0]: device 1
 *               [1]: device 2
 *               ...
 *               [N-1]: device N-1
 */
//--------------------------------------------------------
void ElementLogger::set_logging_level_element(const Tango::DevVarLongStringArray *argin)
{
	DEBUG_STREAM << "ElementLogger::SetLoggingLevelElement()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(ElementLogger::set_logging_level_element) ENABLED START -----*/
	
	//	Add your own code
	//===================================================
	//==           HARD-CODED PARS
	//===================================================
	std::string attr_name= "loggingLevelElement";
	//===================================================

	//## Check args
	int nArgs_s= (int)((argin->svalue).length());
	int nArgs_l= (int)((argin->lvalue).length());
	if(nArgs_l<=0){
		std::string errMsg("No arguments specified!");
		_THROW_TANGO_EXCEPTION("SET_LOGGING_LEVEL_ELEMENT_FAILED",errMsg);
	}
	bool isSubGroup= true;	
	if(nArgs_s<=0) isSubGroup= false;
	
	Tango::DevLong log_level= (argin->lvalue)[0];
	std::vector<std::string> dev_names; 
	for(int i=0;i<nArgs_s;i++){ 
		std::string dev_name( (argin->svalue)[i] );
		dev_names.push_back(dev_name);
	}

	//## Check group
	if(!m_managedLogDeviceGroup){
		std::string errMsg("Log source group was not instantiated!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("SET_LOGGING_LEVEL_ELEMENT_FAILED",errMsg);
	}

	if(m_managedLogDeviceGroup->get_size()<=0){
		std::string errMsg("Log source group is empty!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("SET_LOGGING_LEVEL_ELEMENT_FAILED",errMsg);
	}

	
	//## Extract subgroup
	Tango::Group* grp= 0;
	if(isSubGroup){
		bool requireDevOnline= false;
		grp= Utils_ns::TangoUtils::GetSubGroup(this,m_managedLogDeviceGroup,dev_names,requireDevOnline);
		if(!grp){
			std::string errMsg("Failed to extract given devices from group (invalid/not existing device names?)");
			_THROW_TANGO_EXCEPTION("SET_LOGGING_LEVEL_ELEMENT_FAILED",errMsg);
		}
	}
	else {
		grp= m_managedLogDeviceGroup;
	}

	//## Write attr to group
	try {
		if(Utils_ns::TangoUtils::WriteAttrToGroup<Tango::DevLong>(this,grp,attr_name,log_level)<0){		
			std::string errMsg("Failed to write attr to group (null ptr passed?)");
			_THROW_TANGO_EXCEPTION("SET_LOGGING_LEVEL_ELEMENT_FAILED",errMsg);	
		}
	}//close try
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Failed to write attr to group!");
		throw;
	}
	
	//## If successful, change logging level of this device (make sense if all managed devices are changed)
	if(!isSubGroup) {
		try {
			_INFO_LOG("Changing Element logging level...");
			Tango::WAttribute& wattr= get_device_attr()->get_w_attr_by_name(attr_name.c_str());
			wattr.set_write_value(log_level);
			LMCDevice::write_loggingLevelElement(wattr);
		}
		catch(Tango::DevFailed& e){
			Tango::Except::print_exception(e);
			_ERROR_LOG("Failed to write attr "<<attr_name<<" to this device!");
			throw;
		}
	}//close if

	/*----- PROTECTED REGION END -----*/	//	ElementLogger::set_logging_level_element
}
//--------------------------------------------------------
/**
 *	Command SetLoggingLevelStorage related method
 *	Description: Update logging level to Syslog for specific devices.
 *               Typically used by TM/Central logger or ElementLogger 
 *               to configure logging level for storage.
 *
 *	@param argin Long arg
 *               [0]: log level in Tango format
 *               
 *               String arg
 *               [0]: device 1
 *               [1]: device 2
 *               ...
 *               [N-1]: device N-1
 */
//--------------------------------------------------------
void ElementLogger::set_logging_level_storage(const Tango::DevVarLongStringArray *argin)
{
	DEBUG_STREAM << "ElementLogger::SetLoggingLevelStorage()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(ElementLogger::set_logging_level_storage) ENABLED START -----*/
	
	//	Add your own code
	//===================================================
	//==           HARD-CODED PARS
	//===================================================
	std::string attr_name= "loggingLevelStorage";
	//===================================================

	//## Check args
	int nArgs_s= (int)((argin->svalue).length());
	int nArgs_l= (int)((argin->lvalue).length());
	if(nArgs_l<=0){
		std::string errMsg("No arguments specified!");
		_THROW_TANGO_EXCEPTION("SET_LOGGING_LEVEL_STORAGE_FAILED",errMsg);	
	}
	bool isSubGroup= true;	
	if(nArgs_s<=0) isSubGroup= false;
	
	Tango::DevLong log_level= (argin->lvalue)[0];
	std::vector<std::string> dev_names; 
	for(int i=0;i<nArgs_s;i++){ 
		std::string dev_name( (argin->svalue)[i] );
		dev_names.push_back(dev_name);
	}

	//## Check group
	if(!m_managedLogDeviceGroup){
		std::string errMsg("Log source group was not instantiated!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("SET_LOGGING_LEVEL_STORAGE_FAILED",errMsg);
	}

	if(m_managedLogDeviceGroup->get_size()<=0){
		std::string errMsg("Log source group is empty!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("SET_LOGGING_LEVEL_STORAGE_FAILED",errMsg);
	}

	//## Extract subgroup
	Tango::Group* grp= 0;
	if(isSubGroup){
		bool requireDevOnline= false;
		grp= Utils_ns::TangoUtils::GetSubGroup(this,m_managedLogDeviceGroup,dev_names,requireDevOnline);
		if(!grp){
			std::string errMsg("Failed to extract given devices from group (invalid/not existing device names?)");
			_THROW_TANGO_EXCEPTION("SET_LOGGING_LEVEL_STORAGE_FAILED",errMsg);
		}
	}
	else {
		grp= m_managedLogDeviceGroup;
	}

	//## Write attr to group
	try {
		if(Utils_ns::TangoUtils::WriteAttrToGroup<Tango::DevLong>(this,grp,attr_name,log_level)<0){		
			std::string errMsg("Failed to write attr to group (null ptr passed?)");
			_THROW_TANGO_EXCEPTION("SET_LOGGING_LEVEL_STORAGE_FAILED",errMsg);	
		}
	}//close try
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Failed to write attr to group!");
		throw;
	}
	
	//## If successful, change logging level of this device (make sense if all managed devices are changed)
	if(!isSubGroup) {
		try {
			_INFO_LOG("Changing storage logging level...");
			Tango::WAttribute& wattr= get_device_attr()->get_w_attr_by_name(attr_name.c_str());
			wattr.set_write_value (log_level);
			LMCDevice::write_loggingLevelElement(wattr);
		}
		catch(Tango::DevFailed& e){
			Tango::Except::print_exception(e);
			_ERROR_LOG("Failed to write attr to this device!");
			throw;
		}
	}//close if

	/*----- PROTECTED REGION END -----*/	//	ElementLogger::set_logging_level_storage
}
//--------------------------------------------------------
/**
 *	Command SetSPFLoggingLevel related method
 *	Description: Set SPF logging level. This command changes the logging
 *               level of SPFController Tango device only and NOT of the 
 *               internal SPF devices.
 *
 *	@param argin Log level in Tango format
 */
//--------------------------------------------------------
void ElementLogger::set_spflogging_level(Tango::DevLong argin)
{
	DEBUG_STREAM << "ElementLogger::SetSPFLoggingLevel()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(ElementLogger::set_spflogging_level) ENABLED START -----*/
	
	//	Add your own code
	
	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	try{
		SetSELoggingLevel(spfControllerAddress,argin);
	}
	catch(Tango::DevFailed& e){
		_WARN_LOG("Failed to set SPF logging level!");
		throw;
	}

	/*----- PROTECTED REGION END -----*/	//	ElementLogger::set_spflogging_level
}
//--------------------------------------------------------
/**
 *	Command SetRxLoggingLevel related method
 *	Description: Set the logging level of Rx controller.
 *
 *	@param argin Log level in Tango format
 */
//--------------------------------------------------------
void ElementLogger::set_rx_logging_level(Tango::DevLong argin)
{
	DEBUG_STREAM << "ElementLogger::SetRxLoggingLevel()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(ElementLogger::set_rx_logging_level) ENABLED START -----*/
	
	//	Add your own code
	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	try{
		SetSELoggingLevel(rxControllerAddress,argin);
	}
	catch(Tango::DevFailed& e){
		_WARN_LOG("Failed to set Rx logging level!");
		throw;
	}
	/*----- PROTECTED REGION END -----*/	//	ElementLogger::set_rx_logging_level
}
//--------------------------------------------------------
/**
 *	Command SetSPFLoggingTarget related method
 *	Description: Set SPF device logging target
 *               NB: All existing device log targets will be removed.
 *
 *	@param argin Device to be set as log target in SPF
 */
//--------------------------------------------------------
void ElementLogger::set_spflogging_target(Tango::DevString argin)
{
	DEBUG_STREAM << "ElementLogger::SetSPFLoggingTarget()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(ElementLogger::set_spflogging_target) ENABLED START -----*/
	
	//	Add your own code
	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	std::stringstream ss;
	ss<<"device::"<<argin;
	std::string cmd_argin= ss.str();
	try{
		SetSELoggingTarget(spfControllerAddress,cmd_argin);
	}
	catch(Tango::DevFailed& e){
		_WARN_LOG("Failed to set SPF logging target "<<cmd_argin<<"!");
		throw;
	}
	/*----- PROTECTED REGION END -----*/	//	ElementLogger::set_spflogging_target
}
//--------------------------------------------------------
/**
 *	Command SetRxLoggingTarget related method
 *	Description: Set device log target for SPFRx. 
 *               NB: All existing targets previously set will be removed.
 *
 *	@param argin Device name to be set as log target for SPFRx
 */
//--------------------------------------------------------
void ElementLogger::set_rx_logging_target(Tango::DevString argin)
{
	DEBUG_STREAM << "ElementLogger::SetRxLoggingTarget()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(ElementLogger::set_rx_logging_target) ENABLED START -----*/
	
	//	Add your own code
	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	std::stringstream ss;
	ss<<"device::"<<argin;
	std::string cmd_argin= ss.str();
	try{
		SetSELoggingTarget(rxControllerAddress,cmd_argin);
	}
	catch(Tango::DevFailed& e){
		_WARN_LOG("Failed to set Rx logging target "<<cmd_argin<<"!");
		throw;
	}

	/*----- PROTECTED REGION END -----*/	//	ElementLogger::set_rx_logging_target
}
//--------------------------------------------------------
/**
 *	Command EnableCentralLogger related method
 *	Description: Enable central logger in all or in sub-set of managed LMC
 *               devices.
 *
 *	@param argin List of managed LMC device over which the command will be applied.
 *               If empty, applied to all devices.
 *               
 *               [0]: device 1
 *               [1]: device 2
 *               ...
 *               [N-1]: device N-1
 */
//--------------------------------------------------------
void ElementLogger::enable_central_logger(const Tango::DevVarStringArray *argin)
{
	DEBUG_STREAM << "ElementLogger::EnableCentralLogger()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(ElementLogger::enable_central_logger) ENABLED START -----*/
	
	//	Add your own code
	//================================================
	//==      HARD-CODED PARS
	//================================================
	std::string attr_name= "centralLoggerEnabled";
	Tango::DevBoolean attr_value= true;
	//================================================

	//## Check and retrieve args
	int nArgs= (int)(argin->length());
	bool isSubGroup= true;	
	std::vector<std::string> dev_names; 
	if(nArgs<=0) {
		isSubGroup= false;
	}
	else{
		for(int i=0;i<nArgs;i++){ 
			std::string dev_name( (*argin)[i] );
			dev_names.push_back(dev_name);
		}
	}

	//## Check group
	if(!m_managedLogDeviceGroup){
		std::string errMsg("Log source group was not instantiated!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("ENABLE_CENTRAL_LOGGER_FAILED",errMsg);	
	}

	if(m_managedLogDeviceGroup->get_size()<=0){
		std::string errMsg("Log source group is empty!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("ENABLE_CENTRAL_LOGGER_FAILED",errMsg);	
	}

	//## Extract subgroup
	Tango::Group* grp= 0;
	if(isSubGroup){
		bool requireDevOnline= false;
		grp= Utils_ns::TangoUtils::GetSubGroup(this,m_managedLogDeviceGroup,dev_names,requireDevOnline);
		if(!grp){
			std::string errMsg("Failed to extract given devices from group (invalid/not existing device names?)");
			_THROW_TANGO_EXCEPTION("ENABLE_CENTRAL_LOGGER_FAILED",errMsg);	
		}
	}
	else {
		grp= m_managedLogDeviceGroup;
	}

	//## Write attr to group
	try {
		if(Utils_ns::TangoUtils::WriteAttrToGroup<Tango::DevBoolean>(this,grp,attr_name,attr_value)<0){		
			std::string errMsg("Failed to write attr to group (null ptr passed?)");
			_THROW_TANGO_EXCEPTION("ENABLE_CENTRAL_LOGGER_FAILED",errMsg);
		}
	}//close try
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Failed to write attr "<<attr_name<<" to group!");
		throw;
	}
	
	//## If successful, enable logger of this device (make sense if all managed devices are changed)
	if(!isSubGroup) {
		try {
			_INFO_LOG("Enabling central logger of this device...");
			Tango::WAttribute& wattr= get_device_attr()->get_w_attr_by_name(attr_name.c_str());
			wattr.set_write_value(attr_value);
			//LMCDevice::write_centralLoggerEnabled(wattr);
			write_centralLoggerEnabled(wattr);
		}
		catch(Tango::DevFailed& e){
			Tango::Except::print_exception(e);
			_ERROR_LOG("Failed to write attr "<<attr_name<<" to this device!");
			throw;
		}
	}//close if
	/*----- PROTECTED REGION END -----*/	//	ElementLogger::enable_central_logger
}
//--------------------------------------------------------
/**
 *	Command DisableCentralLogger related method
 *	Description: Disable central logger in all or in sub-set of managed LMC
 *               devices.
 *
 *	@param argin List of managed LMC device over which the command will be applied.
 *               If empty, applied to all devices.
 *               
 *               [0]: device 1
 *               [1]: device 2
 *               ...
 *               [N-1]: device N-1
 */
//--------------------------------------------------------
void ElementLogger::disable_central_logger(const Tango::DevVarStringArray *argin)
{
	DEBUG_STREAM << "ElementLogger::DisableCentralLogger()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(ElementLogger::disable_central_logger) ENABLED START -----*/
	
	//	Add your own code
	//================================================
	//==      HARD-CODED PARS
	//================================================
	std::string attr_name= "centralLoggerEnabled";
	Tango::DevBoolean attr_value= false;
	//================================================

	//## Check and retrieve args
	int nArgs= (int)(argin->length());
	bool isSubGroup= true;	
	std::vector<std::string> dev_names; 
	if(nArgs<=0) {
		isSubGroup= false;
	}
	else{	
		for(int i=0;i<nArgs;i++){ 
			std::string dev_name( (*argin)[i] );
			dev_names.push_back(dev_name);
		}
	}

	//## Check group
	if(!m_managedLogDeviceGroup){
		std::string errMsg("Log source group was not instantiated!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("DISABLE_CENTRAL_LOGGER_FAILED",errMsg);	
	}

	if(m_managedLogDeviceGroup->get_size()<=0){
		std::string errMsg("Log source group is empty!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("DISABLE_CENTRAL_LOGGER_FAILED",errMsg);	
	}

	//## Extract subgroup
	Tango::Group* grp= 0;
	if(isSubGroup){
		bool requireDevOnline= false;
		grp= Utils_ns::TangoUtils::GetSubGroup(this,m_managedLogDeviceGroup,dev_names,requireDevOnline);
		if(!grp){
			std::string errMsg("Failed to extract given devices from group (invalid/not existing device names?)");
			_THROW_TANGO_EXCEPTION("DISABLE_CENTRAL_LOGGER_FAILED",errMsg);	
		}
	}
	else {
		grp= m_managedLogDeviceGroup;
	}

	//## Write attr to group
	try {
		if(Utils_ns::TangoUtils::WriteAttrToGroup<Tango::DevBoolean>(this,grp,attr_name,attr_value)<0){		
			std::string errMsg("Failed to write attr to group (null ptr passed?)");
			_THROW_TANGO_EXCEPTION("DISABLE_CENTRAL_LOGGER_FAILED",errMsg);
		}
	}//close try
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Failed to write attr "<<attr_name<<" to group!");
		throw;
	}

	//## If successful, enable logger of this device (make sense if all managed devices are changed)
	if(!isSubGroup) {
		try {
			_INFO_LOG("Disabling central logger of this device...");
			Tango::WAttribute& wattr= get_device_attr()->get_w_attr_by_name(attr_name.c_str());
			wattr.set_write_value(attr_value);
			//LMCDevice::write_centralLoggerEnabled(wattr);
			write_centralLoggerEnabled(wattr);
		}
		catch(Tango::DevFailed& e){
			Tango::Except::print_exception(e);
			_ERROR_LOG("Failed to write attr "<<attr_name<<" to this device!");
			throw;
		}
	}//close if
	/*----- PROTECTED REGION END -----*/	//	ElementLogger::disable_central_logger
}
//--------------------------------------------------------
/**
 *	Command EnableElementLogger related method
 *	Description: Enable Element logger in all or in sub-set of managed LMC
 *               devices.
 *
 *	@param argin List of managed LMC device over which the command will be applied.
 *               If empty, applied to all devices.
 *               
 *               [0]: device 1
 *               [1]: device 2
 *               ...
 *               [N-1]: device N-1
 */
//--------------------------------------------------------
void ElementLogger::enable_element_logger(const Tango::DevVarStringArray *argin)
{
	DEBUG_STREAM << "ElementLogger::EnableElementLogger()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(ElementLogger::enable_element_logger) ENABLED START -----*/
	
	//	Add your own code
	//================================================
	//==      HARD-CODED PARS
	//================================================
	std::string attr_name= "elementLoggerEnabled";
	Tango::DevBoolean attr_value= true;
	//================================================

	//## Check and retrieve args
	int nArgs= (int)(argin->length());
	bool isSubGroup= true;	
	std::vector<std::string> dev_names; 
	if(nArgs<=0) {
		isSubGroup= false;
	}
	else{
		for(int i=0;i<nArgs;i++){ 
			std::string dev_name( (*argin)[i] );
			dev_names.push_back(dev_name);
		}
	}

	//## Check group
	if(!m_managedLogDeviceGroup){
		std::string errMsg("Log source group was not instantiated!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("ENABLE_ELEMENT_LOGGER_FAILED",errMsg);	
	}

	if(m_managedLogDeviceGroup->get_size()<=0){
		std::string errMsg("Log source group is empty!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("ENABLE_ELEMENT_LOGGER_FAILED",errMsg);	
	}

	//## Extract subgroup
	Tango::Group* grp= 0;
	if(isSubGroup){
		bool requireDevOnline= false;
		grp= Utils_ns::TangoUtils::GetSubGroup(this,m_managedLogDeviceGroup,dev_names,requireDevOnline);
		if(!grp){
			std::string errMsg("Failed to extract given devices from group (invalid/not existing device names?)");
			_THROW_TANGO_EXCEPTION("ENABLE_ELEMENT_LOGGER_FAILED",errMsg);	
		}
	}
	else {
		grp= m_managedLogDeviceGroup;
	}

	//## Write attr to group
	try {
		if(Utils_ns::TangoUtils::WriteAttrToGroup<Tango::DevBoolean>(this,grp,attr_name,attr_value)<0){		
			std::string errMsg("Failed to write attr to group (null ptr passed?)");
			_THROW_TANGO_EXCEPTION("ENABLE_ELEMENT_LOGGER_FAILED",errMsg);
		}
	}//close try
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Failed to write attr "<<attr_name<<" to group!");
		throw;
	}
	
	//## If successful, enable logger of this device (make sense if all managed devices are changed)
	if(!isSubGroup) {
		try {
			_INFO_LOG("Enabling Element logger of this device...");
			Tango::WAttribute& wattr= get_device_attr()->get_w_attr_by_name(attr_name.c_str());
			wattr.set_write_value(attr_value);
			//LMCDevice::write_elementLoggerEnabled(wattr);
			write_elementLoggerEnabled(wattr);
		}
		catch(Tango::DevFailed& e){
			Tango::Except::print_exception(e);
			_ERROR_LOG("Failed to write attr "<<attr_name<<" to this device!");
			throw;
		}
	}//close if
	
	/*----- PROTECTED REGION END -----*/	//	ElementLogger::enable_element_logger
}
//--------------------------------------------------------
/**
 *	Command DisableElementLogger related method
 *	Description: Disable Element logger in all or in sub-set of managed LMC
 *               devices.
 *
 *	@param argin List of managed LMC device over which the command will be applied.
 *               If empty, applied to all devices.
 *               
 *               [0]: device 1
 *               [1]: device 2
 *               ...
 *               [N-1]: device N-1
 */
//--------------------------------------------------------
void ElementLogger::disable_element_logger(const Tango::DevVarStringArray *argin)
{
	DEBUG_STREAM << "ElementLogger::DisableElementLogger()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(ElementLogger::disable_element_logger) ENABLED START -----*/
	
	//	Add your own code
	//================================================
	//==      HARD-CODED PARS
	//================================================
	std::string attr_name= "elementLoggerEnabled";
	Tango::DevBoolean attr_value= false;
	//================================================

	//## Check and retrieve args
	int nArgs= (int)(argin->length());
	bool isSubGroup= true;	
	std::vector<std::string> dev_names; 
	if(nArgs<=0) {
		isSubGroup= false;
	}	
	else{
		for(int i=0;i<nArgs;i++){ 
			std::string dev_name( (*argin)[i] );
			dev_names.push_back(dev_name);
		}
	}

	//## Check group
	if(!m_managedLogDeviceGroup){
		std::string errMsg("Log source group was not instantiated!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("DISABLE_ELEMENT_LOGGER_FAILED",errMsg);	
	}

	if(m_managedLogDeviceGroup->get_size()<=0){
		std::string errMsg("Log source group is empty!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("DISABLE_ELEMENT_LOGGER_FAILED",errMsg);	
	}

	//## Extract subgroup
	Tango::Group* grp= 0;
	if(isSubGroup){
		bool requireDevOnline= false;
		grp= Utils_ns::TangoUtils::GetSubGroup(this,m_managedLogDeviceGroup,dev_names,requireDevOnline);
		if(!grp){
			std::string errMsg("Failed to extract given devices from group (invalid/not existing device names?)");
			_THROW_TANGO_EXCEPTION("DISABLE_ELEMENT_LOGGER_FAILED",errMsg);	
		}
	}
	else {
		grp= m_managedLogDeviceGroup;
	}

	//## Write attr to group
	try {
		if(Utils_ns::TangoUtils::WriteAttrToGroup<Tango::DevBoolean>(this,grp,attr_name,attr_value)<0){		
			std::string errMsg("Failed to write attr to group (null ptr passed?)");
			_THROW_TANGO_EXCEPTION("DISABLE_ELEMENT_LOGGER_FAILED",errMsg);
		}
	}//close try
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Failed to write attr "<<attr_name<<" to group!");
		throw;
	}

	//## If successful, disable logger of this device (make sense if all managed devices are changed)
	if(!isSubGroup) {
		try {
			_INFO_LOG("Disabling Element logger of this device...");
			Tango::WAttribute& wattr= get_device_attr()->get_w_attr_by_name(attr_name.c_str());
			wattr.set_write_value(attr_value);
			//LMCDevice::write_elementLoggerEnabled(wattr);
			write_elementLoggerEnabled(wattr);
		}
		catch(Tango::DevFailed& e){
			Tango::Except::print_exception(e);
			_ERROR_LOG("Failed to write attr "<<attr_name<<" to this device!");
			throw;
		}
	}//close if

	/*----- PROTECTED REGION END -----*/	//	ElementLogger::disable_element_logger
}
//--------------------------------------------------------
/**
 *	Command EnableStorageLogger related method
 *	Description: Enable storage logger in all or in sub-set of managed LMC
 *               devices.
 *
 *	@param argin List of managed LMC device over which the command will be applied.
 *               If empty, applied to all devices.
 *               
 *               [0]: device 1
 *               [1]: device 2
 *               ...
 *               [N-1]: device N-1
 */
//--------------------------------------------------------
void ElementLogger::enable_storage_logger(const Tango::DevVarStringArray *argin)
{
	DEBUG_STREAM << "ElementLogger::EnableStorageLogger()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(ElementLogger::enable_storage_logger) ENABLED START -----*/
	
	//	Add your own code
	//================================================
	//==      HARD-CODED PARS
	//================================================
	std::string attr_name= "storageLoggerEnabled";
	Tango::DevBoolean attr_value= true;
	//================================================

	//## Check and retrieve args
	int nArgs= (int)(argin->length());
	bool isSubGroup= true;		
	std::vector<std::string> dev_names; 
	if(nArgs<=0) {
		isSubGroup= false;
	}	
	else{
		for(int i=0;i<nArgs;i++){ 
			std::string dev_name( (*argin)[i] );
			dev_names.push_back(dev_name);
		}
	}

	//## Check group
	if(!m_managedLogDeviceGroup){
		std::string errMsg("Log source group was not instantiated!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("ENABLE_STORAGE_LOGGER_FAILED",errMsg);	
	}

	if(m_managedLogDeviceGroup->get_size()<=0){
		std::string errMsg("Log source group is empty!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("ENABLE_STORAGE_LOGGER_FAILED",errMsg);	
	}

	//## Extract subgroup
	Tango::Group* grp= 0;
	if(isSubGroup){
		bool requireDevOnline= false;
		grp= Utils_ns::TangoUtils::GetSubGroup(this,m_managedLogDeviceGroup,dev_names,requireDevOnline);
		if(!grp){
			std::string errMsg("Failed to extract given devices from group (invalid/not existing device names?)");
			_THROW_TANGO_EXCEPTION("ENABLE_STORAGE_LOGGER_FAILED",errMsg);	
		}
	}
	else {
		grp= m_managedLogDeviceGroup;
	}

	//## Write attr to group
	try {
		if(Utils_ns::TangoUtils::WriteAttrToGroup<Tango::DevBoolean>(this,grp,attr_name,attr_value)<0){		
			std::string errMsg("Failed to write attr to group (null ptr passed?)");
			_THROW_TANGO_EXCEPTION("ENABLE_STORAGE_LOGGER_FAILED",errMsg);
		}
	}//close try
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Failed to write attr "<<attr_name<<" to group!");
		throw;
	}
	
	//## If successful, enable logger of this device (make sense if all managed devices are changed)
	if(!isSubGroup) {
		try {
			_INFO_LOG("Enabling storage logger of this device...");
			Tango::WAttribute& wattr= get_device_attr()->get_w_attr_by_name(attr_name.c_str());
			wattr.set_write_value(attr_value);
			//LMCDevice::write_storageLoggerEnabled(wattr);
			write_storageLoggerEnabled(wattr);
		}
		catch(Tango::DevFailed& e){
			Tango::Except::print_exception(e);
			_ERROR_LOG("Failed to write attr "<<attr_name<<" to this device!");
			throw;
		}
	}//close if
	/*----- PROTECTED REGION END -----*/	//	ElementLogger::enable_storage_logger
}
//--------------------------------------------------------
/**
 *	Command DisableStorageLogger related method
 *	Description: Disable storage logger in all or in sub-set of managed LMC
 *               devices.
 *
 *	@param argin List of managed LMC device over which the command will be applied.
 *               If empty, applied to all devices.
 *               
 *               [0]: device 1
 *               [1]: device 2
 *               ...
 *               [N-1]: device N-1
 */
//--------------------------------------------------------
void ElementLogger::disable_storage_logger(const Tango::DevVarStringArray *argin)
{
	DEBUG_STREAM << "ElementLogger::DisableStorageLogger()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(ElementLogger::disable_storage_logger) ENABLED START -----*/
	
	//	Add your own code
	//================================================
	//==      HARD-CODED PARS
	//================================================
	std::string attr_name= "storageLoggerEnabled";
	Tango::DevBoolean attr_value= false;
	//================================================

	//## Check and retrieve args
	int nArgs= (int)(argin->length());
	bool isSubGroup= true;	
	std::vector<std::string> dev_names; 
	if(nArgs<=0) {
		isSubGroup= false;
	}
	else{		
		for(int i=0;i<nArgs;i++){ 
			std::string dev_name( (*argin)[i] );
			dev_names.push_back(dev_name);
		}
	}

	//## Check group
	if(!m_managedLogDeviceGroup){
		std::string errMsg("Log source group was not instantiated!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("DISABLE_STORAGE_LOGGER_FAILED",errMsg);	
	}

	if(m_managedLogDeviceGroup->get_size()<=0){
		std::string errMsg("Log source group is empty!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("DISABLE_STORAGE_LOGGER_FAILED",errMsg);	
	}

	//## Extract subgroup
	Tango::Group* grp= 0;
	if(isSubGroup){
		bool requireDevOnline= false;
		grp= Utils_ns::TangoUtils::GetSubGroup(this,m_managedLogDeviceGroup,dev_names,requireDevOnline);
		if(!grp){
			std::string errMsg("Failed to extract given devices from group (invalid/not existing device names?)");
			_THROW_TANGO_EXCEPTION("DISABLE_STORAGE_LOGGER_FAILED",errMsg);	
		}
	}
	else {
		grp= m_managedLogDeviceGroup;
	}

	//## Write attr to group
	try {
		if(Utils_ns::TangoUtils::WriteAttrToGroup<Tango::DevBoolean>(this,grp,attr_name,attr_value)<0){		
			std::string errMsg("Failed to write attr to group (null ptr passed?)");
			_THROW_TANGO_EXCEPTION("DISABLE_STORAGE_LOGGER_FAILED",errMsg);
		}
	}//close try
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Failed to write attr "<<attr_name<<" to group!");
		throw;
	}

	//## If successful, disable logger of this device (make sense if all managed devices are changed)
	if(!isSubGroup) {
		try {
			_INFO_LOG("Disabling storage logger of this device...");
			Tango::WAttribute& wattr= get_device_attr()->get_w_attr_by_name(attr_name.c_str());
			wattr.set_write_value(attr_value);
			//LMCDevice::write_storageLoggerEnabled(wattr);
			write_storageLoggerEnabled(wattr);
		}
		catch(Tango::DevFailed& e){
			Tango::Except::print_exception(e);
			_ERROR_LOG("Failed to write attr "<<attr_name<<" to this device!");
			throw;
		}
	}//close if
	/*----- PROTECTED REGION END -----*/	//	ElementLogger::disable_storage_logger
}
//--------------------------------------------------------
/**
 *	Command SetLoggingTargetCentral related method
 *	Description: Set central log target for all or a subset of LMC devices.
 *
 *	@param argin [0]: log target
 *               [1]: device 1
 *               [2]: device 2
 *               ...
 *               [N-1]: device N-1
 */
//--------------------------------------------------------
void ElementLogger::set_logging_target_central(const Tango::DevVarStringArray *argin)
{
	DEBUG_STREAM << "ElementLogger::SetLoggingTargetCentral()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(ElementLogger::set_logging_target_central) ENABLED START -----*/
	
	//	Add your own code
	//================================================
	//==      HARD-CODED PARS
	//================================================
	std::string attr_name= "loggingTargetCentral";
	std::string attr_value= "";
	//================================================

	//## Check and retrieve args
	int nArgs= (int)(argin->length());
	if(nArgs<=0){
		std::string errMsg("Missing log target argument!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("SET_LOGGING_TARGET_CENTRAL_FAILED",errMsg);	
	}
	attr_value= std::string( (*argin)[0] );

	bool isSubGroup= true;
	std::vector<std::string> dev_names; 
	if(nArgs-1<=0) {
		isSubGroup= false;
	}
	else{	
		for(int i=1;i<nArgs;i++){ 
			std::string dev_name( (*argin)[i] );
			dev_names.push_back(dev_name);
		}
	}

	//## Check group
	if(!m_managedLogDeviceGroup){
		std::string errMsg("Log source group was not instantiated!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("SET_LOGGING_TARGET_CENTRAL_FAILED",errMsg);	
	}

	if(m_managedLogDeviceGroup->get_size()<=0){
		std::string errMsg("Log source group is empty!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("SET_LOGGING_TARGET_CENTRAL_FAILED",errMsg);	
	}

	//## Extract subgroup
	Tango::Group* grp= 0;
	if(isSubGroup){
		bool requireDevOnline= false;
		grp= Utils_ns::TangoUtils::GetSubGroup(this,m_managedLogDeviceGroup,dev_names,requireDevOnline);
		if(!grp){
			std::string errMsg("Failed to extract given devices from group (invalid/not existing device names?)");
			_THROW_TANGO_EXCEPTION("SET_LOGGING_TARGET_CENTRAL_FAILED",errMsg);	
		}
	}
	else {
		grp= m_managedLogDeviceGroup;
	}

	//## Write attr to group
	try {
		if(Utils_ns::TangoUtils::WriteAttrToGroup<std::string>(this,grp,attr_name,attr_value)<0){		
			std::string errMsg("Failed to write attr to group (null ptr passed?)");
			_THROW_TANGO_EXCEPTION("SET_LOGGING_TARGET_CENTRAL_FAILED",errMsg);
		}
	}//close try
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Failed to write attr "<<attr_name<<" to group!");
		throw;
	}
	
	//## If successful, enable logger of this device (make sense if all managed devices are changed)
	if(!isSubGroup) {
		try {
			_INFO_LOG("Setting central log target of this device...");
			Tango::WAttribute& wattr= get_device_attr()->get_w_attr_by_name(attr_name.c_str());
			wattr.set_write_value(attr_value);
			LMCDevice::write_loggingTargetCentral(wattr);
		}
		catch(Tango::DevFailed& e){
			Tango::Except::print_exception(e);
			_ERROR_LOG("Failed to write attr "<<attr_name<<" to this device!");
			throw;
		}
	}//close if
	/*----- PROTECTED REGION END -----*/	//	ElementLogger::set_logging_target_central
}
//--------------------------------------------------------
/**
 *	Command SetLoggingTargetElement related method
 *	Description: Set Element log target for all or a subset of LMC devices.
 *
 *	@param argin [0]: log target
 *               [1]: device 1
 *               [2]: device 2
 *               ...
 *               [N-1]: device N-1
 */
//--------------------------------------------------------
void ElementLogger::set_logging_target_element(const Tango::DevVarStringArray *argin)
{
	DEBUG_STREAM << "ElementLogger::SetLoggingTargetElement()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(ElementLogger::set_logging_target_element) ENABLED START -----*/
	
	//	Add your own code
	//================================================
	//==      HARD-CODED PARS
	//================================================
	std::string attr_name= "loggingTargetElement";
	std::string attr_value= "";
	//================================================

	//## Check and retrieve args
	int nArgs= (int)(argin->length());
	if(nArgs<=0){
		std::string errMsg("Missing log target argument!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("SET_LOGGING_TARGET_ELEMENT_FAILED",errMsg);	
	}
	attr_value= std::string( (*argin)[0] );

	bool isSubGroup= true;
	std::vector<std::string> dev_names; 
	if(nArgs-1<=0) {
		isSubGroup= false;
	}	
	else{
		for(int i=1;i<nArgs;i++){ 
			std::string dev_name( (*argin)[i] );
			dev_names.push_back(dev_name);
		}
	}

	//## Check group
	if(!m_managedLogDeviceGroup){
		std::string errMsg("Log source group was not instantiated!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("SET_LOGGING_TARGET_ELEMENT_FAILED",errMsg);	
	}

	if(m_managedLogDeviceGroup->get_size()<=0){
		std::string errMsg("Log source group is empty!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("SET_LOGGING_TARGET_ELEMENT_FAILED",errMsg);	
	}

	

	//## Extract subgroup
	Tango::Group* grp= 0;
	if(isSubGroup){
		//###    DEBUG  ####################
		std::vector<std::string> group_dev_names= m_managedLogDeviceGroup->get_device_list(true);
		for(size_t i=0;i<group_dev_names.size();i++){
			_INFO_LOG("Group device no. "<<i+1<<": "<<group_dev_names[i]<<" ...");
		}	

		for(size_t i=0;i<dev_names.size();i++){
			std::string dev_name= dev_names[i];
			bool hasDevInGroup= m_managedLogDeviceGroup->contains(dev_name,true);
			_INFO_LOG("Device "<<dev_name<<" found in group? "<<hasDevInGroup);
		}//end loop dev names
		//##################################


		bool requireDevOnline= false;
		grp= Utils_ns::TangoUtils::GetSubGroup(this,m_managedLogDeviceGroup,dev_names,requireDevOnline);
		if(!grp){
			std::string errMsg("Failed to extract given devices from group (invalid/not existing device names?)");
			_THROW_TANGO_EXCEPTION("SET_LOGGING_TARGET_ELEMENT_FAILED",errMsg);	
		}
	}
	else {
		grp= m_managedLogDeviceGroup;
	}

	//## Write attr to group
	try {
		if(Utils_ns::TangoUtils::WriteAttrToGroup<std::string>(this,grp,attr_name,attr_value)<0){		
			std::string errMsg("Failed to write attr to group (null ptr passed?)");
			_THROW_TANGO_EXCEPTION("SET_LOGGING_TARGET_ELEMENT_FAILED",errMsg);
		}
	}//close try
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Failed to write attr "<<attr_name<<" to group!");
		throw;
	}
	
	//## If successful, enable logger of this device (make sense if all managed devices are changed)
	if(!isSubGroup) {
		try {
			_INFO_LOG("Setting Element log target of this device...");
			Tango::WAttribute& wattr= get_device_attr()->get_w_attr_by_name(attr_name.c_str());
			wattr.set_write_value(attr_value);
			LMCDevice::write_loggingTargetElement(wattr);
		}
		catch(Tango::DevFailed& e){
			Tango::Except::print_exception(e);
			_ERROR_LOG("Failed to write attr "<<attr_name<<" to this device!");
			throw;
		}
	}//close if
	/*----- PROTECTED REGION END -----*/	//	ElementLogger::set_logging_target_element
}
//--------------------------------------------------------
/**
 *	Command SetLoggingTargetStorage related method
 *	Description: Set storage log target for all or a subset of LMC devices.
 *
 *	@param argin 
 */
//--------------------------------------------------------
void ElementLogger::set_logging_target_storage(const Tango::DevVarStringArray *argin)
{
	DEBUG_STREAM << "ElementLogger::SetLoggingTargetStorage()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(ElementLogger::set_logging_target_storage) ENABLED START -----*/
	
	//	Add your own code
	//================================================
	//==      HARD-CODED PARS
	//================================================
	std::string attr_name= "loggingTargetStorage";
	std::string attr_value= "";
	//================================================

	//## Check and retrieve args
	int nArgs= (int)(argin->length());
	if(nArgs<=0){
		std::string errMsg("Missing log target argument!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("SET_LOGGING_TARGET_STORAGE_FAILED",errMsg);	
	}
	attr_value= std::string( (*argin)[0] );

	bool isSubGroup= true;
	std::vector<std::string> dev_names; 
	if(nArgs-1<=0) {
		isSubGroup= false;
	}
	else{	
		for(int i=1;i<nArgs;i++){ 
			std::string dev_name( (*argin)[i] );
			dev_names.push_back(dev_name);
		}
	}

	//## Check group
	if(!m_managedLogDeviceGroup){
		std::string errMsg("Log source group was not instantiated!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("SET_LOGGING_TARGET_STORAGE_FAILED",errMsg);	
	}

	if(m_managedLogDeviceGroup->get_size()<=0){
		std::string errMsg("Log source group is empty!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("SET_LOGGING_TARGET_STORAGE_FAILED",errMsg);	
	}

	//## Extract subgroup
	Tango::Group* grp= 0;
	if(isSubGroup){
		bool requireDevOnline= false;
		grp= Utils_ns::TangoUtils::GetSubGroup(this,m_managedLogDeviceGroup,dev_names,requireDevOnline);
		if(!grp){
			std::string errMsg("Failed to extract given devices from group (invalid/not existing device names?)");
			_THROW_TANGO_EXCEPTION("SET_LOGGING_TARGET_STORAGE_FAILED",errMsg);	
		}
	}
	else {
		grp= m_managedLogDeviceGroup;
	}

	//## Write attr to group
	try {
		if(Utils_ns::TangoUtils::WriteAttrToGroup<std::string>(this,grp,attr_name,attr_value)<0){		
			std::string errMsg("Failed to write attr to group (null ptr passed?)");
			_THROW_TANGO_EXCEPTION("SET_LOGGING_TARGET_STORAGE_FAILED",errMsg);
		}
	}//close try
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Failed to write attr "<<attr_name<<" to group!");
		throw;
	}
	
	//## If successful, enable logger of this device (make sense if all managed devices are changed)
	if(!isSubGroup) {
		try {
			_INFO_LOG("Setting storage log target of this device...");
			Tango::WAttribute& wattr= get_device_attr()->get_w_attr_by_name(attr_name.c_str());
			wattr.set_write_value(attr_value);
			LMCDevice::write_loggingTargetStorage(wattr);
		}
		catch(Tango::DevFailed& e){
			Tango::Except::print_exception(e);
			_ERROR_LOG("Failed to write attr "<<attr_name<<" to this device!");
			throw;
		}
	}//close if
	/*----- PROTECTED REGION END -----*/	//	ElementLogger::set_logging_target_storage
}
//--------------------------------------------------------
/**
 *	Command dummyDynCmd related method
 *	Description: 
 *
 */
//--------------------------------------------------------
void ElementLogger::dummy_dyn_cmd(Tango::Command &command)
{
	DEBUG_STREAM << "ElementLogger::" << command.get_name() << "  - " << device_name << endl;
	/*----- PROTECTED REGION ID(ElementLogger::dummy_dyn_cmd) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	ElementLogger::dummy_dyn_cmd
}
//--------------------------------------------------------
/**
 *	Method      : ElementLogger::add_dynamic_commands()
 *	Description : Create the dynamic commands if any
 *                for specified device.
 */
//--------------------------------------------------------
void ElementLogger::add_dynamic_commands()
{
	//	Example to add dynamic command:
	//	Copy inside the folowing protected area to instanciate at startup.
	//	add_dummyDynCmd_dynamic_command("MydummyDynCmdCommand", true);
	
	/*----- PROTECTED REGION ID(ElementLogger::add_dynamic_commands) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic commands if any
	LMCDevice::add_dynamic_commands();

	/*----- PROTECTED REGION END -----*/	//	ElementLogger::add_dynamic_commands
}

/*----- PROTECTED REGION ID(ElementLogger::namespace_ending) ENABLED START -----*/

//	Additional Methods
int ElementLogger::InitCmdAttrStateMachine(){

	//## Register device proxies
	_DEBUG_LOG("Registering cmd/attr rules for device "<<device_name<<"...");
	//...
	//...	

	return 0;

}//close InitCmdAttrStateMachine()

int ElementLogger::RegisterProxies(){

	//## Register device proxies
	_DEBUG_LOG("Registering device proxies for device "<<device_name<<"...");
	//...
	//...	

	return 0;

}//close RegisterProxies()

int ElementLogger::RegisterEventSubscriptions(){

	//## Register event subscriptions
	_DEBUG_LOG("Registering event subscriptions for device "<<device_name<<"...");
	//...
	//...

	return 0;

}//close RegisterEventSubscriptions()

int ElementLogger::RegisterEventHandlers(){

	//## Register event handlers
	_DEBUG_LOG("Registering event handlers for device "<<device_name<<"...");
	//...
	//...
	
	return 0;

}//close RegisterEventHandlers()


int ElementLogger::InitLogSources(){

	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string managedLogDevices_attr_name= "managedLogDevices";
	std::string logDevices_attr_name= "logDevices";
	//###########################################################################

	//Init group if not already done
	if(!m_managedLogDeviceGroup){
		_DEBUG_LOG("Initialize log source group...");
		m_managedLogDeviceGroup= new Tango::Group("managedLogDeviceGroup");
	}

	//Set attr to default property list
	m_log_source_devices.clear();
	m_log_source_devices.insert(m_log_source_devices.end(),managedLogDevicesDefault.begin(),managedLogDevicesDefault.end());

	if(SetDynAttrValue<std::string>(m_log_source_devices,managedLogDevices_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<managedLogDevices_attr_name<<"!";
		_ERROR_LOG(ss.str());	
		return -1;
	}

	std::vector<std::string> tmp;
	if(SetDynAttrValue<std::string>(tmp,logDevices_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<logDevices_attr_name<<"!";
		_ERROR_LOG(ss.str());	
		return -1;
	}

	//Initialize group with log source devices 
	for(unsigned int i=0;i<m_log_source_devices.size();i++){
		std::string dev_name= m_log_source_devices[i];
		_DEBUG_LOG("Adding device "<<dev_name<<" to log source group...");
		
		//Add device
		if(AddLogSourceToGroup(dev_name)<0){
			_WARN_LOG("Failed to add device "<<dev_name<<" to group "<<m_managedLogDeviceGroup->get_name()<<", skip to next...");
			continue;
		}
	}//end loop managed log devices

	return 0;

}//close InitLogSources()


int ElementLogger::InitSELogSources(){

	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string managedSELogDevices_attr_name= "managedSELogDevices";
	std::string logSEDevices_attr_name= "logSEDevices";
	//###########################################################################


	//Set attr to default property list
	m_se_log_source_devices.clear();
	int pos= -1;
	for(size_t i=0;i<managedSELogDevicesDefault.size();i++){
		//Check if default device already exists
		if(Utils_ns::CodeUtils::FindItem(m_se_log_source_devices,managedSELogDevicesDefault[i],pos)){
			continue;
		}

		//Add device to list
		m_se_log_source_devices.push_back(managedSELogDevicesDefault[i]);
	}
	//m_se_log_source_devices.insert(m_se_log_source_devices.end(),managedSELogDevicesDefault.begin(),managedSELogDevicesDefault.end());

	if(SetDynAttrValue<std::string>(m_se_log_source_devices,managedSELogDevices_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<managedSELogDevices_attr_name<<"!";
		_ERROR_LOG(ss.str());	
		return -1;
	}

	std::vector<std::string> tmp;
	if(SetDynAttrValue<std::string>(tmp,logSEDevices_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<logSEDevices_attr_name<<"!";
		_ERROR_LOG(ss.str());	
		return -1;
	}

	//Initialize group with log source devices 
	for(unsigned int i=0;i<m_se_log_source_devices.size();i++){
		std::string dev_name= m_se_log_source_devices[i];
		_DEBUG_LOG("Adding device "<<dev_name<<" to SE log source group...");
		
		//Add device
		if(AddSELogSourceToGroup(dev_name)<0){
			_WARN_LOG("Failed to add device "<<dev_name<<" to SE log sources, skip to next...");
			continue;
		}
	}//end loop managed log devices

	return 0;

}//close InitSELogSources()


int ElementLogger::AddLogSourceToGroup(std::string dev_name){

	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string managedLogDevices_attr_name= "managedLogDevices";
	std::string logDevices_attr_name= "logDevices";
	//###########################################################################

	//Check if group has been initialized
	if(!m_managedLogDeviceGroup){
		_ERROR_LOG("Log source group was not initialized!");
		return -1;
	}

	//Check if group has already the device
	_DEBUG_LOG("Check if group "<<m_managedLogDeviceGroup->get_name()<<" has already the device "<<dev_name<<"...");
	bool hasDevice= false;
	try{		
		hasDevice= m_managedLogDeviceGroup->contains(dev_name,true);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_WARN_LOG("Failed to check if device "<<dev_name<<" exists in group "<<m_managedLogDeviceGroup->get_name()<<"...");
		return -1;		
	}
	if(hasDevice) {
		_DEBUG_LOG("Device "<<dev_name<<" already present in the log source group "<<m_managedLogDeviceGroup->get_name()<<", nothing to be done...");
		return 0;
	}

	//Create proxy to device to be added
	_DEBUG_LOG("Trying to add device proxy "<<dev_name<<" to log source group "<<m_managedLogDeviceGroup->get_name()<<"...");
	Tango::DeviceProxy* dev_proxy= 0;
	try {		
		dev_proxy= new Tango::DeviceProxy(dev_name);
	}
	catch(Tango::DevFailed& e){
		_WARN_LOG("Failed to connect to device proxy "<<dev_name<<", will retry later...");
		if(dev_proxy){
			delete dev_proxy;
			dev_proxy= 0;
		}
		return -1;
	}	
	
	//Check if we can connect to the device
	_DEBUG_LOG("Pinging device "<<dev_name<<"...");
	try {			
		dev_proxy->ping();
	}
	catch(Tango::DevFailed& e){
		_WARN_LOG("Tango exception occurred while pinging device "<<dev_name<<", will retry later...");
		if(dev_proxy){
			delete dev_proxy;
			dev_proxy= 0;
		}
		return -1;
	}	
	if(dev_proxy){
		delete dev_proxy;
		dev_proxy= 0;
	}

	//Add to group (if failing do not add to the list of managed device)
	_DEBUG_LOG("Adding device "<<dev_name<<" to group "<<m_managedLogDeviceGroup->get_name()<<"...");
	try {
		m_managedLogDeviceGroup->add(dev_name);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_WARN_LOG("Failed to add device "<<dev_name<<" to group"<<m_managedLogDeviceGroup->get_name()<<"!");
		return -1;		
	}

	//Update list of log sources
	_DEBUG_LOG("Find if dev name "<<dev_name<<" is present in log source list...");
	int pos= -1;
	if(!Utils_ns::CodeUtils::FindItem(m_log_source_devices,dev_name,pos)){
		_DEBUG_LOG("Add dev name "<<dev_name<<" to log source list...");
		m_log_source_devices.push_back(dev_name);
	}

	
	//Update list of managed log source
	_DEBUG_LOG("Update list of managed log source...");
	if(SetDynAttrValue<std::string>(m_log_source_devices,managedLogDevices_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<managedLogDevices_attr_name<<"!";
		_ERROR_LOG(ss.str());	
	}

	//Update list of log sources attributes
	_DEBUG_LOG("Update list of log sources attributes...");
	std::vector<std::string> devicesInGroup= m_managedLogDeviceGroup->get_device_list(true);
	if(SetDynAttrValue<std::string>(devicesInGroup,logDevices_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<logDevices_attr_name<<"!";
		_ERROR_LOG(ss.str());	
	}

	return 0;

}//close AddLogSourceToGroup()


int ElementLogger::RemoveLogSourceFromGroup(std::string dev_name){

	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string managedLogDevices_attr_name= "managedLogDevices";
	std::string logDevices_attr_name= "logDevices";
	//###########################################################################

	//Check if group has been initialized
	if(!m_managedLogDeviceGroup){
		_ERROR_LOG("Log source device group was not initialized!");
		return -1;
	}
	
	//Check if group has already the device
	bool hasDevice= false;
	try{
		hasDevice= m_managedLogDeviceGroup->contains(dev_name,true);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_WARN_LOG("Failed to check if device "<<dev_name<<" exists in group!");
		return -1;		
	}
	if(!hasDevice) {
		_DEBUG_LOG("Device "<<device_name<<" not present in the log source group, nothing to be removed...");
		return 0;
	}
	
	//Remove from group 
	try {
		m_managedLogDeviceGroup->remove(dev_name);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_WARN_LOG("Failed to remove device "<<dev_name<<" from group!");
		return -1;		
	}

	//Remove item in list if not existing
	try{
		m_log_source_devices.erase(std::remove(m_log_source_devices.begin(), m_log_source_devices.end(), dev_name), m_log_source_devices.end());
	}
	catch(std::exception& e){
		std::stringstream ss;
		ss<<"C++ exception (err="<<e.what()<<" occurred while removing "<<dev_name<<" name from list!";
		_THROW_TANGO_EXCEPTION("REMOVE_LOG_SOURCE_FAILED",ss.str());
	}

	//Update list of managed log source
	if(SetDynAttrValue<std::string>(m_log_source_devices,managedLogDevices_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<managedLogDevices_attr_name<<"!";
		_ERROR_LOG(ss.str());	
	}

	//Update list of log sources attributes
	std::vector<std::string> devicesInGroup= m_managedLogDeviceGroup->get_device_list(true);
	if(SetDynAttrValue<std::string>(devicesInGroup,logDevices_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<logDevices_attr_name<<"!";
		_ERROR_LOG(ss.str());	
	}

	return 0;

}//close RemoveLogSourceFromGroup()


int ElementLogger::AddSELogSourceToGroup(std::string dev_name){

	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string managedSELogDevices_attr_name= "managedSELogDevices";
	std::string seLogDevices_attr_name= "logSEDevices";
	//###########################################################################


	//Check if device is already present in map
	_DEBUG_LOG("Check if device "<<dev_name<<" is present in map...");
	std::map<std::string,Tango::DeviceProxy*>::iterator it = m_managedSELogAdminDeviceMap.find(dev_name);
  if (!m_managedSELogAdminDeviceMap.empty() && it!= m_managedSELogAdminDeviceMap.end()){
		_DEBUG_LOG("Device "<<dev_name<<" already present in SE log source admin map, nothing to be done...");
		return 0;
	}


	//Create proxy to device to be added
	_DEBUG_LOG("Creating device proxy "<<dev_name<<" ...");
	Tango::DeviceProxy* dev_proxy= 0;
	try {		
		dev_proxy= new Tango::DeviceProxy(dev_name);
	}
	catch(Tango::DevFailed& e){
		_WARN_LOG("Failed to connect to device proxy "<<dev_name<<", will retry later...");
		if(dev_proxy){
			delete dev_proxy;
			dev_proxy= 0;
		}
		return -1;
	}	
	
	//Get the admin device name
	_DEBUG_LOG("Get admin device name of device "<<dev_name<<"...");
	std::string admin_dev_name= "";
	try {			
		admin_dev_name= dev_proxy->adm_name();
	}
	catch(Tango::DevFailed& e){
		_WARN_LOG("Tango exception occurred while retrieving admin dev name of device "<<dev_name<<", will retry later...");
		if(dev_proxy){
			delete dev_proxy;
			dev_proxy= 0;
		}
		return -1;
	}	

	//Clear proxy 
	if(dev_proxy){
		delete dev_proxy;
		dev_proxy= 0;
	}


	//Create proxy to admin device 
	_DEBUG_LOG("Creating admin device proxy "<<admin_dev_name<<" ...");
	Tango::DeviceProxy* admin_dev_proxy= 0;
	try {		
		admin_dev_proxy= new Tango::DeviceProxy(admin_dev_name);
	}
	catch(Tango::DevFailed& e){
		_WARN_LOG("Failed to connect to device admin proxy "<<admin_dev_name<<", will retry later...");
		if(admin_dev_proxy){
			delete admin_dev_proxy;
			admin_dev_proxy= 0;
		}
		return -1;
	}	

	//If dev name given in argument is a FQDN strip domain part
	std::string plain_dev_name= dev_name;
	if(dev_name.find("tango://")!=std::string::npos){
		std::string facility_name= "";
		std::string domain_name= "";
		std::string family_name= "";
		std::string member_name= "";
		if(Utils_ns::TangoUtils::ParseFullProxyName(facility_name,domain_name,family_name,member_name,dev_name)<0){
			_WARN_LOG("Failed to parse full proxy name "<<dev_name);
			if(admin_dev_proxy){
				delete admin_dev_proxy;
				admin_dev_proxy= 0;
			}
			return -1;
		}
		plain_dev_name= domain_name + std::string("/") + family_name + std::string("/") + member_name;
		_DEBUG_LOG("Parsed plain name "<<plain_dev_name);
	}

	//Register current device as a log target for this device
	//["*","device:"]
	std::string target_name= std::string("device::") + device_name;
	Tango::DeviceData din; 
  Tango::DevVarStringArray* cmd_argin= 0; 
	try{
		cmd_argin = new Tango::DevVarStringArray(); 
    cmd_argin->length(2); 
    (*cmd_argin)[0] = Tango::string_dup(plain_dev_name.c_str());
    (*cmd_argin)[1] = Tango::string_dup(target_name.c_str()); 
		din << cmd_argin;
	}
	catch(...){
		_WARN_LOG("Exception while setting cmd argin for setting device "<<device_name<<" as log target for "<<admin_dev_name<<", will retry later...");
		if(admin_dev_proxy){
			delete admin_dev_proxy;
			admin_dev_proxy= 0;
		}
		return -1;
	}	

	_INFO_LOG("Trying to add log target "<<target_name<<" to "<<admin_dev_name<<" device ...");
	try {			
    admin_dev_proxy->command_inout("AddLoggingTarget",din);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_WARN_LOG("Failed to add log target "<<target_name<<" to "<<admin_dev_name<<", will retry later...");
		if(admin_dev_proxy){
			delete admin_dev_proxy;
			admin_dev_proxy= 0;
		}
		return -1;
	}	
	
	//Set log level for target
	Tango::DeviceData din2; 
	Tango::DevVarLongStringArray* cmd_argin2= 0; 
	try{
		cmd_argin2 = new Tango::DevVarLongStringArray(); 
		cmd_argin2->svalue.length(1);
		cmd_argin2->lvalue.length(1);
		cmd_argin2->svalue[0] = Tango::string_dup(plain_dev_name.c_str());
		cmd_argin2->lvalue[0] = sELogLevelDefault;
    din2 << cmd_argin2;
	}
	catch(...){
		_WARN_LOG("Exception while setting cmd argin for setting log level "<<sELogLevelDefault<<" in device "<<device_name<<", will retry later...");
		if(admin_dev_proxy){
			delete admin_dev_proxy;
			admin_dev_proxy= 0;
		}
		return -1;
	}	

	_INFO_LOG("Trying to set log level "<<sELogLevelDefault<<" for target "<<target_name<<" ...");
	try {			
    admin_dev_proxy->command_inout("SetLoggingLevel",din2);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_WARN_LOG("Failed to set log level "<<sELogLevelDefault<<" to target "<<target_name<<", will retry later...");
		if(admin_dev_proxy){
			delete admin_dev_proxy;
			admin_dev_proxy= 0;
		}
		return -1;
	}	


	//Add admin device to map	
	_DEBUG_LOG("Add admin device "<<admin_dev_name<<" to map...");
	m_managedSELogAdminDeviceMap.insert( std::pair<std::string,Tango::DeviceProxy*>(dev_name,admin_dev_proxy) );

	//Update list of SE log sources
	_DEBUG_LOG("Find if dev name "<<dev_name<<" is present in log source list...");
	int pos= -1;
	if(!Utils_ns::CodeUtils::FindItem(m_se_log_source_devices,dev_name,pos)){
		_DEBUG_LOG("Add dev name "<<dev_name<<" to log source list...");
		m_se_log_source_devices.push_back(dev_name);
	}

	//Update list of managed log source
	if(SetDynAttrValue<std::string>(m_se_log_source_devices,managedSELogDevices_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<managedSELogDevices_attr_name<<"!";
		_ERROR_LOG(ss.str());	
	}

	//Update list of log sources attributes
	std::vector<std::string> devicesInMap;
	for(it= m_managedSELogAdminDeviceMap.begin(); it!=m_managedSELogAdminDeviceMap.end(); it++) {
    devicesInMap.push_back(it->first);
	}

	if(SetDynAttrValue<std::string>(devicesInMap,seLogDevices_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<seLogDevices_attr_name<<"!";
		_ERROR_LOG(ss.str());	
	}

	return 0;

}//close AddSELogSourceToGroup()


int ElementLogger::RemoveSELogSourceFromGroup(std::string dev_name){

	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string managedSELogDevices_attr_name= "managedLogSEDevices";
	std::string seLogDevices_attr_name= "logSEDevices";
	//###########################################################################


	//Check if device is already present in map
	std::map<std::string,Tango::DeviceProxy*>::iterator it = m_managedSELogAdminDeviceMap.find(dev_name);
  if (m_managedSELogAdminDeviceMap.empty() || it== m_managedSELogAdminDeviceMap.end()){
		_DEBUG_LOG("Device "<<dev_name<<" not present in SE log source admin map, nothing to be done...");
		return 0;
	}

	//Retrieve admin device
	Tango::DeviceProxy* admin_dev_proxy= it->second;
	if(!admin_dev_proxy){
		_ERROR_LOG("Null ptr to admin dev proxy for device "<<dev_name<<" (it should not occur!)");
		return -1;
	}

	//Remove current device from log targets for input device
	//["*","device:"]
	std::string target_name= std::string("device::") + device_name;
	Tango::DeviceData din; 
  Tango::DevVarStringArray* cmd_argin= 0; 
	try{
		cmd_argin = new Tango::DevVarStringArray(); 
    cmd_argin->length(2); 
    (*cmd_argin)[0] = Tango::string_dup(dev_name.c_str());
    (*cmd_argin)[1] = Tango::string_dup(target_name.c_str()); 
		din << cmd_argin;
	}
	catch(...){
		_WARN_LOG("Exception while setting cmd argin for removing device "<<dev_name<<" as log target!");
		return -1;
	}	

	try {			
    admin_dev_proxy->command_inout("RemoveLoggingTarget",din);
	}
	catch(Tango::DevFailed& e){
		_WARN_LOG("Failed to remove device "<<dev_name<<" as log target!");
		return -1;
	}	

	//Remove item from admin device map
	delete (it->second);
	m_managedSELogAdminDeviceMap.erase(it);
	
	//Remove item in list if not existing
	try{
		m_se_log_source_devices.erase(std::remove(m_se_log_source_devices.begin(), m_se_log_source_devices.end(), dev_name), m_se_log_source_devices.end());
	}
	catch(std::exception& e){
		std::stringstream ss;
		ss<<"C++ exception (err="<<e.what()<<" occurred while removing "<<dev_name<<" name from list!";
		_THROW_TANGO_EXCEPTION("REMOVE_LOG_SOURCE_FAILED",ss.str());
	}

	//Update list of managed log source
	if(SetDynAttrValue<std::string>(m_se_log_source_devices,managedSELogDevices_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<managedSELogDevices_attr_name<<"!";
		_ERROR_LOG(ss.str());	
	}

	//Update list of log sources attributes
	std::vector<std::string> devicesInMap;
	std::map<std::string,Tango::DeviceProxy*>::iterator iter= m_managedSELogAdminDeviceMap.begin();
	for(iter= m_managedSELogAdminDeviceMap.begin(); iter!=m_managedSELogAdminDeviceMap.end(); iter++) {
    devicesInMap.push_back(iter->first);
	}

	if(SetDynAttrValue<std::string>(devicesInMap,seLogDevices_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<seLogDevices_attr_name<<"!";
		_ERROR_LOG(ss.str());	
	}

	return 0;

}//close RemoveSELogSourceFromGroup()


void ElementLogger::SetSELoggingTarget(std::string dev_name,std::string log_target){

	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string cmd_name= "RemoveLoggingTarget";
	std::string cmd_name2= "AddLoggingTarget";
	//###########################################################################

	//=====================================================
	//==      GET PROXY DEVICE
	//=====================================================
	//Check if map is empty
	if(m_managedSELogAdminDeviceMap.empty()){
		std::stringstream ss;
		ss<<"Sub-Element log source managed map is empty, cannot find device "<<dev_name<<"!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_SE_LOGGING_TARGET_FAILED",ss.str());	
	}

	//Find admin proxy item from map
	std::string full_proxy_name= dev_name;	
	std::map<std::string,Tango::DeviceProxy*>::iterator it= m_managedSELogAdminDeviceMap.find(full_proxy_name);
	if(it==m_managedSELogAdminDeviceMap.end()){
		_WARN_LOG("Proxy "<<full_proxy_name<<" not found in registered proxy list, trying with alias name...");
		
		//Get full proxy name corresponding to alias
		if(Utils_ns::TangoUtils::GetFQDNDeviceNameFromAlias(full_proxy_name,dev_name)<0){
			std::stringstream ss;
			ss<<"Failed to retrieve full proxy name from alias "<<dev_name<<"!";
			_WARN_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("SET_SE_LOGGING_TARGET_FAILED",ss.str());	
		}

		//Find again 
		it= m_managedSELogAdminDeviceMap.find(full_proxy_name);
		if(it==m_managedSELogAdminDeviceMap.end()){
			std::stringstream ss;
			ss<<"Failed to retrieve proxy "<<full_proxy_name<<" (check valid proxy name or if was added in SE log sources!)";
			_WARN_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("SET_SE_LOGGING_TARGET_FAILED",ss.str());	
		}
	}//close if

	Tango::DeviceProxy* admin_proxy= it->second;
	if(!admin_proxy){
		std::stringstream ss;
		ss<<"Null ptr to proxy "<<full_proxy_name<<" (should not occur!)";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_SE_LOGGING_TARGET_FAILED",ss.str());	
	}

	//Get plain proxy name (without the tango://... part)
	std::string proxy_name= full_proxy_name;
	//Utils_ns::CodeUtils::StripPatternFromString(proxy_name,"tango://");
	if(Utils_ns::TangoUtils::GetPlainProxyName(proxy_name,full_proxy_name)<0){
		std::stringstream ss;
		ss<<"Failed to extract plain device name from FQDN name "<<full_proxy_name<<"!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_SE_LOGGING_TARGET_FAILED",ss.str());	
	}
	
	//=====================================================
	//==      REMOVE ALL TARGETS
	//=====================================================
	_INFO_LOG("Removing all log targets from device "<<proxy_name<<" ...");

	//Set command argin
	Tango::DeviceData din; 
  Tango::DevVarStringArray* cmd_argin= 0; 
	try{
		cmd_argin = new Tango::DevVarStringArray(); 
		cmd_argin->length(2);
		//(*cmd_argin)[0] = Tango::string_dup(full_proxy_name.c_str());
		(*cmd_argin)[0] = Tango::string_dup(proxy_name.c_str());
    (*cmd_argin)[1] = Tango::string_dup("device::*");
		din << cmd_argin;
	}
	catch(...){
		std::stringstream ss;
		ss<<"Exception while setting cmd argin!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_SE_LOGGING_TARGET_FAILED",ss.str());
	}	

	//Invoke command on admin proxy
	//Execute command (no argin, no argout expected)
	Tango::DeviceData dout;
	try {
		dout= admin_proxy->command_inout(cmd_name,din);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		std::stringstream ss;
		ss<<"Tango exception occurred while executing command "<<cmd_name<<" on proxy "<<full_proxy_name<<" (check proxy registered or syntax)!";
		_WARN_LOG(ss.str());
		throw;
	}
	catch(std::exception& e){
		std::stringstream ss;
		ss<<"C++ exception occurred while executing command "<<cmd_name<<" on proxy "<<full_proxy_name<<" (err="<<e.what()<<")!";
		_WARN_LOG(ss.str());
		throw;
	}
	catch(...){
		std::stringstream ss;
		ss<<"Unknown exception occurred while executing command "<<cmd_name<<" on proxy "<<full_proxy_name<<"!";
		_WARN_LOG(ss.str());
		throw;
	}

	//=====================================================
	//==      ADD TARGET
	//=====================================================	
	_INFO_LOG("Adding log target "<<log_target<<" to device "<<proxy_name<<" ...");

	//Set command argin
	Tango::DeviceData din2; 
  Tango::DevVarStringArray* cmd_argin2= 0; 
	try{
		cmd_argin2 = new Tango::DevVarStringArray(); 
		cmd_argin2->length(2);
		//(*cmd_argin2)[0] = Tango::string_dup(full_proxy_name.c_str());	
		(*cmd_argin2)[0] = Tango::string_dup(proxy_name.c_str());
    (*cmd_argin2)[1] = Tango::string_dup(log_target.c_str());
		din2 << cmd_argin2;
	}
	catch(...){
		std::stringstream ss;
		ss<<"Exception while setting cmd argin!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_SE_LOGGING_TARGET_FAILED",ss.str());
	}	

	//Invoke command on admin proxy
	//Execute command (no argin, no argout expected)
	Tango::DeviceData dout2;
	try {
		dout2= admin_proxy->command_inout(cmd_name2,din2);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		std::stringstream ss;
		ss<<"Tango exception occurred while executing command "<<cmd_name2<<" on proxy "<<full_proxy_name<<" (check proxy registered or syntax)!";
		_WARN_LOG(ss.str());
		throw;
	}
	catch(std::exception& e){
		std::stringstream ss;
		ss<<"C++ exception occurred while executing command "<<cmd_name2<<" on proxy "<<full_proxy_name<<" (err="<<e.what()<<")!";
		_WARN_LOG(ss.str());
		throw;
	}
	catch(...){
		std::stringstream ss;
		ss<<"Unknown exception occurred while executing command "<<cmd_name2<<" on proxy "<<full_proxy_name<<"!";
		_WARN_LOG(ss.str());
		throw;
	}
	
}//close SetSELoggingTarget()


void ElementLogger::SetSELoggingLevel(std::string dev_name,Tango::DevLong log_level){

	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string cmd_name= "SetLoggingLevel";
	//###########################################################################

	//=====================================================
	//==      GET PROXY DEVICE
	//=====================================================
	//Check if map is empty
	if(m_managedSELogAdminDeviceMap.empty()){
		std::stringstream ss;
		ss<<"Sub-Element log source managed map is empty, cannot find device "<<dev_name<<"!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_SE_LOGGING_LEVEL_FAILED",ss.str());	
	}

	//Find admin proxy item from map
	std::string full_proxy_name= dev_name;	
	std::map<std::string,Tango::DeviceProxy*>::iterator it= m_managedSELogAdminDeviceMap.find(full_proxy_name);
	if(it==m_managedSELogAdminDeviceMap.end()){
		_WARN_LOG("Proxy "<<full_proxy_name<<" not found in registered proxy list, trying with alias name...");
		
		//Get full proxy name corresponding to alias
		if(Utils_ns::TangoUtils::GetFQDNDeviceNameFromAlias(full_proxy_name,dev_name)<0){
			std::stringstream ss;
			ss<<"Failed to retrieve full proxy name from alias "<<dev_name<<"!";
			_WARN_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("SET_SE_LOGGING_LEVEL_FAILED",ss.str());	
		}

		//Find again 
		it= m_managedSELogAdminDeviceMap.find(full_proxy_name);
		if(it==m_managedSELogAdminDeviceMap.end()){
			std::stringstream ss;
			ss<<"Failed to retrieve proxy "<<full_proxy_name<<" (check valid proxy name or if was added in SE log sources!)";
			_WARN_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("SET_SE_LOGGING_LEVEL_FAILED",ss.str());	
		}
	}//close if

	Tango::DeviceProxy* admin_proxy= it->second;
	if(!admin_proxy){
		std::stringstream ss;
		ss<<"Null ptr to proxy "<<full_proxy_name<<" (should not occur!)";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_SE_LOGGING_LEVEL_FAILED",ss.str());	
	}

	//Get plain proxy name (without the tango://... part)
	std::string proxy_name= full_proxy_name;
	//Utils_ns::CodeUtils::StripPatternFromString(proxy_name,"tango://");
	if(Utils_ns::TangoUtils::GetPlainProxyName(proxy_name,full_proxy_name)<0){
		std::stringstream ss;
		ss<<"Failed to extract plain device name from FQDN name "<<full_proxy_name<<"!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_SE_LOGGING_LEVEL_FAILED",ss.str());	
	}

	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	_INFO_LOG("Settign log level "<<log_level<<" in device "<<proxy_name<<" ...");

	//Set command argin
	Tango::DeviceData din; 
  Tango::DevVarLongStringArray* cmd_argin= 0; 
	try{
		cmd_argin = new Tango::DevVarLongStringArray(); 
		cmd_argin->svalue.length(1);
		cmd_argin->lvalue.length(1); 
    cmd_argin->lvalue[0] = log_level;
    //cmd_argin->svalue[0] = Tango::string_dup(full_proxy_name.c_str()); 
		cmd_argin->svalue[0] = Tango::string_dup(proxy_name.c_str()); 
		din << cmd_argin;
	}
	catch(...){
		std::stringstream ss;
		ss<<"Exception while setting cmd argin!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_SE_LOGGING_LEVEL_FAILED",ss.str());
	}	

	//Invoke command on admin proxy
	//Execute command (no argin, no argout expected)
	Tango::DeviceData dout;
	try {
		dout= admin_proxy->command_inout(cmd_name,din);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		std::stringstream ss;
		ss<<"Tango exception occurred while executing command "<<cmd_name<<" on proxy "<<full_proxy_name<<" (check proxy registered or syntax)!";
		_WARN_LOG(ss.str());
		throw;
	}
	catch(std::exception& e){
		std::stringstream ss;
		ss<<"C++ exception occurred while executing command "<<cmd_name<<" on proxy "<<full_proxy_name<<" (err="<<e.what()<<")!";
		_WARN_LOG(ss.str());
		throw;
	}
	catch(...){
		std::stringstream ss;
		ss<<"Unknown exception occurred while executing command "<<cmd_name<<" on proxy "<<full_proxy_name<<"!";
		_WARN_LOG(ss.str());
		throw;
	}
	
}//close SetSELoggingLevel()


bool ElementLogger::IsForwardedLogSource(std::string log_source)
{
	bool isForwarded= false;

	//Search log sources in forwarded sources
	for(size_t i=0;i<logForwardSources.size();i++){
		std::size_t found = logForwardSources[i].find(log_source);
  	if (found!=std::string::npos){
			isForwarded= true;
			break;
		}
	}//end loop log forward sources
	
	return isForwarded;

}//close IsForwardedLogSources()

// //--------------------------------------------------------
// /**
//  *	Read attribute enableLogForward related method
//  *	Description: 
//  *
//  *	Data type:	Tango::DevBoolean
//  *	Attr type:	Scalar
//  */
// //--------------------------------------------------------
// void ElementLogger::read_enableLogForward(Tango::Attribute &attr)
// {
// 	DEBUG_STREAM << "ElementLogger::read_enableLogForward(Tango::Attribute &attr) entering... " << endl;
// 	//	Set the attribute value
// 	//attr.set_value(attr_enableLogForward_read);
// 	
// 	Tango::DevBoolean* w_val= new Tango::DevBoolean;
// 	std::string attr_name= attr.get_assoc_name();
// 	get_device_attr()->get_w_attr_by_name(attr_name.c_str()).get_write_value(*w_val);
// 	attr.set_value(w_val,1,0,true);
// }

// //--------------------------------------------------------
// /**
//  *	Write attribute enableLogForward related method
//  *	Description: 
//  *
//  *	Data type:	Tango::DevBoolean
//  *	Attr type:	Scalar
//  */
// //--------------------------------------------------------
// void ElementLogger::write_enableLogForward(Tango::WAttribute &attr)
// {
// 	DEBUG_STREAM << "ElementLogger::write_enableLogForward(Tango::WAttribute &attr) entering... " << endl;
// 	//	Retrieve write value
// 	Tango::DevBoolean	w_val;
// 	attr.get_write_value(w_val);
// 	attr.get_write_value(attr_enableLogForward_write);
// 	
// }

// //--------------------------------------------------------
// /**
//  *	Read attribute managedLogDevices related method
//  *	Description: 
//  *
//  *	Data type:	Tango::DevString
//  *	Attr type:	Spectrum max = 1000000
//  */
// //--------------------------------------------------------
// void ElementLogger::read_managedLogDevices(Tango::Attribute &attr)
// {
// 	DEBUG_STREAM << "ElementLogger::read_managedLogDevices(Tango::Attribute &attr) entering... " << endl;
// 	//	Set the attribute value
// 	long data_size= attr.get_data_size();
// 	attr.set_value(attr_managedLogDevices_read, data_size);
// 	
// }

// //--------------------------------------------------------
// /**
//  *	Command RegisterSELogSourceGroup related method
//  *	Description: Initialize and register sub-element devices to 
//  *               SE log source group. 
//  *               This command periodically tries to connect to the SE 
//  *               devices, add them to group and add the device as a 
//  *               log targets for them.
//  *
//  */
// //--------------------------------------------------------
// void ElementLogger::register_selog_source_group()
// {
// 	DEBUG_STREAM << "ElementLogger::RegisterSELogSourceGroup()  - " << device_name << endl;
// 	
// 	//	Add your own code
// 	if(InitAndRegisterSELogSourceGroup()<0){
// 		std::string errMsg("Failed to initialize and register SE log source group");
// 		_THROW_TANGO_EXCEPTION("INITIALIZE_SE_LOG_SOURCE_GROUP_FAILED",errMsg);
// 	}
// }

// //--------------------------------------------------------
// /**
//  *	Read attribute managedLogDevices_static related method
//  *	Description: Managed log devices
//  *
//  *	Data type:	Tango::DevString
//  *	Attr type:	Spectrum max = 100
//  */
// //--------------------------------------------------------
// void ElementLogger::read_managedLogDevices_static(Tango::Attribute &attr)
// {
// 	DEBUG_STREAM << "ElementLogger::read_managedLogDevices_static(Tango::Attribute &attr) entering... " << endl;
// 	//	Set the attribute value
// 	attr.set_value(attr_managedLogDevices_static_read, 100);
// 	
// }

// //--------------------------------------------------------
// /**
//  *	Read attribute logDevices_static related method
//  *	Description: Log source devices
//  *
//  *	Data type:	Tango::DevString
//  *	Attr type:	Spectrum max = 100
//  */
// //--------------------------------------------------------
// void ElementLogger::read_logDevices_static(Tango::Attribute &attr)
// {
// 	DEBUG_STREAM << "ElementLogger::read_logDevices_static(Tango::Attribute &attr) entering... " << endl;
// 	//	Set the attribute value
// 	attr.set_value(attr_logDevices_static_read, 100);
// 	
// }

// //--------------------------------------------------------
// /**
//  *	Read attribute managedSELogDevices_static related method
//  *	Description: 
//  *
//  *	Data type:	Tango::DevString
//  *	Attr type:	Spectrum max = 100
//  */
// //--------------------------------------------------------
// void ElementLogger::read_managedSELogDevices_static(Tango::Attribute &attr)
// {
// 	DEBUG_STREAM << "ElementLogger::read_managedSELogDevices_static(Tango::Attribute &attr) entering... " << endl;
// 	//	Set the attribute value
// 	attr.set_value(attr_managedSELogDevices_static_read, 100);
// 	
// }

// //--------------------------------------------------------
// /**
//  *	Read attribute logSEDevices_static related method
//  *	Description: 
//  *
//  *	Data type:	Tango::DevString
//  *	Attr type:	Spectrum max = 100
//  */
// //--------------------------------------------------------
// void ElementLogger::read_logSEDevices_static(Tango::Attribute &attr)
// {
// 	DEBUG_STREAM << "ElementLogger::read_logSEDevices_static(Tango::Attribute &attr) entering... " << endl;
// 	//	Set the attribute value
// 	attr.set_value(attr_logSEDevices_static_read, 100);
// 	
// }

// //--------------------------------------------------------
// /**
//  *	Read attribute enableLogForward_static related method
//  *	Description: Enable/disable log forwarding
//  *
//  *	Data type:	Tango::DevBoolean
//  *	Attr type:	Scalar
//  */
// //--------------------------------------------------------
// void ElementLogger::read_enableLogForward_static(Tango::Attribute &attr)
// {
// 	DEBUG_STREAM << "ElementLogger::read_enableLogForward_static(Tango::Attribute &attr) entering... " << endl;
// 	//	Set the attribute value
// 	attr.set_value(attr_enableLogForward_static_read);
// 	
// }

// //--------------------------------------------------------
// /**
//  *	Write attribute enableLogForward_static related method
//  *	Description: Enable/disable log forwarding
//  *
//  *	Data type:	Tango::DevBoolean
//  *	Attr type:	Scalar
//  */
// //--------------------------------------------------------
// void ElementLogger::write_enableLogForward_static(Tango::WAttribute &attr)
// {
// 	DEBUG_STREAM << "ElementLogger::write_enableLogForward_static(Tango::WAttribute &attr) entering... " << endl;
// 	//	Retrieve write value
// 	Tango::DevBoolean	w_val;
// 	attr.get_write_value(w_val);
// 	
// 	
// }


/*----- PROTECTED REGION END -----*/	//	ElementLogger::namespace_ending
} //	namespace
