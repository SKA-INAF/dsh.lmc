/*----- PROTECTED REGION ID(DishManager.cpp) ENABLED START -----*/
static const char *RcsId = "$Id:  $";

// **************************************************************************
// * License and Disclaimer                                                 *
// *                                                                        *
// * Copyright 2016 Simone Riggi																			      *
// *																																	      *
// * This file is part of SKA DSH.LMC 																		  *
// * SKA DSH.LMC is free software: you can redistribute it and/or modify it *
// * under the terms of the GNU General Public License as published by      *
// * the Free Software Foundation, either * version 3 of the License,       * 
// * or (at your option) any later version.                                 * 
// * DSH.LMC is distributed in the hope that it will be useful, but 			  *
// * WITHOUT ANY WARRANTY; without even the implied warranty of             * 
// * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                   *
// * See the GNU General Public License for more details. You should        * 
// * have received a copy of the GNU General Public License along with      * 
// * DSH.LMC. If not, see http://www.gnu.org/licenses/.                     *
// **************************************************************************

//=============================================================================
//
// file :        DishManager.cpp
//
// description : C++ source for the DishManager class and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               DishManager are implemented in this file.
//
// project :     DishManager
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
// $Author:  $
//
// $Revision:  $
// $Date:  $
//
// $HeadURL:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <DishManager.h>
#include <DishManagerClass.h>

#include <TangoUtils.h>
#include <TaskManager.h>


#include <yat/time/Time.h>
#include <yat/time/Timer.h>

/*----- PROTECTED REGION END -----*/	//	DishManager.cpp

/**
 *  DishManager class description:
 *    DishManager
 */

//================================================================
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name                    |  Method name
//================================================================
//  ClearTasks                      |  Inherited (no method)
//  GetInitializedAttrFormulas      |  Inherited (no method)
//  GetNFailedTasks                 |  Inherited (no method)
//  GetNQueuedTasks                 |  Inherited (no method)
//  Status                          |  Inherited (no method)
//  FlushTaskQueue                  |  Inherited (no method)
//  GetInitializedFormulas          |  Inherited (no method)
//  GetNIdleTasks                   |  Inherited (no method)
//  GetNRunningTasks                |  Inherited (no method)
//  State                           |  Inherited (no method)
//  GetNTasks                       |  Inherited (no method)
//  GetNTotFailedTasks              |  Inherited (no method)
//  GetQueuedTaskInfo               |  Inherited (no method)
//  GetRegisteredAttrFormulas       |  Inherited (no method)
//  GetRegisteredEvents             |  Inherited (no method)
//  GetRegisteredFormulas           |  Inherited (no method)
//  GetRegisteredProxies            |  Inherited (no method)
//  GetTaskInfo                     |  Inherited (no method)
//  InitializeAttrFormulas          |  Inherited (no method)
//  InitializeDevProxies            |  Inherited (no method)
//  InitializeFormulas              |  Inherited (no method)
//  InitializeFwdAttrs              |  Inherited (no method)
//  InitializeLoggers               |  Inherited (no method)
//  IsTaskQuotaReached              |  Inherited (no method)
//  MonitorProxies                  |  Inherited (no method)
//  RandomizeDynAttrs               |  Inherited (no method)
//  RevokeTask                      |  Inherited (no method)
//  UpdateFormulaAttrs              |  Inherited (no method)
//  UpdateStatusAttrs               |  Inherited (no method)
//  GetFormulaData                  |  Inherited (no method)
//  SetStandbyLPMode                |  set_standby_lpmode
//  SetStandbyFPMode                |  set_standby_fpmode
//  SetOperateMode                  |  set_operate_mode
//  SetMaintenanceMode              |  set_maintenance_mode
//  SetStowMode                     |  set_stow_mode
//  ConfigureBand1                  |  configure_band1
//  ConfigureBand2                  |  configure_band2
//  ConfigureBand3                  |  configure_band3
//  ConfigureBand4                  |  configure_band4
//  ConfigureBand5a                 |  configure_band5a
//  ConfigureBand5b                 |  configure_band5b
//  SetIndexerPosition              |  set_indexer_position
//  SetIndexerPositionTask          |  set_indexer_position_task
//  Track                           |  track
//  Slew                            |  slew
//  Scan                            |  scan
//  HandleBandFunctionalErrorEvent  |  handle_band_functional_error_event
//  HandleEStopEvent                |  handle_estop_event
//  HandlePowerCutEvent             |  handle_power_cut_event
//  HandlePowerRestoreEvent         |  handle_power_restore_event
//  HandleTMCommLossEvent           |  handle_tmcomm_loss_event
//  HandleBandInFocusEvent          |  handle_band_in_focus_event
//  FlushCommandQueue               |  flush_command_queue
//  SetRxStandbyLPMode              |  set_rx_standby_lpmode
//  SetRxStandbyLPModeTask          |  set_rx_standby_lpmode_task
//  SetRxStandbyFPMode              |  set_rx_standby_fpmode
//  SetRxStandbyFPModeTask          |  set_rx_standby_fpmode_task
//  SetRxMaintenanceMode            |  set_rx_maintenance_mode
//  SetRxMaintenanceModeTask        |  set_rx_maintenance_mode_task
//  ConfigureRxBand                 |  configure_rx_band
//  ConfigureRxBandAsync            |  configure_rx_band_async
//  ConfigureRxBandTask             |  configure_rx_band_task
//  ConfigureAndSynchroniseRxBand   |  configure_and_synchronise_rx_band
//  ConfigureRxAttenuation          |  configure_rx_attenuation
//  Capture                         |  capture
//  StartCapture                    |  start_capture
//  StopCapture                     |  stop_capture
//  StartRxCaptureTask              |  start_rx_capture_task
//  Synchronise                     |  synchronise
//  SynchroniseRxBandTask           |  synchronise_rx_band_task
//  EnableRxEngineeringMode         |  enable_rx_engineering_mode
//  ShutdownRXPU                    |  shutdown_rxpu
//  ShutdownRXPUTask                |  shutdown_rxputask
//  PowerOffRXPU                    |  power_off_rxpu
//  PowerOnRXPU                     |  power_on_rxpu
//  PowerOffRXPUTask                |  power_off_rxputask
//  PowerOnRXPUTask                 |  power_on_rxputask
//  SetSPFStandbyLPMode             |  set_spfstandby_lpmode
//  SetSPFStandbyLPModeTask         |  set_spfstandby_lpmode_task
//  SetSPFOperateMode               |  set_spfoperate_mode
//  SetSPFOperateModeTask           |  set_spfoperate_mode_task
//  SetSPFOperational               |  set_spfoperational
//  SetSPFMaintenanceMode           |  set_spfmaintenance_mode
//  SetSPFMaintenanceModeTask       |  set_spfmaintenance_mode_task
//  SetSPFFeedMode                  |  set_spffeed_mode
//  SendSPFFeedCommand              |  send_spffeed_command
//  SetSPFLnaPowerOff               |  set_spflna_power_off
//  SetSPFLnaPowerOn                |  set_spflna_power_on
//  SetSPFLnaPowerOnTask            |  set_spflna_power_on_task
//  SetSPFBandInFocus               |  set_spfband_in_focus
//  SetSPFBandInFocusTask           |  set_spfband_in_focus_task
//  ShutdownSPFC                    |  shutdown_spfc
//  ShutdownSPFCTask                |  shutdown_spfctask
//  PowerOffSPFC                    |  power_off_spfc
//  PowerOnSPFC                     |  power_on_spfc
//  PowerOffSPFCTask                |  power_off_spfctask
//  PowerOnSPFCTask                 |  power_on_spfctask
//  SetDSStandbyLPMode              |  set_dsstandby_lpmode
//  SetDSStandbyLPModeTask          |  set_dsstandby_lpmode_task
//  SetDSStandbyFPMode              |  set_dsstandby_fpmode
//  SetDSStandbyFPModeTask          |  set_dsstandby_fpmode_task
//  SetDSPointMode                  |  set_dspoint_mode
//  SetDSPointModeTask              |  set_dspoint_mode_task
//  SetDSStowMode                   |  set_dsstow_mode
//  SetDSStowModeTask               |  set_dsstow_mode_task
//  SetDSMaintenanceMode            |  set_dsmaintenance_mode
//  SetDSMaintenanceModeTask        |  set_dsmaintenance_mode_task
//  ResetDishMode                   |  reset_dish_mode
//  ResetDishTasks                  |  reset_dish_tasks
//  SendTestLogMsg                  |  Inherited (no method)
//  SetTMProxyAddress               |  set_tmproxy_address
//  RevokeTaskSequence              |  Inherited (no method)
//  RestartSPFComponents            |  restart_spfcomponents
//  ClearTaskHistory                |  Inherited (no method)
//  SetStandbyFPModeOnBandError     |  set_standby_fpmode_on_band_error
//  GetLogAppenderInfo              |  Inherited (no method)
//================================================================

//================================================================
//  Attributes managed are:
//================================================================
//  loggingLevelCentral       |  Tango::DevLong	Scalar
//  loggingLevelElement       |  Tango::DevLong	Scalar
//  loggingLevelStorage       |  Tango::DevLong	Scalar
//  loggingLevelConsole       |  Tango::DevLong	Scalar
//  buildState                |  Tango::DevString	Scalar
//  centralLoggerStatus       |  Tango::DevEnum	Scalar
//  elementLoggerStatus       |  Tango::DevEnum	Scalar
//  storageLoggerStatus       |  Tango::DevEnum	Scalar
//  eventRate                 |  Tango::DevFloat	Scalar
//  exceptionRate             |  Tango::DevFloat	Scalar
//  fwdAttrInitStatus         |  Tango::DevEnum	Scalar
//  centralLoggerEnabled      |  Tango::DevBoolean	Scalar
//  elementLoggerEnabled      |  Tango::DevBoolean	Scalar
//  storageLoggerEnabled      |  Tango::DevBoolean	Scalar
//  loggingTargetCentral      |  Tango::DevString	Scalar
//  loggingTargetElement      |  Tango::DevString	Scalar
//  loggingTargetStorage      |  Tango::DevString	Scalar
//  attrRandomizationEnabled  |  Tango::DevBoolean	Scalar
//  attrRandomizationPeriod   |  Tango::DevULong	Scalar
//================================================================

namespace DishManager_ns
{
/*----- PROTECTED REGION ID(DishManager::namespace_starting) ENABLED START -----*/

//	static initializations

/*----- PROTECTED REGION END -----*/	//	DishManager::namespace_starting

//--------------------------------------------------------
/**
 *	Method      : DishManager::DishManager()
 *	Description : Constructors for a Tango device
 *                implementing the classDishManager
 */
//--------------------------------------------------------
DishManager::DishManager(Tango::DeviceClass *cl, string &s)
 : LMCDevice(cl, s.c_str())
{
	/*----- PROTECTED REGION ID(DishManager::constructor_1) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	DishManager::constructor_1
}
//--------------------------------------------------------
DishManager::DishManager(Tango::DeviceClass *cl, const char *s)
 : LMCDevice(cl, s)
{
	/*----- PROTECTED REGION ID(DishManager::constructor_2) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	DishManager::constructor_2
}
//--------------------------------------------------------
DishManager::DishManager(Tango::DeviceClass *cl, const char *s, const char *d)
 : LMCDevice(cl, s, d)
{
	/*----- PROTECTED REGION ID(DishManager::constructor_3) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	DishManager::constructor_3
}

//--------------------------------------------------------
/**
 *	Method      : DishManager::delete_device()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void DishManager::delete_device()
{
	DEBUG_STREAM << "DishManager::delete_device() " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::delete_device) ENABLED START -----*/
	
	//	Delete device allocated objects
	
	//## Clear task: notify wait cond & exit
	if(ClearConfigurationTask()<0){
		_ERROR_LOG("Failed to clearup task configuration!");
	}


	/*----- PROTECTED REGION END -----*/	//	DishManager::delete_device

	if (Tango::Util::instance()->is_svr_shutting_down()==false  &&
		Tango::Util::instance()->is_device_restarting(device_name)==false &&
		Tango::Util::instance()->is_svr_starting()==false)
	{
		//	If not shutting down call delete device for inherited object
		LMCDevice_ns::LMCDevice::delete_device();
	}
}

//--------------------------------------------------------
/**
 *	Method      : DishManager::init_device()
 *	Description : will be called at device initialization.
 */
//--------------------------------------------------------
void DishManager::init_device()
{
	DEBUG_STREAM << "DishManager::init_device() create device " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::init_device_before) ENABLED START -----*/
	
	//	Initialization before get_device_property() call
	
	/*----- PROTECTED REGION END -----*/	//	DishManager::init_device_before
	
	if (Tango::Util::instance()->is_svr_starting() == false  &&
		Tango::Util::instance()->is_device_restarting(device_name)==false)
	{
		//	If not starting up call init device for inherited object
		LMCDevice_ns::LMCDevice::init_device();
	}

	//	Get the device properties from database
	get_device_property();
	
	//	No longer if mandatory property not set. 
	if (mandatoryNotDefined)
		return;

	/*----- PROTECTED REGION ID(DishManager::init_device) ENABLED START -----*/

	//## Init device state
	set_state(Tango::ON);
	set_status("Device " + device_name + " is running");
	
	/*----- PROTECTED REGION END -----*/	//	DishManager::init_device
}

//--------------------------------------------------------
/**
 *	Method      : DishManager::get_device_property()
 *	Description : Read database to initialize property data members.
 */
//--------------------------------------------------------
void DishManager::get_device_property()
{
	/*----- PROTECTED REGION ID(DishManager::get_device_property_before) ENABLED START -----*/
	
	//	Initialize property data members
	
	/*----- PROTECTED REGION END -----*/	//	DishManager::get_device_property_before

	mandatoryNotDefined = false;

	//	Read device properties from database.
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("StorageLoggerEnabledDefault"));
	dev_prop.push_back(Tango::DbDatum("SyslogFacility"));
	dev_prop.push_back(Tango::DbDatum("SkaLevel"));
	dev_prop.push_back(Tango::DbDatum("LoggingLevelCentralDefault"));
	dev_prop.push_back(Tango::DbDatum("LoggingLevelElementDefault"));
	dev_prop.push_back(Tango::DbDatum("LoggingLevelStorageDefault"));
	dev_prop.push_back(Tango::DbDatum("LoggingTargetCentralDefault"));
	dev_prop.push_back(Tango::DbDatum("LoggingTargetElementDefault"));
	dev_prop.push_back(Tango::DbDatum("LoggingTargetStorageDefault"));
	dev_prop.push_back(Tango::DbDatum("ElementLoggerEnabledDefault"));
	dev_prop.push_back(Tango::DbDatum("CentralLoggerEnabledDefault"));
	dev_prop.push_back(Tango::DbDatum("SyslogHost"));
	dev_prop.push_back(Tango::DbDatum("ConfigFile"));
	dev_prop.push_back(Tango::DbDatum("EnableConfigFromFile"));
	dev_prop.push_back(Tango::DbDatum("EnableDynAttrCleanup"));
	dev_prop.push_back(Tango::DbDatum("EnableDynAttrRandomize"));
	dev_prop.push_back(Tango::DbDatum("DynAttrRandomizePeriod"));
	dev_prop.push_back(Tango::DbDatum("ProxyDevices"));
	dev_prop.push_back(Tango::DbDatum("FormulaVarMaxTimeInterval"));
	dev_prop.push_back(Tango::DbDatum("EnableProxyMonitoring"));
	dev_prop.push_back(Tango::DbDatum("ProxyMonitoringPeriod"));
	dev_prop.push_back(Tango::DbDatum("ProxyStatusAttrPollPeriod"));
	dev_prop.push_back(Tango::DbDatum("ProxyStatusAttrPeriodicEventPeriod"));
	dev_prop.push_back(Tango::DbDatum("ProxyStatusAttrArchiveEventPeriod"));
	dev_prop.push_back(Tango::DbDatum("ProxyTimeout"));
	dev_prop.push_back(Tango::DbDatum("EventSubscriptions"));
	dev_prop.push_back(Tango::DbDatum("EventHandlers"));
	dev_prop.push_back(Tango::DbDatum("EnableEventRateMonitoring"));
	dev_prop.push_back(Tango::DbDatum("MaxQueueableTask"));
	dev_prop.push_back(Tango::DbDatum("MaxTrackableTasks"));
	dev_prop.push_back(Tango::DbDatum("TaskHistoryTimeDepth"));
	dev_prop.push_back(Tango::DbDatum("DefaultTaskTimeout"));
	dev_prop.push_back(Tango::DbDatum("TaskStatusAttrList"));
	dev_prop.push_back(Tango::DbDatum("TaskSequenceStatusAttrList"));
	dev_prop.push_back(Tango::DbDatum("EnableLoggerInitPolling"));
	dev_prop.push_back(Tango::DbDatum("LoggerInitPollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableDevProxyInitPolling"));
	dev_prop.push_back(Tango::DbDatum("DevProxyInitPollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableFwdAttrInitPolling"));
	dev_prop.push_back(Tango::DbDatum("FwdAttrInitPollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableFormulaAttrUpdatePolling"));
	dev_prop.push_back(Tango::DbDatum("FormulaAttrUpdatePollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableStatusAttrUpdatePolling"));
	dev_prop.push_back(Tango::DbDatum("StatusAttrUpdatePollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableClearTaskPolling"));
	dev_prop.push_back(Tango::DbDatum("ClearTaskPollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableProxyStatusAttrCreation"));
	dev_prop.push_back(Tango::DbDatum("EnableAutoAdminProxyRegistration"));
	dev_prop.push_back(Tango::DbDatum("ProcessEventsInQueueThread"));
	dev_prop.push_back(Tango::DbDatum("ElementLoggerAddress"));
	dev_prop.push_back(Tango::DbDatum("ElementAlarmsAddress"));
	dev_prop.push_back(Tango::DbDatum("ElementTelModelAddress"));
	dev_prop.push_back(Tango::DbDatum("ElementDatabaseDSAddress"));
	dev_prop.push_back(Tango::DbDatum("AdminModeDefault"));
	dev_prop.push_back(Tango::DbDatum("AsynchCmdReplyTimeout"));
	dev_prop.push_back(Tango::DbDatum("AsynchCmdReplyNRetries"));
	dev_prop.push_back(Tango::DbDatum("ConfigureMonitoringPollPeriod"));
	dev_prop.push_back(Tango::DbDatum("ConfigureMonitoringTimeout"));
	dev_prop.push_back(Tango::DbDatum("SynchCmdReplyTimeout"));
	dev_prop.push_back(Tango::DbDatum("StowTaskTimeout"));
	dev_prop.push_back(Tango::DbDatum("ConfigureTaskTimeout"));
	dev_prop.push_back(Tango::DbDatum("OperateTaskTimeout"));
	dev_prop.push_back(Tango::DbDatum("ShutdownTaskTimeout"));
	dev_prop.push_back(Tango::DbDatum("RxShutdownTimeDelay"));
	dev_prop.push_back(Tango::DbDatum("StandbyFPTaskTimeout"));
	dev_prop.push_back(Tango::DbDatum("SPFStartupTimeout"));
	dev_prop.push_back(Tango::DbDatum("RxControllerAddress"));
	dev_prop.push_back(Tango::DbDatum("SpfControllerAddress"));
	dev_prop.push_back(Tango::DbDatum("DsManagerAddress"));
	dev_prop.push_back(Tango::DbDatum("ControlModeDefault"));
	dev_prop.push_back(Tango::DbDatum("RequestedBandDefault"));
	dev_prop.push_back(Tango::DbDatum("TmProxyAddressDefault"));
	dev_prop.push_back(Tango::DbDatum("PduManagerAddress"));

	//	is there at least one property to be read ?
	if (dev_prop.size()>0)
	{
		//	Call database and extract values
		if (Tango::Util::instance()->_UseDb==true)
			get_db_device()->get_property(dev_prop);
	
		//	get instance on DishManagerClass to get class property
		Tango::DbDatum	def_prop, cl_prop;
		DishManagerClass	*ds_class =
			(static_cast<DishManagerClass *>(get_device_class()));
		int	i = -1;

		//	Try to initialize StorageLoggerEnabledDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  storageLoggerEnabledDefault;
		else {
			//	Try to initialize StorageLoggerEnabledDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  storageLoggerEnabledDefault;
		}
		//	And try to extract StorageLoggerEnabledDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  storageLoggerEnabledDefault;

		//	Try to initialize SyslogFacility from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  syslogFacility;
		else {
			//	Try to initialize SyslogFacility from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  syslogFacility;
		}
		//	And try to extract SyslogFacility value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  syslogFacility;

		//	Try to initialize SkaLevel from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  skaLevel;
		else {
			//	Try to initialize SkaLevel from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  skaLevel;
		}
		//	And try to extract SkaLevel value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  skaLevel;

		//	Try to initialize LoggingLevelCentralDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingLevelCentralDefault;
		else {
			//	Try to initialize LoggingLevelCentralDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingLevelCentralDefault;
		}
		//	And try to extract LoggingLevelCentralDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingLevelCentralDefault;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize LoggingLevelElementDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingLevelElementDefault;
		else {
			//	Try to initialize LoggingLevelElementDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingLevelElementDefault;
		}
		//	And try to extract LoggingLevelElementDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingLevelElementDefault;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize LoggingLevelStorageDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingLevelStorageDefault;
		else {
			//	Try to initialize LoggingLevelStorageDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingLevelStorageDefault;
		}
		//	And try to extract LoggingLevelStorageDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingLevelStorageDefault;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize LoggingTargetCentralDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingTargetCentralDefault;
		else {
			//	Try to initialize LoggingTargetCentralDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingTargetCentralDefault;
		}
		//	And try to extract LoggingTargetCentralDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingTargetCentralDefault;

		//	Try to initialize LoggingTargetElementDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingTargetElementDefault;
		else {
			//	Try to initialize LoggingTargetElementDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingTargetElementDefault;
		}
		//	And try to extract LoggingTargetElementDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingTargetElementDefault;

		//	Try to initialize LoggingTargetStorageDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingTargetStorageDefault;
		else {
			//	Try to initialize LoggingTargetStorageDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingTargetStorageDefault;
		}
		//	And try to extract LoggingTargetStorageDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingTargetStorageDefault;

		//	Try to initialize ElementLoggerEnabledDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  elementLoggerEnabledDefault;
		else {
			//	Try to initialize ElementLoggerEnabledDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  elementLoggerEnabledDefault;
		}
		//	And try to extract ElementLoggerEnabledDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  elementLoggerEnabledDefault;

		//	Try to initialize CentralLoggerEnabledDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  centralLoggerEnabledDefault;
		else {
			//	Try to initialize CentralLoggerEnabledDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  centralLoggerEnabledDefault;
		}
		//	And try to extract CentralLoggerEnabledDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  centralLoggerEnabledDefault;

		//	Try to initialize SyslogHost from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  syslogHost;
		else {
			//	Try to initialize SyslogHost from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  syslogHost;
		}
		//	And try to extract SyslogHost value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  syslogHost;

		//	Try to initialize ConfigFile from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  configFile;
		else {
			//	Try to initialize ConfigFile from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  configFile;
		}
		//	And try to extract ConfigFile value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  configFile;

		//	Try to initialize EnableConfigFromFile from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableConfigFromFile;
		else {
			//	Try to initialize EnableConfigFromFile from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableConfigFromFile;
		}
		//	And try to extract EnableConfigFromFile value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableConfigFromFile;

		//	Try to initialize EnableDynAttrCleanup from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableDynAttrCleanup;
		else {
			//	Try to initialize EnableDynAttrCleanup from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableDynAttrCleanup;
		}
		//	And try to extract EnableDynAttrCleanup value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableDynAttrCleanup;

		//	Try to initialize EnableDynAttrRandomize from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableDynAttrRandomize;
		else {
			//	Try to initialize EnableDynAttrRandomize from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableDynAttrRandomize;
		}
		//	And try to extract EnableDynAttrRandomize value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableDynAttrRandomize;

		//	Try to initialize DynAttrRandomizePeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  dynAttrRandomizePeriod;
		else {
			//	Try to initialize DynAttrRandomizePeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  dynAttrRandomizePeriod;
		}
		//	And try to extract DynAttrRandomizePeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  dynAttrRandomizePeriod;

		//	Try to initialize ProxyDevices from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyDevices;
		else {
			//	Try to initialize ProxyDevices from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyDevices;
		}
		//	And try to extract ProxyDevices value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyDevices;

		//	Try to initialize FormulaVarMaxTimeInterval from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  formulaVarMaxTimeInterval;
		else {
			//	Try to initialize FormulaVarMaxTimeInterval from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  formulaVarMaxTimeInterval;
		}
		//	And try to extract FormulaVarMaxTimeInterval value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  formulaVarMaxTimeInterval;

		//	Try to initialize EnableProxyMonitoring from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableProxyMonitoring;
		else {
			//	Try to initialize EnableProxyMonitoring from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableProxyMonitoring;
		}
		//	And try to extract EnableProxyMonitoring value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableProxyMonitoring;

		//	Try to initialize ProxyMonitoringPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyMonitoringPeriod;
		else {
			//	Try to initialize ProxyMonitoringPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyMonitoringPeriod;
		}
		//	And try to extract ProxyMonitoringPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyMonitoringPeriod;

		//	Try to initialize ProxyStatusAttrPollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyStatusAttrPollPeriod;
		else {
			//	Try to initialize ProxyStatusAttrPollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyStatusAttrPollPeriod;
		}
		//	And try to extract ProxyStatusAttrPollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyStatusAttrPollPeriod;

		//	Try to initialize ProxyStatusAttrPeriodicEventPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyStatusAttrPeriodicEventPeriod;
		else {
			//	Try to initialize ProxyStatusAttrPeriodicEventPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyStatusAttrPeriodicEventPeriod;
		}
		//	And try to extract ProxyStatusAttrPeriodicEventPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyStatusAttrPeriodicEventPeriod;

		//	Try to initialize ProxyStatusAttrArchiveEventPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyStatusAttrArchiveEventPeriod;
		else {
			//	Try to initialize ProxyStatusAttrArchiveEventPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyStatusAttrArchiveEventPeriod;
		}
		//	And try to extract ProxyStatusAttrArchiveEventPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyStatusAttrArchiveEventPeriod;

		//	Try to initialize ProxyTimeout from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyTimeout;
		else {
			//	Try to initialize ProxyTimeout from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyTimeout;
		}
		//	And try to extract ProxyTimeout value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyTimeout;

		//	Try to initialize EventSubscriptions from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  eventSubscriptions;
		else {
			//	Try to initialize EventSubscriptions from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  eventSubscriptions;
		}
		//	And try to extract EventSubscriptions value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  eventSubscriptions;

		//	Try to initialize EventHandlers from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  eventHandlers;
		else {
			//	Try to initialize EventHandlers from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  eventHandlers;
		}
		//	And try to extract EventHandlers value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  eventHandlers;

		//	Try to initialize EnableEventRateMonitoring from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableEventRateMonitoring;
		else {
			//	Try to initialize EnableEventRateMonitoring from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableEventRateMonitoring;
		}
		//	And try to extract EnableEventRateMonitoring value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableEventRateMonitoring;

		//	Try to initialize MaxQueueableTask from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  maxQueueableTask;
		else {
			//	Try to initialize MaxQueueableTask from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  maxQueueableTask;
		}
		//	And try to extract MaxQueueableTask value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  maxQueueableTask;

		//	Try to initialize MaxTrackableTasks from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  maxTrackableTasks;
		else {
			//	Try to initialize MaxTrackableTasks from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  maxTrackableTasks;
		}
		//	And try to extract MaxTrackableTasks value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  maxTrackableTasks;

		//	Try to initialize TaskHistoryTimeDepth from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  taskHistoryTimeDepth;
		else {
			//	Try to initialize TaskHistoryTimeDepth from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  taskHistoryTimeDepth;
		}
		//	And try to extract TaskHistoryTimeDepth value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  taskHistoryTimeDepth;

		//	Try to initialize DefaultTaskTimeout from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  defaultTaskTimeout;
		else {
			//	Try to initialize DefaultTaskTimeout from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  defaultTaskTimeout;
		}
		//	And try to extract DefaultTaskTimeout value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  defaultTaskTimeout;

		//	Try to initialize TaskStatusAttrList from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  taskStatusAttrList;
		else {
			//	Try to initialize TaskStatusAttrList from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  taskStatusAttrList;
		}
		//	And try to extract TaskStatusAttrList value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  taskStatusAttrList;

		//	Try to initialize TaskSequenceStatusAttrList from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  taskSequenceStatusAttrList;
		else {
			//	Try to initialize TaskSequenceStatusAttrList from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  taskSequenceStatusAttrList;
		}
		//	And try to extract TaskSequenceStatusAttrList value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  taskSequenceStatusAttrList;

		//	Try to initialize EnableLoggerInitPolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableLoggerInitPolling;
		else {
			//	Try to initialize EnableLoggerInitPolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableLoggerInitPolling;
		}
		//	And try to extract EnableLoggerInitPolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableLoggerInitPolling;

		//	Try to initialize LoggerInitPollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggerInitPollPeriod;
		else {
			//	Try to initialize LoggerInitPollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggerInitPollPeriod;
		}
		//	And try to extract LoggerInitPollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggerInitPollPeriod;

		//	Try to initialize EnableDevProxyInitPolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableDevProxyInitPolling;
		else {
			//	Try to initialize EnableDevProxyInitPolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableDevProxyInitPolling;
		}
		//	And try to extract EnableDevProxyInitPolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableDevProxyInitPolling;

		//	Try to initialize DevProxyInitPollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  devProxyInitPollPeriod;
		else {
			//	Try to initialize DevProxyInitPollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  devProxyInitPollPeriod;
		}
		//	And try to extract DevProxyInitPollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  devProxyInitPollPeriod;

		//	Try to initialize EnableFwdAttrInitPolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableFwdAttrInitPolling;
		else {
			//	Try to initialize EnableFwdAttrInitPolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableFwdAttrInitPolling;
		}
		//	And try to extract EnableFwdAttrInitPolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableFwdAttrInitPolling;

		//	Try to initialize FwdAttrInitPollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  fwdAttrInitPollPeriod;
		else {
			//	Try to initialize FwdAttrInitPollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  fwdAttrInitPollPeriod;
		}
		//	And try to extract FwdAttrInitPollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  fwdAttrInitPollPeriod;

		//	Try to initialize EnableFormulaAttrUpdatePolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableFormulaAttrUpdatePolling;
		else {
			//	Try to initialize EnableFormulaAttrUpdatePolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableFormulaAttrUpdatePolling;
		}
		//	And try to extract EnableFormulaAttrUpdatePolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableFormulaAttrUpdatePolling;

		//	Try to initialize FormulaAttrUpdatePollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  formulaAttrUpdatePollPeriod;
		else {
			//	Try to initialize FormulaAttrUpdatePollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  formulaAttrUpdatePollPeriod;
		}
		//	And try to extract FormulaAttrUpdatePollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  formulaAttrUpdatePollPeriod;

		//	Try to initialize EnableStatusAttrUpdatePolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableStatusAttrUpdatePolling;
		else {
			//	Try to initialize EnableStatusAttrUpdatePolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableStatusAttrUpdatePolling;
		}
		//	And try to extract EnableStatusAttrUpdatePolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableStatusAttrUpdatePolling;

		//	Try to initialize StatusAttrUpdatePollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  statusAttrUpdatePollPeriod;
		else {
			//	Try to initialize StatusAttrUpdatePollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  statusAttrUpdatePollPeriod;
		}
		//	And try to extract StatusAttrUpdatePollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  statusAttrUpdatePollPeriod;

		//	Try to initialize EnableClearTaskPolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableClearTaskPolling;
		else {
			//	Try to initialize EnableClearTaskPolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableClearTaskPolling;
		}
		//	And try to extract EnableClearTaskPolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableClearTaskPolling;

		//	Try to initialize ClearTaskPollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  clearTaskPollPeriod;
		else {
			//	Try to initialize ClearTaskPollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  clearTaskPollPeriod;
		}
		//	And try to extract ClearTaskPollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  clearTaskPollPeriod;

		//	Try to initialize EnableProxyStatusAttrCreation from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableProxyStatusAttrCreation;
		else {
			//	Try to initialize EnableProxyStatusAttrCreation from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableProxyStatusAttrCreation;
		}
		//	And try to extract EnableProxyStatusAttrCreation value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableProxyStatusAttrCreation;

		//	Try to initialize EnableAutoAdminProxyRegistration from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableAutoAdminProxyRegistration;
		else {
			//	Try to initialize EnableAutoAdminProxyRegistration from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableAutoAdminProxyRegistration;
		}
		//	And try to extract EnableAutoAdminProxyRegistration value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableAutoAdminProxyRegistration;

		//	Try to initialize ProcessEventsInQueueThread from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  processEventsInQueueThread;
		else {
			//	Try to initialize ProcessEventsInQueueThread from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  processEventsInQueueThread;
		}
		//	And try to extract ProcessEventsInQueueThread value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  processEventsInQueueThread;

		//	Try to initialize ElementLoggerAddress from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  elementLoggerAddress;
		else {
			//	Try to initialize ElementLoggerAddress from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  elementLoggerAddress;
		}
		//	And try to extract ElementLoggerAddress value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  elementLoggerAddress;

		//	Try to initialize ElementAlarmsAddress from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  elementAlarmsAddress;
		else {
			//	Try to initialize ElementAlarmsAddress from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  elementAlarmsAddress;
		}
		//	And try to extract ElementAlarmsAddress value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  elementAlarmsAddress;

		//	Try to initialize ElementTelModelAddress from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  elementTelModelAddress;
		else {
			//	Try to initialize ElementTelModelAddress from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  elementTelModelAddress;
		}
		//	And try to extract ElementTelModelAddress value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  elementTelModelAddress;

		//	Try to initialize ElementDatabaseDSAddress from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  elementDatabaseDSAddress;
		else {
			//	Try to initialize ElementDatabaseDSAddress from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  elementDatabaseDSAddress;
		}
		//	And try to extract ElementDatabaseDSAddress value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  elementDatabaseDSAddress;

		//	Try to initialize AdminModeDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  adminModeDefault;
		else {
			//	Try to initialize AdminModeDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  adminModeDefault;
		}
		//	And try to extract AdminModeDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  adminModeDefault;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize AsynchCmdReplyTimeout from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  asynchCmdReplyTimeout;
		else {
			//	Try to initialize AsynchCmdReplyTimeout from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  asynchCmdReplyTimeout;
		}
		//	And try to extract AsynchCmdReplyTimeout value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  asynchCmdReplyTimeout;

		//	Try to initialize AsynchCmdReplyNRetries from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  asynchCmdReplyNRetries;
		else {
			//	Try to initialize AsynchCmdReplyNRetries from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  asynchCmdReplyNRetries;
		}
		//	And try to extract AsynchCmdReplyNRetries value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  asynchCmdReplyNRetries;

		//	Try to initialize ConfigureMonitoringPollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  configureMonitoringPollPeriod;
		else {
			//	Try to initialize ConfigureMonitoringPollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  configureMonitoringPollPeriod;
		}
		//	And try to extract ConfigureMonitoringPollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  configureMonitoringPollPeriod;

		//	Try to initialize ConfigureMonitoringTimeout from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  configureMonitoringTimeout;
		else {
			//	Try to initialize ConfigureMonitoringTimeout from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  configureMonitoringTimeout;
		}
		//	And try to extract ConfigureMonitoringTimeout value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  configureMonitoringTimeout;

		//	Try to initialize SynchCmdReplyTimeout from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  synchCmdReplyTimeout;
		else {
			//	Try to initialize SynchCmdReplyTimeout from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  synchCmdReplyTimeout;
		}
		//	And try to extract SynchCmdReplyTimeout value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  synchCmdReplyTimeout;

		//	Try to initialize StowTaskTimeout from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  stowTaskTimeout;
		else {
			//	Try to initialize StowTaskTimeout from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  stowTaskTimeout;
		}
		//	And try to extract StowTaskTimeout value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  stowTaskTimeout;

		//	Try to initialize ConfigureTaskTimeout from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  configureTaskTimeout;
		else {
			//	Try to initialize ConfigureTaskTimeout from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  configureTaskTimeout;
		}
		//	And try to extract ConfigureTaskTimeout value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  configureTaskTimeout;

		//	Try to initialize OperateTaskTimeout from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  operateTaskTimeout;
		else {
			//	Try to initialize OperateTaskTimeout from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  operateTaskTimeout;
		}
		//	And try to extract OperateTaskTimeout value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  operateTaskTimeout;

		//	Try to initialize ShutdownTaskTimeout from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  shutdownTaskTimeout;
		else {
			//	Try to initialize ShutdownTaskTimeout from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  shutdownTaskTimeout;
		}
		//	And try to extract ShutdownTaskTimeout value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  shutdownTaskTimeout;

		//	Try to initialize RxShutdownTimeDelay from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  rxShutdownTimeDelay;
		else {
			//	Try to initialize RxShutdownTimeDelay from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  rxShutdownTimeDelay;
		}
		//	And try to extract RxShutdownTimeDelay value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  rxShutdownTimeDelay;

		//	Try to initialize StandbyFPTaskTimeout from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  standbyFPTaskTimeout;
		else {
			//	Try to initialize StandbyFPTaskTimeout from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  standbyFPTaskTimeout;
		}
		//	And try to extract StandbyFPTaskTimeout value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  standbyFPTaskTimeout;

		//	Try to initialize SPFStartupTimeout from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  sPFStartupTimeout;
		else {
			//	Try to initialize SPFStartupTimeout from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  sPFStartupTimeout;
		}
		//	And try to extract SPFStartupTimeout value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  sPFStartupTimeout;

		//	Try to initialize RxControllerAddress from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  rxControllerAddress;
		else {
			//	Try to initialize RxControllerAddress from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  rxControllerAddress;
		}
		//	And try to extract RxControllerAddress value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  rxControllerAddress;

		//	Try to initialize SpfControllerAddress from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  spfControllerAddress;
		else {
			//	Try to initialize SpfControllerAddress from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  spfControllerAddress;
		}
		//	And try to extract SpfControllerAddress value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  spfControllerAddress;

		//	Try to initialize DsManagerAddress from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  dsManagerAddress;
		else {
			//	Try to initialize DsManagerAddress from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  dsManagerAddress;
		}
		//	And try to extract DsManagerAddress value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  dsManagerAddress;

		//	Try to initialize ControlModeDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  controlModeDefault;
		else {
			//	Try to initialize ControlModeDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  controlModeDefault;
		}
		//	And try to extract ControlModeDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  controlModeDefault;

		//	Try to initialize RequestedBandDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  requestedBandDefault;
		else {
			//	Try to initialize RequestedBandDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  requestedBandDefault;
		}
		//	And try to extract RequestedBandDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  requestedBandDefault;

		//	Try to initialize TmProxyAddressDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  tmProxyAddressDefault;
		else {
			//	Try to initialize TmProxyAddressDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  tmProxyAddressDefault;
		}
		//	And try to extract TmProxyAddressDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  tmProxyAddressDefault;

		//	Try to initialize PduManagerAddress from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  pduManagerAddress;
		else {
			//	Try to initialize PduManagerAddress from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  pduManagerAddress;
		}
		//	And try to extract PduManagerAddress value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  pduManagerAddress;

	}

	/*----- PROTECTED REGION ID(DishManager::get_device_property_after) ENABLED START -----*/
	
	//	Check device property data members init
	
	/*----- PROTECTED REGION END -----*/	//	DishManager::get_device_property_after
}
//--------------------------------------------------------
/**
 *	Method      : DishManager::check_mandatory_property()
 *	Description : For mandatory properties check if defined in database.
 */
//--------------------------------------------------------
void DishManager::check_mandatory_property(Tango::DbDatum &class_prop, Tango::DbDatum &dev_prop)
{
	//	Check if all properties are empty
	if (class_prop.is_empty() && dev_prop.is_empty())
	{
		TangoSys_OMemStream	tms;
		tms << endl <<"Property \'" << dev_prop.name;
		if (Tango::Util::instance()->_UseDb==true)
			tms << "\' is mandatory but not defined in database";
		else
			tms << "\' is mandatory but cannot be defined without database";
		string	status(get_status());
		status += tms.str();
		set_status(status);
		mandatoryNotDefined = true;
		/*----- PROTECTED REGION ID(DishManager::check_mandatory_property) ENABLED START -----*/
		cerr << tms.str() << " for " << device_name << endl;
		
		/*----- PROTECTED REGION END -----*/	//	DishManager::check_mandatory_property
	}
}


//--------------------------------------------------------
/**
 *	Method      : DishManager::always_executed_hook()
 *	Description : method always executed before any command is executed
 */
//--------------------------------------------------------
void DishManager::always_executed_hook()
{
	DEBUG_STREAM << "DishManager::always_executed_hook()  " << device_name << endl;
	if (mandatoryNotDefined)
	{
		string	status(get_status());
		Tango::Except::throw_exception(
					(const char *)"PROPERTY_NOT_SET",
					status.c_str(),
					(const char *)"DishManager::always_executed_hook()");
	}
	/*----- PROTECTED REGION ID(DishManager::always_executed_hook) ENABLED START -----*/
	
	//	code always executed before all requests
	
	/*----- PROTECTED REGION END -----*/	//	DishManager::always_executed_hook
}

//--------------------------------------------------------
/**
 *	Method      : DishManager::read_attr_hardware()
 *	Description : Hardware acquisition for attributes
 */
//--------------------------------------------------------
void DishManager::read_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "DishManager::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(DishManager::read_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	DishManager::read_attr_hardware
}
//--------------------------------------------------------
/**
 *	Method      : DishManager::write_attr_hardware()
 *	Description : Hardware writing for attributes
 */
//--------------------------------------------------------
void DishManager::write_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "DishManager::write_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(DishManager::write_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	DishManager::write_attr_hardware
}


//--------------------------------------------------------
/**
 *	Method      : DishManager::add_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *                for specified device.
 */
//--------------------------------------------------------
void DishManager::add_dynamic_attributes()
{
	/*----- PROTECTED REGION ID(DishManager::add_dynamic_attributes) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic attributes if any
	LMCDevice::add_dynamic_attributes();

	/*
	//Add dynamic attributes from config file
	if(AddDynAttrs()<0){
		std::string errMsg("Failed to create dyn attributes!");
		_ERROR_LOG(errMsg);
		set_status(errMsg.c_str());
		set_state(Tango::FAULT);
		return;
	}
	
	//Configure state machine for cmd & attrs
	if(InitCmdAttrStateMachine()<0){
		std::string errMsg("Failed to create cmd & attr state machines for dyn attributes!");
		_ERROR_LOG(errMsg);
		set_status(errMsg.c_str());
		set_state(Tango::FAULT);
		return;
	}
	*/
	/*----- PROTECTED REGION END -----*/	//	DishManager::add_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Command SetStandbyLPMode related method
 *	Description: This command triggers the Dish to transition to the 
 *               STANDBY-LP Dish Element Mode, and returns to the caller. 
 *               Standby_LP is the default mode when the Dish is 
 *               configured for low power consumption, and is the mode 
 *               wherein Dish ends after a start up procedure.
 *
 *	@returns 
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *DishManager::set_standby_lpmode()
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "DishManager::SetStandbyLPMode()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::set_standby_lpmode) ENABLED START -----*/
	
	//	Add your own code
	// == COMMAND BEHAVIOR ==
	// 1) Check if cmd mode-allowed: Always allowed (see ICD)
	// 2) Call 'SetStandbyLPMode(STANDBY-LP)' command in all sub-elements device 
	// 3) Some sub-element will take time to complete the above command, so need to listen for task completion

	//Issue to be clarified: If commands fail on 1 or more sub-element, what to do?
	//Restore previous mode in each sub-element or not (but ensure that dish mode don't go to FORBIDDEN state)?
	
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string cmd_name= "SetStandbyLPMode";
	std::string mode_attr_name= "dishMode";
	std::string mode_str= "STANDBY-LP"; 

	//Task vars	
	std::vector<std::string> taskSequenceStartedMsg {"IDLE","Set dish to STANDBY-LP mode scheduled"};
	std::vector<std::string> taskAlreadyCompletedMsg {"COMPLETED","Dish is already in STANDBY-LP mode"};	 
	std::vector<std::string> taskSequence_progress_ongoing= {"INIT","IDLE","RUNNING"};

	std::string taskSequence_name= "SetStandbyLPMode";
	std::string taskSequence_progress_attr_name= "setStandbyLPModeProgress";

	//- Rx task
	std::string rx_task_name= "SetRxStandbyLPModeTask";
	
	//- SPF tasks
	std::string spf_task_name= "SetSPFStandbyLPModeTask";	
	//std::string spf_task_name= "SetSPFStandbyLPMode";
	std::string spf_task_progress_attr_name= "spfSetStandbyLPModeProgress";

	//- DS tasks
	std::string ds_task_name= "SetDSStandbyLPModeTask";	
	//std::string ds_task_name= "SetDSStandbyLPMode";
	std::string ds_task_progress_attr_name= "dsSetStandbyLPModeProgress";
	//===========================================================================
	

	//=====================================================
	//==         CHECK IF CMD ALLOWED
	//=====================================================
	_DEBUG_LOG("Check if cmd "<<__FUNCTION__<<" is allowed...");
	bool check_cmd= true;
	try {
		IsCmdAllowed(__FUNCTION__,check_cmd);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		throw;
	}

	//=====================================================
	//==         CHECK IF TASK IS ALREADY RUNNING
	//=====================================================
	_DEBUG_LOG("Check if a previous SetStandbyLPMode task is already running...");
	std::vector<std::string> taskProgress;
	if(GetDynAttrValue(taskProgress,taskSequence_progress_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<taskSequence_progress_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STANDBY_LP_MODE_FAILED",ss.str());	
	}
	if(taskProgress.size()<2){
		std::stringstream ss;
		ss<<"Invalid size for attr "<<taskSequence_progress_attr_name<<" value (expected at least equal to 2)!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STANDBY_LP_MODE_FAILED",ss.str());	
	}
	std::string taskProgressStr= taskProgress[0];
	
	//Check if another task is already running
	bool isTaskRunning= false;
	for(size_t i=0;i<taskSequence_progress_ongoing.size();i++){
		if(taskProgressStr==taskSequence_progress_ongoing[i]){
			isTaskRunning= true;
			break;
		}
	}//end loop config busy codes

	if(isTaskRunning) {
		std::stringstream ss;
		ss<<"Another set STANDBY-LP mode task is running or pending for execution (hint: you must wait for completion before requesting a new task)";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STANDBY_LP_MODE_FAILED",ss.str());
	}

	//=====================================================
	//==      CHECK CURRENT MODE
	//=====================================================
	//Retrieve mode value corresponding to label
	Tango::DevShort mode;
	Utils_ns::TangoUtils::GetEnumAttrValue(mode,this,mode_attr_name,mode_str);

	//Get current mode
	Tango::DevShort mode_current;	
	if(GetDynAttrValue(mode_current,mode_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<mode_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STANDBY_LP_MODE_FAILED",ss.str());	
	}	

	//Check if dish STANDBY-LP mode is already active	
	if(mode==mode_current){
		_INFO_LOG("Mode "<<mode_str<<" already active, nothing to be done");
		
		//Set task progress attr
		if(SetDynAttrValue(taskAlreadyCompletedMsg,taskSequence_progress_attr_name)<0){
			std::stringstream ss;
			ss<<"Failed to set attr "<<taskSequence_progress_attr_name<<" value!";
			_ERROR_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("SET_STANDBY_LP_MODE_FAILED",ss.str());	
		}	

		//Return already scheduled ack
		argout= new Tango::DevVarLongStringArray;
		argout->svalue.length(1);
		argout->lvalue.length(1);
		argout->svalue[0] = CORBA::string_dup(taskAlreadyCompletedMsg[1].c_str());	
		argout->lvalue[0] = 0;

		return argout;
	}
	
	//=====================================================
	//==      PREPARE TASKS DATA
	//=====================================================
	
	//Prepare task data
	bool useUTC= false;
	int priority= Utils_ns::Task::eMEDIUM_PRIORITY;

	//#### SPF TASKS ###### 
	//- Task (asynch): SPF SetStandbyLPMode
	Utils_ns::TaskPtr spf_task= std::make_shared<Utils_ns::Task>(this,spf_task_name,priority,useUTC);
	spf_task->SetMaxDuration(defaultTaskTimeout*1000.);//Set task timeout
	spf_task->SetAsynchTask(spf_task_progress_attr_name);//Set asynch task attr status
	
	//#### DS TASKS ###### 
	//- Task (asynch): DS SetStandbyLPMode
	Utils_ns::TaskPtr ds_task= std::make_shared<Utils_ns::Task>(this,ds_task_name,priority,useUTC);
	ds_task->SetMaxDuration(defaultTaskTimeout*1000.);//Set task timeout
	ds_task->SetAsynchTask(ds_task_progress_attr_name);//Set asynch task attr status
	
	//#### Rx TASK ###### 
	//- Task (synch): Rx SetStandbyLPMode
	Utils_ns::TaskPtr rx_task= std::make_shared<Utils_ns::Task>(this,rx_task_name,priority,useUTC);
	rx_task->SetMaxDuration(defaultTaskTimeout*1000.);//Set task timeout
	
	//## Add tasks to sequence
	std::vector<Utils_ns::TaskPtr> tasks;
	tasks.push_back(spf_task);
	tasks.push_back(ds_task);
	tasks.push_back(rx_task);
	
	Utils_ns::TaskSequencePtr taskSequence= std::make_shared<Utils_ns::TaskSequence>(this,taskSequence_name,useUTC);
	taskSequence->SetDevStatusAttr(taskSequence_progress_attr_name);//Set device attr containing task sequence status

	for(size_t i=0;i<tasks.size();i++){
		if(taskSequence->AddTask(tasks[i])<0){
			std::stringstream ss;
			ss<<"Failed to add task "<<i+1<<" (name="<<tasks[i]->cmd_name<<") to sequence!";
			_WARN_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("SET_STANDBY_LP_MODE_FAILED",ss.str());			
		}
	}//end loop tasks


	//=====================================================
	//==      SCHEDULE TASKS
	//=====================================================
	
	//Add task to queue 
	bool addToQueue= true;
	if(m_taskManager->AddTaskSequence(taskSequence,addToQueue)<0){
		std::stringstream ss;
		ss<<"Failed to add task sequence "<<taskSequence_name<<" to queue!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STANDBY_LP_MODE_FAILED",ss.str());
	}
	_INFO_LOG("Added sequence "<<taskSequence_name<<" to task queue...");
	

	/*
	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	//Check if proxy is registered in list
	std::vector<std::string> full_proxy_names= {spfControllerAddress,rxControllerAddress,dsManagerAddress};
	for(size_t i=0;i<full_proxy_names.size();i++){
		if( !m_proxyManager->FindProxy(full_proxy_names[i]) ){
			_WARN_LOG("Proxy "<<full_proxy_names[i]<<" not found in registered proxy list, trying with alias name...");
		
			//Get full proxy name corresponding to alias
			std::string full_proxy_name= "";
			if(Utils_ns::TangoUtils::GetFQDNDeviceNameFromAlias(full_proxy_name,full_proxy_names[i])<0){
				std::stringstream ss;
				ss<<"Failed to retrieve full proxy name from alias "<<full_proxy_names[i]<<"!";
				_WARN_LOG(ss.str());
				_THROW_TANGO_EXCEPTION("SET_STANDBY_LP_MODE_FAILED",ss.str());	
			}
			full_proxy_names[i]= full_proxy_name;
		}
	}//end loop proxy names

	//Now execute command asynchronously and collect responses
	std::vector<Tango::DeviceData> dout;
	int reply_timeout= asynchCmdReplyTimeout;//ms
	int nretries= asynchCmdReplyNRetries;
	try { 
		m_proxyManager->ExecuteGroupCommandsAsynch(dout,full_proxy_names,cmd_name,reply_timeout,nretries);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		std::stringstream ss;
		ss<<"Tango exception occurred while executing command "<<cmd_name<<" on proxies (check proxy registered/syntax/proxy online)!";
		_WARN_LOG(ss.str());
		throw;
	}
	catch(std::exception& e){
		std::stringstream ss;
		ss<<"C++ exception occurred while executing command "<<cmd_name<<" on proxies (err="<<e.what()<<")!";
		_WARN_LOG(ss.str());
		throw;
	}
	catch(...){
		std::stringstream ss;
		ss<<"Unknown exception occurred while executing command "<<cmd_name<<" on proxies!";
		_WARN_LOG(ss.str());
		throw;
	}

	
	//Add task sequence to queue 
	//NB: Task sequence was already executed on device proxy, so add it only to the list of monitored tasks
	bool addToQueue= false;
	if(m_taskManager->AddTaskSequence(taskSequence,addToQueue)<0){
		std::stringstream ss;
		ss<<"Failed to add task sequence "<<taskSequence_name<<" to list!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STANDBY_LP_MODE_FAILED",ss.str());
	}
	_INFO_LOG("Task sequence "<<taskSequence_name<<" was executed and added to the monitored task sequence list...");
	*/
	
	//Set task progress attr to IDLE
	if(SetDynAttrValue(taskSequenceStartedMsg,taskSequence_progress_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<taskSequence_progress_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STANDBY_LP_MODE_FAILED",ss.str());	
	}	

	//Set output argument
	argout= new Tango::DevVarLongStringArray;
	argout->svalue.length(1);
	argout->lvalue.length(1);
	argout->svalue[0] = CORBA::string_dup("Set STANDBY-LP mode task scheduled");	
	argout->lvalue[0] = 1;
	

	/*----- PROTECTED REGION END -----*/	//	DishManager::set_standby_lpmode
	return argout;
}
//--------------------------------------------------------
/**
 *	Command SetStandbyFPMode related method
 *	Description: This command triggers the Dish to transition to the 
 *               STANDBY-FP Dish Element Mode, and returns to the caller.
 *               To prepare all subsystems for active observation, once 
 *               a command is received by TM to go to the FULL_POWER 
 *               mode.
 *               
 *               Command allowed only in DIsh modes:
 *               {STANDBY-LP/STOW/OPERATE/MAINTENANCE}
 *
 *	@returns 
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *DishManager::set_standby_fpmode()
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "DishManager::SetStandbyFPMode()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::set_standby_fpmode) ENABLED START -----*/
	
	//	Add your own code
	// == COMMAND BEHAVIOR ==
	// See State & Modes requirement 
	// 1) Check if cmd mode-allowed: {STANDBY-LP/STOW/OPERATE/MAINTENANCE} (see ICD)
	// 2) Call 'SetStandbyFPMode()' command in DS 
	// 3) Call 'SetStandbyFPMode()' command in Rx (this will automatically start data capture on latest selected band)
	// 4) Call 'SetOperateMode' command in SPF (this lasts a lot)

	//Issue to be clarified: If commands fail on 1 or more sub-element, what to do?
	//Restore previous mode in each sub-element or not (but ensure that dish mode don't go to FORBIDDEN state)?
	
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::vector<std::string> cmd_names {"SetOperateMode","SetStandbyFPMode","SetStandbyFPMode"};
	std::vector<std::string> cmd_argins{"OPERATE","STANDBY-FP","STANDBY-FP"};
	std::string mode_attr_name= "dishMode";
	std::string mode_str= "STANDBY-FP"; 

	//Task vars
	std::vector<std::string> taskSequenceStartedMsg {"IDLE","Set dish to STANDBY-FP mode scheduled"};
	std::vector<std::string> taskAlreadyCompletedMsg {"COMPLETED","Dish is already in STANDBY-FP mode"};
	std::vector<std::string> taskSequence_progress_ongoing= {"INIT","IDLE","RUNNING"};

	std::string taskSequence_name= "SetStandbyFPMode";
	std::string taskSequence_progress_attr_name= "setStandbyFPModeProgress";
	
	//- Rx tasks
	std::string rx_task_name= "SetRxStandbyFPModeTask";

	//- SPF tasks
	std::string spf_task_name= "SetSPFOperateModeTask";
	std::string spf_task_progress_attr_name= "spfSetOperateModeProgress";

	//- DS tasks
	std::string ds_task_name= "SetDSStandbyFPModeTask";
	std::string ds_task_progress_attr_name= "dsSetStandbyFPModeProgress";
	//===========================================================================
	

	//=====================================================
	//==         CHECK IF CMD ALLOWED
	//=====================================================
	_DEBUG_LOG("Check if cmd "<<__FUNCTION__<<" is allowed...");
	bool check_cmd= true;
	try {
		IsCmdAllowed(__FUNCTION__,check_cmd);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		throw;
	}

	//=====================================================
	//==         CHECK IF TASK IS ALREADY RUNNING
	//=====================================================
	_DEBUG_LOG("Check if a previous SetStandbyFPMode task is already running...");
	std::vector<std::string> taskProgress;
	if(GetDynAttrValue(taskProgress,taskSequence_progress_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<taskSequence_progress_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STANDBY_FP_MODE_FAILED",ss.str());	
	}
	if(taskProgress.size()<2){
		std::stringstream ss;
		ss<<"Invalid size for attr "<<taskSequence_progress_attr_name<<" value (expected at least equal to 2)!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STANDBY_FP_MODE_FAILED",ss.str());	
	}

	std::string taskProgressStr= taskProgress[0];
	
	//Check if another task is already running
	bool isTaskRunning= false;
	for(size_t i=0;i<taskSequence_progress_ongoing.size();i++){
		if(taskProgressStr==taskSequence_progress_ongoing[i]){
			isTaskRunning= true;
			break;
		}
	}//end loop config busy codes

	if(isTaskRunning) {
		std::stringstream ss;
		ss<<"Another set STANDBY-FP mode task is running or pending for execution (hint: you must wait for completion before requesting a new task)";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STANDBY_FP_MODE_FAILED",ss.str());
	}


	//=====================================================
	//==      CHECK CURRENT MODE
	//=====================================================
	//Retrieve mode value corresponding to label
	Tango::DevShort mode;
	Utils_ns::TangoUtils::GetEnumAttrValue(mode,this,mode_attr_name,mode_str);

	//Get current mode
	Tango::DevShort mode_current;	
	if(GetDynAttrValue(mode_current,mode_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<mode_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STANDBY_LP_MODE_FAILED",ss.str());	
	}	

	//Check if STANDBY-FP mode is already active	
	if(mode==mode_current){
		_INFO_LOG("Mode "<<mode_str<<" already active, nothing to be done");

		//Set task progress attr
		if(SetDynAttrValue(taskAlreadyCompletedMsg,taskSequence_progress_attr_name)<0){
			std::stringstream ss;
			ss<<"Failed to set attr "<<taskSequence_progress_attr_name<<" value!";
			_ERROR_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("SET_STANDBY_FP_MODE_FAILED",ss.str());	
		}	

		//Return already scheduled ack
		argout= new Tango::DevVarLongStringArray;
		argout->svalue.length(1);
		argout->lvalue.length(1);
		argout->svalue[0] = CORBA::string_dup(taskAlreadyCompletedMsg[1].c_str());	
		argout->lvalue[0] = 0;

		return argout;
	}

	//=====================================================
	//==      PREPARE TASKS DATA
	//=====================================================
	
	//Prepare task data
	bool useUTC= false;
	int priority= Utils_ns::Task::eMEDIUM_PRIORITY;

	//#### SPF TASKS ###### 
	//- Task (asynch): SPF SetOperateMode
	Utils_ns::TaskPtr spf_task= std::make_shared<Utils_ns::Task>(this,spf_task_name,priority,useUTC);
	spf_task->SetMaxDuration(defaultTaskTimeout*1000.);//Set task timeout
	spf_task->SetAsynchTask(spf_task_progress_attr_name);//Set asynch task attr status
	
	//#### DS TASKS ###### 
	//- Task (asynch): DS SetStandbyFPMode
	Utils_ns::TaskPtr ds_task= std::make_shared<Utils_ns::Task>(this,ds_task_name,priority,useUTC);
	ds_task->SetMaxDuration(defaultTaskTimeout*1000.);//Set task timeout
	ds_task->SetAsynchTask(ds_task_progress_attr_name);//Set asynch task attr status
	
	//#### Rx TASKS ###### 
	//- Task (synch): Rx SetStandbyFPMode
	Utils_ns::TaskPtr rx_task= std::make_shared<Utils_ns::Task>(this,rx_task_name,priority,useUTC);
	rx_task->SetMaxDuration(defaultTaskTimeout*1000.);//Set task timeout
	
	//## Add tasks to sequence
	std::vector<Utils_ns::TaskPtr> tasks;
	tasks.push_back(spf_task);
	tasks.push_back(ds_task);
	tasks.push_back(rx_task);
	
	Utils_ns::TaskSequencePtr taskSequence= std::make_shared<Utils_ns::TaskSequence>(this,taskSequence_name,useUTC);
	taskSequence->SetDevStatusAttr(taskSequence_progress_attr_name);//Set device attr containing task sequence status

	for(size_t i=0;i<tasks.size();i++){
		if(taskSequence->AddTask(tasks[i])<0){
			std::stringstream ss;
			ss<<"Failed to add task "<<i+1<<" (name="<<tasks[i]->cmd_name<<") to sequence!";
			_WARN_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("SET_STANDBY_FP_MODE_FAILED",ss.str());			
		}
	}//end loop tasks


	/*
	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================	
	//Check if proxy is registered in list
	std::vector<std::string> full_proxy_names= {spfControllerAddress,rxControllerAddress,dsManagerAddress};
	for(unsigned int i=0;i<full_proxy_names.size();i++){
		if( !m_proxyManager->FindProxy(full_proxy_names[i]) ){
			_WARN_LOG("Proxy "<<full_proxy_names[i]<<" not found in registered proxy list, trying with alias name...");
		
			//Get full proxy name corresponding to alias
			std::string full_proxy_name= "";
			if(Utils_ns::TangoUtils::GetFQDNDeviceNameFromAlias(full_proxy_name,full_proxy_names[i])<0){
				std::stringstream ss;
				ss<<"Failed to retrieve full proxy name from alias "<<full_proxy_names[i]<<"!";
				_WARN_LOG(ss.str());
				_THROW_TANGO_EXCEPTION("SET_STANDBY_FP_MODE_FAILED",ss.str());	
			}
			full_proxy_names[i]= full_proxy_name;
		}
	}//end loop proxy names

	
	//Now execute command asynchronously and collect responses
	std::vector<Tango::DeviceData> dout;
	int reply_timeout= asynchCmdReplyTimeout;//ms
	int nretries= asynchCmdReplyNRetries;
	try { 
		m_proxyManager->ExecuteGroupCommandsAsynch(dout,full_proxy_names,cmd_names,reply_timeout,nretries);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		std::stringstream ss;
		ss<<"Tango exception occurred while executing commands {";
		for(unsigned int i=0;i<cmd_names.size();i++) ss<<cmd_names[i]<<",";
		ss<<"} on proxies (check proxy registered/syntax/proxy online)!";
		_WARN_LOG(ss.str());
		throw;
	}
	catch(std::exception& e){
		std::stringstream ss;
		ss<<"C++ exception occurred while executing commands {";
		for(unsigned int i=0;i<cmd_names.size();i++) ss<<cmd_names[i]<<",";
		ss<<"} on proxies (err="<<e.what()<<")!";
		_WARN_LOG(ss.str());
		throw;
	}
	catch(...){
		std::stringstream ss;
		ss<<"Unknown exception occurred while executing commands {";
		for(unsigned int i=0;i<cmd_names.size();i++) ss<<cmd_names[i]<<",";
		ss<<"} on proxies!";
		_WARN_LOG(ss.str());
		throw;
	}


	//Add task to monitoring 
	//NB: Task was already executed, just add to monitoring list
	bool addToQueue= false;
	if(m_taskManager->AddTaskSequence(taskSequence,addToQueue)<0){
		std::stringstream ss;
		ss<<"Failed to add task sequence "<<taskSequence_name<<" list!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STANDBY_FP_MODE_FAILED",ss.str());
	}
	_DEBUG_LOG("Added task sequence "<<taskSequence_name<<" to monitored task sequence list...");
	*/


	//=====================================================
	//==      SCHEDULE TASKS
	//=====================================================
	
	//Add task to queue 
	bool addToQueue= true;
	if(m_taskManager->AddTaskSequence(taskSequence,addToQueue)<0){
		std::stringstream ss;
		ss<<"Failed to add task sequence "<<taskSequence_name<<" to queue!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STANDBY_FP_MODE_FAILED",ss.str());
	}
	_INFO_LOG("Added sequence "<<taskSequence_name<<" to task queue...");


	//Set task progress attr to IDLE
	if(SetDynAttrValue(taskSequenceStartedMsg,taskSequence_progress_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<taskSequence_progress_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STANDBY_FP_MODE_FAILED",ss.str());	
	}	
	
	//Set output argument
	argout= new Tango::DevVarLongStringArray;
	argout->svalue.length(1);
	argout->lvalue.length(1);
	argout->svalue[0] = CORBA::string_dup("Set STANDBY-FP mode task scheduled");	
	argout->lvalue[0] = 1;

	/*----- PROTECTED REGION END -----*/	//	DishManager::set_standby_fpmode
	return argout;
}
//--------------------------------------------------------
/**
 *	Command SetOperateMode related method
 *	Description: This command triggers the Dish to transition to the 
 *               OPERATE Dish Element Mode, and returns to the caller. 
 *               This mode fulfils the main purpose of the Dish, which is to 
 *               point to designated directions while capturing data and 
 *               transmitting it to CSP.
 *               
 *               Command allowed only in Dish modes:
 *               {STANDBY-FP}
 *
 *	@returns 0]: ack code (0=OK, 1=QUEUED, 2=FAILED)
 *           
 *           == String field ==
 *           [0]: Informative message or error/fault description
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *DishManager::set_operate_mode()
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "DishManager::SetOperateMode()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::set_operate_mode) ENABLED START -----*/
	
	//	Add your own code

	// == COMMAND BEHAVIOR ==
	// See requirement State & Modes R.LMC.SM.11 & TM-Dish ICD
	// 1) Check if cmd mode-allowed: {'STANDBY-FP'} (see ICD)
	// 2) Call 'SetPointMode' command in DS
	// 3) Start capture in Rx
	//    NB: Rx should be already capturing data in STANDBY-FP but better checking. In fact it is potentially possible that some client called StopCapture before)
	// 4) Enable LNAs in SPF (all?) (TBD)

	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string cmd_name= "SetPointMode";
	std::string mode_attr_name= "dishMode";
	std::string mode_str= "OPERATE"; 
	std::string configuredBand_attr_name= "configuredBand";
	std::vector<std::string> configuredBand_attr_values {"B1","B2","B3","B4","B5a","B5b"};

	//Task vars
	//- Task sequence
	std::string taskSequence_name= "SetOperateMode";
	std::string taskSequence_progress_attr_name= "setOperateModeProgress";
	std::vector<std::string> taskSequenceStartedMsg {"IDLE","Set dish to OPERATE mode scheduled"};
	std::vector<std::string> taskAlreadyCompletedMsg {"COMPLETED","Dish is already in OPERATE mode"};
	std::vector<std::string> taskSequence_progress_ongoing= {"INIT","IDLE","RUNNING"};

	//- Rx tasks
	std::string rx_task_name= "StartRxCaptureTask";
	
	//- SPF tasks
	std::string spf_task_name= "SetSPFLnaPowerOnTask";
	//Tango::DevShort spf_task_argin_value= -1;//enable all LNAs?
	Tango::DevShort spf_task_argin_value= 0;//enable only selected band (if no band selected it will fail)

	//- DS tasks
	std::string ds_task_name= "SetDSPointModeTask";
	std::string ds_task_progress_attr_name= "dsSetPointModeProgress";
	//===========================================================================
	
	_INFO_LOG("Setting dish to OPERATE mode...");

	//=====================================================
	//==         CHECK IF CMD ALLOWED
	//=====================================================
	_DEBUG_LOG("Check if cmd "<<__FUNCTION__<<" is allowed...");
	bool check_cmd= true;
	try {
		IsCmdAllowed(__FUNCTION__,check_cmd);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		throw;
	}

	//=========================================================
	//==      CHECK IF TASK IS ALREADY RUNNING
	//=========================================================
	std::vector<std::string> taskProgress;
	if(GetDynAttrValue(taskProgress,taskSequence_progress_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get dyn attr "<<taskSequence_progress_attr_name<<" value!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_OPERATE_MODE_FAILED",ss.str());	
	}	
	if(taskProgress.size()<2){
		std::stringstream ss;
		ss<<"Invalid size for attr "<<taskSequence_progress_attr_name<<" value (expected at least equal to 2)!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_OPERATE_MODE_FAILED",ss.str());	
	}
	std::string taskProgressStr= taskProgress[0];
	
	//Check if another task is already running
	bool isTaskRunning= false;
	for(size_t i=0;i<taskSequence_progress_ongoing.size();i++){
		if(taskProgressStr==taskSequence_progress_ongoing[i]){
			isTaskRunning= true;
			break;
		}
	}//end loop config busy codes

	if(isTaskRunning) {
		std::stringstream ss;
		ss<<"Another set OPERATE mode task is running or pending for execution (hint: you must wait for completion before requesting a new task)";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_OPERATE_MODE_FAILED",ss.str());
	}

	//=====================================================
	//==      CHECK CONFIGURED BAND PRESENT
	//=====================================================
	//Read configured band
	Tango::DevShort configuredBand_current;
	if(GetDynAttrValue(configuredBand_current,configuredBand_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get dyn attr "<<configuredBand_attr_name<<" value!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_OPERATE_MODE_FAILED",ss.str());	
	}
	
	std::string configuredBandStr_current;
	Utils_ns::TangoUtils::GetEnumAttrLabelValue(configuredBandStr_current,this,configuredBand_attr_name,configuredBand_current);

	//Check if no band is selected
	bool hasConfiguredBand= false;
	for(size_t i=0;i<configuredBand_attr_values.size();i++){
		if(configuredBandStr_current==configuredBand_attr_values[i]){
			hasConfiguredBand= true;
			break;
		}
	}

	if(!hasConfiguredBand){
		std::stringstream ss;
		ss<<"No band is selected in Dish or configured band information is unknown. You must have one band active otherwise SPF LNAs cannot be turned on (TBD)";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_OPERATE_MODE_FAILED",ss.str());	

	}

	//=====================================================
	//==      CHECK CURRENT MODE
	//=====================================================
	//Retrieve mode value corresponding to label
	Tango::DevShort mode;
	Utils_ns::TangoUtils::GetEnumAttrValue(mode,this,mode_attr_name,mode_str);

	//Get current mode
	Tango::DevShort mode_current;	
	if(GetDynAttrValue(mode_current,mode_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<mode_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_OPERATE_MODE_FAILED",ss.str());	
	}	

	//Check if OPERATE mode is already active	
	if(mode==mode_current){
		_INFO_LOG("Mode "<<mode_str<<" already active, nothing to be done");
		
		//Set task progress attr
		if(SetDynAttrValue(taskAlreadyCompletedMsg,taskSequence_progress_attr_name)<0){
			std::stringstream ss;
			ss<<"Failed to set attr "<<taskSequence_progress_attr_name<<" value!";
			_ERROR_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("SET_OPERATE_MODE_FAILED",ss.str());	
		}	

		//Return already scheduled ack
		argout= new Tango::DevVarLongStringArray;
		argout->svalue.length(1);
		argout->lvalue.length(1);
		argout->svalue[0] = CORBA::string_dup(taskAlreadyCompletedMsg[1].c_str());	
		argout->lvalue[0] = 0;

		return argout;
	}

	
	//=====================================================
	//==      PREPARE TASKS
	//=====================================================
	
	//Prepare task data
	bool useUTC= false;
	int priority= Utils_ns::Task::eMEDIUM_PRIORITY;

	//#### Rx TASKS ###### 
	//- Task (synch): Rx StartCapture
	Utils_ns::TaskPtr rx_task= std::make_shared<Utils_ns::Task>(this,rx_task_name,priority,useUTC);
	rx_task->SetMaxDuration(defaultTaskTimeout*1000.);//Set task timeout
	
	//#### DS TASKS ###### 
	//- Task (asynch): DS set POINT mode
	Utils_ns::TaskPtr ds_task= std::make_shared<Utils_ns::Task>(this,ds_task_name,priority,useUTC);
	ds_task->SetMaxDuration(defaultTaskTimeout*1000.);//Set task timeout
	ds_task->SetAsynchTask(ds_task_progress_attr_name);//Set asynch task attr status
	
	//#### SPF TASKS ###### 
	//- Task (synch): SPF LNA Power on
	CORBA::Any spf_task_argin;
	spf_task_argin <<= spf_task_argin_value;//power all bands

	Utils_ns::TaskPtr spf_task= std::make_shared<Utils_ns::Task>(this,spf_task_name,priority,useUTC);
	spf_task->SetMaxDuration(defaultTaskTimeout*1000.);//Set task timeout
	spf_task->SetTaskArgin(spf_task_argin,Tango::DEV_SHORT,Tango::SCALAR);//set task argin
	
	//## Add tasks to sequence
	std::vector<Utils_ns::TaskPtr> tasks;
	tasks.push_back(rx_task);
	tasks.push_back(ds_task);
	tasks.push_back(spf_task);

	Utils_ns::TaskSequencePtr taskSequence= std::make_shared<Utils_ns::TaskSequence>(this,taskSequence_name,useUTC);
	taskSequence->SetDevStatusAttr(taskSequence_progress_attr_name);//Set device attr containing task sequence status

	for(size_t i=0;i<tasks.size();i++){
		if(taskSequence->AddTask(tasks[i])<0){
			std::stringstream ss;
			ss<<"Failed to add task "<<i+1<<" (name="<<tasks[i]->cmd_name<<") to sequence!";
			_WARN_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("SET_OPERATE_MODE_FAILED",ss.str());			
		}
	}//end loop tasks

	
	//=====================================================
	//==      SCHEDULE TASKS
	//=====================================================
	
	//Add task to queue 
	bool addToQueue= true;
	if(m_taskManager->AddTaskSequence(taskSequence,addToQueue)<0){
		std::stringstream ss;
		ss<<"Failed to add task sequence "<<taskSequence_name<<" to queue!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_OPERATE_MODE_FAILED",ss.str());
	}
	_INFO_LOG("Added sequence "<<taskSequence_name<<" to task queue...");
	
	//Set task progress attr to IDLE
	if(SetDynAttrValue(taskSequenceStartedMsg,taskSequence_progress_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<taskSequence_progress_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_OPERATE_MODE_FAILED",ss.str());	
	}	

	argout= new Tango::DevVarLongStringArray;
	argout->svalue.length(1);
	argout->lvalue.length(1);
	argout->svalue[0] = CORBA::string_dup("Set OPERATE mode task scheduled");	
	argout->lvalue[0] = 1;

	
	/*----- PROTECTED REGION END -----*/	//	DishManager::set_operate_mode
	return argout;
}
//--------------------------------------------------------
/**
 *	Command SetMaintenanceMode related method
 *	Description: This command triggers the Dish to transition to the 
 *               MAINTENANCE Dish Element Mode, and returns to the 
 *               caller. To go into a state that is safe to approach the 
 *               Dish by a maintainer, and to enable the Engineering 
 *               interface to allow direct access to low level control and
 *               monitoring by engineers and maintainers. 
 *               This mode will also enable engineers and maintainers 
 *               to upgrade SW and FW. Dish also enters this mode 
 *               when an emergency stop button is pressed.
 *               
 *               Command allowed ony in Dish modes: 
 *               {STANDBY-LP/STANDBY-FP}
 *
 *	@returns == Long field ==
 *           [0]: ack code (0=OK, 1=QUEUED, 2=FAILED)
 *           
 *           == String field ==
 *           [0]: Informative message or error/fault description
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *DishManager::set_maintenance_mode()
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "DishManager::SetMaintenanceMode()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::set_maintenance_mode) ENABLED START -----*/
	
	//	Add your own code

	//	Add your own code
	// == COMMAND BEHAVIOR ==
	// See requirement State & Modes R.LMC.SM.11 & TM-Dish ICD
	// 1) Check if cmd mode-allowed: {'STANDBY-LP','STANDBY-FP'} (see ICD)
	// 2) Call 'SetMaintenanceMode' command in all sub-elements device 

	//Issue to be clarified: If commands fail on 1 or more sub-element, what to do?
	//Restore previous mode in each sub-element or not (but ensure that dish mode don't go to FORBIDDEN state)?
	
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string cmd_name= "SetMaintenanceMode";
	std::string mode_attr_name= "dishMode";
	std::string mode_str= "MAINTENANCE"; 

	//Task vars	
	std::vector<std::string> taskSequenceStartedMsg {"IDLE","Set dish to MAINTENANCE mode scheduled"};
	std::vector<std::string> taskAlreadyCompletedMsg {"COMPLETED","Dish is already in MAINTENANCE mode"};
	std::vector<std::string> taskSequence_progress_ongoing= {"INIT","IDLE","RUNNING"};

	std::string taskSequence_name= "SetMaintenanceMode";
	std::string taskSequence_progress_attr_name= "setMaintenanceModeProgress";
	//std::string task_name= "SetMaintenanceMode";		
	//std::string task_progress_attr_name= "spfSetMaintenanceModeProgress";

	//- Rx tasks
	std::string rx_task_name= "SetRxMaintenanceModeTask";
	
	//- SPF tasks
	std::string spf_task_name= "SetSPFMaintenanceModeTask";
	std::string spf_task_progress_attr_name= "spfSetMaintenanceModeProgress";

	//- DS tasks
	std::string ds_task_name= "SetDSMaintenanceModeTask";
	//std::string ds_task_progress_attr_name= "dsSetMaintenanceModeProgress";
	//===========================================================================
	
	_INFO_LOG("Setting dish to MAINTENANCE mode...");

	//=====================================================
	//==         CHECK IF CMD ALLOWED
	//=====================================================
	_DEBUG_LOG("Check if cmd "<<__FUNCTION__<<" is allowed...");
	bool check_cmd= true;
	try {
		IsCmdAllowed(__FUNCTION__,check_cmd);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		throw;
	}

	//=====================================================
	//==         CHECK IF TASK IS ALREADY RUNNING
	//=====================================================
	_DEBUG_LOG("Check if a previous SetMaintenanceMode task is already running...");
	std::vector<std::string> taskProgress;
	if(GetDynAttrValue(taskProgress,taskSequence_progress_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<taskSequence_progress_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_MAINTENANCE_MODE_FAILED",ss.str());	
	}
	if(taskProgress.size()<2){
		std::stringstream ss;
		ss<<"Invalid size for attr "<<taskSequence_progress_attr_name<<" value (expected at least equal to 2)!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_MAINTENANCE_MODE_FAILED",ss.str());	
	}
	std::string taskProgressStr= taskProgress[0];

	//Check if another task is already running
	bool isTaskRunning= false;
	for(size_t i=0;i<taskSequence_progress_ongoing.size();i++){
		if(taskProgressStr==taskSequence_progress_ongoing[i]){
			isTaskRunning= true;
			break;
		}
	}//end loop config busy codes

	if(isTaskRunning) {
		std::stringstream ss;
		ss<<"Another set MAINTENANCE mode task is running or pending for execution (hint: you must wait for completion before requesting a new task)";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_MAINTENANCE_MODE_FAILED",ss.str());
	}


	//=====================================================
	//==      CHECK CURRENT MODE
	//=====================================================
	//Retrieve mode value corresponding to label
	Tango::DevShort mode;
	Utils_ns::TangoUtils::GetEnumAttrValue(mode,this,mode_attr_name,mode_str);

	//Get current mode
	Tango::DevShort mode_current;	
	if(GetDynAttrValue(mode_current,mode_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<mode_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_MAINTENANCE_MODE_FAILED",ss.str());	
	}	

	//Check if maintenance mode is already active	
	if(mode==mode_current){
		_INFO_LOG("Mode "<<mode_str<<" already active, nothing to be done");
		
		//Set task progress attr
		if(SetDynAttrValue(taskAlreadyCompletedMsg,taskSequence_progress_attr_name)<0){
			std::stringstream ss;
			ss<<"Failed to set attr "<<taskSequence_progress_attr_name<<" value!";
			_ERROR_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("SET_MAINTENANCE_MODE_FAILED",ss.str());	
		}	

		//Return already scheduled ack
		argout= new Tango::DevVarLongStringArray;
		argout->svalue.length(1);
		argout->lvalue.length(1);
		argout->svalue[0] = CORBA::string_dup(taskAlreadyCompletedMsg[1].c_str());	
		argout->lvalue[0] = 0;

		return argout;
	}
	

	//=====================================================
	//==      PREPARE TASKS
	//=====================================================
	
	//Prepare task data
	bool useUTC= false;
	int priority= Utils_ns::Task::eMEDIUM_PRIORITY;

	//#### Rx TASKS ###### 
	//- Task (synch): Rx SetMaintenanceMode
	Utils_ns::TaskPtr rx_task= std::make_shared<Utils_ns::Task>(this,rx_task_name,priority,useUTC);
	rx_task->SetMaxDuration(defaultTaskTimeout*1000.);//Set task timeout
	
	//#### DS TASKS ###### 
	//- Task (synch): DS SetMaintenanceMode
	Utils_ns::TaskPtr ds_task= std::make_shared<Utils_ns::Task>(this,ds_task_name,priority,useUTC);
	ds_task->SetMaxDuration(defaultTaskTimeout*1000.);//Set task timeout
	//ds_task->SetAsynchTask(ds_task_progress_attr_name);//Set asynch task attr status
	
	//#### SPF TASKS ###### 
	//- Task (asynch): SPF SetMaintenanceMode
	Utils_ns::TaskPtr spf_task= std::make_shared<Utils_ns::Task>(this,spf_task_name,priority,useUTC);
	spf_task->SetMaxDuration(defaultTaskTimeout*1000.);//Set task timeout
	spf_task->SetAsynchTask(spf_task_progress_attr_name);//Set asynch task attr status
		
	//## Add tasks to sequence
	std::vector<Utils_ns::TaskPtr> tasks;
	tasks.push_back(rx_task);
	tasks.push_back(ds_task);
	tasks.push_back(spf_task);

	Utils_ns::TaskSequencePtr taskSequence= std::make_shared<Utils_ns::TaskSequence>(this,taskSequence_name,useUTC);
	taskSequence->SetDevStatusAttr(taskSequence_progress_attr_name);//Set device attr containing task sequence status

	for(size_t i=0;i<tasks.size();i++){
		if(taskSequence->AddTask(tasks[i])<0){
			std::stringstream ss;
			ss<<"Failed to add task "<<i+1<<" (name="<<tasks[i]->cmd_name<<") to sequence!";
			_WARN_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("SET_MAINTENANCE_MODE_FAILED",ss.str());			
		}
	}//end loop tasks


	//=====================================================
	//==      SCHEDULE TASKS
	//=====================================================
	
	//Add task to queue 
	bool addToQueue= true;
	if(m_taskManager->AddTaskSequence(taskSequence,addToQueue)<0){
		std::stringstream ss;
		ss<<"Failed to add task sequence "<<taskSequence_name<<" to queue!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_MAINTENANCE_MODE_FAILED",ss.str());
	}
	_INFO_LOG("Added sequence "<<taskSequence_name<<" to task queue...");


	/*
	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	//Check if proxy is registered in list
	std::vector<std::string> full_proxy_names= {spfControllerAddress,rxControllerAddress,dsManagerAddress};
	for(unsigned int i=0;i<full_proxy_names.size();i++){
		if( !m_proxyManager->FindProxy(full_proxy_names[i]) ){
			_WARN_LOG("Proxy "<<full_proxy_names[i]<<" not found in registered proxy list, trying with alias name...");
		
			//Get full proxy name corresponding to alias
			std::string full_proxy_name= "";
			if(Utils_ns::TangoUtils::GetFQDNDeviceNameFromAlias(full_proxy_name,full_proxy_names[i])<0){
				std::stringstream ss;
				ss<<"Failed to retrieve full proxy name from alias "<<full_proxy_names[i]<<"!";
				_WARN_LOG(ss.str());
				_THROW_TANGO_EXCEPTION("SET_MAINTENANCE_MODE_FAILED",ss.str());	
			}
			full_proxy_names[i]= full_proxy_name;
		}
	}//end loop proxy names

	//Prepare task data
	bool useUTC= false;
	int priority= Utils_ns::Task::eMEDIUM_PRIORITY;
	Utils_ns::TaskPtr task= std::make_shared<Utils_ns::Task>(this,task_name,priority,useUTC);
	task->SetMaxDuration(operateTaskTimeout*1000.);//Set task timeout
	task->SetAsynchTask(task_progress_attr_name);//Set asynch task attr status

	//Add to task sequence
	Utils_ns::TaskSequencePtr taskSequence= std::make_shared<Utils_ns::TaskSequence>(this,taskSequence_name,useUTC);
	taskSequence->SetDevStatusAttr(taskSequence_progress_attr_name);//Set device attr containing task sequence status

	if(taskSequence->AddTask(task)<0){
		std::stringstream ss;
		ss<<"Failed to add task "<<task_name<<" to sequence!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_MAINTENANCE_MODE_FAILED",ss.str());		
	}
	
	//Now execute command asynchronously and collect responses
	std::vector<Tango::DeviceData> dout;
	int reply_timeout= asynchCmdReplyTimeout;//ms
	int nretries= asynchCmdReplyNRetries;
	try { 
		m_proxyManager->ExecuteGroupCommandsAsynch(dout,full_proxy_names,cmd_name,reply_timeout,nretries);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		std::stringstream ss;
		ss<<"Tango exception occurred while executing command "<<cmd_name<<" on proxies (check proxy registered/syntax/proxy online)!";
		_WARN_LOG(ss.str());
		throw;
	}
	catch(std::exception& e){
		std::stringstream ss;
		ss<<"C++ exception occurred while executing command "<<cmd_name<<" on proxies (err="<<e.what()<<")!";
		_WARN_LOG(ss.str());
		throw;
	}
	catch(...){
		std::stringstream ss;
		ss<<"Unknown exception occurred while executing command "<<cmd_name<<" on proxies!";
		_WARN_LOG(ss.str());
		throw;
	}

	
	//Add task to monitoring 
	//NB: Task was already executed, just add to monitoring list
	bool addToQueue= false;
	if(m_taskManager->AddTaskSequence(taskSequence,addToQueue)<0){
		std::stringstream ss;
		ss<<"Failed to add task sequence "<<task_name<<" list!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_MAINTENANCE_MODE_FAILED",ss.str());
	}
	_DEBUG_LOG("Added task "<<task_name<<" (timeout(ms)="<<operateTaskTimeout*1000<<", priority="<<priority<<") in sequence "<<taskSequence_name<<" to monitored task sequence list...");
	*/



	//Set task progress attr to IDLE
	if(SetDynAttrValue(taskSequenceStartedMsg,taskSequence_progress_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<taskSequence_progress_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_MAINTENANCE_MODE_FAILED",ss.str());	
	}	
	
	//Set output argument
	argout= new Tango::DevVarLongStringArray;
	argout->svalue.length(1);
	argout->lvalue.length(1);
	argout->svalue[0] = CORBA::string_dup("Set MAINTENANCE mode task scheduled");	
	argout->lvalue[0] = 1;

	/*----- PROTECTED REGION END -----*/	//	DishManager::set_maintenance_mode
	return argout;
}
//--------------------------------------------------------
/**
 *	Command SetStowMode related method
 *	Description: This command triggers the Dish to transition to the 
 *               STOW Dish Element Mode, and returns to the caller. 
 *               To point the dish in a direction that minimises the 
 *               wind loads on the structure, for survival in strong wind 
 *               conditions. The Dish is able to observe in the stow 
 *               position, for the purpose of transient detection.
 *
 *	@returns == Long field ==
 *           [0]: ack code (0=OK, 1=QUEUED, 2=FAILED)
 *           
 *           == String field ==
 *           [0]: Informative message or error/fault description
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *DishManager::set_stow_mode()
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "DishManager::SetStowMode()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::set_stow_mode) ENABLED START -----*/
	
	//	Add your own code
	// == COMMAND BEHAVIOR ==
	// 1) Check if cmd mode-allowed: Allowed in all modes (see ICD)
	// 2) Call 'Stow' command in DSManager device 
	// 3) Call 'SetStandbyLPMode' command in SPF (see LMC SOFT TRR OAR61)
	// 4) Call 'SetStandbyFPMode' command in SPFRx (see LMC SOFT TRR OAR61)

	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string cmd_name= "Stow";
	std::string mode_attr_name= "dishMode";
	std::string mode_str= "STOW";
	
	//Task vars
	//- Task sequence
	std::string taskSequence_name= "SetStowMode";
	std::string taskSequence_progress_attr_name= "setStowModeProgress";
	std::vector<std::string> taskSequenceStartedMsg {"IDLE","Set dish to STOW mode scheduled"};
	std::vector<std::string> taskAlreadyCompletedMsg {"COMPLETED","Dish is already in STOW mode"};
	std::vector<std::string> taskSequence_progress_ongoing= {"INIT","IDLE","RUNNING"};

	//- Rx tasks
	std::string rx_task_name= "SetRxStandbyLPModeTask";
	
	//- SPF tasks
	std::string spf_task_name= "SetSPFStandbyLPModeTask";
	std::string spf_task_progress_attr_name= "spfSetStandbyLPModeProgress";
	
	//- DS tasks
	std::string ds_task_name= "SetDSStowModeTask";
	std::string ds_task_progress_attr_name= "dsStowProgress";
	//===========================================================================

	_INFO_LOG("Setting dish to STOW mode...");

	//=====================================================
	//==         CHECK IF CMD ALLOWED
	//=====================================================
	_DEBUG_LOG("Check if cmd "<<__FUNCTION__<<" is allowed...");
	bool check_cmd= true;
	try {
		IsCmdAllowed(__FUNCTION__,check_cmd);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		throw;
	}

	
	//=========================================================
	//==      CHECK IF TASK IS ALREADY RUNNING
	//=========================================================
	std::vector<std::string> taskProgress;
	if(GetDynAttrValue(taskProgress,taskSequence_progress_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get dyn attr "<<taskSequence_progress_attr_name<<" value!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STOW_MODE_FAILED",ss.str());	
	}
	if(taskProgress.size()<2){
		std::stringstream ss;
		ss<<"Invalid size for attr "<<taskSequence_progress_attr_name<<" value (expected at least equal to 2)!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STOW_MODE_FAILED",ss.str());	
	}
	std::string taskProgressStr= taskProgress[0];

	
	//Check if another task is already running
	bool isTaskRunning= false;
	for(size_t i=0;i<taskSequence_progress_ongoing.size();i++){
		if(taskProgressStr==taskSequence_progress_ongoing[i]){
			isTaskRunning= true;
			break;
		}
	}//end loop config busy codes

	if(isTaskRunning) {
		std::stringstream ss;
		ss<<"Another set STOW mode task is running or pending for execution (hint: you must wait for completion before requesting a new task)";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STOW_MODE_FAILED",ss.str());
	}
	
	
	//=====================================================
	//==      CHECK CURRENT MODE
	//=====================================================
	//Retrieve mode value corresponding to label
	Tango::DevShort mode;
	Utils_ns::TangoUtils::GetEnumAttrValue(mode,this,mode_attr_name,mode_str);

	//Get current mode
	Tango::DevShort mode_current;	
	if(GetDynAttrValue(mode_current,mode_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<mode_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STOW_MODE_FAILED",ss.str());	
	}	

	//Check if STOW mode is already active	
	if(mode==mode_current){
		_INFO_LOG("Mode "<<mode_str<<" already active, nothing to be done");
		
		//Set task progress attr
		if(SetDynAttrValue(taskAlreadyCompletedMsg,taskSequence_progress_attr_name)<0){
			std::stringstream ss;
			ss<<"Failed to set attr "<<taskSequence_progress_attr_name<<" value!";
			_ERROR_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("SET_STOW_MODE_FAILED",ss.str());	
		}	

		//Return already scheduled ack
		argout= new Tango::DevVarLongStringArray;
		argout->svalue.length(1);
		argout->lvalue.length(1);
		argout->svalue[0] = CORBA::string_dup(taskAlreadyCompletedMsg[1].c_str());	
		argout->lvalue[0] = 0;

		return argout;
	}
	
	
	//=====================================================
	//==      PREPARE TASKS
	//=====================================================
	
	//Prepare task data
	bool useUTC= false;
	int priority= Utils_ns::Task::eMEDIUM_PRIORITY;

	//#### Rx TASKS ###### 
	//- Task (synch): Rx SetStandbyLPMode
	Utils_ns::TaskPtr rx_task= std::make_shared<Utils_ns::Task>(this,rx_task_name,priority,useUTC);
	rx_task->SetMaxDuration(defaultTaskTimeout*1000.);//Set task timeout
	
	//#### DS TASKS ###### 
	//- Task (asynch): DS SetStowMode
	Utils_ns::TaskPtr ds_task= std::make_shared<Utils_ns::Task>(this,ds_task_name,priority,useUTC);
	ds_task->SetMaxDuration(defaultTaskTimeout*1000.);//Set task timeout
	ds_task->SetAsynchTask(ds_task_progress_attr_name);//Set asynch task attr status
	
	//#### SPF TASKS ###### 
	//- Task (asynch): SPF SetStandbyLPMode
	Utils_ns::TaskPtr spf_task= std::make_shared<Utils_ns::Task>(this,spf_task_name,priority,useUTC);
	spf_task->SetMaxDuration(defaultTaskTimeout*1000.);//Set task timeout
	spf_task->SetAsynchTask(spf_task_progress_attr_name);//Set asynch task attr status
	
	//## Add tasks to sequence
	std::vector<Utils_ns::TaskPtr> tasks;
	tasks.push_back(rx_task);
	tasks.push_back(ds_task);
	tasks.push_back(spf_task);

	Utils_ns::TaskSequencePtr taskSequence= std::make_shared<Utils_ns::TaskSequence>(this,taskSequence_name,useUTC);
	taskSequence->SetDevStatusAttr(taskSequence_progress_attr_name);//Set device attr containing task sequence status

	for(size_t i=0;i<tasks.size();i++){
		if(taskSequence->AddTask(tasks[i])<0){
			std::stringstream ss;
			ss<<"Failed to add task "<<i+1<<" (name="<<tasks[i]->cmd_name<<") to sequence!";
			_WARN_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("SET_STOW_MODE_FAILED",ss.str());			
		}
	}//end loop tasks

	
	//=====================================================
	//==      SCHEDULE TASKS
	//=====================================================
	
	//Add task to queue 
	bool addToQueue= true;
	if(m_taskManager->AddTaskSequence(taskSequence,addToQueue)<0){
		std::stringstream ss;
		ss<<"Failed to add task sequence "<<taskSequence_name<<" to queue!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STOW_MODE_FAILED",ss.str());
	}
	_INFO_LOG("Added sequence "<<taskSequence_name<<" to task queue...");
	
	//Set task progress attr to IDLE
	if(SetDynAttrValue(taskSequenceStartedMsg,taskSequence_progress_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<taskSequence_progress_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STOW_MODE_FAILED",ss.str());	
	}	
	
	argout= new Tango::DevVarLongStringArray;
	argout->svalue.length(1);
	argout->lvalue.length(1);
	argout->svalue[0] = CORBA::string_dup("Set STOW mode task scheduled");	
	argout->lvalue[0] = 1;
	
	/*----- PROTECTED REGION END -----*/	//	DishManager::set_stow_mode
	return argout;
}
//--------------------------------------------------------
/**
 *	Command ConfigureBand1 related method
 *	Description: This command triggers the Dish to transition to the 
 *               CONFIGURE Dish Element Mode, and returns to the caller. 
 *               To configure the Dish to operate in frequency band 1. 
 *               On completion of the band configuration, Dish will 
 *               automatically revert to the previous Dish mode 
 *               (OPERATE or STANDBY-FP).
 *               
 *               Command allowed only in Dish modes:
 *               {STANDBY-FP/OPERATE/STOW}
 *
 *	@param argin [timestamp]
 */
//--------------------------------------------------------
void DishManager::configure_band1(Tango::DevString argin)
{
	DEBUG_STREAM << "DishManager::ConfigureBand1()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::configure_band1) ENABLED START -----*/
	
	//	Add your own code
	std::string activation_timestamp= argin;
	Tango::DevShort bandId= 1;
	try {
		ConfigureBand(bandId,activation_timestamp);
	}
	catch (Tango::DevFailed& e) {
		Tango::Except::print_exception(e);
		_WARN_LOG("Tango exception occurred while configuring band "<<bandId<<"!");
		throw;
	}
	catch(...){
		_WARN_LOG("Unknown exception occurred while configuring band "<<bandId<<"!");
		throw;
	}
	

	/*----- PROTECTED REGION END -----*/	//	DishManager::configure_band1
}
//--------------------------------------------------------
/**
 *	Command ConfigureBand2 related method
 *	Description: This command triggers the Dish to transition to the 
 *               CONFIGURE Dish Element Mode, and returns to the caller. 
 *               To configure the Dish to operate in frequency band 2. 
 *               On completion of the band configuration, Dish will 
 *               automatically revert to the previous Dish mode 
 *               (OPERATE or STANDBY-FP).
 *               
 *               Command allowed only in Dish modes:
 *               {STANDBY-FP/OPERATE/STOW}
 *
 *	@param argin [timestamp]
 */
//--------------------------------------------------------
void DishManager::configure_band2(Tango::DevString argin)
{
	DEBUG_STREAM << "DishManager::ConfigureBand2()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::configure_band2) ENABLED START -----*/
	
	//	Add your own code
	std::string activation_timestamp= argin;
	Tango::DevShort bandId= 2;
	try {
		ConfigureBand(bandId,activation_timestamp);
	}
	catch (Tango::DevFailed& e) {
		Tango::Except::print_exception(e);
		_WARN_LOG("Tango exception occurred while configuring band "<<bandId<<"!");
		throw;
	}
	catch(...){
		_WARN_LOG("Unknown exception occurred while configuring band "<<bandId<<"!");
		throw;
	}
	/*----- PROTECTED REGION END -----*/	//	DishManager::configure_band2
}
//--------------------------------------------------------
/**
 *	Command ConfigureBand3 related method
 *	Description: This command triggers the Dish to transition to the 
 *               CONFIGURE Dish Element Mode, and returns to the caller. 
 *               To configure the Dish to operate in frequency band 3. 
 *               On completion of the band configuration, Dish will 
 *               automatically revert to the previous Dish mode 
 *               (OPERATE or STANDBY-FP).
 *               
 *               Command allowed only in Dish modes:
 *               {STANDBY-FP/OPERATE/STOW}
 *
 *	@param argin [timestamp]
 */
//--------------------------------------------------------
void DishManager::configure_band3(Tango::DevString argin)
{
	DEBUG_STREAM << "DishManager::ConfigureBand3()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::configure_band3) ENABLED START -----*/
	
	//	Add your own code
	std::string activation_timestamp= argin;
	Tango::DevShort bandId= 3;
	try {
		ConfigureBand(bandId,activation_timestamp);
	}
	catch (Tango::DevFailed& e) {
		Tango::Except::print_exception(e);
		_WARN_LOG("Tango exception occurred while configuring band "<<bandId<<"!");
		throw;
	}
	catch(...){
		_WARN_LOG("Unknown exception occurred while configuring band "<<bandId<<"!");
		throw;
	}
	/*----- PROTECTED REGION END -----*/	//	DishManager::configure_band3
}
//--------------------------------------------------------
/**
 *	Command ConfigureBand4 related method
 *	Description: This command triggers the Dish to transition to the 
 *               CONFIGURE Dish Element Mode, and returns to the caller. 
 *               To configure the Dish to operate in frequency band 4. 
 *               On completion of the band configuration, Dish will 
 *               automatically revert to the previous Dish mode 
 *               (OPERATE or STANDBY-FP).
 *               
 *               Command allowed only in Dish modes:
 *               {STANDBY-FP/OPERATE/STOW}
 *
 *	@param argin [timestamp]
 */
//--------------------------------------------------------
void DishManager::configure_band4(Tango::DevString argin)
{
	DEBUG_STREAM << "DishManager::ConfigureBand4()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::configure_band4) ENABLED START -----*/
	
	//	Add your own code
	std::string activation_timestamp= argin;
	Tango::DevShort bandId= 4;
	try {
		ConfigureBand(bandId,activation_timestamp);
	}
	catch (Tango::DevFailed& e) {
		Tango::Except::print_exception(e);
		_WARN_LOG("Tango exception occurred while configuring band "<<bandId<<"!");
		throw;
	}
	catch(...){
		_WARN_LOG("Unknown exception occurred while configuring band "<<bandId<<"!");
		throw;
	}
	/*----- PROTECTED REGION END -----*/	//	DishManager::configure_band4
}
//--------------------------------------------------------
/**
 *	Command ConfigureBand5a related method
 *	Description: This command triggers the Dish to transition to the 
 *               CONFIGURE Dish Element Mode, and returns to the caller. 
 *               To configure the Dish to operate in frequency band 5. 
 *               On completion of the band configuration, Dish will 
 *               automatically revert to the previous Dish mode 
 *               (OPERATE or STANDBY-FP).
 *               
 *               Command allowed only in Dish modes:
 *               {STANDBY-FP/OPERATE/STOW}
 *
 *	@param argin [timestamp]
 */
//--------------------------------------------------------
void DishManager::configure_band5a(Tango::DevString argin)
{
	DEBUG_STREAM << "DishManager::ConfigureBand5a()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::configure_band5a) ENABLED START -----*/
	
	//	Add your own code
	std::string activation_timestamp= argin;
	Tango::DevShort bandId= 5;
	try {
		ConfigureBand(bandId,activation_timestamp);
	}
	catch (Tango::DevFailed& e) {
		Tango::Except::print_exception(e);
		_WARN_LOG("Tango exception occurred while configuring band "<<bandId<<"!");
		throw;
	}
	catch(...){
		_WARN_LOG("Unknown exception occurred while configuring band "<<bandId<<"!");
		throw;
	}
	/*----- PROTECTED REGION END -----*/	//	DishManager::configure_band5a
}
//--------------------------------------------------------
/**
 *	Command ConfigureBand5b related method
 *	Description: This command triggers the Dish to transition to the 
 *               CONFIGURE Dish Element Mode, and returns to the caller. 
 *               To configure the Dish to operate in frequency band 5. 
 *               On completion of the band configuration, Dish will 
 *               automatically revert to the previous Dish mode 
 *               (OPERATE or STANDBY-FP).
 *               
 *               Command allowed only in Dish modes:
 *               {STANDBY-FP/OPERATE/STOW}
 *
 *	@param argin 
 */
//--------------------------------------------------------
void DishManager::configure_band5b(Tango::DevString argin)
{
	DEBUG_STREAM << "DishManager::ConfigureBand5b()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::configure_band5b) ENABLED START -----*/
	
	//	Add your own code
	std::string activation_timestamp= argin;
	Tango::DevShort bandId= 6;
	try {
		ConfigureBand(bandId,activation_timestamp);
	}
	catch (Tango::DevFailed& e) {
		Tango::Except::print_exception(e);
		_WARN_LOG("Tango exception occurred while configuring band "<<bandId<<"!");
		throw;
	}
	catch(...){
		_WARN_LOG("Unknown exception occurred while configuring band "<<bandId<<"!");
		throw;
	}
	/*----- PROTECTED REGION END -----*/	//	DishManager::configure_band5b
}
//--------------------------------------------------------
/**
 *	Command SetIndexerPosition related method
 *	Description: Set indexer position
 *
 *	@param argin bandId position
 */
//--------------------------------------------------------
void DishManager::set_indexer_position(Tango::DevShort argin)
{
	DEBUG_STREAM << "DishManager::SetIndexerPosition()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::set_indexer_position) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string cmd_name= "SetIndexPosition";
	int nBands= 5;
	//###########################################################################

	//=====================================================
	//==      CHECK & EXTRACT TASK DATA
	//=====================================================
	//Check band id
	Tango::DevShort bandId= argin;
	if(bandId<=0 || bandId>nBands){
		std::stringstream ss;
		ss<<"Invalid bandId argument given ("<<bandId<<"), must be in the range [1,"<<nBands<<"]!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_INDEXER_POSITION_FAILED",ss.str());	
	}
	
	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	//Check if proxy is registered in list
	std::string full_proxy_name= dsManagerAddress;
	if( !m_proxyManager->FindProxy(full_proxy_name) ){
		_WARN_LOG("Proxy "<<full_proxy_name<<" not found in registered proxy list, trying with alias name...");
		
		//Get full proxy name corresponding to alias
		if(Utils_ns::TangoUtils::GetFQDNDeviceNameFromAlias(full_proxy_name,dsManagerAddress)<0){
			std::stringstream ss;
			ss<<"Failed to retrieve full proxy name from alias "<<full_proxy_name<<"!";
			_WARN_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("SET_INDEXER_POSITION_FAILED",ss.str());	
		}
	}
	
	//Set command argin 
	Tango::DeviceData din;
 	din << bandId;
	
	//Execute command (no argin, no argout expected)
	Tango::DeviceData dout;
	try {
		m_proxyManager->ExecuteCommand(dout,full_proxy_name,cmd_name,din);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		std::stringstream ss;
		ss<<"Tango exception occurred while executing command "<<cmd_name<<" on proxy "<<full_proxy_name<<" (check proxy registered or syntax)!";
		_WARN_LOG(ss.str());
		throw;
	}
	catch(std::exception& e){
		std::stringstream ss;
		ss<<"C++ exception occurred while executing command "<<cmd_name<<" on proxy "<<full_proxy_name<<" (err="<<e.what()<<")!";
		_WARN_LOG(ss.str());
		throw;
	}
	catch(...){
		std::stringstream ss;
		ss<<"Unknown exception occurred while executing command "<<cmd_name<<" on proxy "<<full_proxy_name<<"!";
		_WARN_LOG(ss.str());
		throw;
	}

	/*----- PROTECTED REGION END -----*/	//	DishManager::set_indexer_position
}
//--------------------------------------------------------
/**
 *	Command SetIndexerPositionTask related method
 *	Description: Set indexer position in DS
 *
 *	@param argin Task encoded data
 */
//--------------------------------------------------------
void DishManager::set_indexer_position_task(Tango::DevString argin)
{
	DEBUG_STREAM << "DishManager::SetIndexerPositionTask()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::set_indexer_position_task) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string cmd_name= "SetIndexPosition";
	int nBands= 5;
	//###########################################################################

	//=====================================================
	//==      CHECK & EXTRACT TASK DATA
	//=====================================================
	//Extract argin encoded data to TaskData
	_DEBUG_LOG("Parsing argin json encoded TaskData...");
	std::string argin_json_str(argin);
	Utils_ns::TaskData taskData;
	if(Utils_ns::TaskUtils::ParseFromJsonString(taskData,this,argin_json_str)<0){
		std::string errMsg("Failed to parse argin json string to TaskData!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("SET_INDEXER_POSITION_TASK_FAILED",errMsg);
	}

	_DEBUG_LOG("Executing cmd="<<taskData.name<<", id="<<taskData.id<<", has_data? "<<taskData.has_data);
	
	//Check if has argin data
	if(!taskData.has_data){
		std::string errMsg("No argin data present (expecting a DevShort arg)!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("SET_INDEXER_POSITION_TASK_FAILED",errMsg);
	}

	//Extract argin task data
	Tango::DevShort bandId;
	if(taskData.GetData<Tango::DevShort>(bandId)<0){
		std::string errMsg("Failed to extract data value in TaskData (check data type?)!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("SET_INDEXER_POSITION_TASK_FAILED",errMsg);		
	}

	//Check band id
	if(bandId<=0 || bandId>nBands){
		std::stringstream ss;
		ss<<"Invalid bandId argument given ("<<bandId<<"), must be in the range [1,"<<nBands<<"]!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_INDEXER_POSITION_TASK_FAILED",ss.str());	
	}
	_DEBUG_LOG("Executing cmd="<<taskData.name<<", id="<<taskData.id<<", has_data? "<<taskData.has_data<<", data="<<bandId);
	
	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	try{
		set_indexer_position(bandId);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Tango exception occurred when commanding set indexer position!");
		throw;
	}

	/*----- PROTECTED REGION END -----*/	//	DishManager::set_indexer_position_task
}
//--------------------------------------------------------
/**
 *	Command Track related method
 *	Description: The Dish moves to the commanded pointing angle at 
 *               the maximum speed, as defined by the specified slew 
 *               rate. No pointing accuracy requirements are applicable 
 *               in this state. SLEW state will also be reported while the 
 *               Dish is settling onto a target and is still not within 
 *               the specified pointing accuracy. As soon as the 
 *               pointing accuracy is within specifications, the state 
 *               changes to TRACK.
 *               
 *               Command allowed only in DIsh modes:
 *               {OPERATE}
 *
 *	@param argin [timestamp]
 */
//--------------------------------------------------------
void DishManager::track(Tango::DevString argin)
{
	DEBUG_STREAM << "DishManager::Track()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::track) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	DishManager::track
}
//--------------------------------------------------------
/**
 *	Command Slew related method
 *	Description: The Dish is tracking the commanded pointing positions 
 *               within the specified TRACK pointing accuracy.
 *               
 *               Command allowed only in DIsh modes:
 *               {OPERATE}
 *
 *	@param argin [timestamp]
 */
//--------------------------------------------------------
void DishManager::slew(Tango::DevString argin)
{
	DEBUG_STREAM << "DishManager::Slew()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::slew) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	DishManager::slew
}
//--------------------------------------------------------
/**
 *	Command Scan related method
 *	Description: The Dish is tracking the commanded pointing positions 
 *               within the specified SCAN pointing accuracy. (TBC)
 *               NOTE: This pointing state is currently proposed and 
 *               there are currently no requirements for this functionality.
 *               
 *               Command allowed only in DIsh modes:
 *               {OPERATE}
 *
 *	@param argin [timestamp]
 */
//--------------------------------------------------------
void DishManager::scan(Tango::DevString argin)
{
	DEBUG_STREAM << "DishManager::Scan()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::scan) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	DishManager::scan
}
//--------------------------------------------------------
/**
 *	Command HandleBandFunctionalErrorEvent related method
 *	Description: Handler cmd for functional band error
 *
 *	@param argin 
 */
//--------------------------------------------------------
void DishManager::handle_band_functional_error_event(Tango::DevString argin)
{
	DEBUG_STREAM << "DishManager::HandleBandFunctionalErrorEvent()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::handle_band_functional_error_event) ENABLED START -----*/
	
	//	Add your own code
	// == COMMAND BEHAVIOR ==
	//1) Check if dish is in OPERATE, if not do nothing
	//2) Check if failing band is the configured band, if not do nothing 
	//3) If equal, set dish to STANDBY_FP mode (R.LMC.SM.18)
	
	//=====================================================
	//==      CHECK & EXTRACT TASK DATA
	//=====================================================
	//Extract argin encoded data to TaskData
	_DEBUG_LOG("Parsing argin json encoded TaskData...");
	std::string argin_json_str(argin);
	Utils_ns::TaskData taskData;
	if(Utils_ns::TaskUtils::ParseFromJsonString(taskData,this,argin_json_str)<0){
		std::string errMsg("Failed to parse argin json string to TaskData for Task_PowerLNA() command!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("HANDLE_BAND_FUNCTIONAL_ERROR_EVENT_FAILED",errMsg);
	}

	_DEBUG_LOG("Executing cmd="<<taskData.name<<", id="<<taskData.id<<", has_data? "<<taskData.has_data);
	

	//=====================================================
	//==      COMMAND SET STANDBY-FP MODE ON BAND ERROR
	//=====================================================
	try{
		set_standby_fpmode_on_band_error();
	}
	catch(...){
		_ERROR_LOG("Failed to handle band functional error event!");
		throw;
	}

	/*----- PROTECTED REGION END -----*/	//	DishManager::handle_band_functional_error_event
}
//--------------------------------------------------------
/**
 *	Command HandleEStopEvent related method
 *	Description: Handler command for emergency stop event
 *
 *	@param argin 
 */
//--------------------------------------------------------
void DishManager::handle_estop_event(Tango::DevString argin)
{
	DEBUG_STREAM << "DishManager::HandleEStopEvent()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::handle_estop_event) ENABLED START -----*/
	
	//	Add your own code
	// == COMMAND BEHAVIOR ==
	// 1) Check current dishMode
	// 2) Case OPERATE/CONFIGURE (R.LMC.SM.23): Set dish to STANDBY_FP mode and report an error to TM 
	// 2)	Else (R.LMC.SM.24): Remain in the mode and report an error to TM

	//NB: The error should be reported by the Alarm System
	
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	Tango::DevShort dsMode_estop= 4;
	std::string dishMode_attr_name= "dishMode";
	std::string dishMode_final_str= "STANDBY-FP";
	std::vector<std::string> dishModes_str {
		"CONFIG",	
		"OPERATE"
	};	
	std::string handlerEnabled_attr_name= "enableESTOPEventHandler";

	//Task vars
	std::vector<std::string> taskSequenceStartedMsg {"IDLE","Set dish to STANDBY-FP mode on ESTOP scheduled"};
	std::vector<std::string> taskAlreadyCompletedMsg {"COMPLETED","Dish is already in STANDBY-FP mode"};
	std::vector<std::string> taskSequence_progress_ongoing= {"INIT","IDLE","RUNNING"};

	std::string taskSequence_name= "HandleESTOPEvent";
	std::string taskSequence_progress_attr_name= "setStandbyFPOnESTOPProgress";

	//- Rx task
	std::string rx_task_name= "SetRxStandbyFPModeTask";
	
	//- SPF tasks
	std::string spf_task_name= "SetSPFOperateModeTask";	
	std::string spf_task_progress_attr_name= "spfSetOperateModeProgress";

	//- DS tasks
	//std::string ds_task_name= "SetDSStandbyFPModeTask";	
	//std::string ds_task_progress_attr_name= "dsSetStandbyFPModeProgress";
	//###########################################################################
	
	//=====================================================
	//==      CHECK HANDLER ENABLED/DISABLED
	//=====================================================
	//## Check if event handling is enabled
	Tango::DevBoolean handlerEnabled;
	if(GetDynAttrValue(handlerEnabled,handlerEnabled_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get dyn attr "<<handlerEnabled_attr_name<<" value!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("HANDLE_ESTOP_EVENT_FAILED",ss.str());		
	}
	if(!handlerEnabled) {
		_INFO_LOG("ESTOP event handler is disabled, will not handle the event");
		return;
	}

	//=====================================================
	//==      CHECK & EXTRACT TASK DATA
	//=====================================================
	//Extract argin encoded data to TaskData
	_DEBUG_LOG("Parsing argin json encoded TaskData...");
	std::string argin_json_str(argin);
	Utils_ns::TaskData taskData;
	if(Utils_ns::TaskUtils::ParseFromJsonString(taskData,this,argin_json_str)<0){
		std::string errMsg("Failed to parse argin json string to TaskData for Task_HandleESTOPEvent() command!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("HANDLE_ESTOP_EVENT_FAILED",errMsg);
	}

	//Check if has argin data
	if(!taskData.has_data){
		std::string errMsg("No argin data present (expecting a DevEnum arg)!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("HANDLE_ESTOP_EVENT_FAILED",errMsg);
	}

	//Extract argin task data
	Tango::DevShort dsMode;
	if(taskData.GetData<Tango::DevShort>(dsMode)<0){
		std::string errMsg("Failed to extract data value in TaskData (check data type?)!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("HANDLE_ESTOP_EVENT_FAILED",errMsg);		
	}
	_DEBUG_LOG("Executing cmd="<<taskData.name<<", id="<<taskData.id<<", has_data? "<<taskData.has_data<<", data="<<dsMode);
	

	//=====================================================
	//==      CHECK DS MODE IS ESTOP
	//=====================================================
	if(dsMode!=dsMode_estop){
		_DEBUG_LOG("Received DS operating mode ("<<dsMode<<") event, nothing to be done...");
		return;
	}

	//=====================================================
	//==      CHECK DISH MODE
	//=====================================================
	//## Get current dishMode attr value
	Tango::DevShort dishMode_current;
	if(GetDynAttrValue(dishMode_current,dishMode_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get dyn attr "<<dishMode_attr_name<<" value!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("HANDLE_ESTOP_EVENT_FAILED",ss.str());		
	}

	//## Retrieve enum label corresponding to value
	std::string dishMode_current_str;
	if(Utils_ns::TangoUtils::GetEnumAttrLabelValue(dishMode_current_str,this,dishMode_attr_name,dishMode_current)<0){
		std::stringstream ss;
		ss<<"Failed to get enum label for dyn attr "<<dishMode_attr_name<<" corresponding to value "<<dishMode_current<<"!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("HANDLE_ESTOP_EVENT_FAILED",ss.str());	
	}
	
	//## Check if trigger actions given the dish mode 
	bool triggerAction= false;
	for(size_t i=0;i<dishModes_str.size();i++){
		if(dishMode_current_str==dishModes_str[i]){
			triggerAction= true;
			break;
		}
	}

	if(!triggerAction){
		_INFO_LOG("Dish is in mode "<<dishMode_current_str<<", no actions required in response tp ESTOP event");
		return;
	}

	//## Check if STANDBY-FP mode is already active	
	if(dishMode_current_str==dishMode_final_str){
		_INFO_LOG("Dish mode "<<dishMode_final_str<<" already active, nothing to be done");

		//Set task progress attr
		if(SetDynAttrValue(taskAlreadyCompletedMsg,taskSequence_progress_attr_name)<0){
			std::stringstream ss;
			ss<<"Failed to set attr "<<taskSequence_progress_attr_name<<" value!";
			_ERROR_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("HANDLE_ESTOP_EVENT_FAILED",ss.str());	
		}	
		return;
	}

	//=====================================================
	//==         CHECK IF TASK IS ALREADY RUNNING
	//=====================================================
	_DEBUG_LOG("Check if a previous SetStandbyFPMode task is already running...");
	std::vector<std::string> taskProgress;
	if(GetDynAttrValue(taskProgress,taskSequence_progress_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<taskSequence_progress_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("HANDLE_ESTOP_EVENT_FAILED",ss.str());	
	}
	if(taskProgress.size()<2){
		std::stringstream ss;
		ss<<"Invalid size for attr "<<taskSequence_progress_attr_name<<" value (expected at least equal to 2)!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("HANDLE_ESTOP_EVENT_FAILED",ss.str());	
	}

	std::string taskProgressStr= taskProgress[0];
	
	//Check if another task is already running
	bool isTaskRunning= false;
	for(size_t i=0;i<taskSequence_progress_ongoing.size();i++){
		if(taskProgressStr==taskSequence_progress_ongoing[i]){
			isTaskRunning= true;
			break;
		}
	}//end loop config busy codes

	if(isTaskRunning) {
		_INFO_LOG("Processing of ESTOP event task is already scheduled/ongoing (e.g. thanks for the event but I'm already processing it)...");
		return;
	}

	//=====================================================
	//==      PREPARE TASKS DATA
	//=====================================================
	_INFO_LOG("Handling ESTOP event...");

	//Prepare task data
	bool useUTC= false;
	int priority= Utils_ns::Task::eHIGH_PRIORITY;

	//#### SPF TASKS ###### 
	//- Task (asynch): SPF SetStandbyFPMode
	Utils_ns::TaskPtr spf_task= std::make_shared<Utils_ns::Task>(this,spf_task_name,priority,useUTC);
	spf_task->SetMaxDuration(defaultTaskTimeout*1000.);//Set task timeout
	spf_task->SetAsynchTask(spf_task_progress_attr_name);//Set asynch task attr status
	
	//#### Rx TASKS ###### 
	//- Task (synch): Rx SetStandbyFPMode
	Utils_ns::TaskPtr rx_task= std::make_shared<Utils_ns::Task>(this,rx_task_name,priority,useUTC);
	rx_task->SetMaxDuration(defaultTaskTimeout*1000.);//Set task timeout
	
	//## Add tasks to sequence
	std::vector<Utils_ns::TaskPtr> tasks;
	tasks.push_back(spf_task);
	tasks.push_back(rx_task);
	
	Utils_ns::TaskSequencePtr taskSequence= std::make_shared<Utils_ns::TaskSequence>(this,taskSequence_name,useUTC);
	taskSequence->SetDevStatusAttr(taskSequence_progress_attr_name);//Set device attr containing task sequence status

	for(size_t i=0;i<tasks.size();i++){
		if(taskSequence->AddTask(tasks[i])<0){
			std::stringstream ss;
			ss<<"Failed to add task "<<i+1<<" (name="<<tasks[i]->cmd_name<<") to sequence!";
			_WARN_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("HANDLE_ESTOP_EVENT_FAILED",ss.str());			
		}
	}//end loop tasks


	//=====================================================
	//==     FLUSH EXISTING TASKS
	//=====================================================
	_INFO_LOG("Flushing existing tasks in queue...");
	try {
		flush_task_queue();
	}
	catch(...){
		_ERROR_LOG("Failed to flush command queue!");
		throw;
	}

	//=====================================================
	//==      SCHEDULE TASKS
	//=====================================================	
	//Add task to queue 
	bool addToQueue= true;
	if(m_taskManager->AddTaskSequence(taskSequence,addToQueue)<0){
		std::stringstream ss;
		ss<<"Failed to add task sequence "<<taskSequence_name<<" to queue!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("HANDLE_ESTOP_EVENT_FAILED",ss.str());
	}
	_INFO_LOG("Added sequence "<<taskSequence_name<<" to task queue...");


	//Set task progress attr to IDLE
	if(SetDynAttrValue(taskSequenceStartedMsg,taskSequence_progress_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<taskSequence_progress_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("HANDLE_ESTOP_EVENT_FAILED",ss.str());	
	}	

	/*----- PROTECTED REGION END -----*/	//	DishManager::handle_estop_event
}
//--------------------------------------------------------
/**
 *	Command HandlePowerCutEvent related method
 *	Description: Handler cmd for power cut event
 *
 *	@param argin Task encoded string including event data
 */
//--------------------------------------------------------
void DishManager::handle_power_cut_event(Tango::DevString argin)
{
	DEBUG_STREAM << "DishManager::HandlePowerCutEvent()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::handle_power_cut_event) ENABLED START -----*/
	
	//	Add your own code

	// == COMMAND BEHAVIOR ==
	// 1) Check if task is already ongoing, if so do not process event!
	// 2) SPF
	//     2.1) Set SPF to STANDBY-LP (synch task) - R.LMC.SM.7
	//     2.2) When SPF is in STANDBY-LP call Shutdown()
	//     2.3) After SPFC shutdown, LMC commands DS Power strip to switch SPFC off 
	// 3) Rx
	//     3.1) After 30 s set Rx to STANDBY-LP (synch task) - R.LMC.SM.19
	//     3.2) When SPFRx is in STANDBY-LP shutdown RXPU. 
	//     3.3) After RXPU shutdown, LMC commands DS Power strip to switch RXPU off

	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string seCtrlPowerStatus_attr_name= "seCtrlPowerStatus";
	std::string seCtrlPowerStatusStr= "OFF";
	std::string handlerEnabled_attr_name= "enablePowerCutEventHandler";
	
	//Task vars
	std::vector<std::string> taskSequenceInitializedMsg {"INIT","Dish shutdown on power cut initialized"};
	std::vector<std::string> taskSequenceStartedMsg {"IDLE","Dish shutdown on power cut scheduled"};
	std::vector<std::string> taskAlreadyCompletedMsg {"COMPLETED","Dish shutdown on power cut completed."};
	std::vector<std::string> taskSequenceAbortedMsg {"ABORTED","Dish shutdown on power cut aborted"};
	std::vector<std::string> taskSequence_progress_ongoing= {"INIT","IDLE","RUNNING"};

	std::string taskSequence_name= "ShutdownOnPowerCut";
	std::string taskSequence_progress_attr_name= "shutdownOnPowerCutProgress";

	//- Rx task
	std::string rx_task1_name= "SetRxStandbyLPModeTask";
	std::string rx_task2_name= "ShutdownRXPUTask";//depends on task 1
	std::string rx_task3_name= "PowerOffRXPUTask";//depends on task 2
	
	//- SPF tasks
	std::string spf_task1_name= "SetSPFStandbyLPModeTask";	
	std::string spf_task1_progress_attr_name= "spfSetStandbyLPModeProgress";
	std::string spf_task2_name= "ShutdownSPFCTask";	
	std::string spf_task3_name= "PowerOffSPFCTask";	
	int spfPowerOffTimeDelay= 5;//in seconds (to allow SPF complete shutdown of Tango servers and OS)
	int rxPowerOffTimeDelay= 5;//in seconds (to allow SPFRx complete shutdown of Tango servers and OS)

	//- DS tasks
	//std::string ds_task_name= "SetDSStandbyFPModeTask";	
	//std::string ds_task_progress_attr_name= "dsSetStandbyFPModeProgress";

	//- Task dependency matrix
	std::vector< std::vector<size_t> > task_dependency_matrix { 	
		{},	
		{0},
		{1},
		{},
		{3},
		{4} 
	};
	//###########################################################################

	//=====================================================
	//==      CHECK HANDLER ENABLED/DISABLED
	//=====================================================
	//## Check if event handling is enabled
	Tango::DevBoolean handlerEnabled;
	if(GetDynAttrValue(handlerEnabled,handlerEnabled_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get dyn attr "<<handlerEnabled_attr_name<<" value!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("HANDLE_POWER_CUT_EVENT_FAILED",ss.str());		
	}
	if(!handlerEnabled) {
		_DEBUG_LOG("Power cut event handler is disabled, will not handle the event");
		return;
	}

	//=====================================================
	//==      CHECK & EXTRACT TASK DATA
	//=====================================================
	//Extract argin encoded data to TaskData
	_DEBUG_LOG("Parsing argin json encoded TaskData...");
	std::string argin_json_str(argin);
	Utils_ns::TaskData taskData;
	if(Utils_ns::TaskUtils::ParseFromJsonString(taskData,this,argin_json_str)<0){
		std::string errMsg("Failed to parse argin json string to TaskData for Task_PowerLNA() command!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("HANDLE_POWER_CUT_EVENT_FAILED",errMsg);
	}

	_DEBUG_LOG("Executing cmd="<<taskData.name<<", id="<<taskData.id<<", has_data? "<<taskData.has_data);
	
	//Check if has argin data
	if(!taskData.has_data){
		std::string errMsg("No argin data present (expecting a bool arg)!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("HANDLE_POWER_CUT_EVENT_FAILED",errMsg);
	}

	//Extract argin task data
	bool isPowerCut= false;
	if(taskData.GetData<Tango::DevBoolean>(isPowerCut)<0){
		std::string errMsg("Failed to extract data value in TaskData (check data type?)!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("HANDLE_POWER_CUT_EVENT_FAILED",errMsg);		
	}
	_DEBUG_LOG("Executing cmd="<<taskData.name<<", id="<<taskData.id<<", has_data? "<<taskData.has_data<<", data="<<isPowerCut);
	

	//Skip if not power cut (e.g. periodic event)
	//NB: This should not occur but check anyway!!!	
	if(!isPowerCut){
		_DEBUG_LOG("Received a power cut event (powerCut=false) (hint: can be the periodic event), ignore event!");
		return;
	}
	

	//=====================================================
	//==      CHECK IF TASK IS ALREADY QUEUED/RUNNING
	//=====================================================
	_DEBUG_LOG("Check if a previous ShutdownOnPowerCut task is already running...");
	std::vector<std::string> taskProgress;
	if(GetDynAttrValue(taskProgress,taskSequence_progress_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<taskSequence_progress_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("HANDLE_POWER_CUT_EVENT_FAILED",ss.str());	
	}
	if(taskProgress.size()<2){
		std::stringstream ss;
		ss<<"Invalid size for attr "<<taskSequence_progress_attr_name<<" value (expected at least equal to 2)!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("HANDLE_POWER_CUT_EVENT_FAILED",ss.str());	
	}

	std::string taskProgressStr= taskProgress[0];
	
	//Check if another task is already running
	bool isTaskRunning= false;
	for(size_t i=0;i<taskSequence_progress_ongoing.size();i++){
		if(taskProgressStr==taskSequence_progress_ongoing[i]){
			isTaskRunning= true;
			break;
		}
	}//end loop config busy codes

	if(isTaskRunning) {
		_INFO_LOG("Shutdown task is already scheduled/ongoing (e.g. thanks for the power cut event but I'm already processing it)...");
		return;
	}

	//=====================================================
	//==      CHECK IF EVENT WAS ALREADY HANDLED
	//=====================================================
	//## Get current se controller power status attr value
	Tango::DevShort seCtrlPowerStatus_current;
	if(GetDynAttrValue(seCtrlPowerStatus_current,seCtrlPowerStatus_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get dyn attr "<<seCtrlPowerStatus_attr_name<<" value!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("HANDLE_POWER_CUT_EVENT_FAILED",ss.str());		
	}


	//## Retrieve enum labels corresponding to value
	std::string seCtrlPowerStatusStr_current= "";
	if(Utils_ns::TangoUtils::GetEnumAttrLabelValue(seCtrlPowerStatusStr_current,this,seCtrlPowerStatus_attr_name,seCtrlPowerStatus_current)<0){
		std::stringstream ss;
		ss<<"Failed to get enum label for dyn attr "<<seCtrlPowerStatus_attr_name<<" corresponding to value "<<seCtrlPowerStatus_current<<"!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("HANDLE_POWER_CUT_EVENT_FAILED",ss.str());	
	}
	
	//## Check if trigger actions given the dish mode 
	bool eventHandled= (
		seCtrlPowerStatusStr_current==seCtrlPowerStatusStr
	);
	if(eventHandled){
		_INFO_LOG("Shutdown task was already handled with success (e.g. thanks for the power cut event but I already processed it) ...");
		return;
	}

	//=====================================================
	//==      PREPARE TASKS
	//=====================================================
	
	//Prepare task data
	bool useUTC= false;
	int priority= Utils_ns::Task::eHIGH_PRIORITY;

	//#### SPF TASKS ###### 
	//== TASK 1 (asynch): SetSPFStandbyLPModeTask ==	
	Utils_ns::TaskPtr spf_task1= std::make_shared<Utils_ns::Task>(this,spf_task1_name,priority,useUTC);
	spf_task1->SetMaxDuration(shutdownTaskTimeout*1000.);//Set task timeout
	spf_task1->SetAsynchTask(spf_task1_progress_attr_name);

	//== TASK 2 (synch): ShutdownSPFCTask ==	
	Utils_ns::TaskPtr spf_task2= std::make_shared<Utils_ns::Task>(this,spf_task2_name,priority,useUTC);
	spf_task2->SetMaxDuration(shutdownTaskTimeout*1000.);//Set task timeout

	//== TASK 3 (synch): PowerOffSPFCTask ==	
	Utils_ns::TaskPtr spf_task3= std::make_shared<Utils_ns::Task>(this,spf_task3_name,priority,useUTC);
	spf_task3->SetTimeDelayAndDuration(spfPowerOffTimeDelay*1000.,shutdownTaskTimeout*1000.);
	//spf_task3->SetMaxDuration(shutdownTaskTimeout*1000.);//Set task timeout
	
	//#### Rx TASKS ###### 
	//== TASK 1  (synch): SetRxStandbyLPModeTask
	Utils_ns::TaskPtr rx_task1= std::make_shared<Utils_ns::Task>(this,rx_task1_name,priority,useUTC);
	rx_task1->SetTimeDelayAndDuration(rxShutdownTimeDelay*1000.,shutdownTaskTimeout*1000.);
	
	//== TASK 2 (synch): ShutdownRXPUTask ==	
	Utils_ns::TaskPtr rx_task2= std::make_shared<Utils_ns::Task>(this,rx_task2_name,priority,useUTC);
	rx_task2->SetMaxDuration(shutdownTaskTimeout*1000.);//Set task timeout

	//== TASK 3 (synch): PowerOffRXPUTask ==	
	Utils_ns::TaskPtr rx_task3= std::make_shared<Utils_ns::Task>(this,rx_task3_name,priority,useUTC);
	//rx_task3->SetMaxDuration(shutdownTaskTimeout*1000.);//Set task timeout
	rx_task3->SetTimeDelayAndDuration(rxPowerOffTimeDelay*1000.,shutdownTaskTimeout*1000.);

	std::vector<Utils_ns::TaskPtr> tasks;
	tasks.push_back(rx_task1);
	tasks.push_back(rx_task2);
	tasks.push_back(rx_task3);
	tasks.push_back(spf_task1);
	tasks.push_back(spf_task2);
	tasks.push_back(spf_task3);

	//Add tasks to sequence
	Utils_ns::TaskSequencePtr taskSequence= std::make_shared<Utils_ns::TaskSequence>(this,taskSequence_name,useUTC);
	taskSequence->SetDevStatusAttr(taskSequence_progress_attr_name);//Set device attr containing task sequence status

	for(size_t i=0;i<tasks.size();i++){
		if(taskSequence->AddTask(tasks[i])<0){
			std::stringstream ss;
			ss<<"Failed to add task "<<i+1<<" (name="<<tasks[i]->cmd_name<<") to sequence!";
			_WARN_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("HANDLE_POWER_CUT_EVENT_FAILED",ss.str());			
		}
	}//end loop tasks

	//Set task dependencies
	if(taskSequence->SetTaskDependency(task_dependency_matrix)<0){
		std::stringstream ss;
		ss<<"Failed to set task dependency indexes in sequence!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("HANDLE_POWER_CUT_EVENT_FAILED",ss.str());		
	}

	//=====================================================
	//==      SET TASK SEQUENCE STATUS TO INIT
	//=====================================================
	//Set task progress attr to INIT
	if(SetDynAttrValue(taskSequenceInitializedMsg,taskSequence_progress_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<taskSequence_progress_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("HANDLE_POWER_CUT_EVENT_FAILED",ss.str());	
	}	

	//=====================================================
	//==     FLUSH EXISTING TASKS
	//=====================================================
	_INFO_LOG("Flushing existing tasks in queue...");
	try {
		flush_task_queue();
	}
	catch(...){
		_ERROR_LOG("Failed to flush command queue!");
		SetDynAttrValue(taskSequenceAbortedMsg,taskSequence_progress_attr_name);
		throw;
	}

	//=====================================================
	//==      SCHEDULE TASKS
	//=====================================================
	//Add task to queue 
	bool addToQueue= true;
	if(m_taskManager->AddTaskSequence(taskSequence,addToQueue)<0){
		std::stringstream ss;
		ss<<"Failed to add task sequence "<<taskSequence_name<<" to queue!";
		_WARN_LOG(ss.str());
		SetDynAttrValue(taskSequenceAbortedMsg,taskSequence_progress_attr_name);
		_THROW_TANGO_EXCEPTION("HANDLE_POWER_CUT_EVENT_FAILED",ss.str());
	}
	_INFO_LOG("Scheduled task "<<taskSequence_name<<" ...");
	
	//=====================================================
	//==      SET TASK SEQUENCE STATUS TO IDLE
	//=====================================================
	//Set task progress attr to IDLE
	if(SetDynAttrValue(taskSequenceStartedMsg,taskSequence_progress_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<taskSequence_progress_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("HANDLE_POWER_CUT_EVENT_FAILED",ss.str());	
	}	
	
	/*----- PROTECTED REGION END -----*/	//	DishManager::handle_power_cut_event
}
//--------------------------------------------------------
/**
 *	Command HandlePowerRestoreEvent related method
 *	Description: Handler cmd for power restoring event
 *
 *	@param argin 
 */
//--------------------------------------------------------
void DishManager::handle_power_restore_event(Tango::DevString argin)
{
	DEBUG_STREAM << "DishManager::HandlePowerRestoreEvent()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::handle_power_restore_event) ENABLED START -----*/
	
	//	Add your own code
	// == COMMAND BEHAVIOR ==
	//1) Revoke queued power off tasks for Rx. Allow Rx to go to STANDBY-LP (see George Smit mail 3 April 2017)
	//2) Restore power in SPFC (if it was powered off in the power cut handling)  (see George Smit mail 3 April 2017) 
	//3) Restore power in RxPU (if it was powered off in the power cut handling)  (see George Smit mail 3 April 2017)
	//4) No actions on DS

	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string seCtrlPowerStatus_attr_name= "seCtrlPowerStatus";
	std::string seCtrlPowerStatusStr= "ON";
	std::string handlerEnabled_attr_name= "enablePowerRestoreEventHandler";

	std::string spfMode_attr_name= "spfOperatingMode";
	std::string spfModeStr= "STANDBY-LP";
	std::string rxMode_attr_name= "rxOperatingMode";
	std::string rxModeStr= "STANDBY-LP";
	std::string spfPowerEnabled_attr_name= "spfcPowerEnabled";
	Tango::DevBoolean spfPowerEnabled= true;
	std::string rxPowerEnabled_attr_name= "rxpuPowerEnabled";
	Tango::DevBoolean rxPowerEnabled= true;

	//Task vars
	std::vector<std::string> taskSequenceStartedMsg {"IDLE","Dish startup on power restore scheduled"};
	std::vector<std::string> taskAlreadyCompletedMsg {"COMPLETED","Dish startup on power restored completed."};
	std::vector<std::string> taskSequence_progress_ongoing= {"INIT","IDLE","RUNNING"};

	std::string taskSequence_name= "StartupOnPowerRestore";
	std::string taskSequence_progress_attr_name= "startupOnPowerRestoreProgress";

	//- Rx task
	std::string rx_task1_name= "PowerOnRXPUTask";
	
	//- SPF tasks
	std::string spf_task1_name= "PowerOnSPFCTask";	
	
	std::vector<std::string> revokedTask_names {
		"ShutdownRXPUTask",
		"PowerOffRXPUTask",
		"ShutdownSPFCTask",
		"PowerOffSPFCTask"
	};
	//###########################################################################

	//=====================================================
	//==      CHECK HANDLER ENABLED/DISABLED
	//=====================================================
	//## Check if event handling is enabled
	Tango::DevBoolean handlerEnabled;
	if(GetDynAttrValue(handlerEnabled,handlerEnabled_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get dyn attr "<<handlerEnabled_attr_name<<" value!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("HANDLE_POWER_RESTORE_EVENT_FAILED",ss.str());		
	}
	if(!handlerEnabled) {
		_DEBUG_LOG("Power cut event handler is disabled, will not handle the event");
		return;
	}

	//=====================================================
	//==      CHECK & EXTRACT TASK DATA
	//=====================================================
	//Extract argin encoded data to TaskData
	_DEBUG_LOG("Parsing argin json encoded TaskData...");
	std::string argin_json_str(argin);
	Utils_ns::TaskData taskData;
	if(Utils_ns::TaskUtils::ParseFromJsonString(taskData,this,argin_json_str)<0){
		std::string errMsg("Failed to parse argin json string to TaskData for HandlePowerRestoreEvent() command!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("HANDLE_POWER_RESTORE_EVENT_FAILED",errMsg);
	}

	_DEBUG_LOG("Executing cmd="<<taskData.name<<", id="<<taskData.id<<", has_data? "<<taskData.has_data);
	
	//Check if has argin data
	if(!taskData.has_data){
		std::string errMsg("No argin data present (expecting a bool arg)!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("HANDLE_POWER_RESTORE_EVENT_FAILED",errMsg);
	}

	//Extract argin task data
	bool isPowerRestore= false;
	if(taskData.GetData<Tango::DevBoolean>(isPowerRestore)<0){
		std::string errMsg("Failed to extract data value in TaskData (check data type?)!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("HANDLE_POWER_RESTORE_EVENT_FAILED",errMsg);		
	}
	_DEBUG_LOG("Executing cmd="<<taskData.name<<", id="<<taskData.id<<", has_data? "<<taskData.has_data<<", data="<<isPowerRestore);
	

	//Skip if not power restore
	//NB: This should not occur but check anyway!!!	
	if(!isPowerRestore){
		_DEBUG_LOG("Received a power restore event (powerRestore=false) (hint: can be the periodic event), do not process event!");
		return;
	}

	//=====================================================
	//==      CHECK IF TASK IS ALREADY QUEUED/RUNNING
	//=====================================================
	_DEBUG_LOG("Check if a previous StartupOnPowerRestore task is already running...");
	std::vector<std::string> taskProgress;
	if(GetDynAttrValue(taskProgress,taskSequence_progress_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<taskSequence_progress_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("HANDLE_POWER_RESTORE_EVENT_FAILED",ss.str());	
	}
	if(taskProgress.size()<2){
		std::stringstream ss;
		ss<<"Invalid size for attr "<<taskSequence_progress_attr_name<<" value (expected at least equal to 2)!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("HANDLE_POWER_RESTORE_EVENT_FAILED",ss.str());	
	}

	std::string taskProgressStr= taskProgress[0];
	
	//Check if another task is already running
	bool isTaskRunning= false;
	for(size_t i=0;i<taskSequence_progress_ongoing.size();i++){
		if(taskProgressStr==taskSequence_progress_ongoing[i]){
			isTaskRunning= true;
			break;
		}
	}//end loop config busy codes

	if(isTaskRunning) {
		_INFO_LOG("Shutdown task is already scheduled/ongoing (e.g. thanks for the power restore event but I'm already processing it)...");
		return;
	}

	//=====================================================
	//==      CHECK IF EVENT WAS ALREADY HANDLED
	//=====================================================
	//## Get current se controller power status attr value
	Tango::DevShort seCtrlPowerStatus_current;
	if(GetDynAttrValue(seCtrlPowerStatus_current,seCtrlPowerStatus_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get dyn attr "<<seCtrlPowerStatus_attr_name<<" value!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("HANDLE_POWER_RESTORE_EVENT_FAILED",ss.str());		
	}


	//## Retrieve enum labels corresponding to value
	std::string seCtrlPowerStatusStr_current= "";
	if(Utils_ns::TangoUtils::GetEnumAttrLabelValue(seCtrlPowerStatusStr_current,this,seCtrlPowerStatus_attr_name,seCtrlPowerStatus_current)<0){
		std::stringstream ss;
		ss<<"Failed to get enum label for dyn attr "<<seCtrlPowerStatus_attr_name<<" corresponding to value "<<seCtrlPowerStatus_current<<"!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("HANDLE_POWER_RESTORE_EVENT_FAILED",ss.str());	
	}
	
	//## Check if trigger actions given the dish mode 
	bool eventHandled= (
		seCtrlPowerStatusStr_current==seCtrlPowerStatusStr
	);
	if(eventHandled){
		_INFO_LOG("Shutdown task was already handled with success (e.g. thanks for the power cut event but I already processed it) ...");
		return;
	}

	//=====================================================
	//==      REVOKE PENDING SHUTDOWN COMMANDS 
	//=====================================================
	for(size_t i=0;i<revokedTask_names.size();i++){
		_INFO_LOG("Revoking previous startup task "<<revokedTask_names[i]<<" ...");
		try{
			revoke_task((char*)revokedTask_names[i].c_str());
		}
		catch(...){
			_ERROR_LOG("Failed to revoke previous startup task "<<revokedTask_names[i]<<"!");
			throw;
		}
	}//end loop revoked tasks

	//=====================================================
	//==      PREPARE TASKS
	//=====================================================
	
	//Prepare task data
	bool useUTC= false;
	int priority= Utils_ns::Task::eHIGH_PRIORITY;

	//#### Rx TASKS ###### 
	//== TASK 2  (synch): PowerOnRxPuTask
	Utils_ns::TaskPtr rx_task1= std::make_shared<Utils_ns::Task>(this,rx_task1_name,priority,useUTC);
	rx_task1->SetMaxDuration(defaultTaskTimeout*1000.);//Set task timeout
	
	//#### SPF TASKS ###### 
	//== TASK 1 (synch): PowerOnSPFCTask ==	
	Utils_ns::TaskPtr spf_task1= std::make_shared<Utils_ns::Task>(this,spf_task1_name,priority,useUTC);
	spf_task1->SetMaxDuration(defaultTaskTimeout*1000.);//Set task timeout
		
	std::vector<Utils_ns::TaskPtr> tasks;
	tasks.push_back(rx_task1);
	tasks.push_back(spf_task1);

	//Add tasks to sequence
	Utils_ns::TaskSequencePtr taskSequence= std::make_shared<Utils_ns::TaskSequence>(this,taskSequence_name,useUTC);
	taskSequence->SetDevStatusAttr(taskSequence_progress_attr_name);//Set device attr containing task sequence status

	for(size_t i=0;i<tasks.size();i++){
		if(taskSequence->AddTask(tasks[i])<0){
			std::stringstream ss;
			ss<<"Failed to add task "<<i+1<<" (name="<<tasks[i]->cmd_name<<") to sequence!";
			_WARN_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("HANDLE_POWER_RESTORE_EVENT_FAILED",ss.str());			
		}
	}//end loop tasks
	
	//=====================================================
	//==      SCHEDULE TASKS
	//=====================================================
	//Add task to queue 
	bool addToQueue= true;
	if(m_taskManager->AddTaskSequence(taskSequence,addToQueue)<0){
		std::stringstream ss;
		ss<<"Failed to add task sequence "<<taskSequence_name<<" to queue!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("HANDLE_POWER_RESTORE_EVENT_FAILED",ss.str());
	}
	_INFO_LOG("Scheduled task "<<taskSequence_name<<" ...");
	
	//=====================================================
	//==      SET TASK SEQUENCE STATUS TO IDLE
	//=====================================================
	//Set task progress attr to IDLE
	if(SetDynAttrValue(taskSequenceStartedMsg,taskSequence_progress_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<taskSequence_progress_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("HANDLE_POWER_RESTORE_EVENT_FAILED",ss.str());	
	}	

	/*----- PROTECTED REGION END -----*/	//	DishManager::handle_power_restore_event
}
//--------------------------------------------------------
/**
 *	Command HandleTMCommLossEvent related method
 *	Description: Handler cmd for TM communication loss event.
 *               Performs the following actions:
 *               
 *               - Flush the command queue
 *               - Reset task progress attributes for mode transitions
 *               - Command DS to go to STOW
 *
 */
//--------------------------------------------------------
void DishManager::handle_tmcomm_loss_event()
{
	DEBUG_STREAM << "DishManager::HandleTMCommLossEvent()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::handle_tmcomm_loss_event) ENABLED START -----*/
	
	//	Add your own code
	// == COMMAND BEHAVIOR ==
	//1) Flush task queue and reset correspodning progress attributes
	//2) Set DS to STOW (R.LMC.FMS.2)
	//3) No actions on SPF & SPFRx

	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	//...
	//...
	//###########################################################################

	_INFO_LOG("Requested to handle a TM comm loss event...");

	//## Reset dish tasks
	try{
		reset_dish_tasks();
	}
	catch(...){
		_ERROR_LOG("Failed to reset dish tasks!");
		throw;
	}

	//## Command DS to STOW
	_INFO_LOG("Commanding DS to go to STOW mode to handle TM comm loss...");
	try{
		set_dsstow_mode();
	}
	catch(...){
		_ERROR_LOG("Failed to command/schedule DS stow mode!");
		throw;
	}
	
	/*----- PROTECTED REGION END -----*/	//	DishManager::handle_tmcomm_loss_event
}
//--------------------------------------------------------
/**
 *	Command HandleBandInFocusEvent related method
 *	Description: Handle indexer position change event from DS.
 *               Set band in focus attr in SPF when notified by DS that
 *               a new band is in focus.
 *
 *	@param argin 
 */
//--------------------------------------------------------
void DishManager::handle_band_in_focus_event(Tango::DevString argin)
{
	DEBUG_STREAM << "DishManager::HandleBandInFocusEvent()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::handle_band_in_focus_event) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	int nBands= 5;
	//===========================================================================

	//=====================================================
	//==      CHECK & EXTRACT TASK DATA
	//=====================================================
	//Extract argin encoded data to TaskData
	_DEBUG_LOG("Parsing argin json encoded TaskData...");
	std::string argin_json_str(argin);
	Utils_ns::TaskData taskData;
	if(Utils_ns::TaskUtils::ParseFromJsonString(taskData,this,argin_json_str)<0){
		std::string errMsg("Failed to parse argin json string to TaskData for Task_PowerLNA() command!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("HANDLE_BAND_IN_FOCUS_EVENT_FAILED",errMsg);
	}

	_DEBUG_LOG("Executing cmd="<<taskData.name<<", id="<<taskData.id<<", has_data? "<<taskData.has_data);
	
	//Check if has argin data
	if(!taskData.has_data){
		std::string errMsg("No argin data present (expecting a bool arg)!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("HANDLE_BAND_IN_FOCUS_EVENT_FAILED",errMsg);
	}

	//Extract argin task data
	Tango::DevShort indexerPosition;
	if(taskData.GetData<Tango::DevShort>(indexerPosition)<0){
		std::string errMsg("Failed to extract data value in TaskData (check data type?)!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("HANDLE_BAND_IN_FOCUS_EVENT_FAILED",errMsg);		
	}
	_DEBUG_LOG("Executing cmd="<<taskData.name<<", id="<<taskData.id<<", has_data? "<<taskData.has_data<<", data="<<indexerPosition);
	
	//Check if invalid position is received (e.g. MOVING, ERROR, UNKNOWN) (FILL ME!!!!)
	if(indexerPosition<=0 || indexerPosition>nBands){
		std::stringstream ss;
		ss<<"Indexer position event received ("<<indexerPosition<<") shall be in range [1,5] to set band in focus (NB: this is not an error if MOVING or UNKNOWN position received), no action will be commanded on SPF.";
		_DEBUG_LOG(ss.str());
		return;
	}
	
	//=====================================================
	//==      EXECUTE TASK
	//=====================================================
	//Set SPF band in focus
	_INFO_LOG("Setting SPF band in focus to "<<indexerPosition<<"...");	
	try {
		set_spfband_in_focus(indexerPosition);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Tango exception occurred while setting SPF band in focus!");
		throw;
	}
	

	/*----- PROTECTED REGION END -----*/	//	DishManager::handle_band_in_focus_event
}
//--------------------------------------------------------
/**
 *	Command FlushCommandQueue related method
 *	Description: Flush the command queue (all queued command will be 
 *               removed).
 *
 */
//--------------------------------------------------------
void DishManager::flush_command_queue()
{
	DEBUG_STREAM << "DishManager::FlushCommandQueue()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::flush_command_queue) ENABLED START -----*/
	
	//	Add your own code
	try{
		flush_task_queue();
	}
	catch(...){
		throw;
	}
	/*----- PROTECTED REGION END -----*/	//	DishManager::flush_command_queue
}
//--------------------------------------------------------
/**
 *	Command SetRxStandbyLPMode related method
 *	Description: Set SPFRx to its STANDBY-LP mode. 
 *               Command mainly for testing purposes.
 *               Allowed only in SPFRx modes {STANDBY-LP, STANDBY-FP, MAINTENANCE}
 *
 */
//--------------------------------------------------------
void DishManager::set_rx_standby_lpmode()
{
	DEBUG_STREAM << "DishManager::SetRxStandbyLPMode()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::set_rx_standby_lpmode) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string cmd_name= "SetStandbyLPMode";
	std::string proxy_name= rxControllerAddress;
	//###########################################################################

	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	_INFO_LOG("Setting SPFRx to STANDBY-LP mode");
	try {
		ExecCmdOnProxy(proxy_name,cmd_name);
	}
	catch(...){
		throw;
	}

	/*----- PROTECTED REGION END -----*/	//	DishManager::set_rx_standby_lpmode
}
//--------------------------------------------------------
/**
 *	Command SetRxStandbyLPModeTask related method
 *	Description: Set Rx to STANDBY-LP mode
 *
 *	@param argin Task encoded data
 */
//--------------------------------------------------------
void DishManager::set_rx_standby_lpmode_task(Tango::DevString argin)
{
	DEBUG_STREAM << "DishManager::SetRxStandbyLPModeTask()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::set_rx_standby_lpmode_task) ENABLED START -----*/
	
	//	Add your own code
	_INFO_LOG("Starting SPFRx set STANDBY-LP mode task...");

	//=====================================================
	//==      CHECK & EXTRACT TASK DATA
	//=====================================================
	//Extract argin encoded data to TaskData
	_DEBUG_LOG("Parsing argin json encoded TaskData...");
	std::string argin_json_str(argin);
	Utils_ns::TaskData taskData;
	if(Utils_ns::TaskUtils::ParseFromJsonString(taskData,this,argin_json_str)<0){
		std::string errMsg("Failed to parse argin json string to TaskData!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("SET_RX_STANDBY_LP_MODE_TASK_FAILED",errMsg);
	}

	_DEBUG_LOG("Executing cmd="<<taskData.name<<", id="<<taskData.id<<", has_data? "<<taskData.has_data);
	
	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	try {
		set_rx_standby_lpmode();
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Tango exception occurred while commanding SPFRx to go to STANDBY-LP mode ");
		throw;
	}

	/*----- PROTECTED REGION END -----*/	//	DishManager::set_rx_standby_lpmode_task
}
//--------------------------------------------------------
/**
 *	Command SetRxStandbyFPMode related method
 *	Description: Set SPFRx STANDBY-FP mode.
 *               Command mainly used for testing.
 *               Allowed only in SPFRx modes: {STANDBY-LP,STANDBY-FP,MAINTENANCE,CONFIGURE,DATA-CAPTURE}
 *
 */
//--------------------------------------------------------
void DishManager::set_rx_standby_fpmode()
{
	DEBUG_STREAM << "DishManager::SetRxStandbyFPMode()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::set_rx_standby_fpmode) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string cmd_name= "SetStandbyFPMode";
	std::string proxy_name= rxControllerAddress;
	//###########################################################################

	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	_INFO_LOG("Setting SPFRx to STANDBY-FP mode");
	try {
		ExecCmdOnProxy(proxy_name,cmd_name);
	}
	catch(...){
		throw;
	}

	/*----- PROTECTED REGION END -----*/	//	DishManager::set_rx_standby_fpmode
}
//--------------------------------------------------------
/**
 *	Command SetRxStandbyFPModeTask related method
 *	Description: Command task to set SPFRx to STANDBY-FP mode
 *
 *	@param argin 
 */
//--------------------------------------------------------
void DishManager::set_rx_standby_fpmode_task(Tango::DevString argin)
{
	DEBUG_STREAM << "DishManager::SetRxStandbyFPModeTask()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::set_rx_standby_fpmode_task) ENABLED START -----*/
	
	//	Add your own code
	_INFO_LOG("Starting SPFRx set STANDBY-FP mode task...");

	//=====================================================
	//==      CHECK & EXTRACT TASK DATA
	//=====================================================
	//Extract argin encoded data to TaskData
	_DEBUG_LOG("Parsing argin json encoded TaskData...");
	std::string argin_json_str(argin);
	Utils_ns::TaskData taskData;
	if(Utils_ns::TaskUtils::ParseFromJsonString(taskData,this,argin_json_str)<0){
		std::string errMsg("Failed to parse argin json string to TaskData!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("SET_RX_STANDBY_FP_MODE_TASK_FAILED",errMsg);
	}

	_DEBUG_LOG("Executing cmd="<<taskData.name<<", id="<<taskData.id<<", has_data? "<<taskData.has_data);
	
	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	try {
		set_rx_standby_fpmode();
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Tango exception occurred while commanding SPFRx to go to STANDBY-FP mode ");
		throw;
	}

	/*----- PROTECTED REGION END -----*/	//	DishManager::set_rx_standby_fpmode_task
}
//--------------------------------------------------------
/**
 *	Command SetRxMaintenanceMode related method
 *	Description: Set SPFRx to MAINTENANCE mode.
 *               Command mainly used for testing. 
 *               Allowed only in SPFRx modes: {STANDBY-LP, STANDBY-FP, MAINTENANCE, DATA-CAPTURE}
 *
 */
//--------------------------------------------------------
void DishManager::set_rx_maintenance_mode()
{
	DEBUG_STREAM << "DishManager::SetRxMaintenanceMode()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::set_rx_maintenance_mode) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string cmd_name= "SetMaintenanceMode";
	std::string proxy_name= rxControllerAddress;
	//###########################################################################

	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	_INFO_LOG("Setting SPFRx to MAINTENANCE mode");
	try {
		ExecCmdOnProxy(proxy_name,cmd_name);
	}
	catch(...){
		throw;
	}
	/*----- PROTECTED REGION END -----*/	//	DishManager::set_rx_maintenance_mode
}
//--------------------------------------------------------
/**
 *	Command SetRxMaintenanceModeTask related method
 *	Description: Command task to set SPFRx to MAINTENANCE mode
 *
 *	@param argin 
 */
//--------------------------------------------------------
void DishManager::set_rx_maintenance_mode_task(Tango::DevString argin)
{
	DEBUG_STREAM << "DishManager::SetRxMaintenanceModeTask()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::set_rx_maintenance_mode_task) ENABLED START -----*/
	
	//	Add your own code
	_INFO_LOG("Starting SPFRx set MAINTENANCE mode task...");

	//=====================================================
	//==      CHECK & EXTRACT TASK DATA
	//=====================================================
	//Extract argin encoded data to TaskData
	_DEBUG_LOG("Parsing argin json encoded TaskData...");
	std::string argin_json_str(argin);
	Utils_ns::TaskData taskData;
	if(Utils_ns::TaskUtils::ParseFromJsonString(taskData,this,argin_json_str)<0){
		std::string errMsg("Failed to parse argin json string to TaskData!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("SET_RX_MAINTENANCE_MODE_TASK_FAILED",errMsg);
	}

	_DEBUG_LOG("Executing cmd="<<taskData.name<<", id="<<taskData.id<<", has_data? "<<taskData.has_data);
	
	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	try {
		set_rx_maintenance_mode();
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Tango exception occurred while commanding SPFRx to go to MAINTENANCE mode ");
		throw;
	}

	/*----- PROTECTED REGION END -----*/	//	DishManager::set_rx_maintenance_mode_task
}
//--------------------------------------------------------
/**
 *	Command ConfigureRxBand related method
 *	Description: Configure band in Rx sub-element.
 *               Command allowed only in spfrx modes: {STANDBY-FP, DATA-CAPTURE, MAINTENANCE}
 *
 *	@param argin Band id
 */
//--------------------------------------------------------
void DishManager::configure_rx_band(Tango::DevShort argin)
{
	DEBUG_STREAM << "DishManager::ConfigureRxBand()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::configure_rx_band) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::vector<std::string> cmd_names {
		"ConfigureBand1",
		"ConfigureBand2",
		"ConfigureBand3",
		"ConfigureBand4",
		"ConfigureBand5a",
		"ConfigureBand5b",
	};
	std::string proxy_name= rxControllerAddress;
	int nBands= static_cast<int>(cmd_names.size());//NB: bands are {1,2,3,4,5a,5b}
	//###########################################################################

	//=====================================================
	//==         CHECK IF CMD ALLOWED
	//=====================================================
	//This is done here and not in the StateMachine file, because this is called by the corresponding task command
	//which does not call the is_ConfigureRxBand_allowed() method
	_DEBUG_LOG("Check if cmd "<<__FUNCTION__<<" is allowed...");
	bool check_cmd= true;
	try {
		IsCmdAllowed(__FUNCTION__,check_cmd);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		throw;
	}

	//=====================================================
	//==      CHECK ARGIN
	//=====================================================	
	//Check band id
	Tango::DevShort bandId= argin;
	if(bandId<=0 || bandId>nBands){
		std::stringstream ss;
		ss<<"Invalid bandId argument given ("<<bandId<<"), must be in the range [1,"<<nBands<<"]!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("CONFIGURE_RX_BAND_FAILED",ss.str());	
	}
	
	_INFO_LOG("Requested to configure band "<<bandId<<" on SPFRx ...");

	//=====================================================
	//==      EXECUTE CONFIGURE COMMAND
	//=====================================================
	//Execute command
	try {
		ExecCmdOnProxy(proxy_name,cmd_names[bandId-1]);
	}
	catch(...){
		throw;
	}

	/*----- PROTECTED REGION END -----*/	//	DishManager::configure_rx_band
}
//--------------------------------------------------------
/**
 *	Command ConfigureRxBandAsync related method
 *	Description: Configure band in Rx sub-element.
 *               NB: This is the long running command version originally 
 *               intended to be used by Rx sub-element. In latest ICD 
 *               the configuration task has been marked as non long-running,
 *               so consider this as DEPRECATED.
 *
 *	@param argin Band id
 *	@returns == Long field ==
 *           [0]: ack code (0=OK, 1=QUEUED, 2=FAILED)
 *           
 *           == String field ==
 *           [0]: Informative message or error/fault description
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *DishManager::configure_rx_band_async(Tango::DevShort argin)
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "DishManager::ConfigureRxBandAsync()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::configure_rx_band_async) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string cmd_name= "ConfigureBandAsync";
	std::string proxy_name= rxControllerAddress;	
	int nBands= 6;//NB: bands are {1,2,3,4,5a,5b}
	//###########################################################################

	//=====================================================
	//==         CHECK IF CMD ALLOWED
	//=====================================================
	_DEBUG_LOG("Check if cmd "<<__FUNCTION__<<" is allowed...");
	bool check_cmd= true;
	try {
		IsCmdAllowed(__FUNCTION__,check_cmd);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		throw;
	}

	//=====================================================
	//==      CHECK & EXTRACT TASK DATA
	//=====================================================	
	//Check band id
	Tango::DevShort bandId= argin;
	if(bandId<=0 || bandId>nBands){
		std::stringstream ss;
		ss<<"Invalid bandId argument given ("<<bandId<<"), must be in the range [1,"<<nBands<<"]!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("CONFIGURE_RX_BAND_ASYNC_FAILED",ss.str());	
	}
	
	_INFO_LOG("Requested to configure band "<<bandId<<" on SPFRx ...");

	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	//Set command argin 
	Tango::DeviceData din;
 	din << bandId;

	//Execute command
	Tango::DeviceData dout;
	try {
		ExecCmdOnProxy(dout,proxy_name,cmd_name,din);
	}
	catch(...){
		throw;
	}

	//Extract command reply
	std::vector<Tango::DevLong> reply_lvalues;
	std::vector<std::string> reply_svalues;
	if(!dout.extract(reply_lvalues, reply_svalues)){
		std::stringstream ss;
		ss<<"Failed to extract command reply data received from SPFRx!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("CONFIGURE_RX_BAND_ASYNC_FAILED",ss.str());	
	}
	
	//Set output argument
	argout= new Tango::DevVarLongStringArray;
	argout->svalue.length(reply_svalues.size());
	argout->lvalue.length(reply_lvalues.size());

	for(unsigned int i=0;i<reply_lvalues.size();i++){
		argout->lvalue[i] = reply_lvalues[i];
	}
	for(unsigned int i=0;i<reply_svalues.size();i++){
		argout->svalue[i] = CORBA::string_dup(reply_svalues[i].c_str());
	}
	
	/*----- PROTECTED REGION END -----*/	//	DishManager::configure_rx_band_async
	return argout;
}
//--------------------------------------------------------
/**
 *	Command ConfigureRxBandTask related method
 *	Description: Configure band in Rx
 *
 *	@param argin Task encoded data
 */
//--------------------------------------------------------
void DishManager::configure_rx_band_task(Tango::DevString argin)
{
	DEBUG_STREAM << "DishManager::ConfigureRxBandTask()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::configure_rx_band_task) ENABLED START -----*/
	
	//	Add your own code
	
	//=====================================================
	//==      CHECK & EXTRACT TASK DATA
	//=====================================================
	//Extract argin encoded data to TaskData
	_DEBUG_LOG("Parsing argin json encoded TaskData...");
	std::string argin_json_str(argin);
	Utils_ns::TaskData taskData;
	if(Utils_ns::TaskUtils::ParseFromJsonString(taskData,this,argin_json_str)<0){
		std::string errMsg("Failed to parse argin json string to TaskData!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("CONFIGURE_RX_BAND_TASK_FAILED",errMsg);
	}

	_DEBUG_LOG("Executing cmd="<<taskData.name<<", id="<<taskData.id<<", has_data? "<<taskData.has_data);
	
	//Check if has argin data
	if(!taskData.has_data){
		std::string errMsg("No argin data present (expecting a DevShort arg)!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("CONFIGURE_RX_BAND_TASK_FAILED",errMsg);
	}

	//Extract argin task data
	Tango::DevShort bandId;
	if(taskData.GetData<Tango::DevShort>(bandId)<0){
		std::string errMsg("Failed to extract data value in TaskData (check data type?)!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("CONFIGURE_RX_BAND_TASK_FAILED",errMsg);		
	}

	_INFO_LOG("Executing command task "<<taskData.name<<" (id="<<taskData.id<<", has_data? "<<taskData.has_data<<", argin="<<bandId<<")");
	
	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	try{
		configure_rx_band(bandId);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Tango exception occurred when commanding Rx band configuration!");
		throw;
	}
	
	/*----- PROTECTED REGION END -----*/	//	DishManager::configure_rx_band_task
}
//--------------------------------------------------------
/**
 *	Command ConfigureAndSynchroniseRxBand related method
 *	Description: Configure and synchronize SPFRx band. 
 *               This performs configuration and at completion run synchronize
 *               on SPFRx.
 *
 *	@param argin Band id {1=B1,2=B2,3=B3,4=B4,5=B5a,6=B5b}
 */
//--------------------------------------------------------
void DishManager::configure_and_synchronise_rx_band(Tango::DevShort argin)
{
	DEBUG_STREAM << "DishManager::ConfigureAndSynchroniseRxBand()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::configure_and_synchronise_rx_band) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string configure_cmd_name= "ConfigureBand";
	std::string synchronize_cmd_name= "Synchronise";
	std::string proxy_name= rxControllerAddress;
	int nBands= 6;//NB: bands are {1,2,3,4,5a,5b}
	//###########################################################################

	//=====================================================
	//==         CHECK IF CMD ALLOWED
	//=====================================================
	//This is done here and not in the StateMachine file, because this is called by the corresponding task command
	//which does not call the is_ConfigureRxBand_allowed() method
	_DEBUG_LOG("Check if cmd "<<__FUNCTION__<<" is allowed...");
	bool check_cmd= true;
	try {
		IsCmdAllowed(__FUNCTION__,check_cmd);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		throw;
	}

	//=====================================================
	//==      CHECK ARGIN
	//=====================================================	
	//Check band id
	Tango::DevShort bandId= argin;
	if(bandId<=0 || bandId>nBands){
		std::stringstream ss;
		ss<<"Invalid bandId argument given ("<<bandId<<"), must be in the range [1,"<<nBands<<"]!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("CONFIGURE_RX_BAND_FAILED",ss.str());	
	}
	
	_INFO_LOG("Requested to configure band "<<bandId<<" on SPFRx ...");

	//=====================================================
	//==      EXECUTE CONFIGURE COMMAND
	//=====================================================
	//Set command argin 
	Tango::DeviceData din;
 	din << bandId;

	//Execute command
	try {
		ExecCmdOnProxy(proxy_name,configure_cmd_name,din);
	}
	catch(...){
		throw;
	}

	//=====================================================
	//==      EXECUTE SYNCHRONIZE COMMAND
	//=====================================================
	//Execute command
	try {
		ExecCmdOnProxy(proxy_name,synchronize_cmd_name,din);
	}
	catch(...){
		throw;
	}

	/*----- PROTECTED REGION END -----*/	//	DishManager::configure_and_synchronise_rx_band
}
//--------------------------------------------------------
/**
 *	Command ConfigureRxAttenuation related method
 *	Description: Set the global attenuation. Changing this value will set 
 *               the attenuation across the system and will be applied to 
 *               all bands.
 *
 *	@param argin Attenuation par in DB
 */
//--------------------------------------------------------
void DishManager::configure_rx_attenuation(Tango::DevFloat argin)
{
	DEBUG_STREAM << "DishManager::ConfigureRxAttenuation()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::configure_rx_attenuation) ENABLED START -----*/
	
	//	Add your own code
	
	// == COMMAND BEHAVIOR ==
	// 1) Check if cmd mode-allowed: Allowed in all modes (see ICD)
	// 2) Call 'AdjustPolHAttenuation/AdjustPolVAttenuation' commands in RxController device (no other actions required on SPF, DS)
	//Issue: power level argument???
	
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::vector<std::string> cmd_names {
		"AdjustPolHAttenuation",
		"AdjustPolVAttenuation"
	};
	std::string proxy_name= rxControllerAddress;
	//===========================================================================
	
	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	_INFO_LOG("Configuring SPFRx attenuation offset on both H/V polarization...");	
	
	for(size_t i=0;i<cmd_names.size();i++){
		//Set command argin 
		Tango::DeviceData din;
  	din << argin;

		//Execute command on proxy
		std::string cmd_name= cmd_names[i];
		try {
			ExecCmdOnProxy(proxy_name,cmd_name,din);
		}
		catch(...){
			throw;
		}
	}//end loop commands

	/*----- PROTECTED REGION END -----*/	//	DishManager::configure_rx_attenuation
}
//--------------------------------------------------------
/**
 *	Command Capture related method
 *	Description: Start/Stop capture on the configured band. 
 *               Command only valide in SPFRx DATA-CAPTURE mode
 *               
 *               Command allowed only in Dish modes:
 *               {OPERATE}
 *
 *	@param argin ON/OFF
 */
//--------------------------------------------------------
void DishManager::capture(Tango::DevBoolean argin)
{
	DEBUG_STREAM << "DishManager::Capture()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::capture) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string cmd_name= "CaptureData";
	std::string proxy_name= rxControllerAddress;
	//===========================================================================
	
	_INFO_LOG("Requested data capture("<<argin<<") on SPFRx...");

	//=====================================================
	//==         CHECK IF CMD ALLOWED
	//=====================================================
	_DEBUG_LOG("Check if cmd "<<__FUNCTION__<<" is allowed...");
	bool check_cmd= true;
	try {
		IsCmdAllowed(__FUNCTION__,check_cmd);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		throw;
	}

	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	//Set argin
	Tango::DeviceData din;
	din<<argin;
	
	//Execute command (no argin expected)
	Tango::DeviceData dout;
	try {
		ExecCmdOnProxy(dout,proxy_name,cmd_name,din);
	}
	catch(...){
		throw;
	}

	/*----- PROTECTED REGION END -----*/	//	DishManager::capture
}
//--------------------------------------------------------
/**
 *	Command StartCapture related method
 *	Description: Start capture on the configured band. 
 *               Command only valid in SPFRx Data_Capture mode.
 *               
 *               Allowed only in OPERATE dish mode
 *
 */
//--------------------------------------------------------
void DishManager::start_capture()
{
	DEBUG_STREAM << "DishManager::StartCapture()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::start_capture) ENABLED START -----*/
	
	//	Add your own code
	
	_INFO_LOG("Requested to start data capture on SPFRx...");

	//=====================================================
	//==         CHECK IF CMD ALLOWED
	//=====================================================
	_DEBUG_LOG("Check if cmd "<<__FUNCTION__<<" is allowed...");
	bool check_cmd= true;
	try {
		IsCmdAllowed(__FUNCTION__,check_cmd);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		throw;
	}

	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	try {
		capture(true);
	}
	catch(Tango::DevFailed& e){
		throw;
	}
	catch(std::exception& e){
		throw;
	}
	catch(...){
		throw;
	}


	/*----- PROTECTED REGION END -----*/	//	DishManager::start_capture
}
//--------------------------------------------------------
/**
 *	Command StopCapture related method
 *	Description: Stop capture on the configured band
 *
 */
//--------------------------------------------------------
void DishManager::stop_capture()
{
	DEBUG_STREAM << "DishManager::StopCapture()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::stop_capture) ENABLED START -----*/
	
	//	Add your own code
	_INFO_LOG("Requested to stop data capture on SPFRx...");

	//=====================================================
	//==         CHECK IF CMD ALLOWED
	//=====================================================
	_DEBUG_LOG("Check if cmd "<<__FUNCTION__<<" is allowed...");
	bool check_cmd= true;
	try {
		IsCmdAllowed(__FUNCTION__,check_cmd);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		throw;
	}

	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	try {
		capture(false);
	}
	catch(Tango::DevFailed& e){
		throw;
	}
	catch(std::exception& e){
		throw;
	}
	catch(...){
		throw;
	}

	/*----- PROTECTED REGION END -----*/	//	DishManager::stop_capture
}
//--------------------------------------------------------
/**
 *	Command StartRxCaptureTask related method
 *	Description: Start capture on Rx sub-element
 *
 *	@param argin 
 */
//--------------------------------------------------------
void DishManager::start_rx_capture_task(Tango::DevString argin)
{
	DEBUG_STREAM << "DishManager::StartRxCaptureTask()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::start_rx_capture_task) ENABLED START -----*/
	
	//	Add your own code
	
	//=====================================================
	//==      CHECK & EXTRACT TASK DATA
	//=====================================================
	//Extract argin encoded data to TaskData
	_DEBUG_LOG("Parsing argin json encoded TaskData...");
	std::string argin_json_str(argin);
	Utils_ns::TaskData taskData;
	if(Utils_ns::TaskUtils::ParseFromJsonString(taskData,this,argin_json_str)<0){
		std::string errMsg("Failed to parse argin json string to TaskData!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("START_RX_CAPTURE_TASK_FAILED",errMsg);
	}

	_INFO_LOG("Executing task command "<<taskData.name<<" (id="<<taskData.id<<", has_data? "<<taskData.has_data<<")...");
	
	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	try{
		start_capture();
	}
	catch(Tango::DevFailed& e){
		throw;
	}
	catch(std::exception& e){
		throw;
	}
	catch(...){
		throw;
	}

	/*----- PROTECTED REGION END -----*/	//	DishManager::start_rx_capture_task
}
//--------------------------------------------------------
/**
 *	Command Synchronise related method
 *	Description: Reset configured band sample counters. 
 *               Command only valid in SPFRx Data_Capture mode.
 *               
 *               Command allowed only in DIsh modes:
 *               {OPERATE}
 *
 */
//--------------------------------------------------------
void DishManager::synchronise()
{
	DEBUG_STREAM << "DishManager::Synchronise()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::synchronise) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string cmd_name= "Synchronise";
	//===========================================================================
	
	_INFO_LOG("Requested to reset configured band sample counters on SPFRx ...");

	//=====================================================
	//==         CHECK IF CMD ALLOWED
	//=====================================================
	_DEBUG_LOG("Check if cmd "<<__FUNCTION__<<" is allowed...");
	bool check_cmd= true;
	try {
		IsCmdAllowed(__FUNCTION__,check_cmd);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		throw;
	}

	//=====================================================
	//==          EXECUTE COMMAND
	//=====================================================
	//Check if proxy is registered in list
	std::string full_proxy_name= rxControllerAddress;
	if( !m_proxyManager->FindProxy(full_proxy_name) ){
		_WARN_LOG("Proxy "<<full_proxy_name<<" not found in registered proxy list, trying with alias name...");
		
		//Get full proxy name corresponding to alias
		if(Utils_ns::TangoUtils::GetFQDNDeviceNameFromAlias(full_proxy_name,rxControllerAddress)<0){
			std::stringstream ss;
			ss<<"Failed to retrieve full proxy name from alias "<<rxControllerAddress<<"!";
			_WARN_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("SYNCHRONISE_FAILED",ss.str());	
		}
	}
	
	//Execute command (no argin, no argout expected)
	Tango::DeviceData dout;
	try {
		m_proxyManager->ExecuteCommand(dout,full_proxy_name,cmd_name);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		std::stringstream ss;
		ss<<"Tango exception occurred while executing command "<<cmd_name<<" on proxy "<<full_proxy_name<<" (check proxy registered or syntax)!";
		_WARN_LOG(ss.str());
		throw;
	}
	catch(std::exception& e){
		std::stringstream ss;
		ss<<"C++ exception occurred while executing command "<<cmd_name<<" on proxy "<<full_proxy_name<<" (err="<<e.what()<<")!";
		_WARN_LOG(ss.str());
		throw;
	}
	catch(...){
		std::stringstream ss;
		ss<<"Unknown exception occurred while executing command "<<cmd_name<<" on proxy "<<full_proxy_name<<"!";
		_WARN_LOG(ss.str());
		throw;
	}
	

	/*----- PROTECTED REGION END -----*/	//	DishManager::synchronise
}
//--------------------------------------------------------
/**
 *	Command SynchroniseRxBandTask related method
 *	Description: Synchronise Rx band
 *
 *	@param argin Task encoded data
 */
//--------------------------------------------------------
void DishManager::synchronise_rx_band_task(Tango::DevString argin)
{
	DEBUG_STREAM << "DishManager::SynchroniseRxBandTask()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::synchronise_rx_band_task) ENABLED START -----*/
	
	//	Add your own code
	
	//=====================================================
	//==      CHECK & EXTRACT TASK DATA
	//=====================================================
	//Extract argin encoded data to TaskData
	_DEBUG_LOG("Parsing argin json encoded TaskData...");
	std::string argin_json_str(argin);
	Utils_ns::TaskData taskData;
	if(Utils_ns::TaskUtils::ParseFromJsonString(taskData,this,argin_json_str)<0){
		std::string errMsg("Failed to parse argin json string to TaskData!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("SYNCHRONISE_RX_BAND_FAILED",errMsg);
	}

	_DEBUG_LOG("Executing cmd="<<taskData.name<<", id="<<taskData.id<<", has_data? "<<taskData.has_data);
	
	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	try {
		synchronise();
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Tango exception occurred while commanding rx to synchronize band");
		throw;
	}

	/*----- PROTECTED REGION END -----*/	//	DishManager::synchronise_rx_band_task
}
//--------------------------------------------------------
/**
 *	Command EnableRxEngineeringMode related method
 *	Description: Enable/disable the SPFRx engineering mode.
 *               NB: When enabled will allow to modify/fine-tune some receiver
 *               parameters (e.g. attenuation, etc). Not to be confused with
 *               receiver MAINTENANCE mode which is intended only
 *               for software/firmware update.
 *
 *	@param argin enable/disable
 */
//--------------------------------------------------------
void DishManager::enable_rx_engineering_mode(Tango::DevBoolean argin)
{
	DEBUG_STREAM << "DishManager::EnableRxEngineeringMode()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::enable_rx_engineering_mode) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string cmd_name= "EnableEngineeringMode";
	std::string proxy_name= rxControllerAddress;
	//###########################################################################

	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	if(argin) _INFO_LOG("Enabling SPFRx engineering mode");
	else _INFO_LOG("Disabling SPFRx engineering mode");

	Tango::DeviceData din;
  din << argin;

	try {
		ExecCmdOnProxy(proxy_name,cmd_name,din);
	}
	catch(...){
		throw;
	}
	

	/*----- PROTECTED REGION END -----*/	//	DishManager::enable_rx_engineering_mode
}
//--------------------------------------------------------
/**
 *	Command ShutdownRXPU related method
 *	Description: Shutdown Rx controller
 *
 */
//--------------------------------------------------------
void DishManager::shutdown_rxpu()
{
	DEBUG_STREAM << "DishManager::ShutdownRXPU()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::shutdown_rxpu) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string cmd_name= "Shutdown";
	std::string proxy_name= rxControllerAddress;
	//===========================================================================
	
	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	_INFO_LOG("Shutting down SPFC");
	Tango::DeviceData dout;
	try {
		ExecCmdOnProxy(dout,proxy_name,cmd_name);
	}
	catch(...){
		throw;
	}
	/*----- PROTECTED REGION END -----*/	//	DishManager::shutdown_rxpu
}
//--------------------------------------------------------
/**
 *	Command ShutdownRXPUTask related method
 *	Description: Shutdown SPFRx controller
 *
 *	@param argin Task data
 */
//--------------------------------------------------------
void DishManager::shutdown_rxputask(Tango::DevString argin)
{
	DEBUG_STREAM << "DishManager::ShutdownRXPUTask()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::shutdown_rxputask) ENABLED START -----*/
	
	//	Add your own code
	//=====================================================
	//==      CHECK & EXTRACT TASK DATA
	//=====================================================
	//Extract argin encoded data to TaskData
	_DEBUG_LOG("Parsing argin json encoded TaskData...");
	std::string argin_json_str(argin);
	Utils_ns::TaskData taskData;
	if(Utils_ns::TaskUtils::ParseFromJsonString(taskData,this,argin_json_str)<0){
		std::string errMsg("Failed to parse argin json string to TaskData!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("SHUTDOWN_RXPU_TASK_FAILED",errMsg);
	}

	_DEBUG_LOG("Executing task command "<<taskData.name<<" (id="<<taskData.id<<", has_data? "<<taskData.has_data<<")...");
	
	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	try {
		shutdown_rxpu();
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Tango exception occurred while commanding SPFRx to shutdown!");
		throw;
	}

	/*----- PROTECTED REGION END -----*/	//	DishManager::shutdown_rxputask
}
//--------------------------------------------------------
/**
 *	Command PowerOffRXPU related method
 *	Description: Power off the RXPU from the PDU interface
 *
 */
//--------------------------------------------------------
void DishManager::power_off_rxpu()
{
	DEBUG_STREAM << "DishManager::PowerOffRXPU()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::power_off_rxpu) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string cmd_name= "SPFRx_OFF";
	std::string proxy_name= pduManagerAddress;
	//===========================================================================
	
	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	_INFO_LOG("Powering off RXPU ...");
	Tango::DeviceData dout;
	try {
		ExecCmdOnProxy(dout,proxy_name,cmd_name);
	}
	catch(...){
		throw;
	}
	/*----- PROTECTED REGION END -----*/	//	DishManager::power_off_rxpu
}
//--------------------------------------------------------
/**
 *	Command PowerOnRXPU related method
 *	Description: Power on RXPU from the PDU interface
 *
 */
//--------------------------------------------------------
void DishManager::power_on_rxpu()
{
	DEBUG_STREAM << "DishManager::PowerOnRXPU()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::power_on_rxpu) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string cmd_name= "SPFRx_ON";
	std::string proxy_name= pduManagerAddress;
	//===========================================================================
	
	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	_INFO_LOG("Powering on RXPU ...");
	Tango::DeviceData dout;
	try {
		ExecCmdOnProxy(dout,proxy_name,cmd_name);
	}
	catch(...){
		throw;
	}
	/*----- PROTECTED REGION END -----*/	//	DishManager::power_on_rxpu
}
//--------------------------------------------------------
/**
 *	Command PowerOffRXPUTask related method
 *	Description: Power off the Rx controller from the PDU interface.
 *               Typically invoked by the Dish power cut handler cmd.
 *
 *	@param argin Task encoded data
 */
//--------------------------------------------------------
void DishManager::power_off_rxputask(Tango::DevString argin)
{
	DEBUG_STREAM << "DishManager::PowerOffRXPUTask()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::power_off_rxputask) ENABLED START -----*/
	
	//	Add your own code
	//=====================================================
	//==      CHECK & EXTRACT TASK DATA
	//=====================================================
	//Extract argin encoded data to TaskData
	_DEBUG_LOG("Parsing argin json encoded TaskData...");
	std::string argin_json_str(argin);
	Utils_ns::TaskData taskData;
	if(Utils_ns::TaskUtils::ParseFromJsonString(taskData,this,argin_json_str)<0){
		std::string errMsg("Failed to parse argin json string to TaskData!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("POWER_OFF_RXPU_TASK_FAILED",errMsg);
	}

	_DEBUG_LOG("Executing task command "<<taskData.name<<" (id="<<taskData.id<<", has_data? "<<taskData.has_data<<")...");
	
	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	try {
		power_off_rxpu();
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Tango exception occurred while commanding SPFRx to power off!");
		throw;
	}
	/*----- PROTECTED REGION END -----*/	//	DishManager::power_off_rxputask
}
//--------------------------------------------------------
/**
 *	Command PowerOnRXPUTask related method
 *	Description: Power on the Rx controller. 
 *               Typically inkoved by the power restore handler cmd.
 *
 *	@param argin Task encoded data
 */
//--------------------------------------------------------
void DishManager::power_on_rxputask(Tango::DevString argin)
{
	DEBUG_STREAM << "DishManager::PowerOnRXPUTask()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::power_on_rxputask) ENABLED START -----*/
	
	//	Add your own code
	//=====================================================
	//==      CHECK & EXTRACT TASK DATA
	//=====================================================
	//Extract argin encoded data to TaskData
	_DEBUG_LOG("Parsing argin json encoded TaskData...");
	std::string argin_json_str(argin);
	Utils_ns::TaskData taskData;
	if(Utils_ns::TaskUtils::ParseFromJsonString(taskData,this,argin_json_str)<0){
		std::string errMsg("Failed to parse argin json string to TaskData!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("POWER_ON_RXPU_TASK_FAILED",errMsg);
	}

	_DEBUG_LOG("Executing task command "<<taskData.name<<" (id="<<taskData.id<<", has_data? "<<taskData.has_data<<")...");
	
	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	try {
		power_on_rxpu();
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Tango exception occurred while commanding SPFRx to power on!");
		throw;
	}
	/*----- PROTECTED REGION END -----*/	//	DishManager::power_on_rxputask
}
//--------------------------------------------------------
/**
 *	Command SetSPFStandbyLPMode related method
 *	Description: Set the SPF sub-element in its STANDBY-LP mode.
 *               Allowed only in SPF modes {STANDBY-LP, OPERATE, MAINTENANCE}
 *
 *	@returns 
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *DishManager::set_spfstandby_lpmode()
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "DishManager::SetSPFStandbyLPMode()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::set_spfstandby_lpmode) ENABLED START -----*/
	
	//	Add your own code
	
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string cmd_name= "SetStandbyLPMode";
	std::string proxy_name= spfControllerAddress;
	//###########################################################################

	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	_INFO_LOG("Setting SPF to STANDBY-LP mode");
	Tango::DeviceData dout;
	try {
		ExecCmdOnProxy(dout,proxy_name,cmd_name);
	}
	catch(...){
		throw;
	}

	//Extract command reply
	std::vector<Tango::DevLong> reply_lvalues;
	std::vector<std::string> reply_svalues;
	if(!dout.extract(reply_lvalues, reply_svalues)){
		std::stringstream ss;
		ss<<"Failed to extract command reply data received from DS!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_SPF_STANDBY_LP_MODE_FAILED",ss.str());	
	}
	
	//Set output argument
	argout= new Tango::DevVarLongStringArray;
	argout->svalue.length(reply_svalues.size());
	argout->lvalue.length(reply_lvalues.size());

	for(unsigned int i=0;i<reply_lvalues.size();i++){
		argout->lvalue[i] = reply_lvalues[i];
	}
	for(unsigned int i=0;i<reply_svalues.size();i++){
		argout->svalue[i] = CORBA::string_dup(reply_svalues[i].c_str());
	}

	/*----- PROTECTED REGION END -----*/	//	DishManager::set_spfstandby_lpmode
	return argout;
}
//--------------------------------------------------------
/**
 *	Command SetSPFStandbyLPModeTask related method
 *	Description: Set SPF in standby LP mode.
 *               Allowed only in SPF modes {STANDBY-LP, OPERATE, MAINTENANCE}
 *
 *	@param argin Task encoded data
 */
//--------------------------------------------------------
void DishManager::set_spfstandby_lpmode_task(Tango::DevString argin)
{
	DEBUG_STREAM << "DishManager::SetSPFStandbyLPModeTask()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::set_spfstandby_lpmode_task) ENABLED START -----*/
	
	//	Add your own code

	_INFO_LOG("Starting SPF set STANDBY-LP mode task...");

	//=====================================================
	//==      CHECK & EXTRACT TASK DATA
	//=====================================================
	//Extract argin encoded data to TaskData
	_DEBUG_LOG("Parsing argin json encoded TaskData...");
	std::string argin_json_str(argin);
	Utils_ns::TaskData taskData;
	if(Utils_ns::TaskUtils::ParseFromJsonString(taskData,this,argin_json_str)<0){
		std::string errMsg("Failed to parse argin json string to TaskData!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("SET_SPF_STANDBY_LP_MODE_TASK_FAILED",errMsg);
	}

	_DEBUG_LOG("Executing cmd="<<taskData.name<<", id="<<taskData.id<<", has_data? "<<taskData.has_data);
	
	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	try {
		set_spfstandby_lpmode();
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Tango exception occurred while commanding spf to go to STANDBY-LP mode ");
		throw;
	}

	/*----- PROTECTED REGION END -----*/	//	DishManager::set_spfstandby_lpmode_task
}
//--------------------------------------------------------
/**
 *	Command SetSPFOperateMode related method
 *	Description: Set SPF sub-element in its OPERATE mode.
 *
 *	@returns == Long field ==
 *           [0]: ack code (0=OK, 1=QUEUED, 2=FAILED)
 *           
 *           == String field ==
 *           [0]: Informative message or error/fault description
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *DishManager::set_spfoperate_mode()
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "DishManager::SetSPFOperateMode()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::set_spfoperate_mode) ENABLED START -----*/
	
	//	Add your own code

	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string cmd_name= "SetOperateMode";
	std::string proxy_name= spfControllerAddress;
	//###########################################################################

	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	_INFO_LOG("Setting SPF to OPERATE mode");
	Tango::DeviceData dout;
	try {
		ExecCmdOnProxy(dout,proxy_name,cmd_name);
	}
	catch(...){
		throw;
	}

	//Extract command reply
	std::vector<Tango::DevLong> reply_lvalues;
	std::vector<std::string> reply_svalues;
	if(!dout.extract(reply_lvalues, reply_svalues)){
		std::stringstream ss;
		ss<<"Failed to extract command reply data received from DS!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_SPF_OPERATE_MODE_FAILED",ss.str());	
	}
	
	//Set output argument
	argout= new Tango::DevVarLongStringArray;
	argout->svalue.length(reply_svalues.size());
	argout->lvalue.length(reply_lvalues.size());

	for(unsigned int i=0;i<reply_lvalues.size();i++){
		argout->lvalue[i] = reply_lvalues[i];
	}
	for(unsigned int i=0;i<reply_svalues.size();i++){
		argout->svalue[i] = CORBA::string_dup(reply_svalues[i].c_str());
	}

	
	/*----- PROTECTED REGION END -----*/	//	DishManager::set_spfoperate_mode
	return argout;
}
//--------------------------------------------------------
/**
 *	Command SetSPFOperateModeTask related method
 *	Description: Set SPF to OPERATE mode. 
 *               This command is mainly for testing SPF Interface.
 *
 *	@param argin Task encoded data
 */
//--------------------------------------------------------
void DishManager::set_spfoperate_mode_task(Tango::DevString argin)
{
	DEBUG_STREAM << "DishManager::SetSPFOperateModeTask()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::set_spfoperate_mode_task) ENABLED START -----*/
	
	//	Add your own code

	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string cmd_name= "SetOperateMode";
	//###########################################################################
	
	//=====================================================
	//==      CHECK & EXTRACT TASK DATA
	//=====================================================
	//Extract argin encoded data to TaskData
	_DEBUG_LOG("Parsing argin json encoded TaskData...");
	std::string argin_json_str(argin);
	Utils_ns::TaskData taskData;
	if(Utils_ns::TaskUtils::ParseFromJsonString(taskData,this,argin_json_str)<0){
		std::string errMsg("Failed to parse argin json string to TaskData!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("SET_SPF_OPERATE_MODE_TASK_FAILED",errMsg);
	}

	_DEBUG_LOG("Executing cmd="<<taskData.name<<", id="<<taskData.id<<", has_data? "<<taskData.has_data);
	
	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	try {
		set_spfoperate_mode();
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Tango exception occurred while commanding spf to go to OPERATE mode ");
		throw;
	}


	/*----- PROTECTED REGION END -----*/	//	DishManager::set_spfoperate_mode_task
}
//--------------------------------------------------------
/**
 *	Command SetSPFOperational related method
 *	Description: Set the SPF operational. 
 *               
 *               1) Set SPF mode to OPERATE
 *               2) Power on LNAs when 1) completes
 *               3) TBD
 *
 *	@param argin Band id
 *               
 *               - bandId=-1 all bands
 *               - bandId=0 active band
 *               - band=[1-5] selected band
 *	@returns == Long field ==
 *           [0]: ack code (0=OK, 1=QUEUED, 2=FAILED)
 *           
 *           == String field ==
 *           [0]: Informative message or error/fault description
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *DishManager::set_spfoperational(Tango::DevShort argin)
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "DishManager::SetSPFOperational()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::set_spfoperational) ENABLED START -----*/
	
	//	Add your own code
	// == COMMAND BEHAVIOR ==
	// 1) Check if cmd mode-allowed
	// 2) Set SPF mode to OPERATE
	// 3) When 2) completes, power ON LNAs for active band (TBD)
	//    NB: Still to be defined if to switch on all LNAs or only the selected band 

	
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string task_name= "SetSPFOperational";
	std::string taskSequence_status_attr_name= "spfGoOperationalProgress";
	int nBands= 5;

	//Task 1
	std::string task1_name= "SetSPFOperateModeTask";
	std::string task1_asynch_attr_name= "spfSetOperateModeProgress";
	
	//Task 2
	std::string task2_name= "SetSPFLnaPowerOnTask";	
	Tango::DevShort task2_cmd_argin= argin;
	//###########################################################################
	
	//Init output attribute
	argout= new Tango::DevVarLongStringArray;
	argout->svalue.length(1);
	argout->lvalue.length(1);

	_INFO_LOG("Setting SPF operational (OPERATE mode + LNA powered on)");

	//=====================================================
	//==      CHECK ARGIN
	//=====================================================
	//Check argin
	if(argin<-1 || argin>nBands){
		std::stringstream ss;
		ss<<"Invalid bandId argument given (valid values must be in range [-1,"<<nBands<<"]";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_SPF_OPERATIONAL_FAILED",ss.str());
	}

	//=====================================================
	//==      PREPARE TASK DATA
	//=====================================================
	//Prepare task data
	bool useUTC= false;
	int priority= Utils_ns::Task::eMEDIUM_PRIORITY;

	CORBA::Any task2_argin;
	task2_argin <<= task2_cmd_argin;

	std::vector<std::vector<size_t>> dep_indexes { {},{0} };

	//== TASK 1 (asynch): SPF go operational ==	
	Utils_ns::TaskPtr task1= std::make_shared<Utils_ns::Task>(this,task1_name,priority,useUTC);
	task1->SetMaxDuration(operateTaskTimeout*1000.);//Set task timeout
	task1->SetAsynchTask(task1_asynch_attr_name);//Set asynch task attr status
	_INFO_LOG("Defined task 1: SPF Go Operational (max_duration(ms)="<<operateTaskTimeout*1000.<<", tcreation="<<(task1->creation_time).to_local_ISO8601()<<", exp_time="<<(task1->expiration_time).to_local_ISO8601()<<")");
	
	//== TASK 2  (synch): SPF power LNA
	Utils_ns::TaskPtr task2= std::make_shared<Utils_ns::Task>(this,task2_name,priority,useUTC);
	task2->SetMaxDuration(defaultTaskTimeout*1000.);//Set task timeout
	task2->SetTaskArgin(task2_argin,Tango::DEV_SHORT,Tango::SCALAR);//set task argin
	_INFO_LOG("Defined task 2: power LNA (max_duration(ms)="<<defaultTaskTimeout*1000.<<", tcreation="<<(task2->creation_time).to_local_ISO8601()<<", exp_time="<<(task2->expiration_time).to_local_ISO8601()<<")");
	
	std::vector<Utils_ns::TaskPtr> tasks;
	tasks.push_back(task1);
	tasks.push_back(task2);

	//Add tasks to sequence
	Utils_ns::TaskSequencePtr taskSequence= std::make_shared<Utils_ns::TaskSequence>(this,task_name,useUTC);
	taskSequence->SetDevStatusAttr(taskSequence_status_attr_name);//Set device attr containing task sequence status

	for(unsigned int i=0;i<tasks.size();i++){
		if(taskSequence->AddTask(tasks[i])<0){
			std::stringstream ss;
			ss<<"Failed to add task "<<i+1<<" (name="<<tasks[i]->cmd_name<<") to sequence!";
			_WARN_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("SET_SPF_OPERATIONAL_FAILED",ss.str());			
		}
	}//end loop tasks

	//Set task dependencies (2 depends on 1 to complete)
	if(taskSequence->SetTaskDependency(dep_indexes)<0){
		std::stringstream ss;
		ss<<"Failed to set task dependency indexes in sequence!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_SPF_OPERATIONAL_FAILED",ss.str());		
	}
	_INFO_LOG("Updated task 1: SPF Go Operational (max_duration(ms)="<<operateTaskTimeout*1000.<<", exp_time="<<(task1->expiration_time).to_local_ISO8601()<<")");
	_INFO_LOG("Updated task 2: power LNA (max_duration(ms)="<<defaultTaskTimeout*1000.<<", exp_time="<<(task2->expiration_time).to_local_ISO8601()<<")");
	
	//=====================================================
	//==      SCHEDULE TASK
	//=====================================================
	//Add task to queue 
	bool addToQueue= true;
	if(m_taskManager->AddTaskSequence(taskSequence,addToQueue)<0){
		std::stringstream ss;
		ss<<"Failed to add task sequence "<<task_name<<" to queue!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_SPF_OPERATIONAL_FAILED",ss.str());
	}
	_DEBUG_LOG("Added task sequence "<<task_name<<" to queue...");

	//Set reply 	
	argout->lvalue[0]= 1;//task queued code
	argout->svalue[0]= CORBA::string_dup("Set SPF operational task scheduled");

	/*----- PROTECTED REGION END -----*/	//	DishManager::set_spfoperational
	return argout;
}
//--------------------------------------------------------
/**
 *	Command SetSPFMaintenanceMode related method
 *	Description: Set the SPF sub-element in its MAINTENANCE mode
 *
 *	@returns 
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *DishManager::set_spfmaintenance_mode()
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "DishManager::SetSPFMaintenanceMode()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::set_spfmaintenance_mode) ENABLED START -----*/
	
	//	Add your own code

	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string cmd_name= "SetMaintenanceMode";
	std::string proxy_name= spfControllerAddress;
	//###########################################################################

	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	_INFO_LOG("Setting SPF to MAINTENANCE mode");
	Tango::DeviceData dout;
	try {
		ExecCmdOnProxy(dout,proxy_name,cmd_name);
	}
	catch(...){
		throw;
	}

	//Extract command reply
	std::vector<Tango::DevLong> reply_lvalues;
	std::vector<std::string> reply_svalues;
	if(!dout.extract(reply_lvalues, reply_svalues)){
		std::stringstream ss;
		ss<<"Failed to extract command reply data received from DS!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_SPF_MAINTENANCE_MODE_FAILED",ss.str());	
	}
	
	//Set output argument
	argout= new Tango::DevVarLongStringArray;
	argout->svalue.length(reply_svalues.size());
	argout->lvalue.length(reply_lvalues.size());

	for(unsigned int i=0;i<reply_lvalues.size();i++){
		argout->lvalue[i] = reply_lvalues[i];
	}
	for(unsigned int i=0;i<reply_svalues.size();i++){
		argout->svalue[i] = CORBA::string_dup(reply_svalues[i].c_str());
	}

	/*----- PROTECTED REGION END -----*/	//	DishManager::set_spfmaintenance_mode
	return argout;
}
//--------------------------------------------------------
/**
 *	Command SetSPFMaintenanceModeTask related method
 *	Description: Set SPF to MAINTENANCE mode task
 *
 *	@param argin Task encoded data
 */
//--------------------------------------------------------
void DishManager::set_spfmaintenance_mode_task(Tango::DevString argin)
{
	DEBUG_STREAM << "DishManager::SetSPFMaintenanceModeTask()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::set_spfmaintenance_mode_task) ENABLED START -----*/
	
	//	Add your own code

	_INFO_LOG("Starting SPF set MAINTENANCE mode task...");

	//=====================================================
	//==      CHECK & EXTRACT TASK DATA
	//=====================================================
	//Extract argin encoded data to TaskData
	_DEBUG_LOG("Parsing argin json encoded TaskData...");
	std::string argin_json_str(argin);
	Utils_ns::TaskData taskData;
	if(Utils_ns::TaskUtils::ParseFromJsonString(taskData,this,argin_json_str)<0){
		std::string errMsg("Failed to parse argin json string to TaskData!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("SET_SPF_MAINTENANCE_MODE_TASK_FAILED",errMsg);
	}

	_DEBUG_LOG("Executing cmd="<<taskData.name<<", id="<<taskData.id<<", has_data? "<<taskData.has_data);
	
	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	try {
		set_spfmaintenance_mode();
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Tango exception occurred while commanding spf to go to MAINTENANCE mode ");
		throw;
	}

	/*----- PROTECTED REGION END -----*/	//	DishManager::set_spfmaintenance_mode_task
}
//--------------------------------------------------------
/**
 *	Command SetSPFFeedMode related method
 *	Description: Set SPF feed package mode
 *               Allowed bands are {1-5}. 
 *               Allowed modes are {0=STANDBY-LP, 1=OPERATE, 2=MAINTENANCE}
 *
 *	@param argin [0]: bandId [1-5]
 *               [1]: mode
 *               
 *               Allowed modes are:
 *               
 *               0= STANDBY-LP
 *               1= OPERATE
 *               2= MAINTENANCE
 *	@returns 
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *DishManager::set_spffeed_mode(const Tango::DevVarShortArray *argin)
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "DishManager::SetSPFFeedMode()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::set_spffeed_mode) ENABLED START -----*/
	
	//	Add your own code
	
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string cmd_name= "SetFeedMode";
	std::string proxy_name= spfControllerAddress;
	int nBands= 5;
	//###########################################################################

	//=====================================================
	//==      CHECK ARGIN
	//=====================================================
	//Check number of args
	if(argin->length()<2){
		std::stringstream ss;
		ss<<"Invalid arguments given (must be at least 2)!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_SPF_FEED_MODE_FAILED",ss.str());	
	}
	Tango::DevShort bandId= (*argin)[0];
	Tango::DevShort feed_mode= (*argin)[1];
	
	//Check argin value
	if(bandId<1 || bandId>nBands){
		std::stringstream ss;
		ss<<"Invalid bandId argument given (valid values are [1,"<<nBands<<"])!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_SPF_FEED_MODE_FAILED",ss.str());	
	}

	

	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	_INFO_LOG("Setting SPF feed band "<<bandId<<" to mode "<<feed_mode);
	
	//Create cmd argin
	Tango::DevVarShortArray* cmd_argin = new Tango::DevVarShortArray(); 
  cmd_argin->length(2); 
  (*cmd_argin)[0] = bandId; 
  (*cmd_argin)[1] = feed_mode; 
  
	Tango::DeviceData din;
	din<<cmd_argin;

	//Execute command
	Tango::DeviceData dout;
	try {
		ExecCmdOnProxy(dout,proxy_name,cmd_name,din);
	}
	catch(...){
		throw;
	}

	//Extract command reply
	std::vector<Tango::DevLong> reply_lvalues;
	std::vector<std::string> reply_svalues;
	if(!dout.extract(reply_lvalues, reply_svalues)){
		std::stringstream ss;
		ss<<"Failed to extract command reply data received from DS!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_SPF_FEED_MODE_FAILED",ss.str());	
	}
	
	//Set output argument
	argout= new Tango::DevVarLongStringArray;
	argout->svalue.length(reply_svalues.size());
	argout->lvalue.length(reply_lvalues.size());

	for(unsigned int i=0;i<reply_lvalues.size();i++){
		argout->lvalue[i] = reply_lvalues[i];
	}
	for(unsigned int i=0;i<reply_svalues.size();i++){
		argout->svalue[i] = CORBA::string_dup(reply_svalues[i].c_str());
	}

	
	/*----- PROTECTED REGION END -----*/	//	DishManager::set_spffeed_mode
	return argout;
}
//--------------------------------------------------------
/**
 *	Command SendSPFFeedCommand related method
 *	Description: Send a once-off command directly to the feed. 
 *               Each feed can have different commands defined, and 
 *               currently they are all defined in the same manner.
 *               
 *               Command is valid in spf mode {STANDBY-LP, OPERATE, MAINTENANCE}
 *               
 *               
 *               Valid values for mcBand argument are: {1-5}.
 *               Valid values for feedComamnd argument are: {0,1}, 
 *               where each enum code corresponds to:
 *               
 *               0 = REGENERATE
 *               1 = CLEAR-ERRORS
 *               
 *               Other additional commands defined in the future 
 *               will follow from the above list into separate lists for 
 *               each feed.
 *
 *	@param argin [0]: mcBand
 *               [1]: feedCommand {0=REGENERATE,1=CLEAR-ERRORS}
 */
//--------------------------------------------------------
void DishManager::send_spffeed_command(const Tango::DevVarShortArray *argin)
{
	DEBUG_STREAM << "DishManager::SendSPFFeedCommand()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::send_spffeed_command) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string cmd_name= "SendFeedCommand";
	std::string proxy_name= spfControllerAddress;
	int nBands= 5;
	//###########################################################################

	//=====================================================
	//==      CHECK ARGIN
	//=====================================================
	//Check number of args
	if(argin->length()<2){
		std::stringstream ss;
		ss<<"Invalid arguments given (must be at least 2)!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SEND_SPF_FEED_COMMAND_FAILED",ss.str());	
	}
	Tango::DevShort bandId= (*argin)[0];
	Tango::DevShort feed_cmd= (*argin)[1];
	
	//Check argin value
	if(bandId<1 || bandId>nBands){
		std::stringstream ss;
		ss<<"Invalid bandId argument given (valid values are [1,"<<nBands<<"])!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SEND_SPF_FEED_COMMAND_FAILED",ss.str());	
	}

	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	_INFO_LOG("Sending command (id="<<feed_cmd<<") to SPF feed band "<<bandId);

	//Create cmd argin
	Tango::DevVarShortArray* cmd_argin = new Tango::DevVarShortArray(); 
  cmd_argin->length(2); 
  (*cmd_argin)[0] = bandId; 
  (*cmd_argin)[1] = feed_cmd; 
  
	Tango::DeviceData din;
	din<<cmd_argin;
	
	//Execute command
	Tango::DeviceData dout;
	try {
		ExecCmdOnProxy(dout,proxy_name,cmd_name,din);
	}
	catch(...){
		throw;
	}


	/*----- PROTECTED REGION END -----*/	//	DishManager::send_spffeed_command
}
//--------------------------------------------------------
/**
 *	Command SetSPFLnaPowerOff related method
 *	Description: Switch SPF LNA power off for selected bands, active band or
 *               all bands depending on the input argument.
 *
 *	@param argin bandId: [1-5]
 *               
 *               If bandId=-1 turns on all bands
 *               If bandId=0 turns on only active band. 
 *               If no band is active (was not configured) an exception 
 *               is thrown.
 */
//--------------------------------------------------------
void DishManager::set_spflna_power_off(Tango::DevShort argin)
{
	DEBUG_STREAM << "DishManager::SetSPFLnaPowerOff()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::set_spflna_power_off) ENABLED START -----*/
	
	//	Add your own code
	
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string proxy_name= spfControllerAddress;
	std::vector<std::string> lna_power_h_attr_names= {
		"b1LnaHPowerState", 
		"b2LnaHPowerState",
		"b3LnaHPowerState",
		"b4LnaHPowerState",
		"b5LnaHPowerState"
	};
	std::vector<std::string> lna_power_v_attr_names= {
		"b1LnaVPowerState", 
		"b2LnaVPowerState",
		"b3LnaVPowerState",
		"b4LnaVPowerState",
		"b5LnaVPowerState"
	};
	int nBands= 6;
	std::map<Tango::DevShort,Tango::DevShort> spfBandIdMap = {
		{-1,-1}, {0,0}, {1,1}, {2,2}, {3,3}, {4,4}, {5,5}, {6,5} 	
	};
	std::vector<int> unsupported_bands;
	//###########################################################################
	
	//=====================================================
	//==      CHECK ARGIN
	//=====================================================
	//Get command args
	Tango::DevShort bandId= spfBandIdMap[argin];
	if(bandId<-1 || bandId>nBands){
		std::stringstream ss;
		ss<<"Invalid bandId argument given ("<<argin<<"), must be in the range [-1,"<<nBands<<"]!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_SPF_LNA_POWER_OFF_FAILED",ss.str());	
	}
	if(bandId==-1) _INFO_LOG("Powering all SPF feed bands off...");
	else _INFO_LOG("Powering SPF feed band "<<bandId<<" off...");

	//=====================================================
	//==      GET ATTRS TO BE WRITTEN
	//=====================================================
	//Get selected attrs
	std::vector<std::string> lna_power_h_attr_names_selected;
	std::vector<std::string> lna_power_v_attr_names_selected;
	try{
		SelectBandAttrsInCmd(lna_power_h_attr_names_selected,bandId,lna_power_h_attr_names,unsupported_bands);
		SelectBandAttrsInCmd(lna_power_v_attr_names_selected,bandId,lna_power_v_attr_names,unsupported_bands);
	}
	catch(...){
		_WARN_LOG("Failed to get the list of lna attributes to be written on SPF!");
		throw;
	}
	std::vector<std::string> lna_power_attr_names_selected;
	lna_power_attr_names_selected.insert(lna_power_attr_names_selected.end(),lna_power_h_attr_names_selected.begin(),lna_power_h_attr_names_selected.end());
	lna_power_attr_names_selected.insert(lna_power_attr_names_selected.end(),lna_power_v_attr_names_selected.begin(),lna_power_v_attr_names_selected.end());

	//=====================================================
	//==      WRITE ATTRS
	//=====================================================
	//Write attribute list
	Tango::DevBoolean lna_power= false;
	try{
		WriteSEAttrs<Tango::DevBoolean>(proxy_name,lna_power_attr_names_selected,lna_power);
	}
	catch(...){
		_WARN_LOG("Failed to write one/more LNA attributes on SPF!");
		throw;
	}

	/*----- PROTECTED REGION END -----*/	//	DishManager::set_spflna_power_off
}
//--------------------------------------------------------
/**
 *	Command SetSPFLnaPowerOn related method
 *	Description: Switch the SPF LNA power on for selected band or for all
 *               bands or for active band depending on attributes.
 *
 *	@param argin bandId: [1-5]
 *               
 *               If bandId=-1 turns on all bands
 *               If bandId=0 turns on only active band. 
 *               If no band is active (was not configured) an exception 
 *               is thrown.
 */
//--------------------------------------------------------
void DishManager::set_spflna_power_on(Tango::DevShort argin)
{
	DEBUG_STREAM << "DishManager::SetSPFLnaPowerOn()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::set_spflna_power_on) ENABLED START -----*/
	
	//	Add your own code
	
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string proxy_name= spfControllerAddress;
	std::vector<std::string> lna_power_h_attr_names= {
		"b1LnaHPowerState", 
		"b2LnaHPowerState",
		"b3LnaHPowerState",
		"b4LnaHPowerState",
		"b5LnaHPowerState"
	};
	std::vector<std::string> lna_power_v_attr_names= {
		"b1LnaVPowerState", 
		"b2LnaVPowerState",
		"b3LnaVPowerState",
		"b4LnaVPowerState",
		"b5LnaVPowerState"
	};
	std::vector<int> unsupported_bands;
	int nBands= 6;
	std::map<Tango::DevShort,Tango::DevShort> spfBandIdMap = {
		{-1,-1}, {0,0}, {1,1}, {2,2}, {3,3}, {4,4}, {5,5}, {6,5} 	
	};
	//###########################################################################

	//=====================================================
	//==      CHECK ARGIN
	//=====================================================
	//Check band id argument
	Tango::DevShort bandId= spfBandIdMap[argin];
	if(bandId<-1 || bandId>nBands){
		std::stringstream ss;
		ss<<"Invalid bandId argument given ("<<argin<<"), must be in the range [-1,"<<nBands<<"]!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_SPF_LNA_POWER_ON_FAILED",ss.str());	
	}
	if(bandId==-1) _INFO_LOG("Powering all SPF feed bands on...");
	else if(bandId==0) _INFO_LOG("Powering active SPF feed band on...");
	else _INFO_LOG("Powering SPF feed band "<<bandId<<" on...");

	//=====================================================
	//==      GET ATTRS TO BE WRITTEN
	//=====================================================
	//Get selected attrs
	std::vector<std::string> lna_power_h_attr_names_selected;
	std::vector<std::string> lna_power_v_attr_names_selected;
	try{
		SelectBandAttrsInCmd(lna_power_h_attr_names_selected,bandId,lna_power_h_attr_names,unsupported_bands);
		SelectBandAttrsInCmd(lna_power_v_attr_names_selected,bandId,lna_power_v_attr_names,unsupported_bands);
	}
	catch(...){
		_WARN_LOG("Failed to get the list of lna attributes to be written on SPF!");
		throw;
	}
	std::vector<std::string> lna_power_attr_names_selected;
	lna_power_attr_names_selected.insert(lna_power_attr_names_selected.end(),lna_power_h_attr_names_selected.begin(),lna_power_h_attr_names_selected.end());
	lna_power_attr_names_selected.insert(lna_power_attr_names_selected.end(),lna_power_v_attr_names_selected.begin(),lna_power_v_attr_names_selected.end());

	//=====================================================
	//==      WRITE ATTRS
	//=====================================================
	//Write attribute list
	Tango::DevBoolean lna_power= true;
	try{
		WriteSEAttrs<Tango::DevBoolean>(proxy_name,lna_power_attr_names_selected,lna_power);
	}
	catch(...){
		_WARN_LOG("Failed to write one/more LNA attributes on SPF!");
		throw;
	}

	/*----- PROTECTED REGION END -----*/	//	DishManager::set_spflna_power_on
}
//--------------------------------------------------------
/**
 *	Command SetSPFLnaPowerOnTask related method
 *	Description: 
 *
 *	@param argin Task encoded data
 */
//--------------------------------------------------------
void DishManager::set_spflna_power_on_task(Tango::DevString argin)
{
	DEBUG_STREAM << "DishManager::SetSPFLnaPowerOnTask()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::set_spflna_power_on_task) ENABLED START -----*/
	
	//	Add your own code
	
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	int nBands= 6;
	std::map<Tango::DevShort,Tango::DevShort> spfBandIdMap = {
		{-1,-1}, {0,0}, {1,1}, {2,2}, {3,3}, {4,4}, {5,5}, {6,5} 	
	};
	//###########################################################################

	//=====================================================
	//==      CHECK & EXTRACT TASK DATA
	//=====================================================
	//Extract argin encoded data to TaskData
	_DEBUG_LOG("Parsing argin json encoded TaskData...");
	std::string argin_json_str(argin);
	Utils_ns::TaskData taskData;
	if(Utils_ns::TaskUtils::ParseFromJsonString(taskData,this,argin_json_str)<0){
		std::string errMsg("Failed to parse argin json string to TaskData for Task_PowerLNA() command!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("SET_SPF_LNA_POWER_ON_TASK_FAILED",errMsg);
	}

	_DEBUG_LOG("Executing cmd="<<taskData.name<<", id="<<taskData.id<<", has_data? "<<taskData.has_data);
	
	//Check if has argin data
	if(!taskData.has_data){
		std::string errMsg("No argin data present (expecting a DevShort arg)!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("SET_SPF_LNA_POWER_ON_TASK_FAILED",errMsg);
	}

	//Extract argin task data
	Tango::DevShort task_argin;
	if(taskData.GetData<Tango::DevShort>(task_argin)<0){
		std::string errMsg("Failed to extract data value in TaskData (check data type?)!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("SET_SPF_LNA_POWER_ON_TASK_FAILED",errMsg);		
	}
	Tango::DevShort bandId= spfBandIdMap[task_argin];
	
	//Check band id argument
	if(bandId<-1 || bandId>nBands){
		std::stringstream ss;
		ss<<"Invalid bandId argument given ("<<task_argin<<"), must be in the range [-1,"<<nBands<<"]!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_SPF_LNA_POWER_ON_TASK_FAILED",ss.str());	
	}
	_INFO_LOG("Executing task command "<<taskData.name<<" (id="<<taskData.id<<", has_data? "<<taskData.has_data<<", argin="<<task_argin<<")");
	
	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	try{
		set_spflna_power_on(bandId);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Tango exceptio occurred when commanding SPF LNA power on!");
		throw;
	}

	/*----- PROTECTED REGION END -----*/	//	DishManager::set_spflna_power_on_task
}
//--------------------------------------------------------
/**
 *	Command SetSPFBandInFocus related method
 *	Description: Set the requested band in SPF. This can be done also via
 *               the corresponding forwarded writable attribute. This command
 *               is provided to support automated execution in task schedule.
 *
 *	@param argin Band id
 */
//--------------------------------------------------------
void DishManager::set_spfband_in_focus(Tango::DevShort argin)
{
	DEBUG_STREAM << "DishManager::SetSPFBandInFocus()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::set_spfband_in_focus) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string proxy_name= spfControllerAddress;
	std::string bandInFocus_attr_name= "bandInFocus";
	int nBands= 5;
	//###########################################################################

	//Get command args
	Tango::DevShort bandId= argin;
	if(bandId<1 || bandId>nBands){
		std::stringstream ss;
		ss<<"Invalid bandId argument given (valid values are [1,"<<nBands<<"])!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_SPF_BANDINFOCUS_FAILED",ss.str());	
	}

	//Write attribute
	std::vector<std::string> attr_names {bandInFocus_attr_name};
	try{
		WriteSEAttrs<Tango::DevShort>(proxy_name,attr_names,bandId);
	}
	catch(...){
		_WARN_LOG("Failed to write bandInFocus attribute on SPF!");
		throw;
	}
	/*----- PROTECTED REGION END -----*/	//	DishManager::set_spfband_in_focus
}
//--------------------------------------------------------
/**
 *	Command SetSPFBandInFocusTask related method
 *	Description: Task to set the requested band in SPF. Used by the configure
 *               schedule command.
 *
 *	@param argin Encoded task data
 */
//--------------------------------------------------------
void DishManager::set_spfband_in_focus_task(Tango::DevString argin)
{
	DEBUG_STREAM << "DishManager::SetSPFBandInFocusTask()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::set_spfband_in_focus_task) ENABLED START -----*/
	
	//	Add your own code
	_INFO_LOG("Starting set SPF band in focus task ...");

	//=====================================================
	//==      CHECK & EXTRACT TASK DATA
	//=====================================================
	//Extract argin encoded data to TaskData
	_DEBUG_LOG("Parsing argin json encoded TaskData...");
	std::string argin_json_str(argin);
	Utils_ns::TaskData taskData;
	if(Utils_ns::TaskUtils::ParseFromJsonString(taskData,this,argin_json_str)<0){
		std::string errMsg("Failed to parse argin json string to TaskData!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("SET_SPF_BANDINFOCUS_TASK_FAILED",errMsg);
	}

	_DEBUG_LOG("Executing cmd="<<taskData.name<<", id="<<taskData.id<<", has_data? "<<taskData.has_data);
	
	//Extract argin task data
	Tango::DevShort bandId;
	if(taskData.GetData<Tango::DevShort>(bandId)<0){
		std::string errMsg("Failed to extract data value in TaskData (check data type?)!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("SET_SPF_BANDINFOCUS_TASK_FAILED",errMsg);		
	}

	_DEBUG_LOG("Executing cmd="<<taskData.name<<", id="<<taskData.id<<", has_data? "<<taskData.has_data<<", data="<<bandId);
	
	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	try {
		set_spfband_in_focus(bandId);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Tango exception occurred while commanding spf to set band in focus!");
		throw;
	}
	/*----- PROTECTED REGION END -----*/	//	DishManager::set_spfband_in_focus_task
}
//--------------------------------------------------------
/**
 *	Command ShutdownSPFC related method
 *	Description: Shutdown the SPF controller
 *
 */
//--------------------------------------------------------
void DishManager::shutdown_spfc()
{
	DEBUG_STREAM << "DishManager::ShutdownSPFC()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::shutdown_spfc) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string cmd_name= "Shutdown";
	std::string proxy_name= spfControllerAddress;
	//===========================================================================
	
	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	_INFO_LOG("Shutting down SPFC");
	Tango::DeviceData dout;
	try {
		ExecCmdOnProxy(dout,proxy_name,cmd_name);
	}
	catch(...){
		throw;
	}

	/*----- PROTECTED REGION END -----*/	//	DishManager::shutdown_spfc
}
//--------------------------------------------------------
/**
 *	Command ShutdownSPFCTask related method
 *	Description: Task command to shutdown the SPF controller
 *
 *	@param argin Task data
 */
//--------------------------------------------------------
void DishManager::shutdown_spfctask(Tango::DevString argin)
{
	DEBUG_STREAM << "DishManager::ShutdownSPFCTask()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::shutdown_spfctask) ENABLED START -----*/
	
	//	Add your own code
	//=====================================================
	//==      CHECK & EXTRACT TASK DATA
	//=====================================================
	//Extract argin encoded data to TaskData
	_DEBUG_LOG("Parsing argin json encoded TaskData...");
	std::string argin_json_str(argin);
	Utils_ns::TaskData taskData;
	if(Utils_ns::TaskUtils::ParseFromJsonString(taskData,this,argin_json_str)<0){
		std::string errMsg("Failed to parse argin json string to TaskData!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("SHUTDOWN_SPFC_TASK_FAILED",errMsg);
	}

	_DEBUG_LOG("Executing task command "<<taskData.name<<" (id="<<taskData.id<<", has_data? "<<taskData.has_data<<")...");
	
	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	try {
		shutdown_spfc();
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Tango exception occurred while commanding SPF to shutdown!");
		throw;
	}

	/*----- PROTECTED REGION END -----*/	//	DishManager::shutdown_spfctask
}
//--------------------------------------------------------
/**
 *	Command PowerOffSPFC related method
 *	Description: Power off SPFC from the PDU interface
 *
 */
//--------------------------------------------------------
void DishManager::power_off_spfc()
{
	DEBUG_STREAM << "DishManager::PowerOffSPFC()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::power_off_spfc) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string cmd_name= "SPFC_OFF";
	std::string proxy_name= pduManagerAddress;
	//===========================================================================
	
	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	_INFO_LOG("Powering off SPFC ...");
	Tango::DeviceData dout;
	try {
		ExecCmdOnProxy(dout,proxy_name,cmd_name);
	}
	catch(...){
		throw;
	}
	/*----- PROTECTED REGION END -----*/	//	DishManager::power_off_spfc
}
//--------------------------------------------------------
/**
 *	Command PowerOnSPFC related method
 *	Description: Power on SPFC from the PDU interface
 *
 */
//--------------------------------------------------------
void DishManager::power_on_spfc()
{
	DEBUG_STREAM << "DishManager::PowerOnSPFC()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::power_on_spfc) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string cmd_name= "SPFC_ON";
	std::string proxy_name= pduManagerAddress;
	//===========================================================================
	
	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	_INFO_LOG("Powering on SPFC ...");
	Tango::DeviceData dout;
	try {
		ExecCmdOnProxy(dout,proxy_name,cmd_name);
	}
	catch(...){
		throw;
	}
	/*----- PROTECTED REGION END -----*/	//	DishManager::power_on_spfc
}
//--------------------------------------------------------
/**
 *	Command PowerOffSPFCTask related method
 *	Description: Task to power off the SPF controller from the PDU.
 *               Typically invoked by the dish power off handler cmd.
 *
 *	@param argin Encoded task data
 */
//--------------------------------------------------------
void DishManager::power_off_spfctask(Tango::DevString argin)
{
	DEBUG_STREAM << "DishManager::PowerOffSPFCTask()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::power_off_spfctask) ENABLED START -----*/
	
	//	Add your own code
	//=====================================================
	//==      CHECK & EXTRACT TASK DATA
	//=====================================================
	//Extract argin encoded data to TaskData
	_DEBUG_LOG("Parsing argin json encoded TaskData...");
	std::string argin_json_str(argin);
	Utils_ns::TaskData taskData;
	if(Utils_ns::TaskUtils::ParseFromJsonString(taskData,this,argin_json_str)<0){
		std::string errMsg("Failed to parse argin json string to TaskData!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("POWER_OFF_SPFC_TASK_FAILED",errMsg);
	}

	_DEBUG_LOG("Executing task command "<<taskData.name<<" (id="<<taskData.id<<", has_data? "<<taskData.has_data<<")...");
	
	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	try {
		power_off_spfc();
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Tango exception occurred while commanding SPF to power off!");
		throw;
	}
	/*----- PROTECTED REGION END -----*/	//	DishManager::power_off_spfctask
}
//--------------------------------------------------------
/**
 *	Command PowerOnSPFCTask related method
 *	Description: Power on the SPF controller. 
 *               Typically invoked by the power restore handler cmd.
 *
 *	@param argin Task encoded data
 */
//--------------------------------------------------------
void DishManager::power_on_spfctask(Tango::DevString argin)
{
	DEBUG_STREAM << "DishManager::PowerOnSPFCTask()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::power_on_spfctask) ENABLED START -----*/
	
	//	Add your own code
	//=====================================================
	//==      CHECK & EXTRACT TASK DATA
	//=====================================================
	//Extract argin encoded data to TaskData
	_DEBUG_LOG("Parsing argin json encoded TaskData...");
	std::string argin_json_str(argin);
	Utils_ns::TaskData taskData;
	if(Utils_ns::TaskUtils::ParseFromJsonString(taskData,this,argin_json_str)<0){
		std::string errMsg("Failed to parse argin json string to TaskData!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("POWER_ON_SPFC_TASK_FAILED",errMsg);
	}

	_DEBUG_LOG("Executing task command "<<taskData.name<<" (id="<<taskData.id<<", has_data? "<<taskData.has_data<<")...");
	
	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	try {
		power_on_spfc();
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Tango exception occurred while commanding SPF to power on!");
		throw;
	}
	/*----- PROTECTED REGION END -----*/	//	DishManager::power_on_spfctask
}
//--------------------------------------------------------
/**
 *	Command SetDSStandbyLPMode related method
 *	Description: Set DS in STANDBY-LP mode
 *
 *	@returns 
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *DishManager::set_dsstandby_lpmode()
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "DishManager::SetDSStandbyLPMode()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::set_dsstandby_lpmode) ENABLED START -----*/
	
	//	Add your own code
	
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string cmd_name= "SetStandbyLPMode";
	std::string proxy_name= dsManagerAddress;
	//###########################################################################

	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	_INFO_LOG("Setting DS to STANDBY-LP mode");
	Tango::DeviceData dout;
	try {
		ExecCmdOnProxy(dout,proxy_name,cmd_name);
	}
	catch(...){
		throw;
	}

	//Extract command reply
	std::vector<Tango::DevLong> reply_lvalues;
	std::vector<std::string> reply_svalues;
	if(!dout.extract(reply_lvalues, reply_svalues)){
		std::stringstream ss;
		ss<<"Failed to extract command reply data received from DS!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_DS_STANDBY_LP_MODE_FAILED",ss.str());	
	}
	
	//Set output argument
	argout= new Tango::DevVarLongStringArray;
	argout->svalue.length(reply_svalues.size());
	argout->lvalue.length(reply_lvalues.size());

	for(unsigned int i=0;i<reply_lvalues.size();i++){
		argout->lvalue[i] = reply_lvalues[i];
	}
	for(unsigned int i=0;i<reply_svalues.size();i++){
		argout->svalue[i] = CORBA::string_dup(reply_svalues[i].c_str());
	}

	/*----- PROTECTED REGION END -----*/	//	DishManager::set_dsstandby_lpmode
	return argout;
}
//--------------------------------------------------------
/**
 *	Command SetDSStandbyLPModeTask related method
 *	Description: Command task to set DS to STANDBY-LP mode
 *
 *	@param argin 
 */
//--------------------------------------------------------
void DishManager::set_dsstandby_lpmode_task(Tango::DevString argin)
{
	DEBUG_STREAM << "DishManager::SetDSStandbyLPModeTask()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::set_dsstandby_lpmode_task) ENABLED START -----*/
	
	//	Add your own code
	_INFO_LOG("Starting DS STANDBY-LP mode task...");

	//=====================================================
	//==      CHECK & EXTRACT TASK DATA
	//=====================================================
	//Extract argin encoded data to TaskData
	_DEBUG_LOG("Parsing argin json encoded TaskData...");
	std::string argin_json_str(argin);
	Utils_ns::TaskData taskData;
	if(Utils_ns::TaskUtils::ParseFromJsonString(taskData,this,argin_json_str)<0){
		std::string errMsg("Failed to parse argin json string to TaskData!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("SET_DS_STANDBY_LP_MODE_TASK_FAILED",errMsg);
	}

	_DEBUG_LOG("Executing cmd="<<taskData.name<<", id="<<taskData.id<<", has_data? "<<taskData.has_data);
	
	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	try {
		set_dsstandby_lpmode();
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Tango exception occurred while commanding DS to go to STANDBY-LP mode ");
		throw;
	}
	/*----- PROTECTED REGION END -----*/	//	DishManager::set_dsstandby_lpmode_task
}
//--------------------------------------------------------
/**
 *	Command SetDSStandbyFPMode related method
 *	Description: Set DS in STANDBY-FP mode
 *
 *	@returns 
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *DishManager::set_dsstandby_fpmode()
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "DishManager::SetDSStandbyFPMode()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::set_dsstandby_fpmode) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string cmd_name= "SetStandbyFPMode";
	std::string proxy_name= dsManagerAddress;
	//###########################################################################

	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	_INFO_LOG("Setting DS to STANDBY-FP mode");
	Tango::DeviceData dout;
	try {
		ExecCmdOnProxy(dout,proxy_name,cmd_name);
	}
	catch(...){
		throw;
	}

	//Extract command reply
	std::vector<Tango::DevLong> reply_lvalues;
	std::vector<std::string> reply_svalues;
	if(!dout.extract(reply_lvalues, reply_svalues)){
		std::stringstream ss;
		ss<<"Failed to extract command reply data received from DS!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_DS_STANDBY_FP_MODE_FAILED",ss.str());	
	}
	
	//Set output argument
	argout= new Tango::DevVarLongStringArray;
	argout->svalue.length(reply_svalues.size());
	argout->lvalue.length(reply_lvalues.size());

	for(unsigned int i=0;i<reply_lvalues.size();i++){
		argout->lvalue[i] = reply_lvalues[i];
	}
	for(unsigned int i=0;i<reply_svalues.size();i++){
		argout->svalue[i] = CORBA::string_dup(reply_svalues[i].c_str());
	}

	/*----- PROTECTED REGION END -----*/	//	DishManager::set_dsstandby_fpmode
	return argout;
}
//--------------------------------------------------------
/**
 *	Command SetDSStandbyFPModeTask related method
 *	Description: Command task to set DS to STANDBY-FP mode
 *
 *	@param argin 
 */
//--------------------------------------------------------
void DishManager::set_dsstandby_fpmode_task(Tango::DevString argin)
{
	DEBUG_STREAM << "DishManager::SetDSStandbyFPModeTask()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::set_dsstandby_fpmode_task) ENABLED START -----*/
	
	//	Add your own code
	_INFO_LOG("Starting DS STANDBY-FP mode task...");

	//=====================================================
	//==      CHECK & EXTRACT TASK DATA
	//=====================================================
	//Extract argin encoded data to TaskData
	_DEBUG_LOG("Parsing argin json encoded TaskData...");
	std::string argin_json_str(argin);
	Utils_ns::TaskData taskData;
	if(Utils_ns::TaskUtils::ParseFromJsonString(taskData,this,argin_json_str)<0){
		std::string errMsg("Failed to parse argin json string to TaskData!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("SET_DS_STANDBY_FP_MODE_TASK_FAILED",errMsg);
	}

	_DEBUG_LOG("Executing cmd="<<taskData.name<<", id="<<taskData.id<<", has_data? "<<taskData.has_data);
	
	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	try {
		set_dsstandby_fpmode();
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Tango exception occurred while commanding DS to go to STANDBY-FP mode ");
		throw;
	}
	/*----- PROTECTED REGION END -----*/	//	DishManager::set_dsstandby_fpmode_task
}
//--------------------------------------------------------
/**
 *	Command SetDSPointMode related method
 *	Description: Set DS point mode
 *
 *	@returns 
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *DishManager::set_dspoint_mode()
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "DishManager::SetDSPointMode()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::set_dspoint_mode) ENABLED START -----*/
	
	//	Add your own code
	
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string cmd_name= "SetPointMode";
	std::string proxy_name= dsManagerAddress;
	//===========================================================================
	
	
	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	_INFO_LOG("Setting DS to POINT mode");
	Tango::DeviceData dout;
	try {
		ExecCmdOnProxy(dout,proxy_name,cmd_name);
	}
	catch(...){
		throw;
	}

	//Extract command reply
	std::vector<Tango::DevLong> reply_lvalues;
	std::vector<std::string> reply_svalues;
	if(!dout.extract(reply_lvalues, reply_svalues)){
		std::stringstream ss;
		ss<<"Failed to extract command reply data received from DS!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_DS_POINT_MODE_FAILED",ss.str());	
	}
	
	//Set output argument
	argout= new Tango::DevVarLongStringArray;
	argout->svalue.length(reply_svalues.size());
	argout->lvalue.length(reply_lvalues.size());

	for(unsigned int i=0;i<reply_lvalues.size();i++){
		argout->lvalue[i] = reply_lvalues[i];
	}
	for(unsigned int i=0;i<reply_svalues.size();i++){
		argout->svalue[i] = CORBA::string_dup(reply_svalues[i].c_str());
	}


	/*----- PROTECTED REGION END -----*/	//	DishManager::set_dspoint_mode
	return argout;
}
//--------------------------------------------------------
/**
 *	Command SetDSPointModeTask related method
 *	Description: 
 *
 *	@param argin Task encoded data
 */
//--------------------------------------------------------
void DishManager::set_dspoint_mode_task(Tango::DevString argin)
{
	DEBUG_STREAM << "DishManager::SetDSPointModeTask()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::set_dspoint_mode_task) ENABLED START -----*/
	
	//	Add your own code
	
	//=====================================================
	//==      CHECK & EXTRACT TASK DATA
	//=====================================================
	//Extract argin encoded data to TaskData
	_DEBUG_LOG("Parsing argin json encoded TaskData...");
	std::string argin_json_str(argin);
	Utils_ns::TaskData taskData;
	if(Utils_ns::TaskUtils::ParseFromJsonString(taskData,this,argin_json_str)<0){
		std::string errMsg("Failed to parse argin json string to TaskData!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("SET_DS_POINT_MODE_TASK_FAILED",errMsg);
	}

	_INFO_LOG("Executing task command "<<taskData.name<<" (id="<<taskData.id<<", has_data? "<<taskData.has_data<<")...");
	
	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	try {
		set_dspoint_mode();
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Tango exception occurred while commanding DS to go to POINT mode!");
		throw;
	}

	/*----- PROTECTED REGION END -----*/	//	DishManager::set_dspoint_mode_task
}
//--------------------------------------------------------
/**
 *	Command SetDSStowMode related method
 *	Description: Set DS stow mode
 *
 *	@returns 
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *DishManager::set_dsstow_mode()
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "DishManager::SetDSStowMode()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::set_dsstow_mode) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string cmd_name= "Stow";
	std::string proxy_name= dsManagerAddress;
	//===========================================================================
	
	
	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	_INFO_LOG("Setting DS to STOW mode");
	Tango::DeviceData dout;
	try {
		ExecCmdOnProxy(dout,proxy_name,cmd_name);
	}
	catch(...){
		throw;
	}

	//Extract command reply
	std::vector<Tango::DevLong> reply_lvalues;
	std::vector<std::string> reply_svalues;
	if(!dout.extract(reply_lvalues, reply_svalues)){
		std::stringstream ss;
		ss<<"Failed to extract command reply data received from DS!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_DS_STOW_MODE_FAILED",ss.str());	
	}
	
	//Set output argument
	argout= new Tango::DevVarLongStringArray;
	argout->svalue.length(reply_svalues.size());
	argout->lvalue.length(reply_lvalues.size());

	for(unsigned int i=0;i<reply_lvalues.size();i++){
		argout->lvalue[i] = reply_lvalues[i];
	}
	for(unsigned int i=0;i<reply_svalues.size();i++){
		argout->svalue[i] = CORBA::string_dup(reply_svalues[i].c_str());
	}

	/*----- PROTECTED REGION END -----*/	//	DishManager::set_dsstow_mode
	return argout;
}
//--------------------------------------------------------
/**
 *	Command SetDSStowModeTask related method
 *	Description: Set DS stow mode task
 *
 *	@param argin 
 */
//--------------------------------------------------------
void DishManager::set_dsstow_mode_task(Tango::DevString argin)
{
	DEBUG_STREAM << "DishManager::SetDSStowModeTask()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::set_dsstow_mode_task) ENABLED START -----*/
	
	//	Add your own code
	//=====================================================
	//==      CHECK & EXTRACT TASK DATA
	//=====================================================
	//Extract argin encoded data to TaskData
	_DEBUG_LOG("Parsing argin json encoded TaskData...");
	std::string argin_json_str(argin);
	Utils_ns::TaskData taskData;
	if(Utils_ns::TaskUtils::ParseFromJsonString(taskData,this,argin_json_str)<0){
		std::string errMsg("Failed to parse argin json string to TaskData!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("SET_DS_STOW_MODE_TASK_FAILED",errMsg);
	}

	_INFO_LOG("Executing task command "<<taskData.name<<" (id="<<taskData.id<<", has_data? "<<taskData.has_data<<")...");
	
	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	try {
		set_dsstow_mode();
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Tango exception occurred while commanding DS to go to STOW mode!");
		throw;
	}

	/*----- PROTECTED REGION END -----*/	//	DishManager::set_dsstow_mode_task
}
//--------------------------------------------------------
/**
 *	Command SetDSMaintenanceMode related method
 *	Description: Set DS to MAINTENANCE mode
 *
 */
//--------------------------------------------------------
void DishManager::set_dsmaintenance_mode()
{
	DEBUG_STREAM << "DishManager::SetDSMaintenanceMode()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::set_dsmaintenance_mode) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string cmd_name= "SetMaintenanceMode";
	std::string proxy_name= dsManagerAddress;
	//===========================================================================
	
	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	_INFO_LOG("Setting DS to MAINTENANCE mode");
	Tango::DeviceData dout;
	try {
		ExecCmdOnProxy(dout,proxy_name,cmd_name);
	}
	catch(...){
		throw;
	}

	/*----- PROTECTED REGION END -----*/	//	DishManager::set_dsmaintenance_mode
}
//--------------------------------------------------------
/**
 *	Command SetDSMaintenanceModeTask related method
 *	Description: Command task to set DS to MAINTENANCE mode
 *
 *	@param argin 
 */
//--------------------------------------------------------
void DishManager::set_dsmaintenance_mode_task(Tango::DevString argin)
{
	DEBUG_STREAM << "DishManager::SetDSMaintenanceModeTask()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::set_dsmaintenance_mode_task) ENABLED START -----*/
	
	//	Add your own code
	//=====================================================
	//==      CHECK & EXTRACT TASK DATA
	//=====================================================
	//Extract argin encoded data to TaskData
	_DEBUG_LOG("Parsing argin json encoded TaskData...");
	std::string argin_json_str(argin);
	Utils_ns::TaskData taskData;
	if(Utils_ns::TaskUtils::ParseFromJsonString(taskData,this,argin_json_str)<0){
		std::string errMsg("Failed to parse argin json string to TaskData!");
		_ERROR_LOG(errMsg);
		_THROW_TANGO_EXCEPTION("SET_DS_MAINTENANCE_MODE_TASK_FAILED",errMsg);
	}

	_INFO_LOG("Executing task command "<<taskData.name<<" (id="<<taskData.id<<", has_data? "<<taskData.has_data<<")...");
	
	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	try {
		set_dsmaintenance_mode();
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		_ERROR_LOG("Tango exception occurred while commanding DS to go to MAINTENANCE mode!");
		throw;
	}

	/*----- PROTECTED REGION END -----*/	//	DishManager::set_dsmaintenance_mode_task
}
//--------------------------------------------------------
/**
 *	Command ResetDishMode related method
 *	Description: Reset dish mode, e.g. when in FORBIDDEN state. 
 *               This command will clear all mode progress attributes, 
 *               flush all queued commands and
 *               set STANDBY-LP mode.
 *
 */
//--------------------------------------------------------
void DishManager::reset_dish_mode()
{
	DEBUG_STREAM << "DishManager::ResetDishMode()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::reset_dish_mode) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::vector<std::string> taskProgressResetMsg {"UNKNOWN","Progress attribute was reset"};
	std::vector<std::string> taskProgress_attr_names {
		"setStowModeProgress",
		"setStandbyLPModeProgress",	
		"setStandbyFPModeProgress",
		"setMaintenanceModeProgress",
		"setOperateModeProgress",
		"configureBandProgress"
	};
	//===========================================================================

	//## Clear all tasks present in queue
	_INFO_LOG("Flushing task queue...");
	try{
		flush_task_queue();
	}
	catch(...){
		throw;
	}

	//## Resetting all progress attributes
	_INFO_LOG("Resetting all progress attributes...");	
	for(size_t i=0;i<taskProgress_attr_names.size();i++){
		if(SetDynAttrValue(taskProgressResetMsg,taskProgress_attr_names[i])<0){
			std::stringstream ss;
			ss<<"Failed to set attr "<<taskProgress_attr_names[i]<<" value!";
			_ERROR_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("RESET_DISH_MODE_FAILED",ss.str());	
		}
	}//end loop progress attrs

	//## Set dish STANDBY-LP mode
	_INFO_LOG("Setting dish mode to STANDBY-LP as reset starting mode...");
	try{
		set_standby_lpmode();
	}
	catch(...){
		throw;
	}

	/*----- PROTECTED REGION END -----*/	//	DishManager::reset_dish_mode
}
//--------------------------------------------------------
/**
 *	Command ResetDishTasks related method
 *	Description: Flush all commands in queue and 
 *               reset all progress attributes.
 *
 */
//--------------------------------------------------------
void DishManager::reset_dish_tasks()
{
	DEBUG_STREAM << "DishManager::ResetDishTasks()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::reset_dish_tasks) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::vector<std::string> taskProgressResetMsg {"UNKNOWN","Progress attribute was reset"};
	std::vector<std::string> taskProgress_attr_names {
		"setStowModeProgress",
		"setStandbyLPModeProgress",	
		"setStandbyFPModeProgress",
		"setMaintenanceModeProgress",
		"setOperateModeProgress",
		"configureBandProgress",
		"startupOnPowerRestoreProgress",
		"shutdownOnPowerCutProgress"
	};
	//===========================================================================

	//## Clear all tasks present in queue
	_INFO_LOG("Flushing task queue...");
	try{
		flush_task_queue();
	}
	catch(...){
		throw;
	}

	//## Resetting all progress attributes
	_INFO_LOG("Resetting all progress attributes...");	
	for(size_t i=0;i<taskProgress_attr_names.size();i++){
		if(SetDynAttrValue(taskProgressResetMsg,taskProgress_attr_names[i])<0){
			std::stringstream ss;
			ss<<"Failed to set attr "<<taskProgress_attr_names[i]<<" value!";
			_ERROR_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("RESET_DISH_MODE_FAILED",ss.str());	
		}
	}//end loop progress attrs

	/*----- PROTECTED REGION END -----*/	//	DishManager::reset_dish_tasks
}
//--------------------------------------------------------
/**
 *	Command SetTMProxyAddress related method
 *	Description: This command reset the TM proexy device to be monitored.
 *
 *	@param argin Name of TM proxy device to be monitored
 */
//--------------------------------------------------------
void DishManager::set_tmproxy_address(Tango::DevString argin)
{
	DEBUG_STREAM << "DishManager::SetTMProxyAddress()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::set_tmproxy_address) ENABLED START -----*/
	
	//	Add your own code
	//=========================================
	//==      HARD_CODED VALUES
	//=========================================
	std::string tmProxyAddress_attr_name= "tmProxyAddress";
	//=========================================

	std::string tmProxyAddress_new= std::string(argin);
	_INFO_LOG("Requested to set a new TM proxy address with name "<<tmProxyAddress_new<<" ...");

	//Get TM proxy device name
	std::string tmProxyAddress;
	if(GetDynAttrValue(tmProxyAddress,tmProxyAddress_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<tmProxyAddress_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_TM_PROXY_ADDRESS_FAILED",ss.str());		
	}

	//Unregister old TM proxy device name
	_INFO_LOG("Unregistering current TM proxy "<<tmProxyAddress<<" from the list of monitored proxies...");
	if(_UNREGISTER_PROXY(tmProxyAddress)<0){
		std::stringstream ss;
		ss<<"Failed to unregister proxy "<<tmProxyAddress<<" in device (proxy names invalid or not found?)!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_TM_PROXY_ADDRESS_FAILED",ss.str());	
	}	

	//Register TM proxy device in list of monitored proxies
	_INFO_LOG("Registering new TM proxy "<<tmProxyAddress_new<<" in the list of monitored proxies...");
	if(_REGISTER_PROXY(tmProxyAddress_new)<0){
		std::stringstream ss;
		ss<<"Failed to register proxy "<<tmProxyAddress_new<<" in device (proxy names invalid or not found?)!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_TM_PROXY_ADDRESS_FAILED",ss.str());	
	}	

	//Set the new TM proxy address attr value
	if(SetDynAttrValue(tmProxyAddress_new,tmProxyAddress_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<tmProxyAddress_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_TM_PROXY_ADDRESS_FAILED",ss.str());		
	}

	/*----- PROTECTED REGION END -----*/	//	DishManager::set_tmproxy_address
}
//--------------------------------------------------------
/**
 *	Command RestartSPFComponents related method
 *	Description: Performs a complete restart of SPF software 
 *               components excluding the SPFController Tango 
 *               device.
 *
 */
//--------------------------------------------------------
void DishManager::restart_spfcomponents()
{
	DEBUG_STREAM << "DishManager::RestartSPFComponents()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::restart_spfcomponents) ENABLED START -----*/
	
	//	Add your own code
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string cmd_name= "Restart";
	std::string proxy_name= spfControllerAddress;
	bool execOnAdminProxy= true;
	//===========================================================================
	
	//=====================================================
	//==      EXECUTE COMMAND
	//=====================================================
	_INFO_LOG("Restarting SPF components...");
	Tango::DeviceData dout;
	try {
		ExecCmdOnProxy(dout,proxy_name,cmd_name,execOnAdminProxy);
	}
	catch(...){
		throw;
	}

	/*----- PROTECTED REGION END -----*/	//	DishManager::restart_spfcomponents
}
//--------------------------------------------------------
/**
 *	Command SetStandbyFPModeOnBandError related method
 *	Description: Set STANDBY-FP mode if:
 *               
 *               - dishMode=OPERATE
 *               - configuredBand!=NONE
 *               - bXCapability=UNAVAILABLE (X=configured band)
 *
 */
//--------------------------------------------------------
void DishManager::set_standby_fpmode_on_band_error()
{
	DEBUG_STREAM << "DishManager::SetStandbyFPModeOnBandError()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::set_standby_fpmode_on_band_error) ENABLED START -----*/
	
	//	Add your own code
	// == COMMAND BEHAVIOR ==
	//1) Check if dish is in OPERATE, if not do nothing
	//2) Check if failing band is the configured band, if not do nothing 
	//3) If equal, set dish to STANDBY_FP mode (R.LMC.SM.18)
	
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################	
	std::string dishMode_attr_name= "dishMode";
	std::vector<std::string> dishModes_str {"OPERATE"};
	std::string dishMode_final_str= "STANDBY-FP";
	std::string configuredBand_attr_name= "configuredBand";
	int nBands= 6;
	std::vector<std::string> capability_attr_names {
		"b1CapabilityState",
		"b2CapabilityState",
		"b3CapabilityState",
		"b4CapabilityState",
		"b5aCapabilityState",
		"b5bCapabilityState",
	};
	std::vector<std::string> capabilities_str {"UNAVAILABLE"};
	std::string handlerEnabled_attr_name= "enableBandErrorEventHandler";

	//Task vars
	std::vector<std::string> taskSequenceStartedMsg {"IDLE","Set dish to STANDBY-FP mode on band error scheduled"};
	std::vector<std::string> taskAlreadyCompletedMsg {"COMPLETED","Dish is already in STANDBY-FP mode"};
	std::vector<std::string> taskSequence_progress_ongoing= {"INIT","IDLE","RUNNING"};

	std::string taskSequence_name= "SetStandbyFPModeOnBandError";
	std::string taskSequence_progress_attr_name= "setStandbyFPOnBandErrorProgress";
	
	//- Rx tasks
	std::string rx_task_name= "SetRxStandbyFPModeTask";

	//- SPF tasks
	std::string spf_task_name= "SetSPFOperateModeTask";
	std::string spf_task_progress_attr_name= "spfSetOperateModeProgress";

	//- DS tasks
	std::string ds_task_name= "SetDSStandbyFPModeTask";
	std::string ds_task_progress_attr_name= "dsSetStandbyFPModeProgress";
	//###########################################################################

	
	//=====================================================
	//==      CHECK HANDLER ENABLED/DISABLED
	//=====================================================
	//## Get handler is enabled/disabled
	Tango::DevBoolean handlerEnabled= true;
	if(GetDynAttrValue(handlerEnabled,handlerEnabled_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get dyn attr "<<dishMode_attr_name<<" value!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STANDBY_FP_ON_BAND_ERROR_FAILED",ss.str());		
	}

	if(!handlerEnabled){
		_INFO_LOG("Band error event handler is disabled, nothing to be done...");
		return;
	}

	//=====================================================
	//==      CHECK DISH MODE
	//=====================================================
	//## Get current dishMode attr value
	Tango::DevShort dishMode_current;
	if(GetDynAttrValue(dishMode_current,dishMode_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get dyn attr "<<dishMode_attr_name<<" value!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STANDBY_FP_ON_BAND_ERROR_FAILED",ss.str());		
	}

	//## Retrieve enum label corresponding to value
	std::string dishMode_current_str;
	if(Utils_ns::TangoUtils::GetEnumAttrLabelValue(dishMode_current_str,this,dishMode_attr_name,dishMode_current)<0){
		std::stringstream ss;
		ss<<"Failed to get enum label for dyn attr "<<dishMode_attr_name<<" corresponding to value "<<dishMode_current<<"!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STANDBY_FP_ON_BAND_ERROR_FAILED",ss.str());	
	}
	
	//## Do nothing if dish is not in the desired modes
	bool triggerAction= false;
	for(size_t i=0;i<dishModes_str.size();i++){
		if(dishMode_current_str==dishModes_str[i]){
			triggerAction= true;
			break;
		}
	}

	if(!triggerAction){
		_DEBUG_LOG("Dish is in mode "<<dishMode_current_str<<", no actions required in case of band errors in this mode...");
		return;
	}

	

	//=====================================================
	//==      CHECK IF A BAND IS CONFIGURED
	//=====================================================
	Tango::DevShort configuredBand_current;
	if(GetDynAttrValue(configuredBand_current,configuredBand_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get dyn attr "<<configuredBand_attr_name<<" value!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STANDBY_FP_ON_BAND_ERROR_FAILED",ss.str());		
	}

	//If no band configured return
	if(configuredBand_current<=0 || configuredBand_current>=nBands){
		_DEBUG_LOG("No band configured in the dish (bandId="<<configuredBand_current<<"), nothing to be done...");
		return;
	}

	//=============================================================
	//==      CHECK IF CONFIGURED BAND CAPABILITY IS UNAVAILABLE
	//=============================================================
	std::string capability_attr_name= capability_attr_names[configuredBand_current-1];
	Tango::DevShort capability_current;
	if(GetDynAttrValue(capability_current,capability_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get dyn attr "<<capability_attr_name<<" value!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STANDBY_FP_ON_BAND_ERROR_FAILED",ss.str());		
	}
	
	//## Retrieve enum label corresponding to value
	std::string capability_current_str;
	if(Utils_ns::TangoUtils::GetEnumAttrLabelValue(capability_current_str,this,capability_attr_name,capability_current)<0){
		std::stringstream ss;
		ss<<"Failed to get enum label for dyn attr "<<capability_attr_name<<" corresponding to value "<<capability_current<<"!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STANDBY_FP_ON_BAND_ERROR_FAILED",ss.str());	
	}
	
	//## Check if capability is UNAVAILABLE
	triggerAction= false;
	for(size_t i=0;i<capabilities_str.size();i++){
		if(capability_current_str==capabilities_str[i]){
			triggerAction= true;
			break;
		}
	}

	if(!triggerAction){
		_DEBUG_LOG("Capability of configured band (B"<<configuredBand_current<<") is "<<capability_current_str<<", no actions required ...");
		return;
	}

	_INFO_LOG("Capability of configured band (B"<<configuredBand_current<<") is out of operate, setting dish to STANDBY-FP mode...");

	//=====================================================
	//==         CHECK IF TASK IS ALREADY RUNNING
	//=====================================================
	_DEBUG_LOG("Check if a previous SetStandbyFPOnBandError task is already running...");
	std::vector<std::string> taskProgress;
	if(GetDynAttrValue(taskProgress,taskSequence_progress_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<taskSequence_progress_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STANDBY_FP_ON_BAND_ERROR_FAILED",ss.str());	
	}
	if(taskProgress.size()<2){
		std::stringstream ss;
		ss<<"Invalid size for attr "<<taskSequence_progress_attr_name<<" value (expected at least equal to 2)!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STANDBY_FP_ON_BAND_ERROR_FAILED",ss.str());	
	}

	std::string taskProgressStr= taskProgress[0];
	
	//Check if another task is already running
	bool isTaskRunning= false;
	for(size_t i=0;i<taskSequence_progress_ongoing.size();i++){
		if(taskProgressStr==taskSequence_progress_ongoing[i]){
			isTaskRunning= true;
			break;
		}
	}//end loop config busy codes

	if(isTaskRunning) {
		std::stringstream ss;
		ss<<"Another set STANDBY-FP mode on band error task is running or pending for execution (hint: you must wait for completion before requesting a new task)";
		_WARN_LOG(ss.str());
		//_THROW_TANGO_EXCEPTION("SET_STANDBY_FP_ON_BAND_ERROR_FAILED",ss.str());
		return;
	}


	//=====================================================
	//==      CHECK IF DISH IS ALREADY IN STANDBY-FP
	//=====================================================
	//## Check if STANDBY-FP mode is already active	
	if(dishMode_current_str==dishMode_final_str){
		_INFO_LOG("Dish mode "<<dishMode_final_str<<" already active, no actions to be done on band error");

		//Set task progress attr
		if(SetDynAttrValue(taskAlreadyCompletedMsg,taskSequence_progress_attr_name)<0){
			std::stringstream ss;
			ss<<"Failed to set attr "<<taskSequence_progress_attr_name<<" value!";
			_ERROR_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("SET_STANDBY_FP_ON_BAND_ERROR_FAILED",ss.str());	
		}	
		return;
	}//close if

	

	//=====================================================
	//==      PREPARE TASKS DATA
	//=====================================================
	
	//Prepare task data
	bool useUTC= false;
	int priority= Utils_ns::Task::eMEDIUM_PRIORITY;

	//#### SPF TASKS ###### 
	//- Task (asynch): SPF SetOperateMode
	Utils_ns::TaskPtr spf_task= std::make_shared<Utils_ns::Task>(this,spf_task_name,priority,useUTC);
	spf_task->SetMaxDuration(defaultTaskTimeout*1000.);//Set task timeout
	spf_task->SetAsynchTask(spf_task_progress_attr_name);//Set asynch task attr status
	
	//#### DS TASKS ###### 
	//- Task (asynch): DS SetStandbyFPMode
	Utils_ns::TaskPtr ds_task= std::make_shared<Utils_ns::Task>(this,ds_task_name,priority,useUTC);
	ds_task->SetMaxDuration(defaultTaskTimeout*1000.);//Set task timeout
	ds_task->SetAsynchTask(ds_task_progress_attr_name);//Set asynch task attr status
	
	//#### Rx TASKS ###### 
	//- Task (synch): Rx SetStandbyFPMode
	Utils_ns::TaskPtr rx_task= std::make_shared<Utils_ns::Task>(this,rx_task_name,priority,useUTC);
	rx_task->SetMaxDuration(defaultTaskTimeout*1000.);//Set task timeout
	
	//## Add tasks to sequence
	std::vector<Utils_ns::TaskPtr> tasks;
	tasks.push_back(spf_task);
	tasks.push_back(ds_task);
	tasks.push_back(rx_task);
	
	Utils_ns::TaskSequencePtr taskSequence= std::make_shared<Utils_ns::TaskSequence>(this,taskSequence_name,useUTC);
	taskSequence->SetDevStatusAttr(taskSequence_progress_attr_name);//Set device attr containing task sequence status

	for(size_t i=0;i<tasks.size();i++){
		if(taskSequence->AddTask(tasks[i])<0){
			std::stringstream ss;
			ss<<"Failed to add task "<<i+1<<" (name="<<tasks[i]->cmd_name<<") to sequence!";
			_WARN_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("SET_STANDBY_FP_ON_BAND_ERROR_FAILED",ss.str());			
		}
	}//end loop tasks


	//=====================================================
	//==      SCHEDULE TASKS
	//=====================================================
	
	//Add task to queue 
	bool addToQueue= true;
	if(m_taskManager->AddTaskSequence(taskSequence,addToQueue)<0){
		std::stringstream ss;
		ss<<"Failed to add task sequence "<<taskSequence_name<<" to queue!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STANDBY_FP_ON_BAND_ERROR_FAILED",ss.str());
	}
	_DEBUG_LOG("Added sequence "<<taskSequence_name<<" to task queue...");


	//Set task progress attr to IDLE
	if(SetDynAttrValue(taskSequenceStartedMsg,taskSequence_progress_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<taskSequence_progress_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SET_STANDBY_FP_ON_BAND_ERROR_FAILED",ss.str());	
	}	

	/*----- PROTECTED REGION END -----*/	//	DishManager::set_standby_fpmode_on_band_error
}
//--------------------------------------------------------
/**
 *	Command dummyDynCmd related method
 *	Description: 
 *
 */
//--------------------------------------------------------
void DishManager::dummy_dyn_cmd(Tango::Command &command)
{
	DEBUG_STREAM << "DishManager::" << command.get_name() << "  - " << device_name << endl;
	/*----- PROTECTED REGION ID(DishManager::dummy_dyn_cmd) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	DishManager::dummy_dyn_cmd
}
//--------------------------------------------------------
/**
 *	Method      : DishManager::add_dynamic_commands()
 *	Description : Create the dynamic commands if any
 *                for specified device.
 */
//--------------------------------------------------------
void DishManager::add_dynamic_commands()
{
	//	Example to add dynamic command:
	//	Copy inside the folowing protected area to instanciate at startup.
	//	add_dummyDynCmd_dynamic_command("MydummyDynCmdCommand", true);
	
	/*----- PROTECTED REGION ID(DishManager::add_dynamic_commands) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic commands if any
	LMCDevice::add_dynamic_commands();

	/*----- PROTECTED REGION END -----*/	//	DishManager::add_dynamic_commands
}

/*----- PROTECTED REGION ID(DishManager::namespace_ending) ENABLED START -----*/

//	Additional Methods
int DishManager::InitCmdAttrStateMachine(){
	
	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string dishMode_attr_name= "dishMode";
	//###########################################################################

	//===================================
	//==        CMD RULES
	//===================================
	//- SetMaintenanceMode()
	_REGISTER_CMD_RULE(std::string,"SetMaintenanceMode",dishMode_attr_name,("STANDBY-LP","STANDBY-FP","MAINTENANCE"));
	
	//- SetStandbyFPMode()
	_REGISTER_CMD_RULE(std::string,"SetStandbyFPMode",dishMode_attr_name,("STANDBY-LP","STANDBY-FP","MAINTENANCE","OPERATE","STOW"));
	
	//- SetOperateMode()
	_REGISTER_CMD_RULE(std::string,"SetOperateMode",dishMode_attr_name,("STANDBY-FP","OPERATE"));
	
	//- Synchronise()
	_REGISTER_CMD_RULE(std::string,"Synchronise",dishMode_attr_name,("OPERATE"));
	
	//- Capture()
	_REGISTER_CMD_RULE(std::string,"Capture",dishMode_attr_name,("OPERATE"));

	//- ConfigureBand()
	_REGISTER_CMD_RULE(std::string,"ConfigureBand1",dishMode_attr_name,("STANDBY-FP","OPERATE","STOW"));
	_REGISTER_CMD_RULE(std::string,"ConfigureBand2",dishMode_attr_name,("STANDBY-FP","OPERATE","STOW"));
	_REGISTER_CMD_RULE(std::string,"ConfigureBand3",dishMode_attr_name,("STANDBY-FP","OPERATE","STOW"));
	_REGISTER_CMD_RULE(std::string,"ConfigureBand4",dishMode_attr_name,("STANDBY-FP","OPERATE","STOW"));
	_REGISTER_CMD_RULE(std::string,"ConfigureBand5a",dishMode_attr_name,("STANDBY-FP","OPERATE","STOW"));
	_REGISTER_CMD_RULE(std::string,"ConfigureBand5b",dishMode_attr_name,("STANDBY-FP","OPERATE","STOW"));
		
	//- Track()
	_REGISTER_CMD_RULE(std::string,"Track",dishMode_attr_name,("OPERATE"));

	//- Slew()
	_REGISTER_CMD_RULE(std::string,"Slew",dishMode_attr_name,("OPERATE"));

	//- Scan()
	_REGISTER_CMD_RULE(std::string,"Scan",dishMode_attr_name,("OPERATE"));

	//===================================
	//==     ATTR TRANSITION RULES
	//===================================
	//...

	
	//=====================================
	//===     ATTR READ/WRITE RULES 
	//=====================================
	//- Dish control model pars
	_REGISTER_ATTR_WRITE_RULE(bool,"dishMode","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"healthState","testMode",(true));	

	//- Dish task pars
	_REGISTER_ATTR_WRITE_RULE(bool,"setStowModeProgress","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"setStandbyLPModeProgress","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"setStandbyFPModeProgress","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"setMaintenanceModeProgress","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"setOperateModeProgress","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"configureBandProgress","testMode",(true));

	_REGISTER_ATTR_WRITE_RULE(bool,"setStowModeProgressStatus","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"setStandbyLPModeProgressStatus","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"setStandbyFPModeProgressStatus","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"setMaintenanceModeProgressStatus","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"setOperateModeProgressStatus","testMode",(true));
	_REGISTER_ATTR_WRITE_RULE(bool,"configureBandProgressStatus","testMode",(true));
	
	return 0;

}//close InitCmdAttrStateMachine()

int DishManager::RegisterProxies(){

	//## Register device proxies
	_DEBUG_LOG("Registering device proxies for device "<<device_name<<"...");
	
	

	return 0;

}//close RegisterProxies()

int DishManager::RegisterEventSubscriptions(){

	//## Register proxy events 
	_DEBUG_LOG("Registering event subscription for device "<<device_name<<"...");
	
	// Tango::CHANGE_EVENT
	// Tango::PERIODIC_EVENT
	// Tango::ARCHIVE_EVENT
	// Tango::ATTR_CONF_EVENT
	// Tango::DATA_READY_EVENT
	// Tango::USER_EVENT
	// Tango::INTERFACE_CHANGE_EVENT,		///< Device interface change event
	// Tango::PIPE_EVENT,					///< Device pipe event
	
	return 0;

}//close RegisterEventSubscriptions()

int DishManager::RegisterEventHandlers(){

	//## Register event handlers

	
	return 0;

}//close RegisterEventHandlers()


int DishManager::ConfigureBand(Tango::DevShort bandId,std::string activation_timestamp)
{
	
	// == COMMAND BEHAVIOR ==
	// 1) Check if cmd mode-allowed: Allowed in {STANDBY-FP,OPERATE} (see TM-LMC ICD)
	// 2) Check if band capability is available
	// 3) Check if band is already active and in case return (exception?)
  //    NB: In case of re-configuration (e.g. if some pars have changed we must allow the command in the same band) 
	// 4) Actions in Rx (see Rx DDR)
	//     4.1) First stop capture on active band with SetStandbyFPMode() (or maybe Capture(off)) (only for reconfiguration)
	//     4.2) SetNoiseSource() (if not done a default value is used) (only for reconfiguration)
	//     4.3) AdjustGain() (if not done a default value is used) (not present in ICD!!!) (only for reconfiguration)
	//     4.4) ConfigureBand(bandId) (can take long time) and monitor task (with timeout)
	//     4.5) When configure finishes and rx_mode=DATA_CAPTURE: Sinchronise()
	// 5) Actions in DS (see State & Modes/ICD)
	//     5.1) Move indexer to desired position (monitor task with timeout)
	// 6) Actions in SPF (see ICD?)
	//     6.1) Power on LNA V- & H-channels for selected band
	//     6.2) Power on 2nd stage temperature control for selected band
	// 7) Final actions
	//     7.1) Set SPF configuredBand attribute if configuration completes

	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string task_name= "ConfigureBand";	
	std::vector<std::string> requestedBand_attr_enums {"B1","B2","B3","B4","B5a","B5b"};
	std::string requestedBand_attr_name= "requestedBand";	
	std::string configuredBand_attr_name= "configuredBand";
	int nBands= static_cast<int>(requestedBand_attr_enums.size());

	std::map<Tango::DevShort,Tango::DevShort> spfBandIdMap = {
		{0,0}, {1,1}, {2,2}, {3,3}, {4,4}, {5,5}, {6,5} 	
	};
	std::map<Tango::DevShort,Tango::DevShort> dsBandIdMap = {
		{0,0}, {1,1}, {2,2}, {3,3}, {4,4}, {5,5}, {6,5} 	
	};
	std::map<Tango::DevShort,Tango::DevShort> rxBandIdMap = {
		{0,0}, {1,1}, {2,2}, {3,3}, {4,4}, {5,5}, {6,6} 	
	};

	
	//Task vars
	//- Task sequence
	std::string taskSequence_name= "ConfigureBand";
	std::string taskSequence_progress_attr_name= "configureBandProgress";
	std::vector<std::string> taskSequence_progress_ongoing= {"INIT","IDLE","RUNNING"};

	//- Rx tasks
	std::string rx_task1_name= "ConfigureRxBandTask";
	//std::string rx_task1_progress_attr_name= "rxConfigureBandProgress";//NB: This is not a long-running task according to ICD
	std::string rx_task2_name= "SynchroniseRxBandTask";

	//- SPF tasks
	std::string spf_task1_name= "SetSPFLnaPowerOnTask";
	std::string spf_task2_name= "SetSPFBandInFocusTask";
	
	//- DS tasks
	std::string ds_task1_name= "SetIndexerPositionTask";
	std::string ds_task1_progress_attr_name= "dsIndexingProgress";//"dsIndexingStatus";

	//- Task dependency matrix
	std::vector< std::vector<size_t> > task_dependency_matrix { 	
		{},	
		{0},
		{},
		{2},
		{2} 
	};
	//###########################################################################
	
	//=====================================================
	//==      CHECK ARGIN
	//=====================================================
	//Check band id arg
	if(bandId<=0 || bandId>nBands){
		std::stringstream ss;
		ss<<"Invalid band id ("<<bandId<<") given, valid values are [1,"<<nBands<<"]!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("CONFIGURE_BAND_FAILED",ss.str());	
	}
	
	//Check activation timestamp
	bool hasActivationTimestamp= (activation_timestamp!="");
	if(hasActivationTimestamp){//Check if valid timestamp (e.g. in the future)
		//...
		//...
	}

	
	//=====================================================
	//==      CHECK IF BAND IS ALREADY ACTIVE
	//=====================================================
	//Read configured band
	Tango::DevShort configuredBand;
	if(GetDynAttrValue(configuredBand,configuredBand_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get dyn attr "<<configuredBand_attr_name<<" value!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("CONFIGURE_BAND_FAILED",ss.str());	
	}

	_INFO_LOG("Requested to configure band "<<bandId<<" in Dish (configuredBand="<<configuredBand<<") ...");


	//Check if band is already active
	/*
	if(bandId==configuredBand){
		std::stringstream ss;
		ss<<"Requested band "<<bandId<<" is already configured in Dish";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("CONFIGURE_BAND_FAILED",ss.str());	.
	}
	*/

	//=====================================================
	//==      CHECK CAPABILITY AVAILABLE
	//=====================================================
	bool isAvailable= false;
	if(IsBandCapabilityAvailable(isAvailable,bandId)<0){
		std::stringstream ss;
		ss<<"Failed to check is capability is available for band "<<bandId<<"!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("CONFIGURE_BAND_FAILED",ss.str());	
	}
	
	if(!isAvailable){
		std::stringstream ss;
		ss<<"Capability band "<<bandId<<" is not available, cannot configure band!";
		_INFO_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("CONFIGURE_BAND_FAILED",ss.str());	
	}
	_INFO_LOG("Capability for band "<<bandId<<" is available for configuration...");

	//=========================================================
	//==      CHECK IF CONFIGURE TASK IS ALREADY RUNNING
	//=========================================================
	//Read configureProgress attr
	std::vector<std::string> taskProgress;
	if(GetDynAttrValue(taskProgress,taskSequence_progress_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get dyn attr "<<taskSequence_progress_attr_name<<" value!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("CONFIGURE_BAND_FAILED",ss.str());	
	}
	std::string taskProgressStr= taskProgress[0];

	
	//Check if another configuration task is already running
	bool isTaskRunning= false;
	for(unsigned int i=0;i<taskSequence_progress_ongoing.size();i++){
		if(taskProgressStr==taskSequence_progress_ongoing[i]){
			isTaskRunning= true;
			break;
		}
	}//end loop config busy codes

	if(isTaskRunning) {
		std::stringstream ss;
		ss<<"Another dish configuration task is running or pending for execution (hint: you must wait for completion before requesting a new/same band (re)configuration)";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("CONFIGURE_BAND_FAILED",ss.str());
	}

	
	//=====================================================
	//==      PREPARE TASKS
	//=====================================================
	
	//Prepare task data
	bool useUTC= false;
	int priority= Utils_ns::Task::eMEDIUM_PRIORITY;
	
	//#### Rx TASKS ###### 
	//- Task 1 (asynch): Rx ConfigureBand	
	CORBA::Any rx_task1_argin;
	rx_task1_argin <<= rxBandIdMap[bandId];

	Utils_ns::TaskPtr rx_task1= std::make_shared<Utils_ns::Task>(this,rx_task1_name,priority,useUTC);
	rx_task1->SetMaxDuration(configureTaskTimeout*1000.);//Set task timeout
	rx_task1->SetTaskArgin(rx_task1_argin,Tango::DEV_SHORT,Tango::SCALAR);//set task argin
	//rx_task1->SetAsynchTask(rx_task1_progress_attr_name);//Set asynch task attr status (IN NEW ICD THIS COMMAND HAS SYNCH RESPONSE)

	//- Task 2  (synch): Rx Synchronise band (depend on Task1)
	Utils_ns::TaskPtr rx_task2= std::make_shared<Utils_ns::Task>(this,rx_task2_name,priority,useUTC);
	rx_task2->SetMaxDuration(defaultTaskTimeout*1000.);//Set task timeout
	
	//#### DS TASKS ###### 
	//- Task 1 (async): DS move indexer
	CORBA::Any ds_task1_argin;
	ds_task1_argin <<= dsBandIdMap[bandId];

	Utils_ns::TaskPtr ds_task1= std::make_shared<Utils_ns::Task>(this,ds_task1_name,priority,useUTC);
	ds_task1->SetMaxDuration(configureTaskTimeout*1000.);//Set task timeout
	ds_task1->SetTaskArgin(ds_task1_argin,Tango::DEV_SHORT,Tango::SCALAR);//set task argin
	ds_task1->SetAsynchTask(ds_task1_progress_attr_name);//Set asynch task attr status

	//#### SPF TASKS ###### 
	//- Task 1 (synch): SPF LNA Power on (depend on DS task)
	CORBA::Any spf_task1_argin;
	spf_task1_argin <<= spfBandIdMap[bandId];

	Utils_ns::TaskPtr spf_task1= std::make_shared<Utils_ns::Task>(this,spf_task1_name,priority,useUTC);
	spf_task1->SetMaxDuration(defaultTaskTimeout*1000.);//Set task timeout
	spf_task1->SetTaskArgin(spf_task1_argin,Tango::DEV_SHORT,Tango::SCALAR);//set task argin
	
	//- Task 2 (synch): SPF set band in focus (depend on DS task)
	CORBA::Any spf_task2_argin;
	spf_task2_argin <<= spfBandIdMap[bandId];

	Utils_ns::TaskPtr spf_task2= std::make_shared<Utils_ns::Task>(this,spf_task2_name,priority,useUTC);
	spf_task2->SetMaxDuration(defaultTaskTimeout*1000.);//Set task timeout
	spf_task2->SetTaskArgin(spf_task2_argin,Tango::DEV_SHORT,Tango::SCALAR);//set task argin
	
	//## Add tasks to sequence
	std::vector<Utils_ns::TaskPtr> tasks;
	tasks.push_back(rx_task1);
	tasks.push_back(rx_task2);
	tasks.push_back(ds_task1);
	tasks.push_back(spf_task1);
	tasks.push_back(spf_task2);

	Utils_ns::TaskSequencePtr taskSequence= std::make_shared<Utils_ns::TaskSequence>(this,taskSequence_name,useUTC);
	taskSequence->SetDevStatusAttr(taskSequence_progress_attr_name);//Set device attr containing task sequence status

	for(unsigned int i=0;i<tasks.size();i++){
		if(taskSequence->AddTask(tasks[i])<0){
			std::stringstream ss;
			ss<<"Failed to add task "<<i+1<<" (name="<<tasks[i]->cmd_name<<") to sequence!";
			_WARN_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("CONFIGURE_BAND_FAILED",ss.str());			
		}
	}//end loop tasks

	//Set task dependencies (task 2 depends on 1 to complete, task 4 & 5 depends on task 3)
	if(taskSequence->SetTaskDependency(task_dependency_matrix)<0){
		std::stringstream ss;
		ss<<"Failed to set task dependency indexes in sequence!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("CONFIGURE_BAND_FAILED",ss.str());		
	}
	
	//=====================================================
	//==      SCHEDULE TASKS
	//=====================================================
	
	//Add task to queue 
	bool addToQueue= true;
	if(m_taskManager->AddTaskSequence(taskSequence,addToQueue)<0){
		std::stringstream ss;
		ss<<"Failed to add task sequence "<<task_name<<" to queue!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("CONFIGURE_BAND_FAILED",ss.str());
	}
	_INFO_LOG("Added sequence "<<task_name<<" to task queue...");
	
	//Set task progress attr to IDLE
	std::stringstream msg_stream;
	msg_stream<<"Dish configuration for band "<<bandId<<" scheduled";
	std::vector<std::string> taskSequenceStartedMsg {"IDLE",msg_stream.str()};

	if(SetDynAttrValue(taskSequenceStartedMsg,taskSequence_progress_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<taskSequence_progress_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("CONFIGURE_BAND_FAILED",ss.str());	
	}	


	//=====================================================
	//==      SET BAND REQUESTED TO BE CONFIGURED
	//=====================================================
	
	//## Set configured band
	std::string requestedBandStr= requestedBand_attr_enums[bandId-1];
	Tango::DevShort requestedBand;
	Utils_ns::TangoUtils::GetEnumAttrValue(requestedBand,this,requestedBand_attr_name,requestedBandStr);
	if(SetDynAttrValue<Tango::DevShort>(requestedBand,requestedBand_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to set attr "<<requestedBand_attr_name<<" to "<<requestedBandStr<<"!";
		_WARN_LOG(ss.str());

		//Set state and status
		set_state(Tango::FAULT);
		set_status("Configuration task was scheduled but an error occurred while storing requested bandId (err= " + ss.str() + ")");

		_THROW_TANGO_EXCEPTION("CONFIGURE_BAND_FAILED",ss.str());	
	}

	return 0;

}//close ConfigureBand()




int DishManager::IsBandCapabilityAvailable(bool& isAvailable,Tango::DevShort bandId){

	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::vector<std::string> cap_attr_names {
		"b1CapabilityState",
		"b2CapabilityState",
		"b3CapabilityState",
		"b4CapabilityState",
		"b5aCapabilityState",
		"b5bCapabilityState"		
	};
	std::vector<std::string> cap_not_available {"UNAVAILABLE","UNKNOWN"};//CHECK IF UNKNOWN capability is to be considered as not available??
	//std::string cap_not_available= "UNAVAILABLE";
	//===========================================================================
	isAvailable= false;

	//Check bandId arg
	if(bandId<=0 || bandId>static_cast<Tango::DevShort>(cap_attr_names.size())){//Wrong arg
		_WARN_LOG("Invalid band id ("<<bandId<<") given, valid range is [1-"<<cap_attr_names.size()<<"]!");
		isAvailable= false;
		return -1;
	}	

	//Read capability value
	std::string cap_attr_name= cap_attr_names[bandId-1];
	Tango::DevShort capabilityState;
	if(GetDynAttrValue(capabilityState,cap_attr_name)<0){
		_WARN_LOG("Failed to get dyn attr "<<cap_attr_name<<" value!");
		isAvailable= false;
		return -1;
	}

	//Get enum label corresponding to value
	std::string capabilityState_str= "";
	if(Utils_ns::TangoUtils::GetEnumAttrLabelValue(capabilityState_str,this,cap_attr_name,capabilityState)<0){
		_WARN_LOG("Failed to retrieve enum label corresponding to value "<<capabilityState<<" for attr "<<cap_attr_name<<"!");
		isAvailable= false;
		return -1;
	}

	//Check if capability is available or not
	isAvailable= true;
	for(unsigned int i=0;i<cap_not_available.size();i++){
		if(capabilityState_str==cap_not_available[i]){
			isAvailable= false;
			break;
		}
	}

	return 0;

}//close IsBandCapabilityAvailable()


int DishManager::InitConfigurationTask(){

	//## Initialize device task
	_DEBUG_LOG("Initializing device configuration task...");
	m_configureTask = 0;

	//- Define task configuration
	ConfigureTask::Config cfg;
  cfg.host_device = this;
	cfg.enable_periodic_msg= false;
	cfg.task_activity_period_ms = configureMonitoringPollPeriod;
	cfg.enable_timeout_msg= false;
	cfg.task_activity_timeout_ms = configureMonitoringTimeout;
	cfg.synchCmdReplyTimeout= synchCmdReplyTimeout;
	cfg.asynchCmdReplyTimeout= asynchCmdReplyTimeout;
	cfg.asynchCmdReplyNRetries= asynchCmdReplyNRetries;
	
	//- Allocate and start the device task
	try {
		_INFO_LOG("Initializing device configuration task...");
    m_configureTask = new (std::nothrow) ConfigureTask(cfg);
	  if (!m_configureTask){
    	throw std::bad_alloc();
		}

    _INFO_LOG("Starting the configure task...");
    m_configureTask->go();
	}
  catch (const std::bad_alloc&) {
		std::string errMsg("Device configure task initialization failed (allocation failed)");
  	_ERROR_LOG(errMsg);
		set_state(Tango::FAULT);
    set_status(errMsg.c_str());
		return -1;
	}
  catch (Tango::DevFailed& e) {
		Tango::Except::print_exception(e);
		std::string errMsg("Device configure task initialization failed [see device log for details]");
  	_ERROR_LOG(errMsg);
		set_state(Tango::FAULT);
    set_status(errMsg.c_str());
    return -1;
  }
  catch (...) {
  	std::string errMsg("Device configure task initialization failed [unknown error]");
  	_ERROR_LOG(errMsg);
		set_state(Tango::FAULT);
    set_status(errMsg.c_str());
    return -1;
  }

	return 0;

}//close InitConfigurationTask()

int DishManager::ClearConfigurationTask(){

	if(!m_configureTask) return 0;

	//## First signal waiting conditions
	m_configureTask->signal_wait();

	//## Release the task: just ask task to quit
	//## NB: Never explicitly delete a yat4tango::DeviceTask
	m_configureTask->exit();
  m_configureTask = 0;

	return 0;

}//close ClearConfigurationTask()

void DishManager::SelectBandAttrsInCmd(std::vector<std::string>& attr_names_selected,int bandId, std::vector<std::string> attr_names,std::vector<int> unsupported_bands){

	//###########################################################################
	//##    HARD-CODED PARAMETERS (TO BE CHANGED IF ICD CHANGE OR USE ALIASES?)
	//###########################################################################
	std::string activeBand_attr_name= "configuredBand";
	int nBands= 6;
	std::map<Tango::DevShort,Tango::DevShort> spfBandIdMap = {
		{-1,-1}, {0,0}, {1,1}, {2,2}, {3,3}, {4,4}, {5,5}, {6,5} 	
	};
	//###########################################################################
	
	//Check argin values
	//int nBands= static_cast<int>(attr_names.size());
	if(bandId<-1 || bandId>nBands){
		std::stringstream ss;
		ss<<"Invalid bandId value given (valid values are [-1,"<<nBands<<"])!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SELECT_BAND_ATTRS_IN_CMD_FAILED",ss.str());	
	}
	bool useAllBands= (bandId==-1);
	bool useActiveBand= (bandId==0);
	bool useSelectedBand= (bandId>=1 && bandId<=nBands);


	//If active band is requested, check there is an active band
	if(useActiveBand){
		attr_names_selected.clear();

		//Read current activeBand
		Tango::DevShort activeBand;
		if(GetDynAttrValue(activeBand,activeBand_attr_name)<0){
			std::stringstream ss;
			ss<<"Failed to get dyn attr "<<activeBand_attr_name<<" value!";
			_WARN_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("SELECT_BAND_ATTRS_IN_CMD_FAILED",ss.str());		
		}

		//Check if a valid active band is present
		if(activeBand<=0 || activeBand>nBands){
			std::stringstream ss;
			ss<<"Invalid or unknown active band (band not configured or determined yet)!";
			_WARN_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("SELECT_BAND_ATTRS_IN_CMD_FAILED",ss.str());	
		}
		
		//Check if supported for active band
		bool isSupported= true;
		for(size_t i=0;i<unsupported_bands.size();i++){
			if(activeBand==unsupported_bands[i]){
				isSupported= false;
				break;
			}
		}
		if(!isSupported){
			std::stringstream ss;
			ss<<"Command is not supported for band "<<activeBand<<" currently active!";
			_WARN_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("SELECT_BAND_ATTRS_IN_CMD_FAILED",ss.str());
		}

		Tango::DevShort bandIndex= spfBandIdMap[activeBand];
		attr_names_selected.push_back(attr_names[bandIndex-1]);

	}//close if useActiveBand
	
	if(useAllBands){
		attr_names_selected.clear();

		for(size_t i=0;i<attr_names.size();i++){
			bool isSupported= true;
			int currentBandId= i+1;
			for(size_t j=0;j<unsupported_bands.size();j++){
				if(currentBandId==unsupported_bands[j]){
					isSupported= false;
					break;
				}
			}//end loop unsupported bands
			if(isSupported) attr_names_selected.push_back(attr_names[i]);
		}//end loop attrs

		
	}//close if all bands

	if(useSelectedBand){
		attr_names_selected.clear();

		bool isSupported= true;
		for(size_t i=0;i<unsupported_bands.size();i++){
			if(bandId==unsupported_bands[i]){
				isSupported= false;
				break;
			}
		}
		if(!isSupported){
			std::stringstream ss;
			ss<<"Command is not supported for requested band "<<bandId<<"!";
			_WARN_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("SELECT_BAND_ATTRS_IN_CMD_FAILED",ss.str());
		}
		
		Tango::DevShort bandIndex= spfBandIdMap[bandId];
		attr_names_selected.push_back(attr_names[bandIndex-1]);
	}//close selected band

	//Check if there are bands left
	if(attr_names_selected.empty()){
		std::stringstream ss;
		ss<<"No supported bands available!";
		_WARN_LOG(ss.str());
		_THROW_TANGO_EXCEPTION("SELECT_BAND_ATTRS_IN_CMD_FAILED",ss.str());
	}

}//close SelectBandAttrsInCmd()





void DishManager::ExecCmdOnProxy(std::string input_proxy_name,std::string cmd_name,bool execOnAdminDevice)
{
	std::string proxy_name= input_proxy_name;

	//=====================================================
	//==      FIND ADMIN DEVICE NAME?
	//=====================================================
	if(execOnAdminDevice){
		std::string proxy_adm_name= "";
		if(Utils_ns::TangoUtils::GetAdminProxyName(proxy_adm_name,proxy_name)<0){
			std::stringstream ss;
			ss<<"Failed to retrieve admin proxy name from proxy name "<<proxy_name<<"!";
			_WARN_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("EXEC_CMD_ON_PROXY_FAILED",ss.str());	
		}
		proxy_name= proxy_adm_name;
	}

	//=====================================================
	//==      FIND PROXY
	//=====================================================
	//Check if proxy is registered in list
	std::string full_proxy_name= proxy_name;
	if( !m_proxyManager->FindProxy(full_proxy_name) ){
		_WARN_LOG("Proxy "<<full_proxy_name<<" not found in registered proxy list, trying with alias name...");
		
		//Get full proxy name corresponding to alias
		if(Utils_ns::TangoUtils::GetFQDNDeviceNameFromAlias(full_proxy_name,proxy_name)<0){
			std::stringstream ss;
			ss<<"Failed to retrieve full proxy name from alias "<<proxy_name<<"!";
			_WARN_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("EXEC_CMD_ON_PROXY_FAILED",ss.str());	
		}
	}
	
	//=====================================================
	//==      EXECUTE CMD
	//=====================================================
	//Now execute command (no argin)
	Tango::DeviceData dout;
	try {
		m_proxyManager->ExecuteCommand(dout,full_proxy_name,cmd_name);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		std::stringstream ss;
		ss<<"Tango exception occurred while executing cmd "<<cmd_name<<" on proxy "<<full_proxy_name<<" (check proxy registered/syntax/proxy online)!";
		_WARN_LOG(ss.str());
		throw;
	}
	catch(std::exception& e){
		std::stringstream ss;
		ss<<"C++ exception occurred while executing cmd "<<cmd_name<<" on proxy "<<full_proxy_name<<" (err="<<e.what()<<")!";
		_WARN_LOG(ss.str());
		throw;
	}
	catch(...){
		std::stringstream ss;
		ss<<"Unknown exception occurred while executing cmd "<<cmd_name<<" on proxy "<<full_proxy_name<<"!";
		_WARN_LOG(ss.str());
		throw;
	}

}//close ExecCmdOnProxy()


void DishManager::ExecCmdOnProxy(std::string input_proxy_name,std::string cmd_name,Tango::DeviceData& din,bool execOnAdminDevice)
{
	std::string proxy_name= input_proxy_name;

	//=====================================================
	//==      FIND ADMIN DEVICE NAME?
	//=====================================================
	if(execOnAdminDevice){
		std::string proxy_adm_name= "";
		if(Utils_ns::TangoUtils::GetAdminProxyName(proxy_adm_name,proxy_name)<0){
			std::stringstream ss;
			ss<<"Failed to retrieve admin proxy name from proxy name "<<proxy_name<<"!";
			_WARN_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("EXEC_CMD_ON_PROXY_FAILED",ss.str());	
		}
		proxy_name= proxy_adm_name;
	}

	//=====================================================
	//==      FIND PROXY
	//=====================================================
	//Check if proxy is registered in list
	std::string full_proxy_name= proxy_name;
	if( !m_proxyManager->FindProxy(full_proxy_name) ){
		_WARN_LOG("Proxy "<<full_proxy_name<<" not found in registered proxy list, trying with alias name...");
		
		//Get full proxy name corresponding to alias
		if(Utils_ns::TangoUtils::GetFQDNDeviceNameFromAlias(full_proxy_name,proxy_name)<0){
			std::stringstream ss;
			ss<<"Failed to retrieve full proxy name from alias "<<proxy_name<<"!";
			_WARN_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("EXEC_CMD_ON_PROXY_FAILED",ss.str());	
		}
	}
	
	//=====================================================
	//==      EXECUTE CMD WITH ARGIN
	//=====================================================
	//Now execute command (no argin)
	Tango::DeviceData dout;
	try {
		m_proxyManager->ExecuteCommand(dout,full_proxy_name,cmd_name,din);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		std::stringstream ss;
		ss<<"Tango exception occurred while executing cmd "<<cmd_name<<" on proxy "<<full_proxy_name<<" (check proxy registered/syntax/proxy online)!";
		_WARN_LOG(ss.str());
		throw;
	}
	catch(std::exception& e){
		std::stringstream ss;
		ss<<"C++ exception occurred while executing cmd "<<cmd_name<<" on proxy "<<full_proxy_name<<" (err="<<e.what()<<")!";
		_WARN_LOG(ss.str());
		throw;
	}
	catch(...){
		std::stringstream ss;
		ss<<"Unknown exception occurred while executing cmd "<<cmd_name<<" on proxy "<<full_proxy_name<<"!";
		_WARN_LOG(ss.str());
		throw;
	}

}//close ExecCmdOnProxy()


void DishManager::ExecCmdOnProxy(Tango::DeviceData& dout,std::string input_proxy_name,std::string cmd_name,Tango::DeviceData& din,bool execOnAdminDevice)
{
	std::string proxy_name= input_proxy_name;

	//=====================================================
	//==      FIND ADMIN DEVICE NAME?
	//=====================================================
	if(execOnAdminDevice){
		std::string proxy_adm_name= "";
		if(Utils_ns::TangoUtils::GetAdminProxyName(proxy_adm_name,proxy_name)<0){
			std::stringstream ss;
			ss<<"Failed to retrieve admin proxy name from proxy name "<<proxy_name<<"!";
			_WARN_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("EXEC_CMD_ON_PROXY_FAILED",ss.str());	
		}
		proxy_name= proxy_adm_name;
	}

	//=====================================================
	//==      FIND PROXY
	//=====================================================
	//Check if proxy is registered in list
	std::string full_proxy_name= proxy_name;
	if( !m_proxyManager->FindProxy(full_proxy_name) ){
		_WARN_LOG("Proxy "<<full_proxy_name<<" not found in registered proxy list, trying with alias name...");
		
		//Get full proxy name corresponding to alias
		if(Utils_ns::TangoUtils::GetFQDNDeviceNameFromAlias(full_proxy_name,proxy_name)<0){
			std::stringstream ss;
			ss<<"Failed to retrieve full proxy name from alias "<<proxy_name<<"!";
			_WARN_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("EXEC_CMD_ON_PROXY_FAILED",ss.str());	
		}
	}
	
	//=====================================================
	//==      EXECUTE CMD WITH ARGIN
	//=====================================================
	//Now execute command (no argin)
	try {
		m_proxyManager->ExecuteCommand(dout,full_proxy_name,cmd_name,din);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		std::stringstream ss;
		ss<<"Tango exception occurred while executing cmd "<<cmd_name<<" on proxy "<<full_proxy_name<<" (check proxy registered/syntax/proxy online)!";
		_WARN_LOG(ss.str());
		throw;
	}
	catch(std::exception& e){
		std::stringstream ss;
		ss<<"C++ exception occurred while executing cmd "<<cmd_name<<" on proxy "<<full_proxy_name<<" (err="<<e.what()<<")!";
		_WARN_LOG(ss.str());
		throw;
	}
	catch(...){
		std::stringstream ss;
		ss<<"Unknown exception occurred while executing cmd "<<cmd_name<<" on proxy "<<full_proxy_name<<"!";
		_WARN_LOG(ss.str());
		throw;
	}

}//close ExecCmdOnProxy()


void DishManager::ExecCmdOnProxy(Tango::DeviceData& dout,std::string input_proxy_name,std::string cmd_name,bool execOnAdminDevice)
{
	std::string proxy_name= input_proxy_name;

	//=====================================================
	//==      FIND ADMIN DEVICE NAME?
	//=====================================================
	if(execOnAdminDevice){
		std::string proxy_adm_name= "";
		if(Utils_ns::TangoUtils::GetAdminProxyName(proxy_adm_name,proxy_name)<0){
			std::stringstream ss;
			ss<<"Failed to retrieve admin proxy name from proxy name "<<proxy_name<<"!";
			_WARN_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("EXEC_CMD_ON_PROXY_FAILED",ss.str());	
		}
		proxy_name= proxy_adm_name;
	}

	//=====================================================
	//==      FIND PROXY
	//=====================================================
	//Check if proxy is registered in list
	std::string full_proxy_name= proxy_name;
	if( !m_proxyManager->FindProxy(full_proxy_name) ){
		_WARN_LOG("Proxy "<<full_proxy_name<<" not found in registered proxy list, trying with alias name...");
		
		//Get full proxy name corresponding to alias
		if(Utils_ns::TangoUtils::GetFQDNDeviceNameFromAlias(full_proxy_name,proxy_name)<0){
			std::stringstream ss;
			ss<<"Failed to retrieve full proxy name from alias "<<proxy_name<<"!";
			_WARN_LOG(ss.str());
			_THROW_TANGO_EXCEPTION("EXEC_CMD_ON_PROXY_FAILED",ss.str());	
		}
	}
	
	//=====================================================
	//==      EXECUTE CMD WITH ARGIN
	//=====================================================
	//Now execute command (no argin)
	try {
		m_proxyManager->ExecuteCommand(dout,full_proxy_name,cmd_name);
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		std::stringstream ss;
		ss<<"Tango exception occurred while executing cmd "<<cmd_name<<" on proxy "<<full_proxy_name<<" (check proxy registered/syntax/proxy online)!";
		_WARN_LOG(ss.str());
		throw;
	}
	catch(std::exception& e){
		std::stringstream ss;
		ss<<"C++ exception occurred while executing cmd "<<cmd_name<<" on proxy "<<full_proxy_name<<" (err="<<e.what()<<")!";
		_WARN_LOG(ss.str());
		throw;
	}
	catch(...){
		std::stringstream ss;
		ss<<"Unknown exception occurred while executing cmd "<<cmd_name<<" on proxy "<<full_proxy_name<<"!";
		_WARN_LOG(ss.str());
		throw;
	}

}//close ExecCmdOnProxy()


int DishManager::HandleProxyRunStatusInfo(std::string proxy_name,int proxy_run_status)
{
	_DEBUG_LOG("Handling proxy run status info (proxy="<<proxy_name<<", runstatus="<<proxy_run_status<<")");
	
	//Handle TM proxy run status
	if(HandleTMProxyRunStatusInfo(proxy_name,proxy_run_status)<0){
		_ERROR_LOG("Failed to handle TM run status event!");
	}
	
	return 0;

}//close HandleProxyRunStatusInfo()


int DishManager::HandleTMProxyRunStatusInfo(std::string proxy_name,int proxy_run_status)
{
	//=========================================
	//==      HARD_CODED VALUES
	//=========================================
	std::string tmProxyAddress_attr_name= "tmProxyAddress";
	std::string enableTMProxyMoniHandler_attr_name= "enableTMProxyMoniHandler";
	//=========================================

	//Get TM proxy device name
	std::string tmProxyAddress;
	if(GetDynAttrValue(tmProxyAddress,tmProxyAddress_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<tmProxyAddress_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		return -1;	
	}

	//Get TM proxy monitoring handler flag value	
	Tango::DevBoolean tmProxyMoniHandlerEnabled= false;
	if(GetDynAttrValue(tmProxyMoniHandlerEnabled,enableTMProxyMoniHandler_attr_name)<0){
		std::stringstream ss;
		ss<<"Failed to get attr "<<enableTMProxyMoniHandler_attr_name<<" value!";
		_ERROR_LOG(ss.str());
		return -1;	
	}
	

	//Check if event is from TM proxy and if handling is enabled
	bool handleTMProxyEvent= (
		tmProxyMoniHandlerEnabled && 
		proxy_name==tmProxyAddress && 
		proxy_run_status==Utils_ns::TangoProxyHelper::ePROXY_HARD_OFFLINE
	);
	if(!handleTMProxyEvent) return 0;

	//Handle the event
	try {
		handle_tmcomm_loss_event();	
	}
	catch(...){
		_ERROR_LOG("Exceptions occurred while handling TM proxy down event!");
		return -1;
	}	

	return 0;

}//close HandleTMProxyRunStatusInfo()



/*----- PROTECTED REGION END -----*/	//	DishManager::namespace_ending
} //	namespace
