/*----- PROTECTED REGION ID(LMCStarter.cpp) ENABLED START -----*/
//=============================================================================
//
// file :        LMCStarter.cpp
//
// description : C++ source for the LMCStarter class and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               LMCStarter are implemented in this file.
//
// project :     LMCManager
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
//
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================

#include <stdio.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <signal.h>
#include <StarterUtil.h>

#include <LMCStarter.h>
#include <LMCStarterClass.h>

/*----- PROTECTED REGION END -----*/	//	LMCStarter.cpp

/**
 *  LMCStarter class description:
 *    This device server is able to control <b>Tango</b> components (database, device servers, clients...).
 *    It is able to start or stop and to report the status of these components.
 */

//================================================================
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name            |  Method name
//================================================================
//  State                   |  dev_state
//  Status                  |  Inherited (no method)
//  InitializeLoggers       |  Inherited (no method)
//  InitializeFwdAttrs      |  Inherited (no method)
//  RandomizeDynAttrs       |  Inherited (no method)
//  InitializeDevProxies    |  Inherited (no method)
//  GetRegisteredProxies    |  Inherited (no method)
//  GetRegisteredEvents     |  Inherited (no method)
//  GetRegisteredFormulas   |  Inherited (no method)
//  GetInitializedFormulas  |  Inherited (no method)
//  GetNRunningTasks        |  Inherited (no method)
//  GetNQueuedTasks         |  Inherited (no method)
//  GetNIdleTasks           |  Inherited (no method)
//  GetNTasks               |  Inherited (no method)
//  GetNFailedTasks         |  Inherited (no method)
//  GetNTotFailedTasks      |  Inherited (no method)
//  IsTaskQuotaReached      |  Inherited (no method)
//  FlushTaskQueue          |  Inherited (no method)
//  GetQueuedTaskInfo       |  Inherited (no method)
//  GetTaskInfo             |  Inherited (no method)
//  ClearTasks              |  Inherited (no method)
//  UpdateFormulaAttrs      |  Inherited (no method)
//  UpdateStatusAttrs       |  Inherited (no method)
//  MonitorProxies          |  Inherited (no method)
//  DevStart                |  dev_start
//  DevStop                 |  dev_stop
//  DevStartAll             |  dev_start_all
//  DevStopAll              |  dev_stop_all
//  DevGetRunningServers    |  dev_get_running_servers
//  DevGetStopServers       |  dev_get_stop_servers
//  DevReadLog              |  dev_read_log
//  HardKillServer          |  hard_kill_server
//  NotifyDaemonState       |  notify_daemon_state
//  ResetStatistics         |  reset_statistics
//  UpdateServersInfo       |  update_servers_info
//  RevokeTask              |  Inherited (no method)
//  GetFormulaData          |  Inherited (no method)
//  SendTestLogMsg          |  Inherited (no method)
//================================================================

//================================================================
//  Attributes managed are:
//================================================================
//  loggingLevelCentral   |  Tango::DevLong	Scalar
//  loggingLevelElement   |  Tango::DevLong	Scalar
//  loggingLevelStorage   |  Tango::DevLong	Scalar
//  NotifdState           |  Tango::DevState	Scalar
//  HostState             |  Tango::DevShort	Scalar
//  loggingLevelConsole   |  Tango::DevLong	Scalar
//  buildState            |  Tango::DevString	Scalar
//  centralLoggerStatus   |  Tango::DevEnum	Scalar
//  elementLoggerStatus   |  Tango::DevEnum	Scalar
//  storageLoggerStatus   |  Tango::DevEnum	Scalar
//  eventRate             |  Tango::DevFloat	Scalar
//  exceptionRate         |  Tango::DevFloat	Scalar
//  fwdAttrInitStatus     |  Tango::DevEnum	Scalar
//  centralLoggerEnabled  |  Tango::DevBoolean	Scalar
//  elementLoggerEnabled  |  Tango::DevBoolean	Scalar
//  storageLoggerEnabled  |  Tango::DevBoolean	Scalar
//  loggingTargetCentral  |  Tango::DevString	Scalar
//  loggingTargetElement  |  Tango::DevString	Scalar
//  loggingTargetStorage  |  Tango::DevString	Scalar
//  RunningServers        |  Tango::DevString	Spectrum  ( max = 200)
//  StoppedServers        |  Tango::DevString	Spectrum  ( max = 200)
//  Servers               |  Tango::DevString	Spectrum  ( max = 1024)
//================================================================

namespace LMCStarter_ns
{
/*----- PROTECTED REGION ID(LMCStarter::namespace_starting) ENABLED START -----*/

//	static initializations

/*----- PROTECTED REGION END -----*/	//	LMCStarter::namespace_starting

//--------------------------------------------------------
/**
 *	Method      : LMCStarter::LMCStarter()
 *	Description : Constructors for a Tango device
 *                implementing the classLMCStarter
 */
//--------------------------------------------------------
LMCStarter::LMCStarter(Tango::DeviceClass *cl, string &s)
 : LMCDevice(cl, s.c_str())
{
	/*----- PROTECTED REGION ID(LMCStarter::constructor_1) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	LMCStarter::constructor_1
}
//--------------------------------------------------------
LMCStarter::LMCStarter(Tango::DeviceClass *cl, const char *s)
 : LMCDevice(cl, s)
{
	/*----- PROTECTED REGION ID(LMCStarter::constructor_2) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	LMCStarter::constructor_2
}
//--------------------------------------------------------
LMCStarter::LMCStarter(Tango::DeviceClass *cl, const char *s, const char *d)
 : LMCDevice(cl, s, d)
{
	/*----- PROTECTED REGION ID(LMCStarter::constructor_3) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	LMCStarter::constructor_3
}

//--------------------------------------------------------
/**
 *	Method      : LMCStarter::delete_device()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void LMCStarter::delete_device()
{
	DEBUG_STREAM << "LMCStarter::delete_device() " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCStarter::delete_device) ENABLED START -----*/
	
	//	Delete device allocated objects
	//	Check if shutting down (or Init command)
	if (Tango::Util::instance()->is_svr_shutting_down() ||
		Tango::Util::instance()->is_device_restarting(get_name()))
	{
		util->log_starter_info("Starter shutdown");

		//	Stop ping threads
		vector<ControlledServer>::iterator it;
		for (it=servers.begin() ; it<servers.end() ; ++it)
			it->thread_data->set_stop_thread();
		util->proc_util->stop_it();

		for (it=servers.begin() ; it<servers.end() ; ++it)
			it->thread->join(NULL);
		util->proc_util->join(NULL);

		//	Delete device allocated objects
		delete dbase;
		delete util;
		delete[] attr_HostState_read;
		delete[] attr_NotifdState_read;
		delete start_proc_data;
	}

	/*----- PROTECTED REGION END -----*/	//	LMCStarter::delete_device

	if (Tango::Util::instance()->is_svr_shutting_down()==false  &&
		Tango::Util::instance()->is_device_restarting(device_name)==false &&
		Tango::Util::instance()->is_svr_starting()==false)
	{
		//	If not shutting down call delete device for inherited object
		LMCDevice_ns::LMCDevice::delete_device();
	}
}

//--------------------------------------------------------
/**
 *	Method      : LMCStarter::init_device()
 *	Description : will be called at device initialization.
 */
//--------------------------------------------------------
void LMCStarter::init_device()
{
	DEBUG_STREAM << "LMCStarter::init_device() create device " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCStarter::init_device_before) ENABLED START -----*/
	
	//	Initialization before get_device_property() call
	cout << "LMCStarter::LMCStarter() init device " << device_name << endl;

	/*----- PROTECTED REGION END -----*/	//	LMCStarter::init_device_before
	
	if (Tango::Util::instance()->is_svr_starting() == false  &&
		Tango::Util::instance()->is_device_restarting(device_name)==false)
	{
		//	If not starting up call init device for inherited object
		LMCDevice_ns::LMCDevice::init_device();
	}

	//	Get the device properties from database
	get_device_property();
	
	//	No longer if mandatory property not set. 
	if (mandatoryNotDefined)
		return;

	/*----- PROTECTED REGION ID(LMCStarter::init_device) ENABLED START -----*/
	
	//	Initialize device
	debug = false;
	char	*dbg = (char *)getenv("DEBUG");
	if (dbg!=NULL)
		if (strcmp(dbg, "true")==0)
		{
			debug = true;
			cout << "!!! Debug mode is set !!!" << endl;
		}
	if (serverStartupTimeout<SERVER_TIMEOUT)
		serverStartupTimeout = SERVER_TIMEOUT;

	//	First time, check if instance and host name are coherent
	if (!debug)
		check_host();

	//	Do it only at startup and not at Init command
	//----------------------------------------------------
	if (Tango::Util::instance()->is_svr_starting() ||
		Tango::Util::instance()->is_device_restarting(get_name()))
	{
		//	Get database server name
		//--------------------------------------
		Tango::Util *tg = Tango::Util::instance();
		char	*dbname = tg->get_database()->get_dbase()->name();
		//	And connect database as DeviceProxy
		//--------------------------------------
		dbase = new Tango::DeviceProxy(dbname);
		CORBA::string_free(dbname);

		//	Build a shared data for StartProcessShared
		start_proc_data = new StartProcessShared();

		//	Get hostname (In case of cluster host could be multiple)
		//-------------------------------------------------------------
		vector<string>	hosts_list;
		char	*env = (char *)getenv("TANGO_CLUSTER");
		if (env==NULL)
			hosts_list.push_back(tg->get_host_name());
		else
		if (strlen(env)==0)
			hosts_list.push_back(tg->get_host_name());
		else
		{
			//	If MULTI_HOST is defined, parse host names
			//--------------------------------------------------
			string	str_list(env);
			cout << "hosts_list = " << str_list << endl;
			int	start = 0;
			int	end = 0;
			while ((end= (int) str_list.find_first_of(":", (unsigned long) start)) > 0)
			{
				string	s = str_list.substr(start, end-start);
				hosts_list.push_back(s);
				start = end+1;
			}
			string	s = str_list.substr(start, str_list.length()-start);
			hosts_list.push_back(s);
			for (unsigned int i=0 ; i<hosts_list.size() ; i++)
				cout << hosts_list[i] << endl;
		}
		//	Create a StarterUtil instance
		//--------------------------------------
		util = new StarterUtil(this,dbase, hosts_list, logFileHome);
		util->log_starter_info("Starter startup");

		//	Initialize Attribute data member
		attr_HostState_read   = new Tango::DevShort[1];
		attr_NotifdState_read = new Tango::DevState[1];
		attr_NotifdState_read[0] = notifyd_state = Tango::UNKNOWN;

		//	Do not want exception during startup
		throwable = false;

		//	Wait a bit if necessary
		if (waitForDriverStartup>0)
		{
			cout << "Waiting " << waitForDriverStartup <<
					" seconds before starting (wait for drivers)." << endl;
			ms_sleep(1000*waitForDriverStartup);
		}

		//	Start notify daemon if not desabled and not already running
		if (useEvents)
		{
			try
			{
				cout << "Checking " << util->notifyd_name << endl;
				if (util->is_notifyd_alive()!=Tango::ON)
				{
					string	name(NOTIFY_DAEMON_SCRIPT);
					name += "/";
					name += tg->get_host_name();
					cout << "Starting " << name << endl;
					dev_start((char*)name.c_str());
				}
			}
			catch (...) {}
		}

		//	query database for controlled objects
		//	Wait for Database device is  OK
		bool	done = false;
		while (!done)
		{
			try {
				util->build_server_ctrl_object(&servers);
				do_update_from_db = false;
				done = true;
			}
			catch(Tango::DevFailed &e) {
				Tango::Except::print_exception(e);
			}
#			ifdef _TG_WINDOWS_
				_sleep(1000);
#			else
				sleep(1);
#			endif
		}

//	A a wait for first ping timeout !!!!
#	ifdef _TG_WINDOWS_
		_sleep(3000);
#	else
		sleep(3);
#	endif

		//	And Start servers for all startup levels.
		//	The interStartupLevelWait value will be managed
		//		by the start process thread.
		//---------------------------------------------------
		int nb_levels =
			((static_cast<LMCStarterClass *>(get_device_class()))->nbStartupLevels);

		if (startServersAtStartup==true)
		{
			//	Update state before
			for (unsigned int i=0 ; i<servers.size() ; i++)
			{
				ControlledServer	*server = &servers[i];
				server->state = server->thread_data->get_state();
			}
			//	And then starl-c16-1 (ZMQ)t levels
			for (int level=1 ; level<=nb_levels ; level++)
			{
				throwable = false;
				try {
					dev_start_all(level);
				}
				catch (Tango::DevFailed &e) {
					cerr << e.errors[0].desc << endl;
				}
				ms_sleep(50);
			}
		}

		//	Want exception during normal run
		throwable = true;

		//	Set the default state
		//-------------------------------
		set_state(Tango::MOVING);
		*attr_HostState_read = get_state();

		check_log_dir();

		//	Update Loggs
		WARN_STREAM << "Starter Server Started !" << endl;
	}
	/*----- PROTECTED REGION END -----*/	//	LMCStarter::init_device
}

//--------------------------------------------------------
/**
 *	Method      : LMCStarter::get_device_property()
 *	Description : Read database to initialize property data members.
 */
//--------------------------------------------------------
void LMCStarter::get_device_property()
{
	/*----- PROTECTED REGION ID(LMCStarter::get_device_property_before) ENABLED START -----*/
	
	//	Initialize property data members
	
	/*----- PROTECTED REGION END -----*/	//	LMCStarter::get_device_property_before

	mandatoryNotDefined = false;

	//	Read device properties from database.
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("CentralLoggerEnabledDefault"));
	dev_prop.push_back(Tango::DbDatum("ElementLoggerEnabledDefault"));
	dev_prop.push_back(Tango::DbDatum("StorageLoggerEnabledDefault"));
	dev_prop.push_back(Tango::DbDatum("LoggingTargetCentralDefault"));
	dev_prop.push_back(Tango::DbDatum("LoggingTargetElementDefault"));
	dev_prop.push_back(Tango::DbDatum("LoggingTargetStorageDefault"));
	dev_prop.push_back(Tango::DbDatum("SkaLevel"));
	dev_prop.push_back(Tango::DbDatum("SyslogFacility"));
	dev_prop.push_back(Tango::DbDatum("SyslogHost"));
	dev_prop.push_back(Tango::DbDatum("LoggingLevelCentralDefault"));
	dev_prop.push_back(Tango::DbDatum("LoggingLevelElementDefault"));
	dev_prop.push_back(Tango::DbDatum("LoggingLevelStorageDefault"));
	dev_prop.push_back(Tango::DbDatum("ConfigFile"));
	dev_prop.push_back(Tango::DbDatum("EnableConfigFromFile"));
	dev_prop.push_back(Tango::DbDatum("EnableDynAttrCleanup"));
	dev_prop.push_back(Tango::DbDatum("EnableDynAttrRandomize"));
	dev_prop.push_back(Tango::DbDatum("DynAttrRandomizePeriod"));
	dev_prop.push_back(Tango::DbDatum("ProxyDevices"));
	dev_prop.push_back(Tango::DbDatum("FormulaVarMaxTimeInterval"));
	dev_prop.push_back(Tango::DbDatum("EnableProxyMonitoring"));
	dev_prop.push_back(Tango::DbDatum("ProxyMonitoringPeriod"));
	dev_prop.push_back(Tango::DbDatum("ProxyStatusAttrPollPeriod"));
	dev_prop.push_back(Tango::DbDatum("ProxyStatusAttrPeriodicEventPeriod"));
	dev_prop.push_back(Tango::DbDatum("ProxyStatusAttrArchiveEventPeriod"));
	dev_prop.push_back(Tango::DbDatum("ProxyTimeout"));
	dev_prop.push_back(Tango::DbDatum("EventSubscriptions"));
	dev_prop.push_back(Tango::DbDatum("EventHandlers"));
	dev_prop.push_back(Tango::DbDatum("MaxQueueableTask"));
	dev_prop.push_back(Tango::DbDatum("MaxTrackableTasks"));
	dev_prop.push_back(Tango::DbDatum("TaskHistoryTimeDepth"));
	dev_prop.push_back(Tango::DbDatum("DefaultTaskTimeout"));
	dev_prop.push_back(Tango::DbDatum("TaskSequenceStatusAttrList"));
	dev_prop.push_back(Tango::DbDatum("TaskStatusAttrList"));
	dev_prop.push_back(Tango::DbDatum("EnableEventRateMonitoring"));
	dev_prop.push_back(Tango::DbDatum("AutoRestartDuration"));
	dev_prop.push_back(Tango::DbDatum("InterStartupLevelWait"));
	dev_prop.push_back(Tango::DbDatum("KeepLogFiles"));
	dev_prop.push_back(Tango::DbDatum("LogFileHome"));
	dev_prop.push_back(Tango::DbDatum("ServerStartupTimeout"));
	dev_prop.push_back(Tango::DbDatum("StartDsPath"));
	dev_prop.push_back(Tango::DbDatum("StartServersAtStartup"));
	dev_prop.push_back(Tango::DbDatum("UseEvents"));
	dev_prop.push_back(Tango::DbDatum("WaitForDriverStartup"));
	dev_prop.push_back(Tango::DbDatum("EnableLoggerInitPolling"));
	dev_prop.push_back(Tango::DbDatum("LoggerInitPollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableDevProxyInitPolling"));
	dev_prop.push_back(Tango::DbDatum("DevProxyInitPollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableFwdAttrInitPolling"));
	dev_prop.push_back(Tango::DbDatum("FwdAttrInitPollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableFormulaAttrUpdatePolling"));
	dev_prop.push_back(Tango::DbDatum("FormulaAttrUpdatePollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableStatusAttrUpdatePolling"));
	dev_prop.push_back(Tango::DbDatum("StatusAttrUpdatePollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableClearTaskPolling"));
	dev_prop.push_back(Tango::DbDatum("ClearTaskPollPeriod"));
	dev_prop.push_back(Tango::DbDatum("EnableProxyStatusAttrCreation"));
	dev_prop.push_back(Tango::DbDatum("EnableAutoAdminProxyRegistration"));
	dev_prop.push_back(Tango::DbDatum("ProcessEventsInQueueThread"));

	//	is there at least one property to be read ?
	if (dev_prop.size()>0)
	{
		//	Call database and extract values
		if (Tango::Util::instance()->_UseDb==true)
			get_db_device()->get_property(dev_prop);
	
		//	get instance on LMCStarterClass to get class property
		Tango::DbDatum	def_prop, cl_prop;
		LMCStarterClass	*ds_class =
			(static_cast<LMCStarterClass *>(get_device_class()));
		int	i = -1;

		//	Try to initialize CentralLoggerEnabledDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  centralLoggerEnabledDefault;
		else {
			//	Try to initialize CentralLoggerEnabledDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  centralLoggerEnabledDefault;
		}
		//	And try to extract CentralLoggerEnabledDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  centralLoggerEnabledDefault;

		//	Try to initialize ElementLoggerEnabledDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  elementLoggerEnabledDefault;
		else {
			//	Try to initialize ElementLoggerEnabledDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  elementLoggerEnabledDefault;
		}
		//	And try to extract ElementLoggerEnabledDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  elementLoggerEnabledDefault;

		//	Try to initialize StorageLoggerEnabledDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  storageLoggerEnabledDefault;
		else {
			//	Try to initialize StorageLoggerEnabledDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  storageLoggerEnabledDefault;
		}
		//	And try to extract StorageLoggerEnabledDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  storageLoggerEnabledDefault;

		//	Try to initialize LoggingTargetCentralDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingTargetCentralDefault;
		else {
			//	Try to initialize LoggingTargetCentralDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingTargetCentralDefault;
		}
		//	And try to extract LoggingTargetCentralDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingTargetCentralDefault;

		//	Try to initialize LoggingTargetElementDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingTargetElementDefault;
		else {
			//	Try to initialize LoggingTargetElementDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingTargetElementDefault;
		}
		//	And try to extract LoggingTargetElementDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingTargetElementDefault;

		//	Try to initialize LoggingTargetStorageDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingTargetStorageDefault;
		else {
			//	Try to initialize LoggingTargetStorageDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingTargetStorageDefault;
		}
		//	And try to extract LoggingTargetStorageDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingTargetStorageDefault;

		//	Try to initialize SkaLevel from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  skaLevel;
		else {
			//	Try to initialize SkaLevel from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  skaLevel;
		}
		//	And try to extract SkaLevel value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  skaLevel;

		//	Try to initialize SyslogFacility from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  syslogFacility;
		else {
			//	Try to initialize SyslogFacility from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  syslogFacility;
		}
		//	And try to extract SyslogFacility value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  syslogFacility;

		//	Try to initialize SyslogHost from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  syslogHost;
		else {
			//	Try to initialize SyslogHost from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  syslogHost;
		}
		//	And try to extract SyslogHost value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  syslogHost;

		//	Try to initialize LoggingLevelCentralDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingLevelCentralDefault;
		else {
			//	Try to initialize LoggingLevelCentralDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingLevelCentralDefault;
		}
		//	And try to extract LoggingLevelCentralDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingLevelCentralDefault;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize LoggingLevelElementDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingLevelElementDefault;
		else {
			//	Try to initialize LoggingLevelElementDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingLevelElementDefault;
		}
		//	And try to extract LoggingLevelElementDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingLevelElementDefault;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize LoggingLevelStorageDefault from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggingLevelStorageDefault;
		else {
			//	Try to initialize LoggingLevelStorageDefault from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggingLevelStorageDefault;
		}
		//	And try to extract LoggingLevelStorageDefault value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggingLevelStorageDefault;
		//	Property StartDsPath is mandatory, check if has been defined in database.
		check_mandatory_property(cl_prop, dev_prop[i]);

		//	Try to initialize ConfigFile from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  configFile;
		else {
			//	Try to initialize ConfigFile from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  configFile;
		}
		//	And try to extract ConfigFile value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  configFile;

		//	Try to initialize EnableConfigFromFile from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableConfigFromFile;
		else {
			//	Try to initialize EnableConfigFromFile from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableConfigFromFile;
		}
		//	And try to extract EnableConfigFromFile value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableConfigFromFile;

		//	Try to initialize EnableDynAttrCleanup from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableDynAttrCleanup;
		else {
			//	Try to initialize EnableDynAttrCleanup from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableDynAttrCleanup;
		}
		//	And try to extract EnableDynAttrCleanup value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableDynAttrCleanup;

		//	Try to initialize EnableDynAttrRandomize from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableDynAttrRandomize;
		else {
			//	Try to initialize EnableDynAttrRandomize from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableDynAttrRandomize;
		}
		//	And try to extract EnableDynAttrRandomize value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableDynAttrRandomize;

		//	Try to initialize DynAttrRandomizePeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  dynAttrRandomizePeriod;
		else {
			//	Try to initialize DynAttrRandomizePeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  dynAttrRandomizePeriod;
		}
		//	And try to extract DynAttrRandomizePeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  dynAttrRandomizePeriod;

		//	Try to initialize ProxyDevices from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyDevices;
		else {
			//	Try to initialize ProxyDevices from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyDevices;
		}
		//	And try to extract ProxyDevices value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyDevices;

		//	Try to initialize FormulaVarMaxTimeInterval from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  formulaVarMaxTimeInterval;
		else {
			//	Try to initialize FormulaVarMaxTimeInterval from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  formulaVarMaxTimeInterval;
		}
		//	And try to extract FormulaVarMaxTimeInterval value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  formulaVarMaxTimeInterval;

		//	Try to initialize EnableProxyMonitoring from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableProxyMonitoring;
		else {
			//	Try to initialize EnableProxyMonitoring from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableProxyMonitoring;
		}
		//	And try to extract EnableProxyMonitoring value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableProxyMonitoring;

		//	Try to initialize ProxyMonitoringPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyMonitoringPeriod;
		else {
			//	Try to initialize ProxyMonitoringPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyMonitoringPeriod;
		}
		//	And try to extract ProxyMonitoringPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyMonitoringPeriod;

		//	Try to initialize ProxyStatusAttrPollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyStatusAttrPollPeriod;
		else {
			//	Try to initialize ProxyStatusAttrPollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyStatusAttrPollPeriod;
		}
		//	And try to extract ProxyStatusAttrPollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyStatusAttrPollPeriod;

		//	Try to initialize ProxyStatusAttrPeriodicEventPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyStatusAttrPeriodicEventPeriod;
		else {
			//	Try to initialize ProxyStatusAttrPeriodicEventPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyStatusAttrPeriodicEventPeriod;
		}
		//	And try to extract ProxyStatusAttrPeriodicEventPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyStatusAttrPeriodicEventPeriod;

		//	Try to initialize ProxyStatusAttrArchiveEventPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyStatusAttrArchiveEventPeriod;
		else {
			//	Try to initialize ProxyStatusAttrArchiveEventPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyStatusAttrArchiveEventPeriod;
		}
		//	And try to extract ProxyStatusAttrArchiveEventPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyStatusAttrArchiveEventPeriod;

		//	Try to initialize ProxyTimeout from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  proxyTimeout;
		else {
			//	Try to initialize ProxyTimeout from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  proxyTimeout;
		}
		//	And try to extract ProxyTimeout value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  proxyTimeout;

		//	Try to initialize EventSubscriptions from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  eventSubscriptions;
		else {
			//	Try to initialize EventSubscriptions from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  eventSubscriptions;
		}
		//	And try to extract EventSubscriptions value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  eventSubscriptions;

		//	Try to initialize EventHandlers from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  eventHandlers;
		else {
			//	Try to initialize EventHandlers from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  eventHandlers;
		}
		//	And try to extract EventHandlers value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  eventHandlers;

		//	Try to initialize MaxQueueableTask from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  maxQueueableTask;
		else {
			//	Try to initialize MaxQueueableTask from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  maxQueueableTask;
		}
		//	And try to extract MaxQueueableTask value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  maxQueueableTask;

		//	Try to initialize MaxTrackableTasks from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  maxTrackableTasks;
		else {
			//	Try to initialize MaxTrackableTasks from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  maxTrackableTasks;
		}
		//	And try to extract MaxTrackableTasks value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  maxTrackableTasks;

		//	Try to initialize TaskHistoryTimeDepth from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  taskHistoryTimeDepth;
		else {
			//	Try to initialize TaskHistoryTimeDepth from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  taskHistoryTimeDepth;
		}
		//	And try to extract TaskHistoryTimeDepth value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  taskHistoryTimeDepth;

		//	Try to initialize DefaultTaskTimeout from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  defaultTaskTimeout;
		else {
			//	Try to initialize DefaultTaskTimeout from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  defaultTaskTimeout;
		}
		//	And try to extract DefaultTaskTimeout value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  defaultTaskTimeout;

		//	Try to initialize TaskSequenceStatusAttrList from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  taskSequenceStatusAttrList;
		else {
			//	Try to initialize TaskSequenceStatusAttrList from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  taskSequenceStatusAttrList;
		}
		//	And try to extract TaskSequenceStatusAttrList value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  taskSequenceStatusAttrList;

		//	Try to initialize TaskStatusAttrList from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  taskStatusAttrList;
		else {
			//	Try to initialize TaskStatusAttrList from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  taskStatusAttrList;
		}
		//	And try to extract TaskStatusAttrList value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  taskStatusAttrList;

		//	Try to initialize EnableEventRateMonitoring from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableEventRateMonitoring;
		else {
			//	Try to initialize EnableEventRateMonitoring from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableEventRateMonitoring;
		}
		//	And try to extract EnableEventRateMonitoring value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableEventRateMonitoring;

		//	Try to initialize AutoRestartDuration from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  autoRestartDuration;
		else {
			//	Try to initialize AutoRestartDuration from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  autoRestartDuration;
		}
		//	And try to extract AutoRestartDuration value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  autoRestartDuration;

		//	Try to initialize InterStartupLevelWait from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  interStartupLevelWait;
		else {
			//	Try to initialize InterStartupLevelWait from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  interStartupLevelWait;
		}
		//	And try to extract InterStartupLevelWait value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  interStartupLevelWait;

		//	Try to initialize KeepLogFiles from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  keepLogFiles;
		else {
			//	Try to initialize KeepLogFiles from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  keepLogFiles;
		}
		//	And try to extract KeepLogFiles value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  keepLogFiles;

		//	Try to initialize LogFileHome from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  logFileHome;
		else {
			//	Try to initialize LogFileHome from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  logFileHome;
		}
		//	And try to extract LogFileHome value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  logFileHome;

		//	Try to initialize ServerStartupTimeout from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  serverStartupTimeout;
		else {
			//	Try to initialize ServerStartupTimeout from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  serverStartupTimeout;
		}
		//	And try to extract ServerStartupTimeout value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  serverStartupTimeout;

		//	Try to initialize StartDsPath from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  startDsPath;
		else {
			//	Try to initialize StartDsPath from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  startDsPath;
		}
		//	And try to extract StartDsPath value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  startDsPath;

		//	Try to initialize StartServersAtStartup from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  startServersAtStartup;
		else {
			//	Try to initialize StartServersAtStartup from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  startServersAtStartup;
		}
		//	And try to extract StartServersAtStartup value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  startServersAtStartup;

		//	Try to initialize UseEvents from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  useEvents;
		else {
			//	Try to initialize UseEvents from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  useEvents;
		}
		//	And try to extract UseEvents value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  useEvents;

		//	Try to initialize WaitForDriverStartup from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  waitForDriverStartup;
		else {
			//	Try to initialize WaitForDriverStartup from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  waitForDriverStartup;
		}
		//	And try to extract WaitForDriverStartup value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  waitForDriverStartup;

		//	Try to initialize EnableLoggerInitPolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableLoggerInitPolling;
		else {
			//	Try to initialize EnableLoggerInitPolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableLoggerInitPolling;
		}
		//	And try to extract EnableLoggerInitPolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableLoggerInitPolling;

		//	Try to initialize LoggerInitPollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  loggerInitPollPeriod;
		else {
			//	Try to initialize LoggerInitPollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  loggerInitPollPeriod;
		}
		//	And try to extract LoggerInitPollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  loggerInitPollPeriod;

		//	Try to initialize EnableDevProxyInitPolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableDevProxyInitPolling;
		else {
			//	Try to initialize EnableDevProxyInitPolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableDevProxyInitPolling;
		}
		//	And try to extract EnableDevProxyInitPolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableDevProxyInitPolling;

		//	Try to initialize DevProxyInitPollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  devProxyInitPollPeriod;
		else {
			//	Try to initialize DevProxyInitPollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  devProxyInitPollPeriod;
		}
		//	And try to extract DevProxyInitPollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  devProxyInitPollPeriod;

		//	Try to initialize EnableFwdAttrInitPolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableFwdAttrInitPolling;
		else {
			//	Try to initialize EnableFwdAttrInitPolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableFwdAttrInitPolling;
		}
		//	And try to extract EnableFwdAttrInitPolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableFwdAttrInitPolling;

		//	Try to initialize FwdAttrInitPollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  fwdAttrInitPollPeriod;
		else {
			//	Try to initialize FwdAttrInitPollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  fwdAttrInitPollPeriod;
		}
		//	And try to extract FwdAttrInitPollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  fwdAttrInitPollPeriod;

		//	Try to initialize EnableFormulaAttrUpdatePolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableFormulaAttrUpdatePolling;
		else {
			//	Try to initialize EnableFormulaAttrUpdatePolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableFormulaAttrUpdatePolling;
		}
		//	And try to extract EnableFormulaAttrUpdatePolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableFormulaAttrUpdatePolling;

		//	Try to initialize FormulaAttrUpdatePollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  formulaAttrUpdatePollPeriod;
		else {
			//	Try to initialize FormulaAttrUpdatePollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  formulaAttrUpdatePollPeriod;
		}
		//	And try to extract FormulaAttrUpdatePollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  formulaAttrUpdatePollPeriod;

		//	Try to initialize EnableStatusAttrUpdatePolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableStatusAttrUpdatePolling;
		else {
			//	Try to initialize EnableStatusAttrUpdatePolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableStatusAttrUpdatePolling;
		}
		//	And try to extract EnableStatusAttrUpdatePolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableStatusAttrUpdatePolling;

		//	Try to initialize StatusAttrUpdatePollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  statusAttrUpdatePollPeriod;
		else {
			//	Try to initialize StatusAttrUpdatePollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  statusAttrUpdatePollPeriod;
		}
		//	And try to extract StatusAttrUpdatePollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  statusAttrUpdatePollPeriod;

		//	Try to initialize EnableClearTaskPolling from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableClearTaskPolling;
		else {
			//	Try to initialize EnableClearTaskPolling from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableClearTaskPolling;
		}
		//	And try to extract EnableClearTaskPolling value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableClearTaskPolling;

		//	Try to initialize ClearTaskPollPeriod from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  clearTaskPollPeriod;
		else {
			//	Try to initialize ClearTaskPollPeriod from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  clearTaskPollPeriod;
		}
		//	And try to extract ClearTaskPollPeriod value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  clearTaskPollPeriod;

		//	Try to initialize EnableProxyStatusAttrCreation from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableProxyStatusAttrCreation;
		else {
			//	Try to initialize EnableProxyStatusAttrCreation from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableProxyStatusAttrCreation;
		}
		//	And try to extract EnableProxyStatusAttrCreation value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableProxyStatusAttrCreation;

		//	Try to initialize EnableAutoAdminProxyRegistration from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  enableAutoAdminProxyRegistration;
		else {
			//	Try to initialize EnableAutoAdminProxyRegistration from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  enableAutoAdminProxyRegistration;
		}
		//	And try to extract EnableAutoAdminProxyRegistration value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableAutoAdminProxyRegistration;

		//	Try to initialize ProcessEventsInQueueThread from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  processEventsInQueueThread;
		else {
			//	Try to initialize ProcessEventsInQueueThread from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  processEventsInQueueThread;
		}
		//	And try to extract ProcessEventsInQueueThread value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  processEventsInQueueThread;

	}

	/*----- PROTECTED REGION ID(LMCStarter::get_device_property_after) ENABLED START -----*/
	
	//	Check device property data members init
	if (startDsPath.empty())
		startDsPath.push_back(".");
	else
	for (unsigned int i=0 ; i<startDsPath.size() ; i++)
		INFO_STREAM << "startDsPath[" << i << "] = " << startDsPath[i] << endl;
	INFO_STREAM << "WaitForDriverStartup = " << waitForDriverStartup << " seconds" << endl;
	cout << "UseEvents  = " << ((useEvents==false)? "False": "True") << endl;
	cout << "interStartupLevelWait  = " << interStartupLevelWait << endl;
	cout << "serverStartupTimeout   = " << serverStartupTimeout << endl;



	//	Get the fireFromDbase value from Default object
	Tango::DbData	data;
	data.push_back(Tango::DbDatum("FireToStarter"));
	Tango::Util *tg = Tango::Util::instance();
	tg->get_database()->get_property("Default", data);
	string	tmp;
	if (data[0].is_empty()==false)
		data[0]  >>  tmp;
	transform(tmp.begin(), tmp.end(), tmp.begin(), ::tolower);
	if (tmp=="false")
		fireFromDbase = false;
	cout << "fireFromDbase  = " << fireFromDbase << endl;
	cout << "logFileHome    = " << logFileHome   << endl;
	cout << "StartServersAtStartup = " << startServersAtStartup  << endl;
	cout << "AutoRestartDuration   = " << autoRestartDuration  << endl;

	/*----- PROTECTED REGION END -----*/	//	LMCStarter::get_device_property_after
}
//--------------------------------------------------------
/**
 *	Method      : LMCStarter::check_mandatory_property()
 *	Description : For mandatory properties check if defined in database.
 */
//--------------------------------------------------------
void LMCStarter::check_mandatory_property(Tango::DbDatum &class_prop, Tango::DbDatum &dev_prop)
{
	//	Check if all properties are empty
	if (class_prop.is_empty() && dev_prop.is_empty())
	{
		TangoSys_OMemStream	tms;
		tms << endl <<"Property \'" << dev_prop.name;
		if (Tango::Util::instance()->_UseDb==true)
			tms << "\' is mandatory but not defined in database";
		else
			tms << "\' is mandatory but cannot be defined without database";
		string	status(get_status());
		status += tms.str();
		set_status(status);
		mandatoryNotDefined = true;
		/*----- PROTECTED REGION ID(LMCStarter::check_mandatory_property) ENABLED START -----*/
		cerr << tms.str() << " for " << device_name << endl;
		
		/*----- PROTECTED REGION END -----*/	//	LMCStarter::check_mandatory_property
	}
}


//--------------------------------------------------------
/**
 *	Method      : LMCStarter::always_executed_hook()
 *	Description : method always executed before any command is executed
 */
//--------------------------------------------------------
void LMCStarter::always_executed_hook()
{
	DEBUG_STREAM << "LMCStarter::always_executed_hook()  " << device_name << endl;
	if (mandatoryNotDefined)
	{
		string	status(get_status());
		Tango::Except::throw_exception(
					(const char *)"PROPERTY_NOT_SET",
					status.c_str(),
					(const char *)"LMCStarter::always_executed_hook()");
	}
	/*----- PROTECTED REGION ID(LMCStarter::always_executed_hook) ENABLED START -----*/
	
	//	code always executed before all requests
	
	/*----- PROTECTED REGION END -----*/	//	LMCStarter::always_executed_hook
}

//--------------------------------------------------------
/**
 *	Method      : LMCStarter::read_attr_hardware()
 *	Description : Hardware acquisition for attributes
 */
//--------------------------------------------------------
void LMCStarter::read_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "LMCStarter::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(LMCStarter::read_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	//	Update if Servers attribute (polled) is called.
	for (unsigned int i=0 ; i < attr_list.size() ; i++)
	{
		Tango::WAttribute &att = dev_attr->get_w_attr_by_ind(attr_list[i]);
		string attr_name = att.get_name();
		if (attr_name == "Servers")
			for (unsigned int j=0 ; j<servers.size() ; j++)
			{
				Tango::DevState	previous_state = servers[j].state;
				//	Update server state
				servers[j].state = servers[j].thread_data->get_state();

				//	Check if state has changed.
				if (previous_state!=servers[j].state)
					manage_changing_state(&servers[j], previous_state);

				//cout << "read_attr_hardware:[" << servers[j].name << "]	" <<
				//				Tango::DevStateName[servers[j].state]  << endl;
			}
	}

	/*----- PROTECTED REGION END -----*/	//	LMCStarter::read_attr_hardware
}
//--------------------------------------------------------
/**
 *	Method      : LMCStarter::write_attr_hardware()
 *	Description : Hardware writing for attributes
 */
//--------------------------------------------------------
void LMCStarter::write_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "LMCStarter::write_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(LMCStarter::write_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	LMCStarter::write_attr_hardware
}

//--------------------------------------------------------
/**
 *	Read attribute NotifdState related method
 *	Description: return ON or FAULT if notify daemon is running or not.
 *
 *	Data type:	Tango::DevState
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void LMCStarter::read_NotifdState(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LMCStarter::read_NotifdState(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(LMCStarter::read_NotifdState) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_NotifdState_read);
	
	attr_NotifdState_read[0] = notifyd_state;
	attr.set_value(attr_NotifdState_read);

	/*----- PROTECTED REGION END -----*/	//	LMCStarter::read_NotifdState
}
//--------------------------------------------------------
/**
 *	Read attribute HostState related method
 *	Description: 
 *
 *	Data type:	Tango::DevShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void LMCStarter::read_HostState(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LMCStarter::read_HostState(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(LMCStarter::read_HostState) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_HostState_read);
	
	*attr_HostState_read = (short) get_state();
	DEBUG_STREAM << "HostState = " << attr_HostState_read[0] << endl;
	attr.set_value(attr_HostState_read);

	/*----- PROTECTED REGION END -----*/	//	LMCStarter::read_HostState
}
//--------------------------------------------------------
/**
 *	Read attribute RunningServers related method
 *	Description: 
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 200
 */
//--------------------------------------------------------
void LMCStarter::read_RunningServers(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LMCStarter::read_RunningServers(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(LMCStarter::read_RunningServers) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_RunningServers_read, 200);
	
	//	Check running ones
	vector<string>	runnings;
	for (unsigned int i=0 ; i<servers.size() ; i++)
		if (servers[i].state==Tango::ON)
			runnings.push_back(servers[i].name);
	if (runnings.empty()) {
		attr.set_value(dummyStringArray, 0);
	}
	else {
		//	And fill attribute
		stringArrayRunning << runnings;
		attr.set_value(stringArrayRunning.get_buffer(), stringArrayRunning.length());
	}

	/*----- PROTECTED REGION END -----*/	//	LMCStarter::read_RunningServers
}
//--------------------------------------------------------
/**
 *	Read attribute StoppedServers related method
 *	Description: Return all the Stopped servers.
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 200
 */
//--------------------------------------------------------
void LMCStarter::read_StoppedServers(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LMCStarter::read_StoppedServers(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(LMCStarter::read_StoppedServers) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_StoppedServers_read, 200);
	
	//	Check stopped ones
	vector<string>	stopped;
	for (unsigned int i=0 ; i<servers.size() ; i++)
		if (servers[i].state!=Tango::ON)
			stopped.push_back(servers[i].name);
	if (stopped.empty()) {
		attr.set_value(dummyStringArray, 0);
	}
	else {
		//	And fill attribute
		stringArrayStopped << stopped;
		attr.set_value(stringArrayStopped.get_buffer(), stringArrayStopped.length());
	}

	/*----- PROTECTED REGION END -----*/	//	LMCStarter::read_StoppedServers
}
//--------------------------------------------------------
/**
 *	Read attribute Servers related method
 *	Description: Return all registred servers for this host.
 *               Server names are followed by their states and controls
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 1024
 */
//--------------------------------------------------------
void LMCStarter::read_Servers(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LMCStarter::read_Servers(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(LMCStarter::read_Servers) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_Servers_read, 1024);
	
	//	Check starting ones
	vector<string>	vs;
	for (unsigned int i=0 ; i<servers.size() ; i++)
	{
		TangoSys_OMemStream tms;
		tms << servers[i].name << "\t" <<
					Tango::DevStateName[servers[i].state] << "\t" <<
					servers[i].controlled  << "\t" << servers[i].startup_level;
		string	s = tms.str();
		vs.push_back(s);

	}
	if (vs.empty())
		attr.set_value(dummyStringArray, 0);
	else {
		//	And fill attribute
		stringArrayServers << vs;
		attr.set_value(stringArrayServers.get_buffer(), stringArrayServers.length());
	}

	/*----- PROTECTED REGION END -----*/	//	LMCStarter::read_Servers
}

//--------------------------------------------------------
/**
 *	Method      : LMCStarter::add_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *                for specified device.
 */
//--------------------------------------------------------
void LMCStarter::add_dynamic_attributes()
{
	/*----- PROTECTED REGION ID(LMCStarter::add_dynamic_attributes) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic attributes if any
	LMCDevice::add_dynamic_attributes();

	/*
	//Add dynamic attributes from config file
	if(AddDynAttrs()<0){
		std::string errMsg("Failed to create dyn attributes!");
		_ERROR_LOG(errMsg);
		set_status(errMsg.c_str());
		set_state(Tango::FAULT);
		return;
	}
	
	//Configure state machine for cmd & attrs
	if(InitCmdAttrStateMachine()<0){
		std::string errMsg("Failed to create cmd & attr state machines for dyn attributes!");
		_ERROR_LOG(errMsg);
		set_status(errMsg.c_str());
		set_state(Tango::FAULT);
		return;
	}	
	*/
	/*----- PROTECTED REGION END -----*/	//	LMCStarter::add_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Command State related method
 *	Description: This command gets the device state (stored in its device_state data member) and returns it to the caller.
 *
 *	@returns Device state
 */
//--------------------------------------------------------
Tango::DevState LMCStarter::dev_state()
{
	DEBUG_STREAM << "LMCStarter::State()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCStarter::dev_state) ENABLED START -----*/
	
	Tango::DevState	argout = Tango::UNKNOWN; // replace by your own algorithm
	//	Add your own code
	
	argout = Tango::DeviceImpl::dev_state();
		//	Add your own state management
	//	Check if last command is more than readInfoDbPeriod class property
	int	period =
		((static_cast<LMCStarterClass *>(get_device_class()))->readInfoDbPeriod);

	//	If not fired -> do it myself by polling
	//---------------------------------------------
	if (fireFromDbase==false)
	{
		static time_t	t0 = 0;
	    	   time_t	t1 = time(NULL);
		//	If less -> no update
		if (t1-t0 >= period)
		{
			t0 = t1;

			//	Update control obj from database (could have been modified)
			INFO_STREAM << "Updating from data base" << endl;
			util->build_server_ctrl_object(&servers);
		}
	}
	else
	if (do_update_from_db)
	{
		//	Has been fired from Dbase
		util->build_server_ctrl_object(&servers);
		do_update_from_db = false;
	}
	//	Check for notify daemon state if requested
	//---------------------------------------------
	if (useEvents)
		notifyd_state = util->is_notifyd_alive();
	else
		notifyd_state = Tango::ON;

	//	Check if servers object initilized
	//---------------------------------------
	if (servers.empty())
	{
		INFO_STREAM << "Exiting dev_state() with servers.size() null" << endl;
		if (notifyd_state==Tango::ON)
			argout = Tango::ON;
		else
			argout = Tango::ALARM;
	}
	else
	{
		//	Check hown many servers are running
		//-----------------------------------------------------------
		ControlledServer		*p_serv;
		int		nb_running   = 0;
		int		nb_controlled = 0;
		int		nb_starting  = 0;
		int		nb_stopped  = 0;
		for (unsigned int i=0 ; i<servers.size() ; i++)
		{
			p_serv = &servers[i];
			//	Count how many are controlled
			if (p_serv->controlled)
			{
				nb_controlled++;

				//	Fixe witch one is running and count how many controlled are running
				if ((p_serv->state==Tango::ON))
					nb_running++;
				else
				if (p_serv->state==Tango::MOVING)
					nb_starting++;
                else
                    nb_stopped++;
			}
		}

		//	compare nb running with nb_controlled to set state
		if (nb_starting>0 || start_proc_data->get_starting_processes()>0)
			argout = Tango::MOVING;
		else
		if (nb_running==nb_controlled && notifyd_state==Tango::ON)
			argout = Tango::ON;
		else
		if (nb_stopped==nb_controlled)
			argout = Tango::OFF;
        else
			argout = Tango::ALARM;
	}

	if (argout==Tango::ON) {
		set_status("All controlled servers are running");
	}
	else if (argout==Tango::ALARM) {
		set_status("At least one of the  controlled servers is not running");
	}
	else if (argout==Tango::OFF) {
		set_status("All controlled servers are not running");
	}
	else if (argout==Tango::MOVING) {
		set_status("At least one of the  controlled servers is running but not responding");
	}
	else
		set_status("Starter state is unknown...");

	/*----- PROTECTED REGION END -----*/	//	LMCStarter::dev_state
	set_state(argout);    // Give the state to Tango.
	if (argout!=Tango::ALARM)
		Tango::DeviceImpl::dev_state();
	return get_state();  // Return it after Tango management.
}
//--------------------------------------------------------
/**
 *	Command DevStart related method
 *	Description: Start the specified server.
 *
 *	@param argin Server to be started.
 */
//--------------------------------------------------------
void LMCStarter::dev_start(Tango::DevString argin)
{
	DEBUG_STREAM << "LMCStarter::DevStart()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCStarter::dev_start) ENABLED START -----*/
	
	//	Add your own code
	try {
		NewProcess	*np = processCouldStart(argin);
		if (np==NULL)
			return;
		//	Build a vector to start process
		vector<NewProcess *>	processes;
		processes.push_back(np);
		startProcesses(processes, 0);

		//	Started with starter -> stopped switched to false.
		string servname(argin);
		ControlledServer	*server = util->get_server_by_name(servname, servers);
		if (server!=NULL) {
			server->stopped = false;
			server->started_time = time(NULL);
		}
	}
	catch (Tango::DevFailed &) {
		throw;
	}
	catch (exception &e) {
		cerr << "================================" << endl;
		cerr << e.what() << endl;
		cerr <<	"================================" << endl;
		TangoSys_OMemStream tms;
		tms << "Starting process failed:   " << e.what();
		Tango::Except::throw_exception(
			   (const char *)"START_PROCASS_FAILDE",
			   tms.str().c_str(),
			   (const char *)"Starter::dev_start()");
	}
	catch (...) {
		cerr << "================================" << endl <<
				"    Unknown exception catched"    << endl <<
				"================================" << endl;
		Tango::Except::throw_exception(
			   (const char *)"START_PROCASS_FAILDE",
			   (const char *)"Starting process failed:    Unknown exception catched",
			   (const char *)"Starter::dev_start()");
	}

	/*----- PROTECTED REGION END -----*/	//	LMCStarter::dev_start
}
//--------------------------------------------------------
/**
 *	Command DevStop related method
 *	Description: Stop the specified server.
 *
 *	@param argin Server be stopped.
 */
//--------------------------------------------------------
void LMCStarter::dev_stop(Tango::DevString argin)
{
	DEBUG_STREAM << "LMCStarter::DevStop()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCStarter::dev_stop) ENABLED START -----*/
	
	//	Add your own code
	//	Check if servers object initilized
	//---------------------------------------
	if (servers.empty())
	{
		TangoSys_OMemStream out_stream;
		out_stream << argin << ": Server  not controlled !" << ends;
		Tango::Except::throw_exception(out_stream.str(),
				out_stream.str(),
				(const char *)"Starter::dev_stop()");
		return;
	}

	//	Check Argin as server name
	//----------------------------------
	string	name(argin);
	ControlledServer	*server = util->get_server_by_name(name, servers);
	if (server==NULL)
	{
		TangoSys_OMemStream out_stream;
		out_stream << argin << ": Unknown Server !" << ends;
		Tango::Except::throw_exception(out_stream.str(),
				out_stream.str(),
				(const char *)"Starter::dev_stop()");
		return;
	}

	//	Make shure that it's  running.
	//---------------------------------------
	if (server->state==Tango::ON)
	{
		//	And Kill it with kill signal
		Tango::DeviceProxy *dev = NULL;
        try {
		    dev = new Tango::DeviceProxy(server->admin_name);
            dev->command_inout("Kill");
            delete dev;
       }
        catch (Tango::DevFailed &e) {
            if (dev!=NULL)
                delete dev;
            throw e;
        }

		TangoSys_OMemStream out_stream;
		out_stream << argin << " stopped";
		WARN_STREAM << out_stream.str() << endl;
		cout << out_stream.str() << endl;
		util->log_starter_info(out_stream.str());
		server->stopped = true;
	}
	else
	if (server->state==Tango::MOVING)
	{
		TangoSys_OMemStream out_stream;
		out_stream << argin << " is running but not responding !" << ends;
		Tango::Except::throw_exception(
				(const char *)"SERVER_NOT_RESPONDING",
				out_stream.str(),
				(const char *)"Starter::dev_stop()");
		return;
	}
	else
	{
		TangoSys_OMemStream out_stream;
		out_stream << argin << " is NOT running !" << ends;
		Tango::Except::throw_exception(
				(const char *)"SERVER_NOT_RUNNING",
				out_stream.str(),
				(const char *)"Starter::dev_stop()");
		return;
	}

	/*----- PROTECTED REGION END -----*/	//	LMCStarter::dev_stop
}
//--------------------------------------------------------
/**
 *	Command DevStartAll related method
 *	Description: Start all device servers controled on the host for the argin level.
 *
 *	@param argin Startup level.
 */
//--------------------------------------------------------
void LMCStarter::dev_start_all(Tango::DevShort argin)
{
	DEBUG_STREAM << "LMCStarter::DevStartAll()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCStarter::dev_start_all) ENABLED START -----*/
	
	//	Add your own code
	Tango::DevShort  level = argin;
	cout << "Starter::dev_start_all(): entering for level "<< level <<"... !" << endl;

	//	Check if servers object initialized
	//---------------------------------------
	if (servers.empty()) {
		if (throwable) {
			TangoSys_OMemStream out_stream;
			out_stream << "NO Server  controlled !" << ends;
			Tango::Except::throw_exception(out_stream.str(),
			out_stream.str(),
				(const char *)"Starter::dev_start_all()");
		}
	}

	//	Do not want exception during start up
	throwable = false;

	//	And start the stopped ones
	//---------------------------------------------------
	vector<NewProcess *>	processes;
	for (unsigned int i=0 ; i<servers.size() ; i++)
	{
		ControlledServer	*server = &servers[i];
		//	server->running could not be initialized
		if (server->controlled  &&  server->startup_level==level)
		{
			cout << "Check startup for " << server->name << endl;
			if (server->state==Tango::FAULT)
			{
				NewProcess	*np = processCouldStart((char*)server->name.c_str());
				if (np!=NULL)
				{
					processes.push_back(np);
					cout << "Try to start " << np->servname << endl;
				}
				else
					cout << "np is null (?)" << endl;
			}
			else
				cout << "	Already running...."<< endl;
		}
	}
	if (processes.empty()==false)
		startProcesses(processes, level);

	//	Want exception during normal run
	throwable = true;

	/*----- PROTECTED REGION END -----*/	//	LMCStarter::dev_start_all
}
//--------------------------------------------------------
/**
 *	Command DevStopAll related method
 *	Description: Stop all device servers controled on the host for the argin level.
 *
 *	@param argin Startup Level.
 */
//--------------------------------------------------------
void LMCStarter::dev_stop_all(Tango::DevShort argin)
{
	DEBUG_STREAM << "LMCStarter::DevStopAll()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCStarter::dev_stop_all) ENABLED START -----*/
	
	//	Add your own code
	Tango::DevShort  level = argin;

	//	Check if servers object initialized
	if (servers.empty())
	{
		TangoSys_OMemStream out_stream;
		out_stream << "NO Server  controlled !" << ends;
		Tango::Except::throw_exception(out_stream.str(),
				out_stream.str(),
				(const char *)"Starter::dev_stop_all()");
		return;
	}

	//  Remove level from list to be started
	cout << "Starter removing level " << level << endl;
    start_proc_data->remove_level(level);

	//	And stop the running ones
	for (unsigned int i=0 ; i<servers.size() ; i++)
	{
		ControlledServer	*server = &servers[i];
		if (server->controlled            &&
			server->startup_level==level  &&
			server->state==Tango::ON)
				dev_stop((char*)server->name.c_str());
	}

	/*----- PROTECTED REGION END -----*/	//	LMCStarter::dev_stop_all
}
//--------------------------------------------------------
/**
 *	Command DevGetRunningServers related method
 *	Description: Control the running process from property list.
 *               And return the list of the processes which are really running.
 *
 *	@param argin True for all servers. False for controled servers only.
 *	@returns List of the processes which are running.
 */
//--------------------------------------------------------
Tango::DevVarStringArray *LMCStarter::dev_get_running_servers(Tango::DevBoolean argin)
{
	Tango::DevVarStringArray *argout;
	DEBUG_STREAM << "LMCStarter::DevGetRunningServers()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCStarter::dev_get_running_servers) ENABLED START -----*/
	
	//	Add your own code
	Tango::DevBoolean  all_serv = argin;
	argout = new Tango::DevVarStringArray;
	INFO_STREAM << "Starter::dev_get_running_server(): entering... !" << endl;

	//	Check if servers object initilized
	//---------------------------------------
	if (servers.empty())
	{
		return argout;
	}

	//	prepare the argout for running servers list
	//-----------------------------------------------------------
	int		nb = 0;
	int		x;
	unsigned int	i;
	for (i=0 ; i<servers.size() ; i++)
		if (all_serv || servers[i].controlled)
			if (servers[i].state==Tango::ON)
				nb ++;

	//	And fill it
	//-----------------------------------------------------------
	argout->length(nb);
	for (i=0, x=0 ; i<servers.size() && x<nb ; i++)
		if (all_serv || servers[i].controlled)
			if (servers[i].state==Tango::ON)
			{
				INFO_STREAM << "RUNNING: " << servers[i].name << endl;
				(*argout)[x++] = CORBA::string_dup(servers[i].name.c_str());
			}

	/*----- PROTECTED REGION END -----*/	//	LMCStarter::dev_get_running_servers
	return argout;
}
//--------------------------------------------------------
/**
 *	Command DevGetStopServers related method
 *	Description: Control the running process from property list.
 *               And return the list of the processes which are not running.
 *
 *	@param argin True for all servers. False for controled servers only.
 *	@returns List of the processes which are not running.
 */
//--------------------------------------------------------
Tango::DevVarStringArray *LMCStarter::dev_get_stop_servers(Tango::DevBoolean argin)
{
	Tango::DevVarStringArray *argout;
	DEBUG_STREAM << "LMCStarter::DevGetStopServers()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCStarter::dev_get_stop_servers) ENABLED START -----*/
	
	//	Add your own code
	Tango::DevBoolean  all_serv = argin;
	argout = new Tango::DevVarStringArray();
	INFO_STREAM << "Starter::dev_get_stop_servers(): entering... !" << endl;

	//	Check if servers object initilized
	//---------------------------------------
	if (servers.empty())
	{
		argout->length(0);
		return argout;
	}

	//	prepeare the argout for NOT running servers list
	//-----------------------------------------------------------
	int		nb = 0;
	int		x;
	unsigned int	i;
	for (i=0 ; i<servers.size() ; i++)
		if (all_serv || servers[i].controlled)
			if (servers[i].state!=Tango::ON)
				nb ++;

	//	And fill it
	//-----------------------------------------------------------
	argout->length(nb);
	for (i=0, x=0  ; i<servers.size() && x<nb; i++)
		if (all_serv || servers[i].controlled)
			if (servers[i].state!=Tango::ON)
			{
				INFO_STREAM << "STOPPED: " << servers[i].name << endl;
				(*argout)[x++] = CORBA::string_dup(servers[i].name.c_str());
			}

	/*----- PROTECTED REGION END -----*/	//	LMCStarter::dev_get_stop_servers
	return argout;
}
//--------------------------------------------------------
/**
 *	Command DevReadLog related method
 *	Description: At server startup, its standard error is redirected to a log file.
 *               This command will read this file and return the read string from the file.
 *
 *	@param argin server name and domain (e.g. Starter/corvus)
 *               If argin ==``Starter``     -> return Starter logg file content.
 *               If argin ==``Statistics``  -> return Starter statistics file content.
 *	@returns String found in log file.
 */
//--------------------------------------------------------
Tango::ConstDevString LMCStarter::dev_read_log(Tango::DevString argin)
{
	Tango::ConstDevString argout;
	DEBUG_STREAM << "LMCStarter::DevReadLog()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCStarter::dev_read_log) ENABLED START -----*/
	
	//	Add your own code
	string	filename;
	bool	on_starter;
	//	Check if for Starter itself
	if (strcmp(argin, "Starter")==0)
	{
		on_starter = true;
		filename = util->starter_log_file;
	}
	else
	if (strcmp(argin, "Statistics")==0)
	{
		on_starter = true;
		filename = util->starter_stat_file;
	}
	else
	{
		on_starter = false;
		filename = util->build_log_file_name(argin);
	}

	//	Try to open log file
	ifstream	ifs((char *)filename.c_str());
	if (!ifs)
	{
		//	Open log file failed -> Throw exception
		//----------------------------------------------
		TangoSys_OMemStream reason;
		TangoSys_OMemStream description;
		reason << "Cannot open " << filename << ends;
		description << strerror(errno);
		Tango::Except::throw_exception(reason.str(),
						description.str(),
						(const char *)"Starter::dev_read_log");
	}

	//	Read and close log file, and return string read from it.
	//-------------------------------------------------------------
	stringstream	strlog;
	if (!on_starter)
	{
		strlog << filename << endl;
		strlog << util->get_file_date((char *)filename.c_str()) << endl << endl;
	}
	strlog << ifs.rdbuf() << ends;
	ifs.close();
	returned_str = strlog.str();
	argout = returned_str.c_str();

	/*----- PROTECTED REGION END -----*/	//	LMCStarter::dev_read_log
	return argout;
}
//--------------------------------------------------------
/**
 *	Command HardKillServer related method
 *	Description: Hard kill a server (kill -9)
 *
 *	@param argin Server name
 */
//--------------------------------------------------------
void LMCStarter::hard_kill_server(Tango::DevString argin)
{
	DEBUG_STREAM << "LMCStarter::HardKillServer()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCStarter::hard_kill_server) ENABLED START -----*/
	
	//	Add your own code
	string	servname(argin);
	int	pid = util->proc_util->get_server_pid(servname);
	if (pid<0)
	{
		TangoSys_OMemStream tms;
		tms << "Server " << argin << " is not running !";
		Tango::Except::throw_exception(
					(const char *)"SERVER_NOT_RUNNING",
					tms.str().c_str(),
					(const char *)"Starter::hard_kill_server()");
	}
#ifdef _TG_WINDOWS_

	HANDLE	handle = NULL;				//- process addr (in the heap)
	if( (handle=OpenProcess(PROCESS_TERMINATE, false, pid)) == NULL)
	{
		TangoSys_OMemStream tms;
		tms << "Open handle on server " << argin << " failed !";
		Tango::Except::throw_exception(
					(const char *)"KILL_DERVER_FAILED",
					tms.str().c_str(),
					(const char *)"Starter::hard_kill_server()");
	}

	TerminateProcess(handle, 0);
	CloseHandle(handle);
	if (GetLastError()!= ERROR_SUCCESS)
	{
		TangoSys_OMemStream tms;
		tms << "Kill server " << argin << " failed !";
		Tango::Except::throw_exception(
					(const char *)"KILL_DERVER_FAILED",
					tms.str().c_str(),
					(const char *)"Starter::hard_kill_server()");
	}

#else

	TangoSys_OMemStream cmd;
	cmd << "kill -9 " << pid;
	if (system(cmd.str().c_str())<0)
	{
		TangoSys_OMemStream tms;
		tms << "Kill server " << argin << " failed !";
		Tango::Except::throw_exception(
					(const char *)"KILL_DERVER_FAILED",
					tms.str().c_str(),
					(const char *)"Starter::hard_kill_server()");
	}
#endif
	/*----- PROTECTED REGION END -----*/	//	LMCStarter::hard_kill_server
}
//--------------------------------------------------------
/**
 *	Command NotifyDaemonState related method
 *	Description: Returns the Notify Daemon state.
 *
 *	@returns Tango::ON if Notify daemon is running else Tango::FAULT.
 */
//--------------------------------------------------------
Tango::DevState LMCStarter::notify_daemon_state()
{
	Tango::DevState argout;
	DEBUG_STREAM << "LMCStarter::NotifyDaemonState()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCStarter::notify_daemon_state) ENABLED START -----*/
	
	//	Add your own code
	if (useEvents==false)
		Tango::Except::throw_exception(
					(const char *)"NOTIFY_NOT_AVAILABLE",
					(const char *)"Notify Daemon control is disabled",
					(const char *)"Starter::notify_daemon_state()");
	argout = notifyd_state;

	/*----- PROTECTED REGION END -----*/	//	LMCStarter::notify_daemon_state
	return argout;
}
//--------------------------------------------------------
/**
 *	Command ResetStatistics related method
 *	Description: Reset statistics file.
 *
 */
//--------------------------------------------------------
void LMCStarter::reset_statistics()
{
	DEBUG_STREAM << "LMCStarter::ResetStatistics()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCStarter::reset_statistics) ENABLED START -----*/
	
	//	Add your own code
	util->reset_starter_stat_file(&servers);

	/*----- PROTECTED REGION END -----*/	//	LMCStarter::reset_statistics
}
//--------------------------------------------------------
/**
 *	Command UpdateServersInfo related method
 *	Description: Indicate to the device server than the information about servers to be controlled has been modified.
 *               The device server must read the database to update the servers info list.
 *               If the default case, this command is sent by Database server itself.
 *
 */
//--------------------------------------------------------
void LMCStarter::update_servers_info()
{
	DEBUG_STREAM << "LMCStarter::UpdateServersInfo()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCStarter::update_servers_info) ENABLED START -----*/
	
	//	Add your own code
	do_update_from_db = true;

	/*----- PROTECTED REGION END -----*/	//	LMCStarter::update_servers_info
}
//--------------------------------------------------------
/**
 *	Command dummy_dyn_cmd related method
 *	Description: 
 *
 */
//--------------------------------------------------------
void LMCStarter::dummy_dyn_cmd(Tango::Command &command)
{
	DEBUG_STREAM << "LMCStarter::" << command.get_name() << "  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LMCStarter::dummy_dyn_cmd) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	LMCStarter::dummy_dyn_cmd
}
//--------------------------------------------------------
/**
 *	Method      : LMCStarter::add_dynamic_commands()
 *	Description : Create the dynamic commands if any
 *                for specified device.
 */
//--------------------------------------------------------
void LMCStarter::add_dynamic_commands()
{
	//	Example to add dynamic command:
	//	Copy inside the folowing protected area to instanciate at startup.
	//	add_dummy_dyn_cmd_dynamic_command("Mydummy_dyn_cmdCommand", true);
	
	/*----- PROTECTED REGION ID(LMCStarter::add_dynamic_commands) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic commands if any
	LMCDevice::add_dynamic_commands();

	/*----- PROTECTED REGION END -----*/	//	LMCStarter::add_dynamic_commands
}

/*----- PROTECTED REGION ID(LMCStarter::namespace_ending) ENABLED START -----*/

//	Additional Methods
//+------------------------------------------------------------------
/**
 *	Check if a process could be started (file exists, is not running, ...)
 */
//+------------------------------------------------------------------
NewProcess *LMCStarter::processCouldStart(char *argin)
{
	INFO_STREAM << "Starter::processCouldStart(\""<< argin << "\"): entering... !" << endl;

	//	Make sure that it's not running.
	//---------------------------------------
	if (servers.empty()==false)
	{
		string	name(argin);
		ControlledServer	*server = util->get_server_by_name(name, servers);
		if (server!=NULL)
			if (server->state!=Tango::FAULT)
			{
				INFO_STREAM << argin << " is already running !" <<endl;
				TangoSys_OMemStream tms;
				tms << argin << " is already running !" << ends;
				if (throwable)
					Tango::Except::throw_exception(
								(const char *)"ALREADY_RUNNING",
								tms.str(),
								(const char *)"Starter::dev_start()");
				return NULL;
			}
	}

	//	Separate server name and instancename.
	char	*servname     = util->get_server_name(argin) ;
	char	*instancename = util->get_instance_name(argin);
	char	*adminname    = new char[strlen(servname)+ strlen(instancename)+10];
	sprintf(adminname, "dserver/%s/%s", servname, instancename);
	char	*filename;
	try {
		filename = util->check_exe_file(servname, startDsPath);
	}
	catch(Tango::DevFailed &e)
	{
		delete[] servname;
		delete[] instancename;
		delete[] adminname;
		if (throwable)
			throw;
		else
		{
			cerr << e.errors[0].desc << endl;
			return NULL;
		}
	}
	delete[] servname;

	check_log_dir();

	string	log_file = util->build_log_file_name(argin);
	NewProcess	*np  = new NewProcess;
	np->servname     = filename;
	np->instancename = instancename;
	np->adminname    = adminname;
	np->logfile      = new char[log_file.length()+1];
	np->logfile      = strcpy(np->logfile, log_file.c_str());

	INFO_STREAM << "LOG file : " << log_file << endl;

	return np;
}
//+------------------------------------------------------------------
//+------------------------------------------------------------------
void LMCStarter::startProcesses(vector<NewProcess *> v_np, int level)
{
	//	Start process to start processes
	//-------------------------------------
	try {
		start_proc_data->push_back_level(level);
		StartProcessThread	*pt =
		new StartProcessThread(v_np, level, this);
		pt->start();
	}
	catch(omni_thread_fatal &e) {
		TangoSys_OMemStream tms;
		tms << "Starting process thread failed: " << e.error;
		Tango::Except::throw_exception(
			   (const char *)"THREAD_FAILDE",
			   tms.str().c_str(),
			   (const char *)"Starter::startProcesses()");
	}
	catch(omni_thread_invalid &e) {
		TangoSys_OMemStream tms;
		tms << "Starting process thread failed: omni_thread_invalid";
		Tango::Except::throw_exception(
			   (const char *)"THREAD_FAILDE",
			   tms.str().c_str(),
			   (const char *)"Starter::startProcesses()");
	}
	catch(...) {
		TangoSys_OMemStream tms;
		tms << "Starting process thread failed";
		Tango::Except::throw_exception(
			   (const char *)"THREAD_FAILDE",
			   tms.str().c_str(),
			   (const char *)"Starter::startProcesses()");
	}
}
//+------------------------------------------------------------------
/**
 *	Return how many servers to start for specified level.
 */
//+------------------------------------------------------------------
int	LMCStarter::nb_servers_to_start(int level)
{
	int	cnt = 0;
	for (unsigned int i=0 ; i<servers.size() ; i++)
	{
		ControlledServer	*server = &servers[i];
		//	server->running could not be initialized
		if (server->controlled  &&  server->startup_level==level)
			if (server->state!=Tango::ON)
				cnt++;
	}
	return cnt;
}
//=================================================================
//=================================================================
void LMCStarter::check_host()
{
	string	hostname = Tango::Util::instance()->get_host_name();
	transform(hostname.begin(), hostname.end(), hostname.begin(), ::tolower);
	//	remove FQDN
	string::size_type	pos = hostname.find('.');
	if (pos!=string::npos)
		hostname = hostname.substr(0, pos);

	string	devname = device_name;
	transform(devname.begin(), devname.end(), devname.begin(), ::tolower);

	//	Get only member
	pos = devname.find('/');
	if (pos!=string::npos)
	{
		pos = devname.find('/', pos+1);
		if (pos!=string::npos)
			devname = devname.substr(pos+1);
	}
	//cout << hostname << " == " << devname << endl;

	if (devname != hostname)
	{
		TangoSys_OMemStream	tms;
		tms << "This server must run on " << devname << " and not on "  << hostname;
		string	descr(tms.str());

		Tango::Except::throw_exception(
				(const char *)"BAD_PARAM",
				(const char *) descr.c_str(),
				(const char *)"Starter::check_host()");
	}
}
//=================================================================
//=================================================================
void LMCStarter::check_log_dir()
{
	//	Check if log dir already exists.
	//-------------------------------------
	string	logpath;
	LogPath(logpath,logFileHome);
	if (chdir(logpath.c_str())==-1)
	{
		if (errno==ENOENT)
		{
			//	Create directory
			//-------------------------
			cerr << "ENOENT" << endl;
			cerr << errno << "  " << strerror(errno) << endl;
#ifdef _TG_WINDOWS_
			mkdir(TmpRoot);
			int r = mkdir(logpath.c_str());
#else
#	ifdef linux
			int r = mkdir(logpath.c_str(), (mode_t)(0775) );
#	else
			int r = mkdir(logpath.c_str(), (mode_t)(O_RDWR | O_CREAT, 0775) );
#	endif
#endif
			if (r<0)
			{
				TangoSys_OMemStream	message;
				message << "Cannot create error log directory:\n";
				message << logpath;
				message << "\n" << strerror(errno) << endl;
				cerr << message.str() << endl;;
				set_status(message.str());
				Tango::Except::throw_exception(
									(const char *)"CANNOT_CREATE_LOG_FILE",
									message.str(),
									(const char *)"Starter::dev_start");
			}
			else
			{
				TangoSys_OMemStream	tms;
				tms << logpath << " Created !" << endl;
				INFO_STREAM << tms.str() << endl;
				set_status(tms.str());
			}
		}
		else
		{
			TangoSys_OMemStream	tms;
			tms << "Cannot change to log directory:\n";
			tms << logpath;
			tms << "\n" << strerror(errno) << endl;
			cerr << tms.str() << endl;;
			set_status(tms.str());
		}
	}
}
//=================================================================
//=================================================================
void LMCStarter::manage_changing_state(ControlledServer *server, TANGO_UNUSED(Tango::DevState previous_state))
{
	//	Do it only if server is controlled.
	if (server->controlled==false || server->startup_level==0)
		return;

	Tango::DevState state = server->state;
	//cout << "manage_changing_state:[" << server->name << "]	" <<
	//	Tango::DevStateName[previous_state]	<< "  -->  " << Tango::DevStateName[state] << endl;

	switch(state)
	{
	case Tango::ON:
		server->started_time = time(NULL);
		//	Log statistics
		util->log_starter_statistics(server);

		if (server->failure_time>0)
		{
			cout << "Failure duration:	" <<
				(server->started_time-server->failure_time)  << " sec." << endl;
			server->failure_time  = -1;
		}
		break;
	case Tango::FAULT:
		if (server->stopped==false)		//	Has failed
		{
			server->failure_time = time(NULL);
			//	Log statistics
			util->log_starter_statistics(server);

			//	Check auto restart
			if (autoRestartDuration>0) {
				int	minDuration = autoRestartDuration;

				if (debug==false)
					minDuration *= 60;	//	minutes to seconds
				int	runDuration = server->failure_time -  server->started_time;
				cout << "Has run " << runDuration << " sec.  (> " << minDuration << " ?)" << endl;
				if (runDuration>minDuration) {
					try {
						//	Restart it
						cout << "	YES:  Restart it !!" << endl;
						server->auto_start = true;
						dev_start((char *)server->name.c_str());
					}
					catch(Tango::DevFailed &e) {
						Tango::Except::print_exception(e);
					}
				}
			}
		}
		break;
	default:
		//	Do nothing
		break;
	}
}

/*----- PROTECTED REGION END -----*/	//	LMCStarter::namespace_ending
} //	namespace
